'use strict'
var y5 = Object.create
var Kl = Object.defineProperty
var E5 = Object.getOwnPropertyDescriptor
var S5 = Object.getOwnPropertyNames
var b5 = Object.getPrototypeOf,
  v5 = Object.prototype.hasOwnProperty
var ue = (e, t) => () => (e && (t = e((e = 0))), t)
var l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
  fd = (e, t) => {
    for (var n in t) Kl(e, n, { get: t[n], enumerable: !0 })
  },
  RA = (e, t, n, r) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let s of S5(t))
        !v5.call(e, s) &&
          s !== n &&
          Kl(e, s, {
            get: () => t[s],
            enumerable: !(r = E5(t, s)) || r.enumerable,
          })
    return e
  }
var sn = (e, t, n) => (
    (n = e != null ? y5(b5(e)) : {}),
    RA(
      t || !e || !e.__esModule
        ? Kl(n, 'default', { value: e, enumerable: !0 })
        : n,
      e,
    )
  ),
  w = (e) => RA(Kl({}, '__esModule', { value: !0 }), e)
var lS = l((uS) => {
  Object.defineProperty(uS, '__esModule', { value: !0 })
  function C5(e, t) {
    return e ?? t()
  }
  uS._nullishCoalesce = C5
})
var DA = l((mS) => {
  Object.defineProperty(mS, '__esModule', { value: !0 })
  var T5 = lS()
  async function w5(e, t) {
    return T5._nullishCoalesce(e, t)
  }
  mS._asyncNullishCoalesce = w5
})
var _S = l((pS) => {
  Object.defineProperty(pS, '__esModule', { value: !0 })
  async function I5(e) {
    let t,
      n = e[0],
      r = 1
    for (; r < e.length; ) {
      let s = e[r],
        o = e[r + 1]
      if (
        ((r += 2),
        (s === 'optionalAccess' || s === 'optionalCall') && n == null)
      )
        return
      s === 'access' || s === 'optionalAccess'
        ? ((t = n), (n = await o(n)))
        : (s === 'call' || s === 'optionalCall') &&
          ((n = await o((...i) => n.call(t, ...i))), (t = void 0))
    }
    return n
  }
  pS._asyncOptionalChain = I5
})
var AA = l((fS) => {
  Object.defineProperty(fS, '__esModule', { value: !0 })
  var x5 = _S()
  async function P5(e) {
    let t = await x5._asyncOptionalChain(e)
    return t ?? !0
  }
  fS._asyncOptionalChainDelete = P5
})
var gS = l((hS) => {
  Object.defineProperty(hS, '__esModule', { value: !0 })
  function R5(e) {
    let t,
      n = e[0],
      r = 1
    for (; r < e.length; ) {
      let s = e[r],
        o = e[r + 1]
      if (
        ((r += 2),
        (s === 'optionalAccess' || s === 'optionalCall') && n == null)
      )
        return
      s === 'access' || s === 'optionalAccess'
        ? ((t = n), (n = o(n)))
        : (s === 'call' || s === 'optionalCall') &&
          ((n = o((...i) => n.call(t, ...i))), (t = void 0))
    }
    return n
  }
  hS._optionalChain = R5
})
var OA = l((yS) => {
  Object.defineProperty(yS, '__esModule', { value: !0 })
  var D5 = gS()
  function A5(e) {
    let t = D5._optionalChain(e)
    return t ?? !0
  }
  yS._optionalChainDelete = A5
})
var Se = l((Gr) => {
  Object.defineProperty(Gr, '__esModule', { value: !0 })
  var O5 = DA(),
    N5 = _S(),
    q5 = AA(),
    k5 = lS(),
    M5 = gS(),
    L5 = OA()
  Gr._asyncNullishCoalesce = O5._asyncNullishCoalesce
  Gr._asyncOptionalChain = N5._asyncOptionalChain
  Gr._asyncOptionalChainDelete = q5._asyncOptionalChainDelete
  Gr._nullishCoalesce = k5._nullishCoalesce
  Gr._optionalChain = M5._optionalChain
  Gr._optionalChainDelete = L5._optionalChainDelete
})
var Ut = l((He) => {
  Object.defineProperty(He, '__esModule', { value: !0 })
  var NA = Object.prototype.toString
  function U5(e) {
    switch (NA.call(e)) {
      case '[object Error]':
      case '[object Exception]':
      case '[object DOMException]':
        return !0
      default:
        return Xl(e, Error)
    }
  }
  function ri(e, t) {
    return NA.call(e) === `[object ${t}]`
  }
  function F5(e) {
    return ri(e, 'ErrorEvent')
  }
  function B5(e) {
    return ri(e, 'DOMError')
  }
  function j5(e) {
    return ri(e, 'DOMException')
  }
  function G5(e) {
    return ri(e, 'String')
  }
  function $5(e) {
    return e === null || (typeof e != 'object' && typeof e != 'function')
  }
  function qA(e) {
    return ri(e, 'Object')
  }
  function z5(e) {
    return typeof Event < 'u' && Xl(e, Event)
  }
  function H5(e) {
    return typeof Element < 'u' && Xl(e, Element)
  }
  function V5(e) {
    return ri(e, 'RegExp')
  }
  function Y5(e) {
    return !!(e && e.then && typeof e.then == 'function')
  }
  function W5(e) {
    return (
      qA(e) &&
      'nativeEvent' in e &&
      'preventDefault' in e &&
      'stopPropagation' in e
    )
  }
  function K5(e) {
    return typeof e == 'number' && e !== e
  }
  function Xl(e, t) {
    try {
      return e instanceof t
    } catch {
      return !1
    }
  }
  function X5(e) {
    return !!(typeof e == 'object' && e !== null && (e.__isVue || e._isVue))
  }
  He.isDOMError = B5
  He.isDOMException = j5
  He.isElement = H5
  He.isError = U5
  He.isErrorEvent = F5
  He.isEvent = z5
  He.isInstanceOf = Xl
  He.isNaN = K5
  He.isPlainObject = qA
  He.isPrimitive = $5
  He.isRegExp = V5
  He.isString = G5
  He.isSyntheticEvent = W5
  He.isThenable = Y5
  He.isVueViewModel = X5
})
var hd = l((Js) => {
  Object.defineProperty(Js, '__esModule', { value: !0 })
  var Jl = Ut()
  function J5(e, t = 0) {
    return typeof e != 'string' || t === 0 || e.length <= t
      ? e
      : `${e.slice(0, t)}...`
  }
  function Q5(e, t) {
    let n = e,
      r = n.length
    if (r <= 150) return n
    t > r && (t = r)
    let s = Math.max(t - 60, 0)
    s < 5 && (s = 0)
    let o = Math.min(s + 140, r)
    return (
      o > r - 5 && (o = r),
      o === r && (s = Math.max(o - 140, 0)),
      (n = n.slice(s, o)),
      s > 0 && (n = `'{snip} ${n}`),
      o < r && (n += ' {snip}'),
      n
    )
  }
  function Z5(e, t) {
    if (!Array.isArray(e)) return ''
    let n = []
    for (let r = 0; r < e.length; r++) {
      let s = e[r]
      try {
        Jl.isVueViewModel(s) ? n.push('[VueViewModel]') : n.push(String(s))
      } catch {
        n.push('[value cannot be serialized]')
      }
    }
    return n.join(t)
  }
  function kA(e, t, n = !1) {
    return Jl.isString(e)
      ? Jl.isRegExp(t)
        ? t.test(e)
        : Jl.isString(t)
          ? n
            ? e === t
            : e.includes(t)
          : !1
      : !1
  }
  function e9(e, t = [], n = !1) {
    return t.some((r) => kA(e, r, n))
  }
  Js.isMatchingPattern = kA
  Js.safeJoin = Z5
  Js.snipLine = Q5
  Js.stringMatchesSomePattern = e9
  Js.truncate = J5
})
var UA = l((bS) => {
  Object.defineProperty(bS, '__esModule', { value: !0 })
  var ES = Ut(),
    t9 = hd()
  function n9(e, t, n = 250, r, s, o, i) {
    if (
      !o.exception ||
      !o.exception.values ||
      !i ||
      !ES.isInstanceOf(i.originalException, Error)
    )
      return
    let a =
      o.exception.values.length > 0
        ? o.exception.values[o.exception.values.length - 1]
        : void 0
    a &&
      (o.exception.values = r9(
        SS(e, t, s, i.originalException, r, o.exception.values, a, 0),
        n,
      ))
  }
  function SS(e, t, n, r, s, o, i, a) {
    if (o.length >= n + 1) return o
    let c = [...o]
    if (ES.isInstanceOf(r[s], Error)) {
      MA(i, a)
      let u = e(t, r[s]),
        d = c.length
      LA(u, s, d, a), (c = SS(e, t, n, r[s], s, [u, ...c], u, d))
    }
    return (
      Array.isArray(r.errors) &&
        r.errors.forEach((u, d) => {
          if (ES.isInstanceOf(u, Error)) {
            MA(i, a)
            let p = e(t, u),
              _ = c.length
            LA(p, `errors[${d}]`, _, a),
              (c = SS(e, t, n, u, s, [p, ...c], p, _))
          }
        }),
      c
    )
  }
  function MA(e, t) {
    ;(e.mechanism = e.mechanism || { type: 'generic', handled: !0 }),
      (e.mechanism = {
        ...e.mechanism,
        is_exception_group: !0,
        exception_id: t,
      })
  }
  function LA(e, t, n, r) {
    ;(e.mechanism = e.mechanism || { type: 'generic', handled: !0 }),
      (e.mechanism = {
        ...e.mechanism,
        type: 'chained',
        source: t,
        exception_id: n,
        parent_id: r,
      })
  }
  function r9(e, t) {
    return e.map((n) => (n.value && (n.value = t9.truncate(n.value, t)), n))
  }
  bS.applyAggregateErrorsToEvent = n9
})
var sr = l((gd) => {
  Object.defineProperty(gd, '__esModule', { value: !0 })
  function Ql(e) {
    return e && e.Math == Math ? e : void 0
  }
  var vS =
    (typeof globalThis == 'object' && Ql(globalThis)) ||
    (typeof window == 'object' && Ql(window)) ||
    (typeof self == 'object' && Ql(self)) ||
    (typeof global == 'object' && Ql(global)) ||
    (function () {
      return this
    })() ||
    {}
  function s9() {
    return vS
  }
  function o9(e, t, n) {
    let r = n || vS,
      s = (r.__SENTRY__ = r.__SENTRY__ || {})
    return s[e] || (s[e] = t())
  }
  gd.GLOBAL_OBJ = vS
  gd.getGlobalObject = s9
  gd.getGlobalSingleton = o9
})
var CS = l((yd) => {
  Object.defineProperty(yd, '__esModule', { value: !0 })
  var i9 = Ut(),
    a9 = sr(),
    Zl = a9.getGlobalObject(),
    c9 = 80
  function d9(e, t = {}) {
    try {
      let n = e,
        r = 5,
        s = [],
        o = 0,
        i = 0,
        a = ' > ',
        c = a.length,
        u,
        d = Array.isArray(t) ? t : t.keyAttrs,
        p = (!Array.isArray(t) && t.maxStringLength) || c9
      for (
        ;
        n &&
        o++ < r &&
        ((u = u9(n, d)),
        !(u === 'html' || (o > 1 && i + s.length * c + u.length >= p)));

      )
        s.push(u), (i += u.length), (n = n.parentNode)
      return s.reverse().join(a)
    } catch {
      return '<unknown>'
    }
  }
  function u9(e, t) {
    let n = e,
      r = [],
      s,
      o,
      i,
      a,
      c
    if (!n || !n.tagName) return ''
    r.push(n.tagName.toLowerCase())
    let u =
      t && t.length
        ? t.filter((p) => n.getAttribute(p)).map((p) => [p, n.getAttribute(p)])
        : null
    if (u && u.length)
      u.forEach((p) => {
        r.push(`[${p[0]}="${p[1]}"]`)
      })
    else if (
      (n.id && r.push(`#${n.id}`), (s = n.className), s && i9.isString(s))
    )
      for (o = s.split(/\s+/), c = 0; c < o.length; c++) r.push(`.${o[c]}`)
    let d = ['aria-label', 'type', 'name', 'title', 'alt']
    for (c = 0; c < d.length; c++)
      (i = d[c]), (a = n.getAttribute(i)), a && r.push(`[${i}="${a}"]`)
    return r.join('')
  }
  function l9() {
    try {
      return Zl.document.location.href
    } catch {
      return ''
    }
  }
  function m9(e) {
    return Zl.document && Zl.document.querySelector
      ? Zl.document.querySelector(e)
      : null
  }
  yd.getDomElement = m9
  yd.getLocationHref = l9
  yd.htmlTreeAsString = d9
})
var Qs = l((si) => {
  Object.defineProperty(si, '__esModule', { value: !0 })
  var TS = sr(),
    p9 = 'Sentry Logger ',
    wS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'],
    IS = {}
  function FA(e) {
    if (!('console' in TS.GLOBAL_OBJ)) return e()
    let t = TS.GLOBAL_OBJ.console,
      n = {},
      r = Object.keys(IS)
    r.forEach((s) => {
      let o = IS[s]
      ;(n[s] = t[s]), (t[s] = o)
    })
    try {
      return e()
    } finally {
      r.forEach((s) => {
        t[s] = n[s]
      })
    }
  }
  function _9() {
    let e = !1,
      t = {
        enable: () => {
          e = !0
        },
        disable: () => {
          e = !1
        },
        isEnabled: () => e,
      }
    return (
      typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__
        ? wS.forEach((n) => {
            t[n] = (...r) => {
              e &&
                FA(() => {
                  TS.GLOBAL_OBJ.console[n](`${p9}[${n}]:`, ...r)
                })
            }
          })
        : wS.forEach((n) => {
            t[n] = () => {}
          }),
      t
    )
  }
  var f9 = _9()
  si.CONSOLE_LEVELS = wS
  si.consoleSandbox = FA
  si.logger = f9
  si.originalConsoleMethods = IS
})
var xS = l((Ed) => {
  Object.defineProperty(Ed, '__esModule', { value: !0 })
  var em = Qs(),
    h9 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/
  function g9(e) {
    return e === 'http' || e === 'https'
  }
  function y9(e, t = !1) {
    let {
      host: n,
      path: r,
      pass: s,
      port: o,
      projectId: i,
      protocol: a,
      publicKey: c,
    } = e
    return `${a}://${c}${t && s ? `:${s}` : ''}@${n}${o ? `:${o}` : ''}/${
      r && `${r}/`
    }${i}`
  }
  function BA(e) {
    let t = h9.exec(e)
    if (!t) {
      console.error(`Invalid Sentry Dsn: ${e}`)
      return
    }
    let [n, r, s = '', o, i = '', a] = t.slice(1),
      c = '',
      u = a,
      d = u.split('/')
    if ((d.length > 1 && ((c = d.slice(0, -1).join('/')), (u = d.pop())), u)) {
      let p = u.match(/^\d+/)
      p && (u = p[0])
    }
    return jA({
      host: o,
      pass: s,
      path: c,
      projectId: u,
      port: i,
      protocol: n,
      publicKey: r,
    })
  }
  function jA(e) {
    return {
      protocol: e.protocol,
      publicKey: e.publicKey || '',
      pass: e.pass || '',
      host: e.host,
      port: e.port || '',
      path: e.path || '',
      projectId: e.projectId,
    }
  }
  function E9(e) {
    if (!(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__)) return !0
    let { port: t, projectId: n, protocol: r } = e
    return ['protocol', 'publicKey', 'host', 'projectId'].find((i) =>
      e[i] ? !1 : (em.logger.error(`Invalid Sentry Dsn: ${i} missing`), !0),
    )
      ? !1
      : n.match(/^\d+$/)
        ? g9(r)
          ? t && isNaN(parseInt(t, 10))
            ? (em.logger.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1)
            : !0
          : (em.logger.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1)
        : (em.logger.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1)
  }
  function S9(e) {
    let t = typeof e == 'string' ? BA(e) : jA(e)
    if (!(!t || !E9(t))) return t
  }
  Ed.dsnFromString = BA
  Ed.dsnToString = y9
  Ed.makeDsn = S9
})
var DS = l((RS) => {
  Object.defineProperty(RS, '__esModule', { value: !0 })
  var PS = class extends Error {
    constructor(t, n = 'warn') {
      super(t),
        (this.message = t),
        (this.name = new.target.prototype.constructor.name),
        Object.setPrototypeOf(this, new.target.prototype),
        (this.logLevel = n)
    }
  }
  RS.SentryError = PS
})
var $r = l((on) => {
  Object.defineProperty(on, '__esModule', { value: !0 })
  var b9 = CS(),
    oi = Ut(),
    v9 = Qs(),
    GA = hd()
  function C9(e, t, n) {
    if (!(t in e)) return
    let r = e[t],
      s = n(r)
    typeof s == 'function' && VA(s, r), (e[t] = s)
  }
  function HA(e, t, n) {
    try {
      Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 })
    } catch {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        v9.logger.log(
          `Failed to add non-enumerable property "${t}" to object`,
          e,
        )
    }
  }
  function VA(e, t) {
    try {
      let n = t.prototype || {}
      ;(e.prototype = t.prototype = n), HA(e, '__sentry_original__', t)
    } catch {}
  }
  function T9(e) {
    return e.__sentry_original__
  }
  function w9(e) {
    return Object.keys(e)
      .map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`)
      .join('&')
  }
  function YA(e) {
    if (oi.isError(e))
      return { message: e.message, name: e.name, stack: e.stack, ...zA(e) }
    if (oi.isEvent(e)) {
      let t = {
        type: e.type,
        target: $A(e.target),
        currentTarget: $A(e.currentTarget),
        ...zA(e),
      }
      return (
        typeof CustomEvent < 'u' &&
          oi.isInstanceOf(e, CustomEvent) &&
          (t.detail = e.detail),
        t
      )
    } else return e
  }
  function $A(e) {
    try {
      return oi.isElement(e)
        ? b9.htmlTreeAsString(e)
        : Object.prototype.toString.call(e)
    } catch {
      return '<unknown>'
    }
  }
  function zA(e) {
    if (typeof e == 'object' && e !== null) {
      let t = {}
      for (let n in e)
        Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
      return t
    } else return {}
  }
  function I9(e, t = 40) {
    let n = Object.keys(YA(e))
    if ((n.sort(), !n.length)) return '[object has no keys]'
    if (n[0].length >= t) return GA.truncate(n[0], t)
    for (let r = n.length; r > 0; r--) {
      let s = n.slice(0, r).join(', ')
      if (!(s.length > t)) return r === n.length ? s : GA.truncate(s, t)
    }
    return ''
  }
  function x9(e) {
    return AS(e, new Map())
  }
  function AS(e, t) {
    if (oi.isPlainObject(e)) {
      let n = t.get(e)
      if (n !== void 0) return n
      let r = {}
      t.set(e, r)
      for (let s of Object.keys(e)) typeof e[s] < 'u' && (r[s] = AS(e[s], t))
      return r
    }
    if (Array.isArray(e)) {
      let n = t.get(e)
      if (n !== void 0) return n
      let r = []
      return (
        t.set(e, r),
        e.forEach((s) => {
          r.push(AS(s, t))
        }),
        r
      )
    }
    return e
  }
  function P9(e) {
    let t
    switch (!0) {
      case e == null:
        t = new String(e)
        break
      case typeof e == 'symbol' || typeof e == 'bigint':
        t = Object(e)
        break
      case oi.isPrimitive(e):
        t = new e.constructor(e)
        break
      default:
        t = e
        break
    }
    return t
  }
  on.addNonEnumerableProperty = HA
  on.convertToPlainObject = YA
  on.dropUndefinedKeys = x9
  on.extractExceptionKeysForMessage = I9
  on.fill = C9
  on.getOriginalFunction = T9
  on.markFunctionWrapped = VA
  on.objectify = P9
  on.urlEncode = w9
})
var nm = l((tm) => {
  Object.defineProperty(tm, '__esModule', { value: !0 })
  function WA(e, t = !1) {
    return (
      !(
        t ||
        (e &&
          !e.startsWith('/') &&
          !e.includes(':\\') &&
          !e.startsWith('.') &&
          !e.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))
      ) &&
      e !== void 0 &&
      !e.includes('node_modules/')
    )
  }
  function R9(e) {
    let t = /^\s*[-]{4,}$/,
      n = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/
    return (r) => {
      let s = r.match(n)
      if (s) {
        let o, i, a, c, u
        if (s[1]) {
          a = s[1]
          let _ = a.lastIndexOf('.')
          if ((a[_ - 1] === '.' && _--, _ > 0)) {
            ;(o = a.slice(0, _)), (i = a.slice(_ + 1))
            let f = o.indexOf('.Module')
            f > 0 && ((a = a.slice(f + 1)), (o = o.slice(0, f)))
          }
          c = void 0
        }
        i && ((c = o), (u = i)),
          i === '<anonymous>' && ((u = void 0), (a = void 0)),
          a === void 0 && ((u = u || '<anonymous>'), (a = c ? `${c}.${u}` : u))
        let d = s[2] && s[2].startsWith('file://') ? s[2].slice(7) : s[2],
          p = s[5] === 'native'
        return (
          !d && s[5] && !p && (d = s[5]),
          {
            filename: d,
            module: e ? e(d) : void 0,
            function: a,
            lineno: parseInt(s[3], 10) || void 0,
            colno: parseInt(s[4], 10) || void 0,
            in_app: WA(d, p),
          }
        )
      }
      if (r.match(t)) return { filename: r }
    }
  }
  tm.filenameIsInApp = WA
  tm.node = R9
})
var Sd = l((zr) => {
  Object.defineProperty(zr, '__esModule', { value: !0 })
  var JA = nm(),
    QA = 50,
    KA = /\(error: (.*)\)/,
    XA = /captureMessage|captureException/
  function ZA(...e) {
    let t = e.sort((n, r) => n[0] - r[0]).map((n) => n[1])
    return (n, r = 0) => {
      let s = [],
        o = n.split(`
`)
      for (let i = r; i < o.length; i++) {
        let a = o[i]
        if (a.length > 1024) continue
        let c = KA.test(a) ? a.replace(KA, '$1') : a
        if (!c.match(/\S*Error: /)) {
          for (let u of t) {
            let d = u(c)
            if (d) {
              s.push(d)
              break
            }
          }
          if (s.length >= QA) break
        }
      }
      return eO(s)
    }
  }
  function D9(e) {
    return Array.isArray(e) ? ZA(...e) : e
  }
  function eO(e) {
    if (!e.length) return []
    let t = Array.from(e)
    return (
      /sentryWrapped/.test(t[t.length - 1].function || '') && t.pop(),
      t.reverse(),
      XA.test(t[t.length - 1].function || '') &&
        (t.pop(), XA.test(t[t.length - 1].function || '') && t.pop()),
      t.slice(0, QA).map((n) => ({
        ...n,
        filename: n.filename || t[t.length - 1].filename,
        function: n.function || '?',
      }))
    )
  }
  var OS = '<anonymous>'
  function A9(e) {
    try {
      return !e || typeof e != 'function' ? OS : e.name || OS
    } catch {
      return OS
    }
  }
  function O9(e) {
    return [90, JA.node(e)]
  }
  zr.filenameIsInApp = JA.filenameIsInApp
  zr.createStackParser = ZA
  zr.getFunctionName = A9
  zr.nodeStackLineParser = O9
  zr.stackParserFromStackParserOptions = D9
  zr.stripSentryFramesAndReverse = eO
})
var kS = l((En) => {
  Object.defineProperty(En, '__esModule', { value: !0 })
  var N9 = Qs(),
    q9 = sr(),
    rm = q9.getGlobalObject()
  function k9() {
    try {
      return new ErrorEvent(''), !0
    } catch {
      return !1
    }
  }
  function M9() {
    try {
      return new DOMError(''), !0
    } catch {
      return !1
    }
  }
  function L9() {
    try {
      return new DOMException(''), !0
    } catch {
      return !1
    }
  }
  function qS() {
    if (!('fetch' in rm)) return !1
    try {
      return (
        new Headers(), new Request('http://www.example.com'), new Response(), !0
      )
    } catch {
      return !1
    }
  }
  function NS(e) {
    return (
      e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
    )
  }
  function U9() {
    if (!qS()) return !1
    if (NS(rm.fetch)) return !0
    let e = !1,
      t = rm.document
    if (t && typeof t.createElement == 'function')
      try {
        let n = t.createElement('iframe')
        ;(n.hidden = !0),
          t.head.appendChild(n),
          n.contentWindow &&
            n.contentWindow.fetch &&
            (e = NS(n.contentWindow.fetch)),
          t.head.removeChild(n)
      } catch (n) {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          N9.logger.warn(
            'Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ',
            n,
          )
      }
    return e
  }
  function F9() {
    return 'ReportingObserver' in rm
  }
  function B9() {
    if (!qS()) return !1
    try {
      return new Request('_', { referrerPolicy: 'origin' }), !0
    } catch {
      return !1
    }
  }
  En.isNativeFetch = NS
  En.supportsDOMError = M9
  En.supportsDOMException = L9
  En.supportsErrorEvent = k9
  En.supportsFetch = qS
  En.supportsNativeFetch = U9
  En.supportsReferrerPolicy = B9
  En.supportsReportingObserver = F9
})
var LS = l((MS) => {
  Object.defineProperty(MS, '__esModule', { value: !0 })
  var j9 = sr(),
    sm = j9.getGlobalObject()
  function G9() {
    let e = sm.chrome,
      t = e && e.app && e.app.runtime,
      n = 'history' in sm && !!sm.history.pushState && !!sm.history.replaceState
    return !t && n
  }
  MS.supportsHistory = G9
})
var dO = l((Hr) => {
  Object.defineProperty(Hr, '__esModule', { value: !0 })
  var tO = Ut(),
    vd = Qs(),
    an = $r(),
    $9 = Sd(),
    z9 = kS(),
    Zs = sr(),
    H9 = LS(),
    Be = Zs.getGlobalObject(),
    bd = '__sentry_xhr_v2__',
    eo = {},
    nO = {}
  function V9(e) {
    if (!nO[e])
      switch (((nO[e] = !0), e)) {
        case 'console':
          K9()
          break
        case 'dom':
          cO()
          break
        case 'xhr':
          aO()
          break
        case 'fetch':
          X9()
          break
        case 'history':
          J9()
          break
        case 'error':
          tX()
          break
        case 'unhandledrejection':
          nX()
          break
        default:
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            vd.logger.warn('unknown instrumentation type:', e)
          return
      }
  }
  function Y9(e, t) {
    ;(eo[e] = eo[e] || []), eo[e].push(t), V9(e)
  }
  function W9() {
    Object.keys(eo).forEach((e) => {
      eo[e] = void 0
    })
  }
  function cn(e, t) {
    if (!(!e || !eo[e]))
      for (let n of eo[e] || [])
        try {
          n(t)
        } catch (r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            vd.logger.error(
              `Error while triggering instrumentation handler.
Type: ${e}
Name: ${$9.getFunctionName(n)}
Error:`,
              r,
            )
        }
  }
  function K9() {
    'console' in Zs.GLOBAL_OBJ &&
      vd.CONSOLE_LEVELS.forEach(function (e) {
        e in Zs.GLOBAL_OBJ.console &&
          an.fill(Zs.GLOBAL_OBJ.console, e, function (t) {
            return (
              (vd.originalConsoleMethods[e] = t),
              function (...n) {
                cn('console', { args: n, level: e })
                let r = vd.originalConsoleMethods[e]
                r && r.apply(Zs.GLOBAL_OBJ.console, n)
              }
            )
          })
      })
  }
  function X9() {
    z9.supportsNativeFetch() &&
      an.fill(Zs.GLOBAL_OBJ, 'fetch', function (e) {
        return function (...t) {
          let { method: n, url: r } = iO(t),
            s = {
              args: t,
              fetchData: { method: n, url: r },
              startTimestamp: Date.now(),
            }
          return (
            cn('fetch', { ...s }),
            e.apply(Zs.GLOBAL_OBJ, t).then(
              (o) => (
                cn('fetch', { ...s, endTimestamp: Date.now(), response: o }), o
              ),
              (o) => {
                throw (
                  (cn('fetch', { ...s, endTimestamp: Date.now(), error: o }), o)
                )
              },
            )
          )
        }
      })
  }
  function US(e, t) {
    return !!e && typeof e == 'object' && !!e[t]
  }
  function rO(e) {
    return typeof e == 'string'
      ? e
      : e
        ? US(e, 'url')
          ? e.url
          : e.toString
            ? e.toString()
            : ''
        : ''
  }
  function iO(e) {
    if (e.length === 0) return { method: 'GET', url: '' }
    if (e.length === 2) {
      let [n, r] = e
      return {
        url: rO(n),
        method: US(r, 'method') ? String(r.method).toUpperCase() : 'GET',
      }
    }
    let t = e[0]
    return {
      url: rO(t),
      method: US(t, 'method') ? String(t.method).toUpperCase() : 'GET',
    }
  }
  function aO() {
    if (!Be.XMLHttpRequest) return
    let e = XMLHttpRequest.prototype
    an.fill(e, 'open', function (t) {
      return function (...n) {
        let r = n[1],
          s = (this[bd] = {
            method: tO.isString(n[0]) ? n[0].toUpperCase() : n[0],
            url: n[1],
            request_headers: {},
          })
        tO.isString(r) &&
          s.method === 'POST' &&
          r.match(/sentry_key/) &&
          (this.__sentry_own_request__ = !0)
        let o = () => {
          let i = this[bd]
          if (i && this.readyState === 4) {
            try {
              i.status_code = this.status
            } catch {}
            cn('xhr', {
              args: n,
              endTimestamp: Date.now(),
              startTimestamp: Date.now(),
              xhr: this,
            })
          }
        }
        return (
          'onreadystatechange' in this &&
          typeof this.onreadystatechange == 'function'
            ? an.fill(this, 'onreadystatechange', function (i) {
                return function (...a) {
                  return o(), i.apply(this, a)
                }
              })
            : this.addEventListener('readystatechange', o),
          an.fill(this, 'setRequestHeader', function (i) {
            return function (...a) {
              let [c, u] = a,
                d = this[bd]
              return (
                d && (d.request_headers[c.toLowerCase()] = u), i.apply(this, a)
              )
            }
          }),
          t.apply(this, n)
        )
      }
    }),
      an.fill(e, 'send', function (t) {
        return function (...n) {
          let r = this[bd]
          return (
            r && n[0] !== void 0 && (r.body = n[0]),
            cn('xhr', { args: n, startTimestamp: Date.now(), xhr: this }),
            t.apply(this, n)
          )
        }
      })
  }
  var om
  function J9() {
    if (!H9.supportsHistory()) return
    let e = Be.onpopstate
    Be.onpopstate = function (...n) {
      let r = Be.location.href,
        s = om
      if (((om = r), cn('history', { from: s, to: r }), e))
        try {
          return e.apply(this, n)
        } catch {}
    }
    function t(n) {
      return function (...r) {
        let s = r.length > 2 ? r[2] : void 0
        if (s) {
          let o = om,
            i = String(s)
          ;(om = i), cn('history', { from: o, to: i })
        }
        return n.apply(this, r)
      }
    }
    an.fill(Be.history, 'pushState', t), an.fill(Be.history, 'replaceState', t)
  }
  var Q9 = 1e3,
    sO,
    im
  function Z9(e, t) {
    if (e.type !== t.type) return !1
    try {
      if (e.target !== t.target) return !1
    } catch {}
    return !0
  }
  function eX(e) {
    if (e.type !== 'keypress') return !1
    try {
      let t = e.target
      if (!t || !t.tagName) return !0
      if (
        t.tagName === 'INPUT' ||
        t.tagName === 'TEXTAREA' ||
        t.isContentEditable
      )
        return !1
    } catch {}
    return !0
  }
  function oO(e, t = !1) {
    return (n) => {
      if (!n || n._sentryCaptured || eX(n)) return
      an.addNonEnumerableProperty(n, '_sentryCaptured', !0)
      let r = n.type === 'keypress' ? 'input' : n.type
      ;(im === void 0 || !Z9(im, n)) &&
        (e({ event: n, name: r, global: t }), (im = n)),
        clearTimeout(sO),
        (sO = Be.setTimeout(() => {
          im = void 0
        }, Q9))
    }
  }
  function cO() {
    if (!Be.document) return
    let e = cn.bind(null, 'dom'),
      t = oO(e, !0)
    Be.document.addEventListener('click', t, !1),
      Be.document.addEventListener('keypress', t, !1),
      ['EventTarget', 'Node'].forEach((n) => {
        let r = Be[n] && Be[n].prototype
        !r ||
          !r.hasOwnProperty ||
          !r.hasOwnProperty('addEventListener') ||
          (an.fill(r, 'addEventListener', function (s) {
            return function (o, i, a) {
              if (o === 'click' || o == 'keypress')
                try {
                  let c = this,
                    u = (c.__sentry_instrumentation_handlers__ =
                      c.__sentry_instrumentation_handlers__ || {}),
                    d = (u[o] = u[o] || { refCount: 0 })
                  if (!d.handler) {
                    let p = oO(e)
                    ;(d.handler = p), s.call(this, o, p, a)
                  }
                  d.refCount++
                } catch {}
              return s.call(this, o, i, a)
            }
          }),
          an.fill(r, 'removeEventListener', function (s) {
            return function (o, i, a) {
              if (o === 'click' || o == 'keypress')
                try {
                  let c = this,
                    u = c.__sentry_instrumentation_handlers__ || {},
                    d = u[o]
                  d &&
                    (d.refCount--,
                    d.refCount <= 0 &&
                      (s.call(this, o, d.handler, a),
                      (d.handler = void 0),
                      delete u[o]),
                    Object.keys(u).length === 0 &&
                      delete c.__sentry_instrumentation_handlers__)
                } catch {}
              return s.call(this, o, i, a)
            }
          }))
      })
  }
  var am = null
  function tX() {
    ;(am = Be.onerror),
      (Be.onerror = function (e, t, n, r, s) {
        return (
          cn('error', { column: r, error: s, line: n, msg: e, url: t }),
          am && !am.__SENTRY_LOADER__ ? am.apply(this, arguments) : !1
        )
      }),
      (Be.onerror.__SENTRY_INSTRUMENTED__ = !0)
  }
  var cm = null
  function nX() {
    ;(cm = Be.onunhandledrejection),
      (Be.onunhandledrejection = function (e) {
        return (
          cn('unhandledrejection', e),
          cm && !cm.__SENTRY_LOADER__ ? cm.apply(this, arguments) : !0
        )
      }),
      (Be.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0)
  }
  Hr.SENTRY_XHR_DATA_KEY = bd
  Hr.addInstrumentationHandler = Y9
  Hr.instrumentDOM = cO
  Hr.instrumentXHR = aO
  Hr.parseFetchArgs = iO
  Hr.resetInstrumentationHandlers = W9
})
var BS = l((FS) => {
  Object.defineProperty(FS, '__esModule', { value: !0 })
  function rX() {
    let e = typeof WeakSet == 'function',
      t = e ? new WeakSet() : []
    function n(s) {
      if (e) return t.has(s) ? !0 : (t.add(s), !1)
      for (let o = 0; o < t.length; o++) if (t[o] === s) return !0
      return t.push(s), !1
    }
    function r(s) {
      if (e) t.delete(s)
      else
        for (let o = 0; o < t.length; o++)
          if (t[o] === s) {
            t.splice(o, 1)
            break
          }
    }
    return [n, r]
  }
  FS.memoBuilder = rX
})
var dm = l((Sn) => {
  Object.defineProperty(Sn, '__esModule', { value: !0 })
  var sX = $r(),
    jS = hd(),
    oX = sr()
  function iX() {
    let e = oX.GLOBAL_OBJ,
      t = e.crypto || e.msCrypto,
      n = () => Math.random() * 16
    try {
      if (t && t.randomUUID) return t.randomUUID().replace(/-/g, '')
      t &&
        t.getRandomValues &&
        (n = () => t.getRandomValues(new Uint8Array(1))[0])
    } catch {}
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (r) =>
      (r ^ ((n() & 15) >> (r / 4))).toString(16),
    )
  }
  function uO(e) {
    return e.exception && e.exception.values ? e.exception.values[0] : void 0
  }
  function aX(e) {
    let { message: t, event_id: n } = e
    if (t) return t
    let r = uO(e)
    return r
      ? r.type && r.value
        ? `${r.type}: ${r.value}`
        : r.type || r.value || n || '<unknown>'
      : n || '<unknown>'
  }
  function cX(e, t, n) {
    let r = (e.exception = e.exception || {}),
      s = (r.values = r.values || []),
      o = (s[0] = s[0] || {})
    o.value || (o.value = t || ''), o.type || (o.type = n || 'Error')
  }
  function dX(e, t) {
    let n = uO(e)
    if (!n) return
    let r = { type: 'generic', handled: !0 },
      s = n.mechanism
    if (((n.mechanism = { ...r, ...s, ...t }), t && 'data' in t)) {
      let o = { ...(s && s.data), ...t.data }
      n.mechanism.data = o
    }
  }
  var uX =
    /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/
  function lX(e) {
    let t = e.match(uX) || [],
      n = parseInt(t[1], 10),
      r = parseInt(t[2], 10),
      s = parseInt(t[3], 10)
    return {
      buildmetadata: t[5],
      major: isNaN(n) ? void 0 : n,
      minor: isNaN(r) ? void 0 : r,
      patch: isNaN(s) ? void 0 : s,
      prerelease: t[4],
    }
  }
  function mX(e, t, n = 5) {
    if (t.lineno === void 0) return
    let r = e.length,
      s = Math.max(Math.min(r - 1, t.lineno - 1), 0)
    ;(t.pre_context = e
      .slice(Math.max(0, s - n), s)
      .map((o) => jS.snipLine(o, 0))),
      (t.context_line = jS.snipLine(e[Math.min(r - 1, s)], t.colno || 0)),
      (t.post_context = e
        .slice(Math.min(s + 1, r), s + 1 + n)
        .map((o) => jS.snipLine(o, 0)))
  }
  function pX(e) {
    if (e && e.__sentry_captured__) return !0
    try {
      sX.addNonEnumerableProperty(e, '__sentry_captured__', !0)
    } catch {}
    return !1
  }
  function _X(e) {
    return Array.isArray(e) ? e : [e]
  }
  Sn.addContextToFrame = mX
  Sn.addExceptionMechanism = dX
  Sn.addExceptionTypeValue = cX
  Sn.arrayify = _X
  Sn.checkOrSetAlreadyCaught = pX
  Sn.getEventDescription = aX
  Sn.parseSemver = lX
  Sn.uuid4 = iX
})
var GS = l((um) => {
  Object.defineProperty(um, '__esModule', { value: !0 })
  function fX() {
    return typeof __SENTRY_BROWSER_BUNDLE__ < 'u' && !!__SENTRY_BROWSER_BUNDLE__
  }
  function hX() {
    return 'npm'
  }
  um.getSDKSource = hX
  um.isBrowserBundle = fX
})
var $S = l((Cd, mm) => {
  Object.defineProperty(Cd, '__esModule', { value: !0 })
  var gX = GS()
  function yX() {
    return (
      !gX.isBrowserBundle() &&
      Object.prototype.toString.call(typeof process < 'u' ? process : 0) ===
        '[object process]'
    )
  }
  function lm(e, t) {
    return e.require(t)
  }
  function EX(e) {
    let t
    try {
      t = lm(mm, e)
    } catch {}
    try {
      let { cwd: n } = lm(mm, 'process')
      t = lm(mm, `${n()}/node_modules/${e}`)
    } catch {}
    return t
  }
  Cd.dynamicRequire = lm
  Cd.isNodeEnv = yX
  Cd.loadModule = EX
})
var wd = l((Td) => {
  Object.defineProperty(Td, '__esModule', { value: !0 })
  var zS = Ut(),
    SX = BS(),
    bX = $r(),
    vX = Sd()
  function lO(e, t = 100, n = 1 / 0) {
    try {
      return pm('', e, t, n)
    } catch (r) {
      return { ERROR: `**non-serializable** (${r})` }
    }
  }
  function mO(e, t = 3, n = 100 * 1024) {
    let r = lO(e, t)
    return IX(r) > n ? mO(e, t - 1, n) : r
  }
  function pm(e, t, n = 1 / 0, r = 1 / 0, s = SX.memoBuilder()) {
    let [o, i] = s
    if (
      t == null ||
      (['number', 'boolean', 'string'].includes(typeof t) && !zS.isNaN(t))
    )
      return t
    let a = CX(e, t)
    if (!a.startsWith('[object ')) return a
    if (t.__sentry_skip_normalization__) return t
    let c =
      typeof t.__sentry_override_normalization_depth__ == 'number'
        ? t.__sentry_override_normalization_depth__
        : n
    if (c === 0) return a.replace('object ', '')
    if (o(t)) return '[Circular ~]'
    let u = t
    if (u && typeof u.toJSON == 'function')
      try {
        let f = u.toJSON()
        return pm('', f, c - 1, r, s)
      } catch {}
    let d = Array.isArray(t) ? [] : {},
      p = 0,
      _ = bX.convertToPlainObject(t)
    for (let f in _) {
      if (!Object.prototype.hasOwnProperty.call(_, f)) continue
      if (p >= r) {
        d[f] = '[MaxProperties ~]'
        break
      }
      let h = _[f]
      ;(d[f] = pm(f, h, c - 1, r, s)), p++
    }
    return i(t), d
  }
  function CX(e, t) {
    try {
      if (e === 'domain' && t && typeof t == 'object' && t._events)
        return '[Domain]'
      if (e === 'domainEmitter') return '[DomainEmitter]'
      if (typeof global < 'u' && t === global) return '[Global]'
      if (typeof window < 'u' && t === window) return '[Window]'
      if (typeof document < 'u' && t === document) return '[Document]'
      if (zS.isVueViewModel(t)) return '[VueViewModel]'
      if (zS.isSyntheticEvent(t)) return '[SyntheticEvent]'
      if (typeof t == 'number' && t !== t) return '[NaN]'
      if (typeof t == 'function') return `[Function: ${vX.getFunctionName(t)}]`
      if (typeof t == 'symbol') return `[${String(t)}]`
      if (typeof t == 'bigint') return `[BigInt: ${String(t)}]`
      let n = TX(t)
      return /^HTML(\w*)Element$/.test(n)
        ? `[HTMLElement: ${n}]`
        : `[object ${n}]`
    } catch (n) {
      return `**non-serializable** (${n})`
    }
  }
  function TX(e) {
    let t = Object.getPrototypeOf(e)
    return t ? t.constructor.name : 'null prototype'
  }
  function wX(e) {
    return ~-encodeURI(e).split(/%..|./).length
  }
  function IX(e) {
    return wX(JSON.stringify(e))
  }
  Td.normalize = lO
  Td.normalizeToSize = mO
  Td.walk = pm
})
var yO = l((or) => {
  Object.defineProperty(or, '__esModule', { value: !0 })
  function _O(e, t) {
    let n = 0
    for (let r = e.length - 1; r >= 0; r--) {
      let s = e[r]
      s === '.'
        ? e.splice(r, 1)
        : s === '..'
          ? (e.splice(r, 1), n++)
          : n && (e.splice(r, 1), n--)
    }
    if (t) for (; n--; n) e.unshift('..')
    return e
  }
  var xX =
    /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/
  function fO(e) {
    let t = e.length > 1024 ? `<truncated>${e.slice(-1024)}` : e,
      n = xX.exec(t)
    return n ? n.slice(1) : []
  }
  function HS(...e) {
    let t = '',
      n = !1
    for (let r = e.length - 1; r >= -1 && !n; r--) {
      let s = r >= 0 ? e[r] : '/'
      s && ((t = `${s}/${t}`), (n = s.charAt(0) === '/'))
    }
    return (
      (t = _O(
        t.split('/').filter((r) => !!r),
        !n,
      ).join('/')),
      (n ? '/' : '') + t || '.'
    )
  }
  function pO(e) {
    let t = 0
    for (; t < e.length && e[t] === ''; t++);
    let n = e.length - 1
    for (; n >= 0 && e[n] === ''; n--);
    return t > n ? [] : e.slice(t, n - t + 1)
  }
  function PX(e, t) {
    ;(e = HS(e).slice(1)), (t = HS(t).slice(1))
    let n = pO(e.split('/')),
      r = pO(t.split('/')),
      s = Math.min(n.length, r.length),
      o = s
    for (let a = 0; a < s; a++)
      if (n[a] !== r[a]) {
        o = a
        break
      }
    let i = []
    for (let a = o; a < n.length; a++) i.push('..')
    return (i = i.concat(r.slice(o))), i.join('/')
  }
  function hO(e) {
    let t = gO(e),
      n = e.slice(-1) === '/',
      r = _O(
        e.split('/').filter((s) => !!s),
        !t,
      ).join('/')
    return !r && !t && (r = '.'), r && n && (r += '/'), (t ? '/' : '') + r
  }
  function gO(e) {
    return e.charAt(0) === '/'
  }
  function RX(...e) {
    return hO(e.join('/'))
  }
  function DX(e) {
    let t = fO(e),
      n = t[0],
      r = t[1]
    return !n && !r ? '.' : (r && (r = r.slice(0, r.length - 1)), n + r)
  }
  function AX(e, t) {
    let n = fO(e)[2]
    return (
      t &&
        n.slice(t.length * -1) === t &&
        (n = n.slice(0, n.length - t.length)),
      n
    )
  }
  or.basename = AX
  or.dirname = DX
  or.isAbsolute = gO
  or.join = RX
  or.normalizePath = hO
  or.relative = PX
  or.resolve = HS
})
var VS = l((xd) => {
  Object.defineProperty(xd, '__esModule', { value: !0 })
  var OX = Ut(),
    ir
  ;(function (e) {
    e[(e.PENDING = 0)] = 'PENDING'
    let n = 1
    e[(e.RESOLVED = n)] = 'RESOLVED'
    let r = 2
    e[(e.REJECTED = r)] = 'REJECTED'
  })(ir || (ir = {}))
  function NX(e) {
    return new Id((t) => {
      t(e)
    })
  }
  function qX(e) {
    return new Id((t, n) => {
      n(e)
    })
  }
  var Id = class e {
    constructor(t) {
      e.prototype.__init.call(this),
        e.prototype.__init2.call(this),
        e.prototype.__init3.call(this),
        e.prototype.__init4.call(this),
        (this._state = ir.PENDING),
        (this._handlers = [])
      try {
        t(this._resolve, this._reject)
      } catch (n) {
        this._reject(n)
      }
    }
    then(t, n) {
      return new e((r, s) => {
        this._handlers.push([
          !1,
          (o) => {
            if (!t) r(o)
            else
              try {
                r(t(o))
              } catch (i) {
                s(i)
              }
          },
          (o) => {
            if (!n) s(o)
            else
              try {
                r(n(o))
              } catch (i) {
                s(i)
              }
          },
        ]),
          this._executeHandlers()
      })
    }
    catch(t) {
      return this.then((n) => n, t)
    }
    finally(t) {
      return new e((n, r) => {
        let s, o
        return this.then(
          (i) => {
            ;(o = !1), (s = i), t && t()
          },
          (i) => {
            ;(o = !0), (s = i), t && t()
          },
        ).then(() => {
          if (o) {
            r(s)
            return
          }
          n(s)
        })
      })
    }
    __init() {
      this._resolve = (t) => {
        this._setResult(ir.RESOLVED, t)
      }
    }
    __init2() {
      this._reject = (t) => {
        this._setResult(ir.REJECTED, t)
      }
    }
    __init3() {
      this._setResult = (t, n) => {
        if (this._state === ir.PENDING) {
          if (OX.isThenable(n)) {
            n.then(this._resolve, this._reject)
            return
          }
          ;(this._state = t), (this._value = n), this._executeHandlers()
        }
      }
    }
    __init4() {
      this._executeHandlers = () => {
        if (this._state === ir.PENDING) return
        let t = this._handlers.slice()
        ;(this._handlers = []),
          t.forEach((n) => {
            n[0] ||
              (this._state === ir.RESOLVED && n[1](this._value),
              this._state === ir.REJECTED && n[2](this._value),
              (n[0] = !0))
          })
      }
    }
  }
  xd.SyncPromise = Id
  xd.rejectedSyncPromise = qX
  xd.resolvedSyncPromise = NX
})
var EO = l((WS) => {
  Object.defineProperty(WS, '__esModule', { value: !0 })
  var kX = DS(),
    YS = VS()
  function MX(e) {
    let t = []
    function n() {
      return e === void 0 || t.length < e
    }
    function r(i) {
      return t.splice(t.indexOf(i), 1)[0]
    }
    function s(i) {
      if (!n())
        return YS.rejectedSyncPromise(
          new kX.SentryError(
            'Not adding Promise because buffer limit was reached.',
          ),
        )
      let a = i()
      return (
        t.indexOf(a) === -1 && t.push(a),
        a.then(() => r(a)).then(null, () => r(a).then(null, () => {})),
        a
      )
    }
    function o(i) {
      return new YS.SyncPromise((a, c) => {
        let u = t.length
        if (!u) return a(!0)
        let d = setTimeout(() => {
          i && i > 0 && a(!1)
        }, i)
        t.forEach((p) => {
          YS.resolvedSyncPromise(p).then(() => {
            --u || (clearTimeout(d), a(!0))
          }, c)
        })
      })
    }
    return { $: t, add: s, drain: o }
  }
  WS.makePromiseBuffer = MX
})
var KS = l((ii) => {
  Object.defineProperty(ii, '__esModule', { value: !0 })
  function LX(e) {
    if (!e) return {}
    let t = e.match(
      /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,
    )
    if (!t) return {}
    let n = t[6] || '',
      r = t[8] || ''
    return {
      host: t[4],
      path: t[5],
      protocol: t[2],
      search: n,
      hash: r,
      relative: t[5] + n + r,
    }
  }
  function UX(e) {
    return e.split(/[\?#]/, 1)[0]
  }
  function FX(e) {
    return e.split(/\\?\//).filter((t) => t.length > 0 && t !== ',').length
  }
  function BX(e) {
    let { protocol: t, host: n, path: r } = e,
      s =
        (n &&
          n
            .replace(/^.*@/, '[filtered]:[filtered]@')
            .replace(':80', '')
            .replace(':443', '')) ||
        ''
    return `${t ? `${t}://` : ''}${s}${r}`
  }
  ii.getNumberOfUrlSegments = FX
  ii.getSanitizedUrlString = BX
  ii.parseUrl = LX
  ii.stripUrlQueryAndFragment = UX
})
var vO = l((ai) => {
  Object.defineProperty(ai, '__esModule', { value: !0 })
  var SO = Ut(),
    jX = wd(),
    GX = KS(),
    $X = { ip: !1, request: !0, transaction: !0, user: !0 },
    zX = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'],
    HX = ['id', 'username', 'email']
  function VX(e, t, n) {
    e &&
      ((!e.metadata.source || e.metadata.source === 'url') &&
        e.setName(..._m(t, { path: !0, method: !0 })),
      e.setData('url', t.originalUrl || t.url),
      t.baseUrl && e.setData('baseUrl', t.baseUrl),
      e.setData('query', bO(t, n)))
  }
  function _m(e, t = {}) {
    let n = e.method && e.method.toUpperCase(),
      r = '',
      s = 'url'
    t.customRoute || e.route
      ? ((r = t.customRoute || `${e.baseUrl || ''}${e.route && e.route.path}`),
        (s = 'route'))
      : (e.originalUrl || e.url) &&
        (r = GX.stripUrlQueryAndFragment(e.originalUrl || e.url || ''))
    let o = ''
    return (
      t.method && n && (o += n),
      t.method && t.path && (o += ' '),
      t.path && r && (o += r),
      [o, s]
    )
  }
  function YX(e, t) {
    switch (t) {
      case 'path':
        return _m(e, { path: !0 })[0]
      case 'handler':
        return (
          (e.route &&
            e.route.stack &&
            e.route.stack[0] &&
            e.route.stack[0].name) ||
          '<anonymous>'
        )
      case 'methodPath':
      default:
        return _m(e, { path: !0, method: !0 })[0]
    }
  }
  function WX(e, t) {
    let n = {}
    return (
      (Array.isArray(t) ? t : HX).forEach((s) => {
        e && s in e && (n[s] = e[s])
      }),
      n
    )
  }
  function XS(e, t) {
    let { include: n = zX, deps: r } = t || {},
      s = {},
      o = e.headers || {},
      i = e.method,
      a = e.hostname || e.host || o.host || '<no host>',
      c =
        e.protocol === 'https' || (e.socket && e.socket.encrypted)
          ? 'https'
          : 'http',
      u = e.originalUrl || e.url || '',
      d = `${c}://${a}${u}`
    return (
      n.forEach((p) => {
        switch (p) {
          case 'headers': {
            s.headers = o
            break
          }
          case 'method': {
            s.method = i
            break
          }
          case 'url': {
            s.url = d
            break
          }
          case 'cookies': {
            s.cookies =
              e.cookies ||
              (o.cookie && r && r.cookie && r.cookie.parse(o.cookie)) ||
              {}
            break
          }
          case 'query_string': {
            s.query_string = bO(e, r)
            break
          }
          case 'data': {
            if (i === 'GET' || i === 'HEAD') break
            e.body !== void 0 &&
              (s.data = SO.isString(e.body)
                ? e.body
                : JSON.stringify(jX.normalize(e.body)))
            break
          }
          default:
            ;({}).hasOwnProperty.call(e, p) && (s[p] = e[p])
        }
      }),
      s
    )
  }
  function KX(e, t, n) {
    let r = { ...$X, ...(n && n.include) }
    if (r.request) {
      let s = Array.isArray(r.request)
        ? XS(t, { include: r.request, deps: n && n.deps })
        : XS(t, { deps: n && n.deps })
      e.request = { ...e.request, ...s }
    }
    if (r.user) {
      let s = t.user && SO.isPlainObject(t.user) ? WX(t.user, r.user) : {}
      Object.keys(s).length && (e.user = { ...e.user, ...s })
    }
    if (r.ip) {
      let s = t.ip || (t.socket && t.socket.remoteAddress)
      s && (e.user = { ...e.user, ip_address: s })
    }
    return (
      r.transaction && !e.transaction && (e.transaction = YX(t, r.transaction)),
      e
    )
  }
  function bO(e, t) {
    let n = e.originalUrl || e.url || ''
    if (n)
      return (
        n.startsWith('/') && (n = `http://dogs.are.great${n}`),
        e.query ||
          (typeof URL !== void 0 && new URL(n).search.replace('?', '')) ||
          (t && t.url && t.url.parse(n).query) ||
          void 0
      )
  }
  ai.addRequestDataToEvent = KX
  ai.addRequestDataToTransaction = VX
  ai.extractPathForTransaction = _m
  ai.extractRequestData = XS
})
var wO = l((Pd) => {
  Object.defineProperty(Pd, '__esModule', { value: !0 })
  var CO = ['fatal', 'error', 'warning', 'log', 'info', 'debug']
  function XX(e) {
    return TO(e)
  }
  function TO(e) {
    return e === 'warn' ? 'warning' : CO.includes(e) ? e : 'log'
  }
  Pd.severityFromString = XX
  Pd.severityLevelFromString = TO
  Pd.validSeverityLevels = CO
})
var QS = l((Ft, DO) => {
  Object.defineProperty(Ft, '__esModule', { value: !0 })
  var xO = $S(),
    JX = sr(),
    PO = JX.getGlobalObject(),
    JS = { nowSeconds: () => Date.now() / 1e3 }
  function QX() {
    let { performance: e } = PO
    if (!e || !e.now) return
    let t = Date.now() - e.now()
    return { now: () => e.now(), timeOrigin: t }
  }
  function ZX() {
    try {
      return xO.dynamicRequire(DO, 'perf_hooks').performance
    } catch {
      return
    }
  }
  var fm = xO.isNodeEnv() ? ZX() : QX(),
    IO =
      fm === void 0
        ? JS
        : { nowSeconds: () => (fm.timeOrigin + fm.now()) / 1e3 },
    e7 = JS.nowSeconds.bind(JS),
    RO = IO.nowSeconds.bind(IO),
    t7 = RO,
    n7 = fm !== void 0
  Ft._browserPerformanceTimeOriginMode = void 0
  var r7 = (() => {
    let { performance: e } = PO
    if (!e || !e.now) {
      Ft._browserPerformanceTimeOriginMode = 'none'
      return
    }
    let t = 3600 * 1e3,
      n = e.now(),
      r = Date.now(),
      s = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t,
      o = s < t,
      i = e.timing && e.timing.navigationStart,
      c = typeof i == 'number' ? Math.abs(i + n - r) : t,
      u = c < t
    return o || u
      ? s <= c
        ? ((Ft._browserPerformanceTimeOriginMode = 'timeOrigin'), e.timeOrigin)
        : ((Ft._browserPerformanceTimeOriginMode = 'navigationStart'), i)
      : ((Ft._browserPerformanceTimeOriginMode = 'dateNow'), r)
  })()
  Ft.browserPerformanceTimeOrigin = r7
  Ft.dateTimestampInSeconds = e7
  Ft.timestampInSeconds = RO
  Ft.timestampWithMs = t7
  Ft.usingPerformanceAPI = n7
})
var eb = l((Vr) => {
  Object.defineProperty(Vr, '__esModule', { value: !0 })
  var s7 = Ut(),
    o7 = Qs(),
    i7 = 'baggage',
    ZS = 'sentry-',
    OO = /^sentry-/,
    NO = 8192
  function a7(e) {
    if (!s7.isString(e) && !Array.isArray(e)) return
    let t = {}
    if (Array.isArray(e))
      t = e.reduce((r, s) => {
        let o = AO(s)
        return { ...r, ...o }
      }, {})
    else {
      if (!e) return
      t = AO(e)
    }
    let n = Object.entries(t).reduce((r, [s, o]) => {
      if (s.match(OO)) {
        let i = s.slice(ZS.length)
        r[i] = o
      }
      return r
    }, {})
    if (Object.keys(n).length > 0) return n
  }
  function c7(e) {
    if (!e) return
    let t = Object.entries(e).reduce(
      (n, [r, s]) => (s && (n[`${ZS}${r}`] = s), n),
      {},
    )
    return d7(t)
  }
  function AO(e) {
    return e
      .split(',')
      .map((t) => t.split('=').map((n) => decodeURIComponent(n.trim())))
      .reduce((t, [n, r]) => ((t[n] = r), t), {})
  }
  function d7(e) {
    if (Object.keys(e).length !== 0)
      return Object.entries(e).reduce((t, [n, r], s) => {
        let o = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`,
          i = s === 0 ? o : `${t},${o}`
        return i.length > NO
          ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              o7.logger.warn(
                `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`,
              ),
            t)
          : i
      }, '')
  }
  Vr.BAGGAGE_HEADER_NAME = i7
  Vr.MAX_BAGGAGE_STRING_LENGTH = NO
  Vr.SENTRY_BAGGAGE_KEY_PREFIX = ZS
  Vr.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = OO
  Vr.baggageHeaderToDynamicSamplingContext = a7
  Vr.dynamicSamplingContextToSentryBaggageHeader = c7
})
var MO = l((ci) => {
  Object.defineProperty(ci, '__esModule', { value: !0 })
  var u7 = eb(),
    hm = dm(),
    qO = new RegExp('^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$')
  function kO(e) {
    if (!e) return
    let t = e.match(qO)
    if (!t) return
    let n
    return (
      t[3] === '1' ? (n = !0) : t[3] === '0' && (n = !1),
      { traceId: t[1], parentSampled: n, parentSpanId: t[2] }
    )
  }
  function l7(e, t) {
    let n = kO(e),
      r = u7.baggageHeaderToDynamicSamplingContext(t),
      { traceId: s, parentSpanId: o, parentSampled: i } = n || {},
      a = {
        traceId: s || hm.uuid4(),
        spanId: hm.uuid4().substring(16),
        sampled: i,
      }
    return (
      o && (a.parentSpanId = o),
      r && (a.dsc = r),
      { traceparentData: n, dynamicSamplingContext: r, propagationContext: a }
    )
  }
  function m7(e = hm.uuid4(), t = hm.uuid4().substring(16), n) {
    let r = ''
    return n !== void 0 && (r = n ? '-1' : '-0'), `${e}-${t}${r}`
  }
  ci.TRACEPARENT_REGEXP = qO
  ci.extractTraceparentData = kO
  ci.generateSentryTraceHeader = m7
  ci.tracingContextFromHeaders = l7
})
var nb = l((Bt) => {
  Object.defineProperty(Bt, '__esModule', { value: !0 })
  var p7 = xS(),
    _7 = wd(),
    LO = $r()
  function f7(e, t = []) {
    return [e, t]
  }
  function h7(e, t) {
    let [n, r] = e
    return [n, [...r, t]]
  }
  function UO(e, t) {
    let n = e[1]
    for (let r of n) {
      let s = r[0].type
      if (t(r, s)) return !0
    }
    return !1
  }
  function g7(e, t) {
    return UO(e, (n, r) => t.includes(r))
  }
  function tb(e, t) {
    return (t || new TextEncoder()).encode(e)
  }
  function y7(e, t) {
    let [n, r] = e,
      s = JSON.stringify(n)
    function o(i) {
      typeof s == 'string'
        ? (s = typeof i == 'string' ? s + i : [tb(s, t), i])
        : s.push(typeof i == 'string' ? tb(i, t) : i)
    }
    for (let i of r) {
      let [a, c] = i
      if (
        (o(`
${JSON.stringify(a)}
`),
        typeof c == 'string' || c instanceof Uint8Array)
      )
        o(c)
      else {
        let u
        try {
          u = JSON.stringify(c)
        } catch {
          u = JSON.stringify(_7.normalize(c))
        }
        o(u)
      }
    }
    return typeof s == 'string' ? s : E7(s)
  }
  function E7(e) {
    let t = e.reduce((s, o) => s + o.length, 0),
      n = new Uint8Array(t),
      r = 0
    for (let s of e) n.set(s, r), (r += s.length)
    return n
  }
  function S7(e, t, n) {
    let r = typeof e == 'string' ? t.encode(e) : e
    function s(c) {
      let u = r.subarray(0, c)
      return (r = r.subarray(c + 1)), u
    }
    function o() {
      let c = r.indexOf(10)
      return c < 0 && (c = r.length), JSON.parse(n.decode(s(c)))
    }
    let i = o(),
      a = []
    for (; r.length; ) {
      let c = o(),
        u = typeof c.length == 'number' ? c.length : void 0
      a.push([c, u ? s(u) : o()])
    }
    return [i, a]
  }
  function b7(e, t) {
    let n = typeof e.data == 'string' ? tb(e.data, t) : e.data
    return [
      LO.dropUndefinedKeys({
        type: 'attachment',
        length: n.length,
        filename: e.filename,
        content_type: e.contentType,
        attachment_type: e.attachmentType,
      }),
      n,
    ]
  }
  var v7 = {
    session: 'session',
    sessions: 'session',
    attachment: 'attachment',
    transaction: 'transaction',
    event: 'error',
    client_report: 'internal',
    user_report: 'default',
    profile: 'profile',
    replay_event: 'replay',
    replay_recording: 'replay',
    check_in: 'monitor',
  }
  function C7(e) {
    return v7[e]
  }
  function T7(e) {
    if (!e || !e.sdk) return
    let { name: t, version: n } = e.sdk
    return { name: t, version: n }
  }
  function w7(e, t, n, r) {
    let s =
      e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext
    return {
      event_id: e.event_id,
      sent_at: new Date().toISOString(),
      ...(t && { sdk: t }),
      ...(!!n && r && { dsn: p7.dsnToString(r) }),
      ...(s && { trace: LO.dropUndefinedKeys({ ...s }) }),
    }
  }
  Bt.addItemToEnvelope = h7
  Bt.createAttachmentEnvelopeItem = b7
  Bt.createEnvelope = f7
  Bt.createEventEnvelopeHeaders = w7
  Bt.envelopeContainsItemType = g7
  Bt.envelopeItemTypeToDataCategory = C7
  Bt.forEachEnvelopeItem = UO
  Bt.getSdkMetadataForEnvelopeHeader = T7
  Bt.parseEnvelope = S7
  Bt.serializeEnvelope = y7
})
var FO = l((rb) => {
  Object.defineProperty(rb, '__esModule', { value: !0 })
  var I7 = nb(),
    x7 = QS()
  function P7(e, t, n) {
    let r = [
      { type: 'client_report' },
      { timestamp: n || x7.dateTimestampInSeconds(), discarded_events: e },
    ]
    return I7.createEnvelope(t ? { dsn: t } : {}, [r])
  }
  rb.createClientReportEnvelope = P7
})
var $O = l((to) => {
  Object.defineProperty(to, '__esModule', { value: !0 })
  var BO = 60 * 1e3
  function jO(e, t = Date.now()) {
    let n = parseInt(`${e}`, 10)
    if (!isNaN(n)) return n * 1e3
    let r = Date.parse(`${e}`)
    return isNaN(r) ? BO : r - t
  }
  function GO(e, t) {
    return e[t] || e.all || 0
  }
  function R7(e, t, n = Date.now()) {
    return GO(e, t) > n
  }
  function D7(e, { statusCode: t, headers: n }, r = Date.now()) {
    let s = { ...e },
      o = n && n['x-sentry-rate-limits'],
      i = n && n['retry-after']
    if (o)
      for (let a of o.trim().split(',')) {
        let [c, u] = a.split(':', 2),
          d = parseInt(c, 10),
          p = (isNaN(d) ? 60 : d) * 1e3
        if (!u) s.all = r + p
        else for (let _ of u.split(';')) s[_] = r + p
      }
    else i ? (s.all = r + jO(i, r)) : t === 429 && (s.all = r + 60 * 1e3)
    return s
  }
  to.DEFAULT_RETRY_AFTER = BO
  to.disabledUntil = GO
  to.isRateLimited = R7
  to.parseRetryAfterHeader = jO
  to.updateRateLimits = D7
})
var VO = l((sb) => {
  Object.defineProperty(sb, '__esModule', { value: !0 })
  function zO(e, t, n) {
    let r = t.match(/([a-z_]+)\.(.*)/i)
    if (r === null) e[t] = n
    else {
      let s = e[r[1]]
      zO(s, r[2], n)
    }
  }
  function A7(e, t, n = {}) {
    return Array.isArray(t) ? HO(e, t, n) : O7(e, t, n)
  }
  function HO(e, t, n) {
    let r = t.find((s) => s.name === e.name)
    if (r) {
      for (let [s, o] of Object.entries(n)) zO(r, s, o)
      return t
    }
    return [...t, e]
  }
  function O7(e, t, n) {
    return (s) => {
      let o = t(s)
      return e.allowExclusionByUser && !o.find((a) => a.name === e.name)
        ? o
        : HO(e, o, n)
    }
  }
  sb.addOrUpdateIntegration = A7
})
var YO = l((ob) => {
  Object.defineProperty(ob, '__esModule', { value: !0 })
  function N7(e) {
    let t = [],
      n = {}
    return {
      add(r, s) {
        for (; t.length >= e; ) {
          let o = t.shift()
          o !== void 0 && delete n[o]
        }
        n[r] && this.delete(r), t.push(r), (n[r] = s)
      },
      clear() {
        ;(n = {}), (t = [])
      },
      get(r) {
        return n[r]
      },
      size() {
        return t.length
      },
      delete(r) {
        if (!n[r]) return !1
        delete n[r]
        for (let s = 0; s < t.length; s++)
          if (t[s] === r) {
            t.splice(s, 1)
            break
          }
        return !0
      },
    }
  }
  ob.makeFifoCache = N7
})
var JO = l((di) => {
  Object.defineProperty(di, '__esModule', { value: !0 })
  var WO = Ut(),
    KO = dm(),
    q7 = wd(),
    k7 = $r()
  function ib(e, t) {
    return e(t.stack || '', 1)
  }
  function XO(e, t) {
    let n = { type: t.name || t.constructor.name, value: t.message },
      r = ib(e, t)
    return r.length && (n.stacktrace = { frames: r }), n
  }
  function M7(e) {
    if ('name' in e && typeof e.name == 'string') {
      let t = `'${e.name}' captured as exception`
      return (
        'message' in e &&
          typeof e.message == 'string' &&
          (t += ` with message '${e.message}'`),
        t
      )
    } else
      return 'message' in e && typeof e.message == 'string'
        ? e.message
        : `Object captured as exception with keys: ${k7.extractExceptionKeysForMessage(
            e,
          )}`
  }
  function L7(e, t, n, r) {
    let s = n,
      i = (r && r.data && r.data.mechanism) || { handled: !0, type: 'generic' }
    if (!WO.isError(n)) {
      if (WO.isPlainObject(n)) {
        let c = e(),
          u = c.getClient(),
          d = u && u.getOptions().normalizeDepth
        c.configureScope((_) => {
          _.setExtra('__serialized__', q7.normalizeToSize(n, d))
        })
        let p = M7(n)
        ;(s = (r && r.syntheticException) || new Error(p)), (s.message = p)
      } else (s = (r && r.syntheticException) || new Error(n)), (s.message = n)
      i.synthetic = !0
    }
    let a = { exception: { values: [XO(t, s)] } }
    return (
      KO.addExceptionTypeValue(a, void 0, void 0),
      KO.addExceptionMechanism(a, i),
      { ...a, event_id: r && r.event_id }
    )
  }
  function U7(e, t, n = 'info', r, s) {
    let o = { event_id: r && r.event_id, level: n, message: t }
    if (s && r && r.syntheticException) {
      let i = ib(e, r.syntheticException)
      i.length &&
        (o.exception = { values: [{ value: t, stacktrace: { frames: i } }] })
    }
    return o
  }
  di.eventFromMessage = U7
  di.eventFromUnknownInput = L7
  di.exceptionFromError = XO
  di.parseStackFrames = ib
})
var QO = l((gm) => {
  Object.defineProperty(gm, '__esModule', { value: !0 })
  var F7 = $r(),
    B7 = Sd(),
    j7 = nm()
  function G7(e, t, n, r) {
    let s = e(),
      o = !1,
      i = !0
    return (
      setInterval(() => {
        let a = s.getTimeMs()
        o === !1 && a > t + n && ((o = !0), i && r()), a < t + n && (o = !1)
      }, 20),
      {
        poll: () => {
          s.reset()
        },
        enabled: (a) => {
          i = a
        },
      }
    )
  }
  function $7(e, t, n) {
    let r = t ? t.replace(/^file:\/\//, '') : void 0,
      s = e.location.columnNumber ? e.location.columnNumber + 1 : void 0,
      o = e.location.lineNumber ? e.location.lineNumber + 1 : void 0
    return F7.dropUndefinedKeys({
      filename: r,
      module: n(r),
      function: e.functionName || '?',
      colno: s,
      lineno: o,
      in_app: r ? j7.filenameIsInApp(r) : void 0,
    })
  }
  function z7(e, t, n) {
    let r = new Map()
    return (s) => {
      if (s.method === 'Debugger.scriptParsed')
        r.set(s.params.scriptId, s.params.url)
      else if (s.method === 'Debugger.paused') {
        let o = [...s.params.callFrames]
        e('Debugger.resume'), e('Debugger.disable')
        let i = B7.stripSentryFramesAndReverse(
          o.map((a) => $7(a, r.get(a.location.scriptId), t)),
        )
        n(i)
      }
    }
  }
  gm.createDebugPauseMessageHandler = z7
  gm.watchdogTimer = G7
})
var ZO = l((ab) => {
  Object.defineProperty(ab, '__esModule', { value: !0 })
  function H7(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')
  }
  ab.escapeStringForRegex = H7
})
var O = l((S) => {
  Object.defineProperty(S, '__esModule', { value: !0 })
  var V7 = UA(),
    cb = CS(),
    db = xS(),
    Y7 = DS(),
    ub = sr(),
    ui = dO(),
    at = Ut(),
    ym = Qs(),
    W7 = BS(),
    Yr = dm(),
    lb = $S(),
    mb = wd(),
    ar = $r(),
    no = yO(),
    K7 = EO(),
    Em = vO(),
    pb = wO(),
    Rd = Sd(),
    Dd = hd(),
    Wr = kS(),
    _b = VS(),
    li = QS(),
    Sm = MO(),
    eN = GS(),
    bn = nb(),
    X7 = FO(),
    Ad = $O(),
    mi = eb(),
    bm = KS(),
    J7 = VO(),
    Q7 = YO(),
    vm = JO(),
    tN = QO(),
    Z7 = nm(),
    eJ = ZO(),
    tJ = LS()
  S.applyAggregateErrorsToEvent = V7.applyAggregateErrorsToEvent
  S.getDomElement = cb.getDomElement
  S.getLocationHref = cb.getLocationHref
  S.htmlTreeAsString = cb.htmlTreeAsString
  S.dsnFromString = db.dsnFromString
  S.dsnToString = db.dsnToString
  S.makeDsn = db.makeDsn
  S.SentryError = Y7.SentryError
  S.GLOBAL_OBJ = ub.GLOBAL_OBJ
  S.getGlobalObject = ub.getGlobalObject
  S.getGlobalSingleton = ub.getGlobalSingleton
  S.SENTRY_XHR_DATA_KEY = ui.SENTRY_XHR_DATA_KEY
  S.addInstrumentationHandler = ui.addInstrumentationHandler
  S.instrumentDOM = ui.instrumentDOM
  S.instrumentXHR = ui.instrumentXHR
  S.parseFetchArgs = ui.parseFetchArgs
  S.resetInstrumentationHandlers = ui.resetInstrumentationHandlers
  S.isDOMError = at.isDOMError
  S.isDOMException = at.isDOMException
  S.isElement = at.isElement
  S.isError = at.isError
  S.isErrorEvent = at.isErrorEvent
  S.isEvent = at.isEvent
  S.isInstanceOf = at.isInstanceOf
  S.isNaN = at.isNaN
  S.isPlainObject = at.isPlainObject
  S.isPrimitive = at.isPrimitive
  S.isRegExp = at.isRegExp
  S.isString = at.isString
  S.isSyntheticEvent = at.isSyntheticEvent
  S.isThenable = at.isThenable
  S.isVueViewModel = at.isVueViewModel
  S.CONSOLE_LEVELS = ym.CONSOLE_LEVELS
  S.consoleSandbox = ym.consoleSandbox
  S.logger = ym.logger
  S.originalConsoleMethods = ym.originalConsoleMethods
  S.memoBuilder = W7.memoBuilder
  S.addContextToFrame = Yr.addContextToFrame
  S.addExceptionMechanism = Yr.addExceptionMechanism
  S.addExceptionTypeValue = Yr.addExceptionTypeValue
  S.arrayify = Yr.arrayify
  S.checkOrSetAlreadyCaught = Yr.checkOrSetAlreadyCaught
  S.getEventDescription = Yr.getEventDescription
  S.parseSemver = Yr.parseSemver
  S.uuid4 = Yr.uuid4
  S.dynamicRequire = lb.dynamicRequire
  S.isNodeEnv = lb.isNodeEnv
  S.loadModule = lb.loadModule
  S.normalize = mb.normalize
  S.normalizeToSize = mb.normalizeToSize
  S.walk = mb.walk
  S.addNonEnumerableProperty = ar.addNonEnumerableProperty
  S.convertToPlainObject = ar.convertToPlainObject
  S.dropUndefinedKeys = ar.dropUndefinedKeys
  S.extractExceptionKeysForMessage = ar.extractExceptionKeysForMessage
  S.fill = ar.fill
  S.getOriginalFunction = ar.getOriginalFunction
  S.markFunctionWrapped = ar.markFunctionWrapped
  S.objectify = ar.objectify
  S.urlEncode = ar.urlEncode
  S.basename = no.basename
  S.dirname = no.dirname
  S.isAbsolute = no.isAbsolute
  S.join = no.join
  S.normalizePath = no.normalizePath
  S.relative = no.relative
  S.resolve = no.resolve
  S.makePromiseBuffer = K7.makePromiseBuffer
  S.addRequestDataToEvent = Em.addRequestDataToEvent
  S.addRequestDataToTransaction = Em.addRequestDataToTransaction
  S.extractPathForTransaction = Em.extractPathForTransaction
  S.extractRequestData = Em.extractRequestData
  S.severityFromString = pb.severityFromString
  S.severityLevelFromString = pb.severityLevelFromString
  S.validSeverityLevels = pb.validSeverityLevels
  S.createStackParser = Rd.createStackParser
  S.getFunctionName = Rd.getFunctionName
  S.nodeStackLineParser = Rd.nodeStackLineParser
  S.stackParserFromStackParserOptions = Rd.stackParserFromStackParserOptions
  S.stripSentryFramesAndReverse = Rd.stripSentryFramesAndReverse
  S.isMatchingPattern = Dd.isMatchingPattern
  S.safeJoin = Dd.safeJoin
  S.snipLine = Dd.snipLine
  S.stringMatchesSomePattern = Dd.stringMatchesSomePattern
  S.truncate = Dd.truncate
  S.isNativeFetch = Wr.isNativeFetch
  S.supportsDOMError = Wr.supportsDOMError
  S.supportsDOMException = Wr.supportsDOMException
  S.supportsErrorEvent = Wr.supportsErrorEvent
  S.supportsFetch = Wr.supportsFetch
  S.supportsNativeFetch = Wr.supportsNativeFetch
  S.supportsReferrerPolicy = Wr.supportsReferrerPolicy
  S.supportsReportingObserver = Wr.supportsReportingObserver
  S.SyncPromise = _b.SyncPromise
  S.rejectedSyncPromise = _b.rejectedSyncPromise
  S.resolvedSyncPromise = _b.resolvedSyncPromise
  Object.defineProperty(S, '_browserPerformanceTimeOriginMode', {
    enumerable: !0,
    get: () => li._browserPerformanceTimeOriginMode,
  })
  S.browserPerformanceTimeOrigin = li.browserPerformanceTimeOrigin
  S.dateTimestampInSeconds = li.dateTimestampInSeconds
  S.timestampInSeconds = li.timestampInSeconds
  S.timestampWithMs = li.timestampWithMs
  S.usingPerformanceAPI = li.usingPerformanceAPI
  S.TRACEPARENT_REGEXP = Sm.TRACEPARENT_REGEXP
  S.extractTraceparentData = Sm.extractTraceparentData
  S.generateSentryTraceHeader = Sm.generateSentryTraceHeader
  S.tracingContextFromHeaders = Sm.tracingContextFromHeaders
  S.getSDKSource = eN.getSDKSource
  S.isBrowserBundle = eN.isBrowserBundle
  S.addItemToEnvelope = bn.addItemToEnvelope
  S.createAttachmentEnvelopeItem = bn.createAttachmentEnvelopeItem
  S.createEnvelope = bn.createEnvelope
  S.createEventEnvelopeHeaders = bn.createEventEnvelopeHeaders
  S.envelopeContainsItemType = bn.envelopeContainsItemType
  S.envelopeItemTypeToDataCategory = bn.envelopeItemTypeToDataCategory
  S.forEachEnvelopeItem = bn.forEachEnvelopeItem
  S.getSdkMetadataForEnvelopeHeader = bn.getSdkMetadataForEnvelopeHeader
  S.parseEnvelope = bn.parseEnvelope
  S.serializeEnvelope = bn.serializeEnvelope
  S.createClientReportEnvelope = X7.createClientReportEnvelope
  S.DEFAULT_RETRY_AFTER = Ad.DEFAULT_RETRY_AFTER
  S.disabledUntil = Ad.disabledUntil
  S.isRateLimited = Ad.isRateLimited
  S.parseRetryAfterHeader = Ad.parseRetryAfterHeader
  S.updateRateLimits = Ad.updateRateLimits
  S.BAGGAGE_HEADER_NAME = mi.BAGGAGE_HEADER_NAME
  S.MAX_BAGGAGE_STRING_LENGTH = mi.MAX_BAGGAGE_STRING_LENGTH
  S.SENTRY_BAGGAGE_KEY_PREFIX = mi.SENTRY_BAGGAGE_KEY_PREFIX
  S.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = mi.SENTRY_BAGGAGE_KEY_PREFIX_REGEX
  S.baggageHeaderToDynamicSamplingContext =
    mi.baggageHeaderToDynamicSamplingContext
  S.dynamicSamplingContextToSentryBaggageHeader =
    mi.dynamicSamplingContextToSentryBaggageHeader
  S.getNumberOfUrlSegments = bm.getNumberOfUrlSegments
  S.getSanitizedUrlString = bm.getSanitizedUrlString
  S.parseUrl = bm.parseUrl
  S.stripUrlQueryAndFragment = bm.stripUrlQueryAndFragment
  S.addOrUpdateIntegration = J7.addOrUpdateIntegration
  S.makeFifoCache = Q7.makeFifoCache
  S.eventFromMessage = vm.eventFromMessage
  S.eventFromUnknownInput = vm.eventFromUnknownInput
  S.exceptionFromError = vm.exceptionFromError
  S.parseStackFrames = vm.parseStackFrames
  S.createDebugPauseMessageHandler = tN.createDebugPauseMessageHandler
  S.watchdogTimer = tN.watchdogTimer
  S.filenameIsInApp = Z7.filenameIsInApp
  S.escapeStringForRegex = eJ.escapeStringForRegex
  S.supportsHistory = tJ.supportsHistory
})
var Od = l((fb) => {
  Object.defineProperty(fb, '__esModule', { value: !0 })
  var nJ = 'production'
  fb.DEFAULT_ENVIRONMENT = nJ
})
var qd = l((Nd) => {
  Object.defineProperty(Nd, '__esModule', { value: !0 })
  var Cm = O()
  function nN() {
    return Cm.getGlobalSingleton('globalEventProcessors', () => [])
  }
  function rJ(e) {
    nN().push(e)
  }
  function hb(e, t, n, r = 0) {
    return new Cm.SyncPromise((s, o) => {
      let i = e[r]
      if (t === null || typeof i != 'function') s(t)
      else {
        let a = i({ ...t }, n)
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          i.id &&
          a === null &&
          Cm.logger.log(`Event processor "${i.id}" dropped event`),
          Cm.isThenable(a)
            ? a.then((c) => hb(e, c, n, r + 1).then(s)).then(null, o)
            : hb(e, a, n, r + 1)
                .then(s)
                .then(null, o)
      }
    })
  }
  Nd.addGlobalEventProcessor = rJ
  Nd.getGlobalEventProcessors = nN
  Nd.notifyEventProcessors = hb
})
var Ld = l((Md) => {
  Object.defineProperty(Md, '__esModule', { value: !0 })
  var kd = O()
  function sJ(e) {
    let t = kd.timestampInSeconds(),
      n = {
        sid: kd.uuid4(),
        init: !0,
        timestamp: t,
        started: t,
        duration: 0,
        status: 'ok',
        errors: 0,
        ignoreDuration: !1,
        toJSON: () => iJ(n),
      }
    return e && gb(n, e), n
  }
  function gb(e, t = {}) {
    if (
      (t.user &&
        (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address),
        !e.did &&
          !t.did &&
          (e.did = t.user.id || t.user.email || t.user.username)),
      (e.timestamp = t.timestamp || kd.timestampInSeconds()),
      t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
      t.sid && (e.sid = t.sid.length === 32 ? t.sid : kd.uuid4()),
      t.init !== void 0 && (e.init = t.init),
      !e.did && t.did && (e.did = `${t.did}`),
      typeof t.started == 'number' && (e.started = t.started),
      e.ignoreDuration)
    )
      e.duration = void 0
    else if (typeof t.duration == 'number') e.duration = t.duration
    else {
      let n = e.timestamp - e.started
      e.duration = n >= 0 ? n : 0
    }
    t.release && (e.release = t.release),
      t.environment && (e.environment = t.environment),
      !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
      !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
      typeof t.errors == 'number' && (e.errors = t.errors),
      t.status && (e.status = t.status)
  }
  function oJ(e, t) {
    let n = {}
    t ? (n = { status: t }) : e.status === 'ok' && (n = { status: 'exited' }),
      gb(e, n)
  }
  function iJ(e) {
    return kd.dropUndefinedKeys({
      sid: `${e.sid}`,
      init: e.init,
      started: new Date(e.started * 1e3).toISOString(),
      timestamp: new Date(e.timestamp * 1e3).toISOString(),
      status: e.status,
      errors: e.errors,
      did:
        typeof e.did == 'number' || typeof e.did == 'string'
          ? `${e.did}`
          : void 0,
      duration: e.duration,
      attrs: {
        release: e.release,
        environment: e.environment,
        ip_address: e.ipAddress,
        user_agent: e.userAgent,
      },
    })
  }
  Md.closeSession = oJ
  Md.makeSession = sJ
  Md.updateSession = gb
})
var Tm = l((Eb) => {
  Object.defineProperty(Eb, '__esModule', { value: !0 })
  var Ud = O(),
    rN = qd(),
    aJ = Ld(),
    cJ = 100,
    yb = class e {
      constructor() {
        ;(this._notifyingListeners = !1),
          (this._scopeListeners = []),
          (this._eventProcessors = []),
          (this._breadcrumbs = []),
          (this._attachments = []),
          (this._user = {}),
          (this._tags = {}),
          (this._extra = {}),
          (this._contexts = {}),
          (this._sdkProcessingMetadata = {}),
          (this._propagationContext = sN())
      }
      static clone(t) {
        let n = new e()
        return (
          t &&
            ((n._breadcrumbs = [...t._breadcrumbs]),
            (n._tags = { ...t._tags }),
            (n._extra = { ...t._extra }),
            (n._contexts = { ...t._contexts }),
            (n._user = t._user),
            (n._level = t._level),
            (n._span = t._span),
            (n._session = t._session),
            (n._transactionName = t._transactionName),
            (n._fingerprint = t._fingerprint),
            (n._eventProcessors = [...t._eventProcessors]),
            (n._requestSession = t._requestSession),
            (n._attachments = [...t._attachments]),
            (n._sdkProcessingMetadata = { ...t._sdkProcessingMetadata }),
            (n._propagationContext = { ...t._propagationContext })),
          n
        )
      }
      addScopeListener(t) {
        this._scopeListeners.push(t)
      }
      addEventProcessor(t) {
        return this._eventProcessors.push(t), this
      }
      setUser(t) {
        return (
          (this._user = t || {}),
          this._session && aJ.updateSession(this._session, { user: t }),
          this._notifyScopeListeners(),
          this
        )
      }
      getUser() {
        return this._user
      }
      getRequestSession() {
        return this._requestSession
      }
      setRequestSession(t) {
        return (this._requestSession = t), this
      }
      setTags(t) {
        return (
          (this._tags = { ...this._tags, ...t }),
          this._notifyScopeListeners(),
          this
        )
      }
      setTag(t, n) {
        return (
          (this._tags = { ...this._tags, [t]: n }),
          this._notifyScopeListeners(),
          this
        )
      }
      setExtras(t) {
        return (
          (this._extra = { ...this._extra, ...t }),
          this._notifyScopeListeners(),
          this
        )
      }
      setExtra(t, n) {
        return (
          (this._extra = { ...this._extra, [t]: n }),
          this._notifyScopeListeners(),
          this
        )
      }
      setFingerprint(t) {
        return (this._fingerprint = t), this._notifyScopeListeners(), this
      }
      setLevel(t) {
        return (this._level = t), this._notifyScopeListeners(), this
      }
      setTransactionName(t) {
        return (this._transactionName = t), this._notifyScopeListeners(), this
      }
      setContext(t, n) {
        return (
          n === null ? delete this._contexts[t] : (this._contexts[t] = n),
          this._notifyScopeListeners(),
          this
        )
      }
      setSpan(t) {
        return (this._span = t), this._notifyScopeListeners(), this
      }
      getSpan() {
        return this._span
      }
      getTransaction() {
        let t = this.getSpan()
        return t && t.transaction
      }
      setSession(t) {
        return (
          t ? (this._session = t) : delete this._session,
          this._notifyScopeListeners(),
          this
        )
      }
      getSession() {
        return this._session
      }
      update(t) {
        if (!t) return this
        if (typeof t == 'function') {
          let n = t(this)
          return n instanceof e ? n : this
        }
        return (
          t instanceof e
            ? ((this._tags = { ...this._tags, ...t._tags }),
              (this._extra = { ...this._extra, ...t._extra }),
              (this._contexts = { ...this._contexts, ...t._contexts }),
              t._user && Object.keys(t._user).length && (this._user = t._user),
              t._level && (this._level = t._level),
              t._fingerprint && (this._fingerprint = t._fingerprint),
              t._requestSession && (this._requestSession = t._requestSession),
              t._propagationContext &&
                (this._propagationContext = t._propagationContext))
            : Ud.isPlainObject(t) &&
              ((t = t),
              (this._tags = { ...this._tags, ...t.tags }),
              (this._extra = { ...this._extra, ...t.extra }),
              (this._contexts = { ...this._contexts, ...t.contexts }),
              t.user && (this._user = t.user),
              t.level && (this._level = t.level),
              t.fingerprint && (this._fingerprint = t.fingerprint),
              t.requestSession && (this._requestSession = t.requestSession),
              t.propagationContext &&
                (this._propagationContext = t.propagationContext)),
          this
        )
      }
      clear() {
        return (
          (this._breadcrumbs = []),
          (this._tags = {}),
          (this._extra = {}),
          (this._user = {}),
          (this._contexts = {}),
          (this._level = void 0),
          (this._transactionName = void 0),
          (this._fingerprint = void 0),
          (this._requestSession = void 0),
          (this._span = void 0),
          (this._session = void 0),
          this._notifyScopeListeners(),
          (this._attachments = []),
          (this._propagationContext = sN()),
          this
        )
      }
      addBreadcrumb(t, n) {
        let r = typeof n == 'number' ? n : cJ
        if (r <= 0) return this
        let s = { timestamp: Ud.dateTimestampInSeconds(), ...t },
          o = this._breadcrumbs
        return (
          o.push(s),
          (this._breadcrumbs = o.length > r ? o.slice(-r) : o),
          this._notifyScopeListeners(),
          this
        )
      }
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
      }
      clearBreadcrumbs() {
        return (this._breadcrumbs = []), this._notifyScopeListeners(), this
      }
      addAttachment(t) {
        return this._attachments.push(t), this
      }
      getAttachments() {
        return this._attachments
      }
      clearAttachments() {
        return (this._attachments = []), this
      }
      applyToEvent(t, n = {}, r) {
        if (
          (this._extra &&
            Object.keys(this._extra).length &&
            (t.extra = { ...this._extra, ...t.extra }),
          this._tags &&
            Object.keys(this._tags).length &&
            (t.tags = { ...this._tags, ...t.tags }),
          this._user &&
            Object.keys(this._user).length &&
            (t.user = { ...this._user, ...t.user }),
          this._contexts &&
            Object.keys(this._contexts).length &&
            (t.contexts = { ...this._contexts, ...t.contexts }),
          this._level && (t.level = this._level),
          this._transactionName && (t.transaction = this._transactionName),
          this._span)
        ) {
          t.contexts = { trace: this._span.getTraceContext(), ...t.contexts }
          let i = this._span.transaction
          if (i) {
            t.sdkProcessingMetadata = {
              dynamicSamplingContext: i.getDynamicSamplingContext(),
              ...t.sdkProcessingMetadata,
            }
            let a = i.name
            a && (t.tags = { transaction: a, ...t.tags })
          }
        }
        this._applyFingerprint(t)
        let s = this._getBreadcrumbs(),
          o = [...(t.breadcrumbs || []), ...s]
        return (
          (t.breadcrumbs = o.length > 0 ? o : void 0),
          (t.sdkProcessingMetadata = {
            ...t.sdkProcessingMetadata,
            ...this._sdkProcessingMetadata,
            propagationContext: this._propagationContext,
          }),
          rN.notifyEventProcessors(
            [
              ...(r || []),
              ...rN.getGlobalEventProcessors(),
              ...this._eventProcessors,
            ],
            t,
            n,
          )
        )
      }
      setSDKProcessingMetadata(t) {
        return (
          (this._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata,
            ...t,
          }),
          this
        )
      }
      setPropagationContext(t) {
        return (this._propagationContext = t), this
      }
      getPropagationContext() {
        return this._propagationContext
      }
      _getBreadcrumbs() {
        return this._breadcrumbs
      }
      _notifyScopeListeners() {
        this._notifyingListeners ||
          ((this._notifyingListeners = !0),
          this._scopeListeners.forEach((t) => {
            t(this)
          }),
          (this._notifyingListeners = !1))
      }
      _applyFingerprint(t) {
        ;(t.fingerprint = t.fingerprint ? Ud.arrayify(t.fingerprint) : []),
          this._fingerprint &&
            (t.fingerprint = t.fingerprint.concat(this._fingerprint)),
          t.fingerprint && !t.fingerprint.length && delete t.fingerprint
      }
    }
  function sN() {
    return { traceId: Ud.uuid4(), spanId: Ud.uuid4().substring(16) }
  }
  Eb.Scope = yb
})
var $t = l((Gt) => {
  Object.defineProperty(Gt, '__esModule', { value: !0 })
  var jt = O(),
    dJ = Od(),
    bb = Tm(),
    Sb = Ld(),
    wm = 4,
    uJ = 100,
    pi = class {
      constructor(t, n = new bb.Scope(), r = wm) {
        ;(this._version = r),
          (this._stack = [{ scope: n }]),
          t && this.bindClient(t)
      }
      isOlderThan(t) {
        return this._version < t
      }
      bindClient(t) {
        let n = this.getStackTop()
        ;(n.client = t), t && t.setupIntegrations && t.setupIntegrations()
      }
      pushScope() {
        let t = bb.Scope.clone(this.getScope())
        return this.getStack().push({ client: this.getClient(), scope: t }), t
      }
      popScope() {
        return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
      }
      withScope(t) {
        let n = this.pushScope()
        try {
          t(n)
        } finally {
          this.popScope()
        }
      }
      getClient() {
        return this.getStackTop().client
      }
      getScope() {
        return this.getStackTop().scope
      }
      getStack() {
        return this._stack
      }
      getStackTop() {
        return this._stack[this._stack.length - 1]
      }
      captureException(t, n) {
        let r = (this._lastEventId = n && n.event_id ? n.event_id : jt.uuid4()),
          s = new Error('Sentry syntheticException')
        return (
          this._withClient((o, i) => {
            o.captureException(
              t,
              {
                originalException: t,
                syntheticException: s,
                ...n,
                event_id: r,
              },
              i,
            )
          }),
          r
        )
      }
      captureMessage(t, n, r) {
        let s = (this._lastEventId = r && r.event_id ? r.event_id : jt.uuid4()),
          o = new Error(t)
        return (
          this._withClient((i, a) => {
            i.captureMessage(
              t,
              n,
              {
                originalException: t,
                syntheticException: o,
                ...r,
                event_id: s,
              },
              a,
            )
          }),
          s
        )
      }
      captureEvent(t, n) {
        let r = n && n.event_id ? n.event_id : jt.uuid4()
        return (
          t.type || (this._lastEventId = r),
          this._withClient((s, o) => {
            s.captureEvent(t, { ...n, event_id: r }, o)
          }),
          r
        )
      }
      lastEventId() {
        return this._lastEventId
      }
      addBreadcrumb(t, n) {
        let { scope: r, client: s } = this.getStackTop()
        if (!s) return
        let { beforeBreadcrumb: o = null, maxBreadcrumbs: i = uJ } =
          (s.getOptions && s.getOptions()) || {}
        if (i <= 0) return
        let c = { timestamp: jt.dateTimestampInSeconds(), ...t },
          u = o ? jt.consoleSandbox(() => o(c, n)) : c
        u !== null &&
          (s.emit && s.emit('beforeAddBreadcrumb', u, n), r.addBreadcrumb(u, i))
      }
      setUser(t) {
        this.getScope().setUser(t)
      }
      setTags(t) {
        this.getScope().setTags(t)
      }
      setExtras(t) {
        this.getScope().setExtras(t)
      }
      setTag(t, n) {
        this.getScope().setTag(t, n)
      }
      setExtra(t, n) {
        this.getScope().setExtra(t, n)
      }
      setContext(t, n) {
        this.getScope().setContext(t, n)
      }
      configureScope(t) {
        let { scope: n, client: r } = this.getStackTop()
        r && t(n)
      }
      run(t) {
        let n = vb(this)
        try {
          t(this)
        } finally {
          vb(n)
        }
      }
      getIntegration(t) {
        let n = this.getClient()
        if (!n) return null
        try {
          return n.getIntegration(t)
        } catch {
          return (
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              jt.logger.warn(
                `Cannot retrieve integration ${t.id} from the current Hub`,
              ),
            null
          )
        }
      }
      startTransaction(t, n) {
        let r = this._callExtensionMethod('startTransaction', t, n)
        if ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) && !r) {
          let s = this.getClient()
          console.warn(
            s
              ? `Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`
              : "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'",
          )
        }
        return r
      }
      traceHeaders() {
        return this._callExtensionMethod('traceHeaders')
      }
      captureSession(t = !1) {
        if (t) return this.endSession()
        this._sendSessionUpdate()
      }
      endSession() {
        let n = this.getStackTop().scope,
          r = n.getSession()
        r && Sb.closeSession(r), this._sendSessionUpdate(), n.setSession()
      }
      startSession(t) {
        let { scope: n, client: r } = this.getStackTop(),
          { release: s, environment: o = dJ.DEFAULT_ENVIRONMENT } =
            (r && r.getOptions()) || {},
          { userAgent: i } = jt.GLOBAL_OBJ.navigator || {},
          a = Sb.makeSession({
            release: s,
            environment: o,
            user: n.getUser(),
            ...(i && { userAgent: i }),
            ...t,
          }),
          c = n.getSession && n.getSession()
        return (
          c && c.status === 'ok' && Sb.updateSession(c, { status: 'exited' }),
          this.endSession(),
          n.setSession(a),
          a
        )
      }
      shouldSendDefaultPii() {
        let t = this.getClient(),
          n = t && t.getOptions()
        return !!(n && n.sendDefaultPii)
      }
      _sendSessionUpdate() {
        let { scope: t, client: n } = this.getStackTop(),
          r = t.getSession()
        r && n && n.captureSession && n.captureSession(r)
      }
      _withClient(t) {
        let { scope: n, client: r } = this.getStackTop()
        r && t(r, n)
      }
      _callExtensionMethod(t, ...n) {
        let s = ro().__SENTRY__
        if (s && s.extensions && typeof s.extensions[t] == 'function')
          return s.extensions[t].apply(this, n)
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          jt.logger.warn(
            `Extension method ${t} couldn't be found, doing nothing.`,
          )
      }
    }
  function ro() {
    return (
      (jt.GLOBAL_OBJ.__SENTRY__ = jt.GLOBAL_OBJ.__SENTRY__ || {
        extensions: {},
        hub: void 0,
      }),
      jt.GLOBAL_OBJ
    )
  }
  function vb(e) {
    let t = ro(),
      n = Fd(t)
    return Im(t, e), n
  }
  function lJ() {
    let e = ro()
    if (e.__SENTRY__ && e.__SENTRY__.acs) {
      let t = e.__SENTRY__.acs.getCurrentHub()
      if (t) return t
    }
    return oN(e)
  }
  function oN(e = ro()) {
    return (!iN(e) || Fd(e).isOlderThan(wm)) && Im(e, new pi()), Fd(e)
  }
  function mJ(e, t = oN()) {
    if (!iN(e) || Fd(e).isOlderThan(wm)) {
      let n = t.getStackTop()
      Im(e, new pi(n.client, bb.Scope.clone(n.scope)))
    }
  }
  function pJ(e) {
    let t = ro()
    ;(t.__SENTRY__ = t.__SENTRY__ || {}), (t.__SENTRY__.acs = e)
  }
  function _J(e, t = {}) {
    let n = ro()
    return n.__SENTRY__ && n.__SENTRY__.acs
      ? n.__SENTRY__.acs.runWithAsyncContext(e, t)
      : e()
  }
  function iN(e) {
    return !!(e && e.__SENTRY__ && e.__SENTRY__.hub)
  }
  function Fd(e) {
    return jt.getGlobalSingleton('hub', () => new pi(), e)
  }
  function Im(e, t) {
    if (!e) return !1
    let n = (e.__SENTRY__ = e.__SENTRY__ || {})
    return (n.hub = t), !0
  }
  Gt.API_VERSION = wm
  Gt.Hub = pi
  Gt.ensureHubOnCarrier = mJ
  Gt.getCurrentHub = lJ
  Gt.getHubFromCarrier = Fd
  Gt.getMainCarrier = ro
  Gt.makeMain = vb
  Gt.runWithAsyncContext = _J
  Gt.setAsyncContextStrategy = pJ
  Gt.setHubOnCarrier = Im
})
var xm = l((_i) => {
  Object.defineProperty(_i, '__esModule', { value: !0 })
  var fJ = $t(),
    Cb = O()
  function hJ(e) {
    return (e || fJ.getCurrentHub()).getScope().getTransaction()
  }
  _i.TRACEPARENT_REGEXP = Cb.TRACEPARENT_REGEXP
  _i.extractTraceparentData = Cb.extractTraceparentData
  _i.stripUrlQueryAndFragment = Cb.stripUrlQueryAndFragment
  _i.getActiveTransaction = hJ
})
var cN = l((Ib) => {
  Object.defineProperty(Ib, '__esModule', { value: !0 })
  var Tb = O(),
    gJ = xm(),
    aN = !1
  function yJ() {
    aN ||
      ((aN = !0),
      Tb.addInstrumentationHandler('error', wb),
      Tb.addInstrumentationHandler('unhandledrejection', wb))
  }
  function wb() {
    let e = gJ.getActiveTransaction()
    if (e) {
      let t = 'internal_error'
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Tb.logger.log(`[Tracing] Transaction: ${t} -> Global error occured`),
        e.setStatus(t)
    }
  }
  wb.tag = 'sentry_tracingErrorCallback'
  Ib.registerErrorInstrumentation = yJ
})
var Pm = l((Bd) => {
  Object.defineProperty(Bd, '__esModule', { value: !0 })
  var vn = O(),
    xb = class {
      constructor(t = 1e3) {
        ;(this._maxlen = t), (this.spans = [])
      }
      add(t) {
        this.spans.length > this._maxlen
          ? (t.spanRecorder = void 0)
          : this.spans.push(t)
      }
    },
    Pb = class e {
      constructor(t = {}) {
        ;(this.traceId = t.traceId || vn.uuid4()),
          (this.spanId = t.spanId || vn.uuid4().substring(16)),
          (this.startTimestamp = t.startTimestamp || vn.timestampInSeconds()),
          (this.tags = t.tags || {}),
          (this.data = t.data || {}),
          (this.instrumenter = t.instrumenter || 'sentry'),
          (this.origin = t.origin || 'manual'),
          t.parentSpanId && (this.parentSpanId = t.parentSpanId),
          'sampled' in t && (this.sampled = t.sampled),
          t.op && (this.op = t.op),
          t.description && (this.description = t.description),
          t.name && (this.description = t.name),
          t.status && (this.status = t.status),
          t.endTimestamp && (this.endTimestamp = t.endTimestamp)
      }
      get name() {
        return this.description || ''
      }
      set name(t) {
        this.setName(t)
      }
      startChild(t) {
        let n = new e({
          ...t,
          parentSpanId: this.spanId,
          sampled: this.sampled,
          traceId: this.traceId,
        })
        if (
          ((n.spanRecorder = this.spanRecorder),
          n.spanRecorder && n.spanRecorder.add(n),
          (n.transaction = this.transaction),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) && n.transaction)
        ) {
          let r = (t && t.op) || '< unknown op >',
            s = n.transaction.name || '< unknown name >',
            o = n.transaction.spanId,
            i = `[Tracing] Starting '${r}' span on transaction '${s}' (${o}).`
          ;(n.transaction.metadata.spanMetadata[n.spanId] = { logMessage: i }),
            vn.logger.log(i)
        }
        return n
      }
      setTag(t, n) {
        return (this.tags = { ...this.tags, [t]: n }), this
      }
      setData(t, n) {
        return (this.data = { ...this.data, [t]: n }), this
      }
      setStatus(t) {
        return (this.status = t), this
      }
      setHttpStatus(t) {
        this.setTag('http.status_code', String(t)),
          this.setData('http.response.status_code', t)
        let n = dN(t)
        return n !== 'unknown_error' && this.setStatus(n), this
      }
      setName(t) {
        this.description = t
      }
      isSuccess() {
        return this.status === 'ok'
      }
      finish(t) {
        if (
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          this.transaction &&
          this.transaction.spanId !== this.spanId
        ) {
          let { logMessage: n } =
            this.transaction.metadata.spanMetadata[this.spanId]
          n && vn.logger.log(n.replace('Starting', 'Finishing'))
        }
        this.endTimestamp = typeof t == 'number' ? t : vn.timestampInSeconds()
      }
      toTraceparent() {
        return vn.generateSentryTraceHeader(
          this.traceId,
          this.spanId,
          this.sampled,
        )
      }
      toContext() {
        return vn.dropUndefinedKeys({
          data: this.data,
          description: this.description,
          endTimestamp: this.endTimestamp,
          op: this.op,
          parentSpanId: this.parentSpanId,
          sampled: this.sampled,
          spanId: this.spanId,
          startTimestamp: this.startTimestamp,
          status: this.status,
          tags: this.tags,
          traceId: this.traceId,
        })
      }
      updateWithContext(t) {
        return (
          (this.data = t.data || {}),
          (this.description = t.description),
          (this.endTimestamp = t.endTimestamp),
          (this.op = t.op),
          (this.parentSpanId = t.parentSpanId),
          (this.sampled = t.sampled),
          (this.spanId = t.spanId || this.spanId),
          (this.startTimestamp = t.startTimestamp || this.startTimestamp),
          (this.status = t.status),
          (this.tags = t.tags || {}),
          (this.traceId = t.traceId || this.traceId),
          this
        )
      }
      getTraceContext() {
        return vn.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          trace_id: this.traceId,
        })
      }
      toJSON() {
        return vn.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          start_timestamp: this.startTimestamp,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          timestamp: this.endTimestamp,
          trace_id: this.traceId,
          origin: this.origin,
        })
      }
    }
  function dN(e) {
    if (e < 400 && e >= 100) return 'ok'
    if (e >= 400 && e < 500)
      switch (e) {
        case 401:
          return 'unauthenticated'
        case 403:
          return 'permission_denied'
        case 404:
          return 'not_found'
        case 409:
          return 'already_exists'
        case 413:
          return 'failed_precondition'
        case 429:
          return 'resource_exhausted'
        default:
          return 'invalid_argument'
      }
    if (e >= 500 && e < 600)
      switch (e) {
        case 501:
          return 'unimplemented'
        case 503:
          return 'unavailable'
        case 504:
          return 'deadline_exceeded'
        default:
          return 'internal_error'
      }
    return 'unknown_error'
  }
  Bd.Span = Pb
  Bd.SpanRecorder = xb
  Bd.spanStatusfromHttpCode = dN
})
var jd = l((Rb) => {
  Object.defineProperty(Rb, '__esModule', { value: !0 })
  var EJ = O(),
    SJ = Od()
  function bJ(e, t, n) {
    let r = t.getOptions(),
      { publicKey: s } = t.getDsn() || {},
      { segment: o } = (n && n.getUser()) || {},
      i = EJ.dropUndefinedKeys({
        environment: r.environment || SJ.DEFAULT_ENVIRONMENT,
        release: r.release,
        user_segment: o,
        public_key: s,
        trace_id: e,
      })
    return t.emit && t.emit('createDsc', i), i
  }
  Rb.getDynamicSamplingContextFromClient = bJ
})
var Rm = l((Ab) => {
  Object.defineProperty(Ab, '__esModule', { value: !0 })
  var Gd = O(),
    uN = $t(),
    vJ = jd(),
    lN = Pm(),
    Db = class extends lN.Span {
      constructor(t, n) {
        super(t),
          delete this.description,
          (this._measurements = {}),
          (this._contexts = {}),
          (this._hub = n || uN.getCurrentHub()),
          (this._name = t.name || ''),
          (this.metadata = {
            source: 'custom',
            ...t.metadata,
            spanMetadata: {},
          }),
          (this._trimEnd = t.trimEnd),
          (this.transaction = this)
        let r = this.metadata.dynamicSamplingContext
        r && (this._frozenDynamicSamplingContext = { ...r })
      }
      get name() {
        return this._name
      }
      set name(t) {
        this.setName(t)
      }
      setName(t, n = 'custom') {
        ;(this._name = t), (this.metadata.source = n)
      }
      initSpanRecorder(t = 1e3) {
        this.spanRecorder || (this.spanRecorder = new lN.SpanRecorder(t)),
          this.spanRecorder.add(this)
      }
      setContext(t, n) {
        n === null ? delete this._contexts[t] : (this._contexts[t] = n)
      }
      setMeasurement(t, n, r = '') {
        this._measurements[t] = { value: n, unit: r }
      }
      setMetadata(t) {
        this.metadata = { ...this.metadata, ...t }
      }
      finish(t) {
        let n = this._finishTransaction(t)
        if (n) return this._hub.captureEvent(n)
      }
      toContext() {
        let t = super.toContext()
        return Gd.dropUndefinedKeys({
          ...t,
          name: this.name,
          trimEnd: this._trimEnd,
        })
      }
      updateWithContext(t) {
        return (
          super.updateWithContext(t),
          (this.name = t.name || ''),
          (this._trimEnd = t.trimEnd),
          this
        )
      }
      getDynamicSamplingContext() {
        if (this._frozenDynamicSamplingContext)
          return this._frozenDynamicSamplingContext
        let t = this._hub || uN.getCurrentHub(),
          n = t.getClient()
        if (!n) return {}
        let r = t.getScope(),
          s = vJ.getDynamicSamplingContextFromClient(this.traceId, n, r),
          o = this.metadata.sampleRate
        o !== void 0 && (s.sample_rate = `${o}`)
        let i = this.metadata.source
        return (
          i && i !== 'url' && (s.transaction = this.name),
          this.sampled !== void 0 && (s.sampled = String(this.sampled)),
          s
        )
      }
      setHub(t) {
        this._hub = t
      }
      _finishTransaction(t) {
        if (this.endTimestamp !== void 0) return
        this.name ||
          ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Gd.logger.warn(
              'Transaction has no name, falling back to `<unlabeled transaction>`.',
            ),
          (this.name = '<unlabeled transaction>')),
          super.finish(t)
        let n = this._hub.getClient()
        if (
          (n && n.emit && n.emit('finishTransaction', this),
          this.sampled !== !0)
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Gd.logger.log(
              '[Tracing] Discarding transaction because its trace was not chosen to be sampled.',
            ),
            n && n.recordDroppedEvent('sample_rate', 'transaction')
          return
        }
        let r = this.spanRecorder
          ? this.spanRecorder.spans.filter((a) => a !== this && a.endTimestamp)
          : []
        this._trimEnd &&
          r.length > 0 &&
          (this.endTimestamp = r.reduce((a, c) =>
            a.endTimestamp && c.endTimestamp
              ? a.endTimestamp > c.endTimestamp
                ? a
                : c
              : a,
          ).endTimestamp)
        let s = this.metadata,
          o = {
            contexts: { ...this._contexts, trace: this.getTraceContext() },
            spans: r,
            start_timestamp: this.startTimestamp,
            tags: this.tags,
            timestamp: this.endTimestamp,
            transaction: this.name,
            type: 'transaction',
            sdkProcessingMetadata: {
              ...s,
              dynamicSamplingContext: this.getDynamicSamplingContext(),
            },
            ...(s.source && { transaction_info: { source: s.source } }),
          }
        return (
          Object.keys(this._measurements).length > 0 &&
            ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Gd.logger.log(
                '[Measurements] Adding measurements to transaction',
                JSON.stringify(this._measurements, void 0, 2),
              ),
            (o.measurements = this._measurements)),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Gd.logger.log(
              `[Tracing] Finishing ${this.op} transaction: ${this.name}.`,
            ),
          o
        )
      }
    }
  Ab.Transaction = Db
})
var Nb = l(($d) => {
  Object.defineProperty($d, '__esModule', { value: !0 })
  var Ve = O(),
    CJ = Pm(),
    TJ = Rm(),
    Dm = { idleTimeout: 1e3, finalTimeout: 3e4, heartbeatInterval: 5e3 },
    wJ = 'finishReason',
    fi = [
      'heartbeatFailed',
      'idleTimeout',
      'documentHidden',
      'finalTimeout',
      'externalFinish',
      'cancelled',
    ],
    Am = class extends CJ.SpanRecorder {
      constructor(t, n, r, s) {
        super(s),
          (this._pushActivity = t),
          (this._popActivity = n),
          (this.transactionSpanId = r)
      }
      add(t) {
        t.spanId !== this.transactionSpanId &&
          ((t.finish = (n) => {
            ;(t.endTimestamp =
              typeof n == 'number' ? n : Ve.timestampInSeconds()),
              this._popActivity(t.spanId)
          }),
          t.endTimestamp === void 0 && this._pushActivity(t.spanId)),
          super.add(t)
      }
    },
    Ob = class extends TJ.Transaction {
      constructor(
        t,
        n,
        r = Dm.idleTimeout,
        s = Dm.finalTimeout,
        o = Dm.heartbeatInterval,
        i = !1,
      ) {
        super(t, n),
          (this._idleHub = n),
          (this._idleTimeout = r),
          (this._finalTimeout = s),
          (this._heartbeatInterval = o),
          (this._onScope = i),
          (this.activities = {}),
          (this._heartbeatCounter = 0),
          (this._finished = !1),
          (this._idleTimeoutCanceledPermanently = !1),
          (this._beforeFinishCallbacks = []),
          (this._finishReason = fi[4]),
          i &&
            ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ve.logger.log(
                `Setting idle transaction on scope. Span ID: ${this.spanId}`,
              ),
            n.configureScope((a) => a.setSpan(this))),
          this._restartIdleTimeout(),
          setTimeout(() => {
            this._finished ||
              (this.setStatus('deadline_exceeded'),
              (this._finishReason = fi[3]),
              this.finish())
          }, this._finalTimeout)
      }
      finish(t = Ve.timestampInSeconds()) {
        if (
          ((this._finished = !0),
          (this.activities = {}),
          this.op === 'ui.action.click' && this.setTag(wJ, this._finishReason),
          this.spanRecorder)
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Ve.logger.log(
              '[Tracing] finishing IdleTransaction',
              new Date(t * 1e3).toISOString(),
              this.op,
            )
          for (let n of this._beforeFinishCallbacks) n(this, t)
          ;(this.spanRecorder.spans = this.spanRecorder.spans.filter((n) => {
            if (n.spanId === this.spanId) return !0
            n.endTimestamp ||
              ((n.endTimestamp = t),
              n.setStatus('cancelled'),
              (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Ve.logger.log(
                  '[Tracing] cancelling span since transaction ended early',
                  JSON.stringify(n, void 0, 2),
                ))
            let r = n.startTimestamp < t,
              s = (this._finalTimeout + this._idleTimeout) / 1e3,
              o = n.endTimestamp - this.startTimestamp < s
            if (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) {
              let i = JSON.stringify(n, void 0, 2)
              r
                ? o ||
                  Ve.logger.log(
                    '[Tracing] discarding Span since it finished after Transaction final timeout',
                    i,
                  )
                : Ve.logger.log(
                    '[Tracing] discarding Span since it happened after Transaction was finished',
                    i,
                  )
            }
            return r && o
          })),
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ve.logger.log('[Tracing] flushing IdleTransaction')
        } else
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Ve.logger.log('[Tracing] No active IdleTransaction')
        if (this._onScope) {
          let n = this._idleHub.getScope()
          n.getTransaction() === this && n.setSpan(void 0)
        }
        return super.finish(t)
      }
      registerBeforeFinishCallback(t) {
        this._beforeFinishCallbacks.push(t)
      }
      initSpanRecorder(t) {
        if (!this.spanRecorder) {
          let n = (s) => {
              this._finished || this._pushActivity(s)
            },
            r = (s) => {
              this._finished || this._popActivity(s)
            }
          ;(this.spanRecorder = new Am(n, r, this.spanId, t)),
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ve.logger.log('Starting heartbeat'),
            this._pingHeartbeat()
        }
        this.spanRecorder.add(this)
      }
      cancelIdleTimeout(
        t,
        { restartOnChildSpanChange: n } = { restartOnChildSpanChange: !0 },
      ) {
        ;(this._idleTimeoutCanceledPermanently = n === !1),
          this._idleTimeoutID &&
            (clearTimeout(this._idleTimeoutID),
            (this._idleTimeoutID = void 0),
            Object.keys(this.activities).length === 0 &&
              this._idleTimeoutCanceledPermanently &&
              ((this._finishReason = fi[5]), this.finish(t)))
      }
      setFinishReason(t) {
        this._finishReason = t
      }
      _restartIdleTimeout(t) {
        this.cancelIdleTimeout(),
          (this._idleTimeoutID = setTimeout(() => {
            !this._finished &&
              Object.keys(this.activities).length === 0 &&
              ((this._finishReason = fi[1]), this.finish(t))
          }, this._idleTimeout))
      }
      _pushActivity(t) {
        this.cancelIdleTimeout(void 0, {
          restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently,
        }),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Ve.logger.log(`[Tracing] pushActivity: ${t}`),
          (this.activities[t] = !0),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Ve.logger.log(
              '[Tracing] new activities count',
              Object.keys(this.activities).length,
            )
      }
      _popActivity(t) {
        if (
          (this.activities[t] &&
            ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ve.logger.log(`[Tracing] popActivity ${t}`),
            delete this.activities[t],
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ve.logger.log(
                '[Tracing] new activities count',
                Object.keys(this.activities).length,
              )),
          Object.keys(this.activities).length === 0)
        ) {
          let n = Ve.timestampInSeconds()
          this._idleTimeoutCanceledPermanently
            ? ((this._finishReason = fi[5]), this.finish(n))
            : this._restartIdleTimeout(n + this._idleTimeout / 1e3)
        }
      }
      _beat() {
        if (this._finished) return
        let t = Object.keys(this.activities).join('')
        t === this._prevHeartbeatString
          ? this._heartbeatCounter++
          : (this._heartbeatCounter = 1),
          (this._prevHeartbeatString = t),
          this._heartbeatCounter >= 3
            ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Ve.logger.log(
                  '[Tracing] Transaction finished because of no change for 3 heart beats',
                ),
              this.setStatus('deadline_exceeded'),
              (this._finishReason = fi[0]),
              this.finish())
            : this._pingHeartbeat()
      }
      _pingHeartbeat() {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Ve.logger.log(
            `pinging Heartbeat -> current counter: ${this._heartbeatCounter}`,
          ),
          setTimeout(() => {
            this._beat()
          }, this._heartbeatInterval)
      }
    }
  $d.IdleTransaction = Ob
  $d.IdleTransactionSpanRecorder = Am
  $d.TRACING_DEFAULTS = Dm
})
var Om = l((qb) => {
  Object.defineProperty(qb, '__esModule', { value: !0 })
  var IJ = $t()
  function xJ(e) {
    if (typeof __SENTRY_TRACING__ == 'boolean' && !__SENTRY_TRACING__) return !1
    let t = IJ.getCurrentHub().getClient(),
      n = e || (t && t.getOptions())
    return (
      !!n &&
      (n.enableTracing || 'tracesSampleRate' in n || 'tracesSampler' in n)
    )
  }
  qb.hasTracingEnabled = xJ
})
var mN = l((kb) => {
  Object.defineProperty(kb, '__esModule', { value: !0 })
  var so = O(),
    PJ = Om()
  function RJ(e, t, n) {
    if (!PJ.hasTracingEnabled(t)) return (e.sampled = !1), e
    if (e.sampled !== void 0)
      return e.setMetadata({ sampleRate: Number(e.sampled) }), e
    let r
    return (
      typeof t.tracesSampler == 'function'
        ? ((r = t.tracesSampler(n)), e.setMetadata({ sampleRate: Number(r) }))
        : n.parentSampled !== void 0
          ? (r = n.parentSampled)
          : typeof t.tracesSampleRate < 'u'
            ? ((r = t.tracesSampleRate),
              e.setMetadata({ sampleRate: Number(r) }))
            : ((r = 1), e.setMetadata({ sampleRate: r })),
      DJ(r)
        ? r
          ? ((e.sampled = Math.random() < r),
            e.sampled
              ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  so.logger.log(
                    `[Tracing] starting ${e.op} transaction - ${e.name}`,
                  ),
                e)
              : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  so.logger.log(
                    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
                      r,
                    )})`,
                  ),
                e))
          : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              so.logger.log(
                `[Tracing] Discarding transaction because ${
                  typeof t.tracesSampler == 'function'
                    ? 'tracesSampler returned 0 or false'
                    : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'
                }`,
              ),
            (e.sampled = !1),
            e)
        : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            so.logger.warn(
              '[Tracing] Discarding transaction because of invalid sample rate.',
            ),
          (e.sampled = !1),
          e)
    )
  }
  function DJ(e) {
    return so.isNaN(e) || !(typeof e == 'number' || typeof e == 'boolean')
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          so.logger.warn(
            `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
              e,
            )} of type ${JSON.stringify(typeof e)}.`,
          ),
        !1)
      : e < 0 || e > 1
        ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            so.logger.warn(
              `[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${e}.`,
            ),
          !1)
        : !0
  }
  kb.sampleTransaction = RJ
})
var Mb = l((Nm) => {
  Object.defineProperty(Nm, '__esModule', { value: !0 })
  var AJ = O(),
    OJ = $t(),
    NJ = cN(),
    qJ = Nb(),
    pN = mN(),
    kJ = Rm()
  function MJ() {
    let t = this.getScope().getSpan()
    return t ? { 'sentry-trace': t.toTraceparent() } : {}
  }
  function LJ(e, t) {
    let n = this.getClient(),
      r = (n && n.getOptions()) || {},
      s = r.instrumenter || 'sentry',
      o = e.instrumenter || 'sentry'
    s !== o &&
      ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        AJ.logger
          .error(`A transaction was started with instrumenter=\`${o}\`, but the SDK is configured with the \`${s}\` instrumenter.
The transaction will not be sampled. Please use the ${s} instrumentation to start transactions.`),
      (e.sampled = !1))
    let i = new kJ.Transaction(e, this)
    return (
      (i = pN.sampleTransaction(i, r, {
        parentSampled: e.parentSampled,
        transactionContext: e,
        ...t,
      })),
      i.sampled &&
        i.initSpanRecorder(r._experiments && r._experiments.maxSpans),
      n && n.emit && n.emit('startTransaction', i),
      i
    )
  }
  function UJ(e, t, n, r, s, o, i) {
    let a = e.getClient(),
      c = (a && a.getOptions()) || {},
      u = new qJ.IdleTransaction(t, e, n, r, i, s)
    return (
      (u = pN.sampleTransaction(u, c, {
        parentSampled: t.parentSampled,
        transactionContext: t,
        ...o,
      })),
      u.sampled &&
        u.initSpanRecorder(c._experiments && c._experiments.maxSpans),
      a && a.emit && a.emit('startTransaction', u),
      u
    )
  }
  function FJ() {
    let e = OJ.getMainCarrier()
    e.__SENTRY__ &&
      ((e.__SENTRY__.extensions = e.__SENTRY__.extensions || {}),
      e.__SENTRY__.extensions.startTransaction ||
        (e.__SENTRY__.extensions.startTransaction = LJ),
      e.__SENTRY__.extensions.traceHeaders ||
        (e.__SENTRY__.extensions.traceHeaders = MJ),
      NJ.registerErrorInstrumentation())
  }
  Nm.addTracingExtensions = FJ
  Nm.startIdleTransaction = UJ
})
var Lb = l((zd) => {
  Object.defineProperty(zd, '__esModule', { value: !0 })
  zd.SpanStatus = void 0
  ;(function (e) {
    let t = 'ok'
    e.Ok = t
    let n = 'deadline_exceeded'
    e.DeadlineExceeded = n
    let r = 'unauthenticated'
    e.Unauthenticated = r
    let s = 'permission_denied'
    e.PermissionDenied = s
    let o = 'not_found'
    e.NotFound = o
    let i = 'resource_exhausted'
    e.ResourceExhausted = i
    let a = 'invalid_argument'
    e.InvalidArgument = a
    let c = 'unimplemented'
    e.Unimplemented = c
    let u = 'unavailable'
    e.Unavailable = u
    let d = 'internal_error'
    e.InternalError = d
    let p = 'unknown_error'
    e.UnknownError = p
    let _ = 'cancelled'
    e.Cancelled = _
    let f = 'already_exists'
    e.AlreadyExists = f
    let h = 'failed_precondition'
    e.FailedPrecondition = h
    let y = 'aborted'
    e.Aborted = y
    let E = 'out_of_range'
    e.OutOfRange = E
    let C = 'data_loss'
    e.DataLoss = C
  })(zd.SpanStatus || (zd.SpanStatus = {}))
})
var gN = l((cr) => {
  Object.defineProperty(cr, '__esModule', { value: !0 })
  var hi = O(),
    gi = $t(),
    _N = Om()
  function BJ(e, t, n = () => {}) {
    let r = Fb(e),
      s = gi.getCurrentHub(),
      o = s.getScope(),
      i = o.getSpan(),
      a = Ub(s, i, r)
    o.setSpan(a)
    function c() {
      a && a.finish(), s.getScope().setSpan(i)
    }
    let u
    try {
      u = t(a)
    } catch (d) {
      throw (a && a.setStatus('internal_error'), n(d), c(), d)
    }
    return (
      hi.isThenable(u)
        ? Promise.resolve(u).then(
            () => {
              c()
            },
            (d) => {
              a && a.setStatus('internal_error'), n(d), c()
            },
          )
        : c(),
      u
    )
  }
  function fN(e, t) {
    let n = Fb(e),
      r = gi.getCurrentHub(),
      s = r.getScope(),
      o = s.getSpan(),
      i = Ub(r, o, n)
    s.setSpan(i)
    function a() {
      i && i.finish(), r.getScope().setSpan(o)
    }
    let c
    try {
      c = t(i)
    } catch (u) {
      throw (i && i.setStatus('internal_error'), a(), u)
    }
    return (
      hi.isThenable(c)
        ? Promise.resolve(c).then(
            () => {
              a()
            },
            () => {
              i && i.setStatus('internal_error'), a()
            },
          )
        : a(),
      c
    )
  }
  var jJ = fN
  function GJ(e, t) {
    let n = Fb(e),
      r = gi.getCurrentHub(),
      s = r.getScope(),
      o = s.getSpan(),
      i = Ub(r, o, n)
    s.setSpan(i)
    function a() {
      i && i.finish(), r.getScope().setSpan(o)
    }
    let c
    try {
      c = t(i, a)
    } catch (u) {
      throw (i && i.setStatus('internal_error'), u)
    }
    return (
      hi.isThenable(c) &&
        Promise.resolve(c).then(void 0, () => {
          i && i.setStatus('internal_error')
        }),
      c
    )
  }
  function $J(e) {
    if (!_N.hasTracingEnabled()) return
    let t = { ...e }
    t.name !== void 0 && t.description === void 0 && (t.description = t.name)
    let n = gi.getCurrentHub(),
      r = hN()
    return r ? r.startChild(t) : n.startTransaction(t)
  }
  function hN() {
    return gi.getCurrentHub().getScope().getSpan()
  }
  function zJ({ sentryTrace: e, baggage: t }, n) {
    let s = gi.getCurrentHub().getScope(),
      {
        traceparentData: o,
        dynamicSamplingContext: i,
        propagationContext: a,
      } = hi.tracingContextFromHeaders(e, t)
    s.setPropagationContext(a),
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        o &&
        hi.logger.log(`[Tracing] Continuing trace ${o.traceId}.`)
    let c = {
      ...o,
      metadata: hi.dropUndefinedKeys({
        dynamicSamplingContext: o && !i ? {} : i,
      }),
    }
    return n(c)
  }
  function Ub(e, t, n) {
    if (_N.hasTracingEnabled())
      return t ? t.startChild(n) : e.startTransaction(n)
  }
  function Fb(e) {
    let t = { ...e }
    return (
      t.name !== void 0 && t.description === void 0 && (t.description = t.name),
      t
    )
  }
  cr.continueTrace = zJ
  cr.getActiveSpan = hN
  cr.startActiveSpan = jJ
  cr.startInactiveSpan = $J
  cr.startSpan = fN
  cr.startSpanManual = GJ
  cr.trace = BJ
})
var yN = l((Bb) => {
  Object.defineProperty(Bb, '__esModule', { value: !0 })
  var HJ = xm()
  function VJ(e, t, n) {
    let r = HJ.getActiveTransaction()
    r && r.setMeasurement(e, t, n)
  }
  Bb.setMeasurement = VJ
})
var EN = l((Le) => {
  Object.defineProperty(Le, '__esModule', { value: !0 })
  var Hd = O(),
    Ye = $t()
  function YJ(e, t) {
    return Ye.getCurrentHub().captureException(e, { captureContext: t })
  }
  function WJ(e, t) {
    let n = typeof t == 'string' ? t : void 0,
      r = typeof t != 'string' ? { captureContext: t } : void 0
    return Ye.getCurrentHub().captureMessage(e, n, r)
  }
  function KJ(e, t) {
    return Ye.getCurrentHub().captureEvent(e, t)
  }
  function XJ(e) {
    Ye.getCurrentHub().configureScope(e)
  }
  function JJ(e) {
    Ye.getCurrentHub().addBreadcrumb(e)
  }
  function QJ(e, t) {
    Ye.getCurrentHub().setContext(e, t)
  }
  function ZJ(e) {
    Ye.getCurrentHub().setExtras(e)
  }
  function eQ(e, t) {
    Ye.getCurrentHub().setExtra(e, t)
  }
  function tQ(e) {
    Ye.getCurrentHub().setTags(e)
  }
  function nQ(e, t) {
    Ye.getCurrentHub().setTag(e, t)
  }
  function rQ(e) {
    Ye.getCurrentHub().setUser(e)
  }
  function sQ(e) {
    Ye.getCurrentHub().withScope(e)
  }
  function oQ(e, t) {
    return Ye.getCurrentHub().startTransaction({ ...e }, t)
  }
  function iQ(e, t) {
    let n = Ye.getCurrentHub(),
      r = n.getScope(),
      s = n.getClient()
    if (!s)
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Hd.logger.warn('Cannot capture check-in. No client defined.')
    else if (!s.captureCheckIn)
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Hd.logger.warn(
          'Cannot capture check-in. Client does not support sending check-ins.',
        )
    else return s.captureCheckIn(e, t, r)
    return Hd.uuid4()
  }
  async function aQ(e) {
    let t = Ye.getCurrentHub().getClient()
    return t
      ? t.flush(e)
      : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Hd.logger.warn('Cannot flush events. No client defined.'),
        Promise.resolve(!1))
  }
  async function cQ(e) {
    let t = Ye.getCurrentHub().getClient()
    return t
      ? t.close(e)
      : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Hd.logger.warn(
            'Cannot flush events and disable SDK. No client defined.',
          ),
        Promise.resolve(!1))
  }
  function dQ() {
    return Ye.getCurrentHub().lastEventId()
  }
  Le.addBreadcrumb = JJ
  Le.captureCheckIn = iQ
  Le.captureEvent = KJ
  Le.captureException = YJ
  Le.captureMessage = WJ
  Le.close = cQ
  Le.configureScope = XJ
  Le.flush = aQ
  Le.lastEventId = dQ
  Le.setContext = QJ
  Le.setExtra = eQ
  Le.setExtras = ZJ
  Le.setTag = nQ
  Le.setTags = tQ
  Le.setUser = rQ
  Le.startTransaction = oQ
  Le.withScope = sQ
})
var $b = l((Gb) => {
  Object.defineProperty(Gb, '__esModule', { value: !0 })
  var uQ = O(),
    lQ = $t(),
    jb = class {
      constructor(t, n) {
        ;(this._client = t),
          (this.flushTimeout = 60),
          (this._pendingAggregates = {}),
          (this._isEnabled = !0),
          (this._intervalId = setInterval(
            () => this.flush(),
            this.flushTimeout * 1e3,
          )),
          (this._sessionAttrs = n)
      }
      flush() {
        let t = this.getSessionAggregates()
        t.aggregates.length !== 0 &&
          ((this._pendingAggregates = {}), this._client.sendSession(t))
      }
      getSessionAggregates() {
        let t = Object.keys(this._pendingAggregates).map(
            (r) => this._pendingAggregates[parseInt(r)],
          ),
          n = { attrs: this._sessionAttrs, aggregates: t }
        return uQ.dropUndefinedKeys(n)
      }
      close() {
        clearInterval(this._intervalId), (this._isEnabled = !1), this.flush()
      }
      incrementSessionStatusCount() {
        if (!this._isEnabled) return
        let t = lQ.getCurrentHub().getScope(),
          n = t.getRequestSession()
        n &&
          n.status &&
          (this._incrementSessionStatusCount(n.status, new Date()),
          t.setRequestSession(void 0))
      }
      _incrementSessionStatusCount(t, n) {
        let r = new Date(n).setSeconds(0, 0)
        this._pendingAggregates[r] = this._pendingAggregates[r] || {}
        let s = this._pendingAggregates[r]
        switch ((s.started || (s.started = new Date(r).toISOString()), t)) {
          case 'errored':
            return (s.errored = (s.errored || 0) + 1), s.errored
          case 'ok':
            return (s.exited = (s.exited || 0) + 1), s.exited
          default:
            return (s.crashed = (s.crashed || 0) + 1), s.crashed
        }
      }
    }
  Gb.SessionFlusher = jb
})
var km = l((qm) => {
  Object.defineProperty(qm, '__esModule', { value: !0 })
  var zb = O(),
    mQ = '7'
  function SN(e) {
    let t = e.protocol ? `${e.protocol}:` : '',
      n = e.port ? `:${e.port}` : ''
    return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ''}/api/`
  }
  function pQ(e) {
    return `${SN(e)}${e.projectId}/envelope/`
  }
  function _Q(e, t) {
    return zb.urlEncode({
      sentry_key: e.publicKey,
      sentry_version: mQ,
      ...(t && { sentry_client: `${t.name}/${t.version}` }),
    })
  }
  function fQ(e, t = {}) {
    let n = typeof t == 'string' ? t : t.tunnel,
      r = typeof t == 'string' || !t._metadata ? void 0 : t._metadata.sdk
    return n || `${pQ(e)}?${_Q(e, r)}`
  }
  function hQ(e, t) {
    let n = zb.makeDsn(e)
    if (!n) return ''
    let r = `${SN(n)}embed/error-page/`,
      s = `dsn=${zb.dsnToString(n)}`
    for (let o in t)
      if (o !== 'dsn')
        if (o === 'user') {
          let i = t.user
          if (!i) continue
          i.name && (s += `&name=${encodeURIComponent(i.name)}`),
            i.email && (s += `&email=${encodeURIComponent(i.email)}`)
        } else s += `&${encodeURIComponent(o)}=${encodeURIComponent(t[o])}`
    return `${r}?${s}`
  }
  qm.getEnvelopeEndpointWithUrlEncodedAuth = fQ
  qm.getReportDialogEndpoint = hQ
})
var bN = l((Mm) => {
  Object.defineProperty(Mm, '__esModule', { value: !0 })
  var yi = O()
  function gQ(e, t) {
    return (
      t &&
        ((e.sdk = e.sdk || {}),
        (e.sdk.name = e.sdk.name || t.name),
        (e.sdk.version = e.sdk.version || t.version),
        (e.sdk.integrations = [
          ...(e.sdk.integrations || []),
          ...(t.integrations || []),
        ]),
        (e.sdk.packages = [...(e.sdk.packages || []), ...(t.packages || [])])),
      e
    )
  }
  function yQ(e, t, n, r) {
    let s = yi.getSdkMetadataForEnvelopeHeader(n),
      o = {
        sent_at: new Date().toISOString(),
        ...(s && { sdk: s }),
        ...(!!r && t && { dsn: yi.dsnToString(t) }),
      },
      i =
        'aggregates' in e
          ? [{ type: 'sessions' }, e]
          : [{ type: 'session' }, e.toJSON()]
    return yi.createEnvelope(o, [i])
  }
  function EQ(e, t, n, r) {
    let s = yi.getSdkMetadataForEnvelopeHeader(n),
      o = e.type && e.type !== 'replay_event' ? e.type : 'event'
    gQ(e, n && n.sdk)
    let i = yi.createEventEnvelopeHeaders(e, s, r, t)
    delete e.sdkProcessingMetadata
    let a = [{ type: o }, e]
    return yi.createEnvelope(i, [a])
  }
  Mm.createEventEnvelope = EQ
  Mm.createSessionEnvelope = yQ
})
var Yb = l((oo) => {
  Object.defineProperty(oo, '__esModule', { value: !0 })
  var Vb = O(),
    SQ = qd(),
    vN = $t(),
    Hb = []
  function bQ(e) {
    let t = {}
    return (
      e.forEach((n) => {
        let { name: r } = n,
          s = t[r]
        ;(s && !s.isDefaultInstance && n.isDefaultInstance) || (t[r] = n)
      }),
      Object.keys(t).map((n) => t[n])
    )
  }
  function vQ(e) {
    let t = e.defaultIntegrations || [],
      n = e.integrations
    t.forEach((i) => {
      i.isDefaultInstance = !0
    })
    let r
    Array.isArray(n)
      ? (r = [...t, ...n])
      : typeof n == 'function'
        ? (r = Vb.arrayify(n(t)))
        : (r = t)
    let s = bQ(r),
      o = wQ(s, (i) => i.name === 'Debug')
    if (o !== -1) {
      let [i] = s.splice(o, 1)
      s.push(i)
    }
    return s
  }
  function CQ(e, t) {
    let n = {}
    return (
      t.forEach((r) => {
        r && CN(e, r, n)
      }),
      n
    )
  }
  function CN(e, t, n) {
    if (
      ((n[t.name] = t),
      Hb.indexOf(t.name) === -1 &&
        (t.setupOnce(SQ.addGlobalEventProcessor, vN.getCurrentHub),
        Hb.push(t.name)),
      e.on && typeof t.preprocessEvent == 'function')
    ) {
      let r = t.preprocessEvent.bind(t)
      e.on('preprocessEvent', (s, o) => r(s, o, e))
    }
    if (e.addEventProcessor && typeof t.processEvent == 'function') {
      let r = t.processEvent.bind(t),
        s = Object.assign((o, i) => r(o, i, e), { id: t.name })
      e.addEventProcessor(s)
    }
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      Vb.logger.log(`Integration installed: ${t.name}`)
  }
  function TQ(e) {
    let t = vN.getCurrentHub().getClient()
    if (!t || !t.addIntegration) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Vb.logger.warn(
          `Cannot add integration "${e.name}" because no SDK Client is available.`,
        )
      return
    }
    t.addIntegration(e)
  }
  function wQ(e, t) {
    for (let n = 0; n < e.length; n++) if (t(e[n]) === !0) return n
    return -1
  }
  oo.addIntegration = TQ
  oo.getIntegrationsToSetup = vQ
  oo.installedIntegrations = Hb
  oo.setupIntegration = CN
  oo.setupIntegrations = CQ
})
var Wb = l((Vd) => {
  Object.defineProperty(Vd, '__esModule', { value: !0 })
  var bt = O(),
    IQ = Od(),
    TN = qd(),
    xQ = Tm()
  function PQ(e, t, n, r, s) {
    let { normalizeDepth: o = 3, normalizeMaxBreadth: i = 1e3 } = e,
      a = {
        ...t,
        event_id: t.event_id || n.event_id || bt.uuid4(),
        timestamp: t.timestamp || bt.dateTimestampInSeconds(),
      },
      c = n.integrations || e.integrations.map((_) => _.name)
    RQ(a, e), DQ(a, c), t.type === void 0 && IN(a, e.stackParser)
    let u = r
    n.captureContext && (u = xQ.Scope.clone(u).update(n.captureContext))
    let d = bt.resolvedSyncPromise(a),
      p = s && s.getEventProcessors ? s.getEventProcessors() : []
    if (u) {
      if (u.getAttachments) {
        let _ = [...(n.attachments || []), ...u.getAttachments()]
        _.length && (n.attachments = _)
      }
      d = u.applyToEvent(a, n, p)
    } else
      d = TN.notifyEventProcessors(
        [...p, ...TN.getGlobalEventProcessors()],
        a,
        n,
      )
    return d.then(
      (_) => (_ && xN(_), typeof o == 'number' && o > 0 ? AQ(_, o, i) : _),
    )
  }
  function RQ(e, t) {
    let { environment: n, release: r, dist: s, maxValueLength: o = 250 } = t
    'environment' in e ||
      (e.environment = 'environment' in t ? n : IQ.DEFAULT_ENVIRONMENT),
      e.release === void 0 && r !== void 0 && (e.release = r),
      e.dist === void 0 && s !== void 0 && (e.dist = s),
      e.message && (e.message = bt.truncate(e.message, o))
    let i = e.exception && e.exception.values && e.exception.values[0]
    i && i.value && (i.value = bt.truncate(i.value, o))
    let a = e.request
    a && a.url && (a.url = bt.truncate(a.url, o))
  }
  var wN = new WeakMap()
  function IN(e, t) {
    let n = bt.GLOBAL_OBJ._sentryDebugIds
    if (!n) return
    let r,
      s = wN.get(t)
    s ? (r = s) : ((r = new Map()), wN.set(t, r))
    let o = Object.keys(n).reduce((i, a) => {
      let c,
        u = r.get(a)
      u ? (c = u) : ((c = t(a)), r.set(a, c))
      for (let d = c.length - 1; d >= 0; d--) {
        let p = c[d]
        if (p.filename) {
          i[p.filename] = n[a]
          break
        }
      }
      return i
    }, {})
    try {
      e.exception.values.forEach((i) => {
        i.stacktrace.frames.forEach((a) => {
          a.filename && (a.debug_id = o[a.filename])
        })
      })
    } catch {}
  }
  function xN(e) {
    let t = {}
    try {
      e.exception.values.forEach((r) => {
        r.stacktrace.frames.forEach((s) => {
          s.debug_id &&
            (s.abs_path
              ? (t[s.abs_path] = s.debug_id)
              : s.filename && (t[s.filename] = s.debug_id),
            delete s.debug_id)
        })
      })
    } catch {}
    if (Object.keys(t).length === 0) return
    ;(e.debug_meta = e.debug_meta || {}),
      (e.debug_meta.images = e.debug_meta.images || [])
    let n = e.debug_meta.images
    Object.keys(t).forEach((r) => {
      n.push({ type: 'sourcemap', code_file: r, debug_id: t[r] })
    })
  }
  function DQ(e, t) {
    t.length > 0 &&
      ((e.sdk = e.sdk || {}),
      (e.sdk.integrations = [...(e.sdk.integrations || []), ...t]))
  }
  function AQ(e, t, n) {
    if (!e) return null
    let r = {
      ...e,
      ...(e.breadcrumbs && {
        breadcrumbs: e.breadcrumbs.map((s) => ({
          ...s,
          ...(s.data && { data: bt.normalize(s.data, t, n) }),
        })),
      }),
      ...(e.user && { user: bt.normalize(e.user, t, n) }),
      ...(e.contexts && { contexts: bt.normalize(e.contexts, t, n) }),
      ...(e.extra && { extra: bt.normalize(e.extra, t, n) }),
    }
    return (
      e.contexts &&
        e.contexts.trace &&
        r.contexts &&
        ((r.contexts.trace = e.contexts.trace),
        e.contexts.trace.data &&
          (r.contexts.trace.data = bt.normalize(e.contexts.trace.data, t, n))),
      e.spans &&
        (r.spans = e.spans.map(
          (s) => (s.data && (s.data = bt.normalize(s.data, t, n)), s),
        )),
      r
    )
  }
  Vd.applyDebugIds = IN
  Vd.applyDebugMeta = xN
  Vd.prepareEvent = PQ
})
var Jb = l((Xb) => {
  Object.defineProperty(Xb, '__esModule', { value: !0 })
  var fe = O(),
    OQ = km(),
    PN = bN(),
    RN = Yb(),
    DN = Ld(),
    NQ = jd(),
    qQ = Wb(),
    AN = "Not capturing exception because it's already been captured.",
    Kb = class {
      constructor(t) {
        if (
          ((this._options = t),
          (this._integrations = {}),
          (this._integrationsInitialized = !1),
          (this._numProcessing = 0),
          (this._outcomes = {}),
          (this._hooks = {}),
          (this._eventProcessors = []),
          t.dsn
            ? (this._dsn = fe.makeDsn(t.dsn))
            : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              fe.logger.warn('No DSN provided, client will not send events.'),
          this._dsn)
        ) {
          let n = OQ.getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, t)
          this._transport = t.transport({
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...t.transportOptions,
            url: n,
          })
        }
      }
      captureException(t, n, r) {
        if (fe.checkOrSetAlreadyCaught(t)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            fe.logger.log(AN)
          return
        }
        let s = n && n.event_id
        return (
          this._process(
            this.eventFromException(t, n)
              .then((o) => this._captureEvent(o, n, r))
              .then((o) => {
                s = o
              }),
          ),
          s
        )
      }
      captureMessage(t, n, r, s) {
        let o = r && r.event_id,
          i = fe.isPrimitive(t)
            ? this.eventFromMessage(String(t), n, r)
            : this.eventFromException(t, r)
        return (
          this._process(
            i
              .then((a) => this._captureEvent(a, r, s))
              .then((a) => {
                o = a
              }),
          ),
          o
        )
      }
      captureEvent(t, n, r) {
        if (
          n &&
          n.originalException &&
          fe.checkOrSetAlreadyCaught(n.originalException)
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            fe.logger.log(AN)
          return
        }
        let s = n && n.event_id
        return (
          this._process(
            this._captureEvent(t, n, r).then((o) => {
              s = o
            }),
          ),
          s
        )
      }
      captureSession(t) {
        typeof t.release != 'string'
          ? (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            fe.logger.warn(
              'Discarded session because of missing or non-string release',
            )
          : (this.sendSession(t), DN.updateSession(t, { init: !1 }))
      }
      getDsn() {
        return this._dsn
      }
      getOptions() {
        return this._options
      }
      getSdkMetadata() {
        return this._options._metadata
      }
      getTransport() {
        return this._transport
      }
      flush(t) {
        let n = this._transport
        return n
          ? this._isClientDoneProcessing(t).then((r) =>
              n.flush(t).then((s) => r && s),
            )
          : fe.resolvedSyncPromise(!0)
      }
      close(t) {
        return this.flush(t).then((n) => ((this.getOptions().enabled = !1), n))
      }
      getEventProcessors() {
        return this._eventProcessors
      }
      addEventProcessor(t) {
        this._eventProcessors.push(t)
      }
      setupIntegrations(t) {
        ;((t && !this._integrationsInitialized) ||
          (this._isEnabled() && !this._integrationsInitialized)) &&
          ((this._integrations = RN.setupIntegrations(
            this,
            this._options.integrations,
          )),
          (this._integrationsInitialized = !0))
      }
      getIntegrationById(t) {
        return this._integrations[t]
      }
      getIntegration(t) {
        try {
          return this._integrations[t.id] || null
        } catch {
          return (
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              fe.logger.warn(
                `Cannot retrieve integration ${t.id} from the current Client`,
              ),
            null
          )
        }
      }
      addIntegration(t) {
        RN.setupIntegration(this, t, this._integrations)
      }
      sendEvent(t, n = {}) {
        this.emit('beforeSendEvent', t, n)
        let r = PN.createEventEnvelope(
          t,
          this._dsn,
          this._options._metadata,
          this._options.tunnel,
        )
        for (let o of n.attachments || [])
          r = fe.addItemToEnvelope(
            r,
            fe.createAttachmentEnvelopeItem(
              o,
              this._options.transportOptions &&
                this._options.transportOptions.textEncoder,
            ),
          )
        let s = this._sendEnvelope(r)
        s && s.then((o) => this.emit('afterSendEvent', t, o), null)
      }
      sendSession(t) {
        let n = PN.createSessionEnvelope(
          t,
          this._dsn,
          this._options._metadata,
          this._options.tunnel,
        )
        this._sendEnvelope(n)
      }
      recordDroppedEvent(t, n, r) {
        if (this._options.sendClientReports) {
          let s = `${t}:${n}`
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            fe.logger.log(`Adding outcome: "${s}"`),
            (this._outcomes[s] = this._outcomes[s] + 1 || 1)
        }
      }
      on(t, n) {
        this._hooks[t] || (this._hooks[t] = []), this._hooks[t].push(n)
      }
      emit(t, ...n) {
        this._hooks[t] && this._hooks[t].forEach((r) => r(...n))
      }
      _updateSessionFromEvent(t, n) {
        let r = !1,
          s = !1,
          o = n.exception && n.exception.values
        if (o) {
          s = !0
          for (let c of o) {
            let u = c.mechanism
            if (u && u.handled === !1) {
              r = !0
              break
            }
          }
        }
        let i = t.status === 'ok'
        ;((i && t.errors === 0) || (i && r)) &&
          (DN.updateSession(t, {
            ...(r && { status: 'crashed' }),
            errors: t.errors || Number(s || r),
          }),
          this.captureSession(t))
      }
      _isClientDoneProcessing(t) {
        return new fe.SyncPromise((n) => {
          let r = 0,
            s = 1,
            o = setInterval(() => {
              this._numProcessing == 0
                ? (clearInterval(o), n(!0))
                : ((r += s), t && r >= t && (clearInterval(o), n(!1)))
            }, s)
        })
      }
      _isEnabled() {
        return this.getOptions().enabled !== !1 && this._transport !== void 0
      }
      _prepareEvent(t, n, r) {
        let s = this.getOptions(),
          o = Object.keys(this._integrations)
        return (
          !n.integrations && o.length > 0 && (n.integrations = o),
          this.emit('preprocessEvent', t, n),
          qQ.prepareEvent(s, t, n, r, this).then((i) => {
            if (i === null) return i
            let { propagationContext: a } = i.sdkProcessingMetadata || {}
            if (!(i.contexts && i.contexts.trace) && a) {
              let { traceId: u, spanId: d, parentSpanId: p, dsc: _ } = a
              i.contexts = {
                trace: { trace_id: u, span_id: d, parent_span_id: p },
                ...i.contexts,
              }
              let f = _ || NQ.getDynamicSamplingContextFromClient(u, this, r)
              i.sdkProcessingMetadata = {
                dynamicSamplingContext: f,
                ...i.sdkProcessingMetadata,
              }
            }
            return i
          })
        )
      }
      _captureEvent(t, n = {}, r) {
        return this._processEvent(t, n, r).then(
          (s) => s.event_id,
          (s) => {
            if (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) {
              let o = s
              o.logLevel === 'log'
                ? fe.logger.log(o.message)
                : fe.logger.warn(o)
            }
          },
        )
      }
      _processEvent(t, n, r) {
        let s = this.getOptions(),
          { sampleRate: o } = s,
          i = NN(t),
          a = ON(t),
          c = t.type || 'error',
          u = `before send for type \`${c}\``
        if (a && typeof o == 'number' && Math.random() > o)
          return (
            this.recordDroppedEvent('sample_rate', 'error', t),
            fe.rejectedSyncPromise(
              new fe.SentryError(
                `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
                'log',
              ),
            )
          )
        let d = c === 'replay_event' ? 'replay' : c
        return this._prepareEvent(t, n, r)
          .then((p) => {
            if (p === null)
              throw (
                (this.recordDroppedEvent('event_processor', d, t),
                new fe.SentryError(
                  'An event processor returned `null`, will not send event.',
                  'log',
                ))
              )
            if (n.data && n.data.__sentry__ === !0) return p
            let f = MQ(s, p, n)
            return kQ(f, u)
          })
          .then((p) => {
            if (p === null)
              throw (
                (this.recordDroppedEvent('before_send', d, t),
                new fe.SentryError(
                  `${u} returned \`null\`, will not send event.`,
                  'log',
                ))
              )
            let _ = r && r.getSession()
            !i && _ && this._updateSessionFromEvent(_, p)
            let f = p.transaction_info
            if (i && f && p.transaction !== t.transaction) {
              let h = 'custom'
              p.transaction_info = { ...f, source: h }
            }
            return this.sendEvent(p, n), p
          })
          .then(null, (p) => {
            throw p instanceof fe.SentryError
              ? p
              : (this.captureException(p, {
                  data: { __sentry__: !0 },
                  originalException: p,
                }),
                new fe.SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`))
          })
      }
      _process(t) {
        this._numProcessing++,
          t.then(
            (n) => (this._numProcessing--, n),
            (n) => (this._numProcessing--, n),
          )
      }
      _sendEnvelope(t) {
        if (
          (this.emit('beforeEnvelope', t), this._isEnabled() && this._transport)
        )
          return this._transport.send(t).then(null, (n) => {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              fe.logger.error('Error while sending event:', n)
          })
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          fe.logger.error('Transport disabled')
      }
      _clearOutcomes() {
        let t = this._outcomes
        return (
          (this._outcomes = {}),
          Object.keys(t).map((n) => {
            let [r, s] = n.split(':')
            return { reason: r, category: s, quantity: t[n] }
          })
        )
      }
    }
  function kQ(e, t) {
    let n = `${t} must return \`null\` or a valid event.`
    if (fe.isThenable(e))
      return e.then(
        (r) => {
          if (!fe.isPlainObject(r) && r !== null) throw new fe.SentryError(n)
          return r
        },
        (r) => {
          throw new fe.SentryError(`${t} rejected with ${r}`)
        },
      )
    if (!fe.isPlainObject(e) && e !== null) throw new fe.SentryError(n)
    return e
  }
  function MQ(e, t, n) {
    let { beforeSend: r, beforeSendTransaction: s } = e
    return ON(t) && r ? r(t, n) : NN(t) && s ? s(t, n) : t
  }
  function ON(e) {
    return e.type === void 0
  }
  function NN(e) {
    return e.type === 'transaction'
  }
  Xb.BaseClient = Kb
})
var ev = l((Zb) => {
  Object.defineProperty(Zb, '__esModule', { value: !0 })
  var Qb = O()
  function LQ(e, t, n, r, s) {
    let o = { sent_at: new Date().toISOString() }
    n && n.sdk && (o.sdk = { name: n.sdk.name, version: n.sdk.version }),
      r && s && (o.dsn = Qb.dsnToString(s)),
      t && (o.trace = Qb.dropUndefinedKeys(t))
    let i = UQ(e)
    return Qb.createEnvelope(o, [i])
  }
  function UQ(e) {
    return [{ type: 'check_in' }, e]
  }
  Zb.createCheckInEnvelope = LQ
})
var qN = l((nv) => {
  Object.defineProperty(nv, '__esModule', { value: !0 })
  var dr = O(),
    FQ = Jb(),
    BQ = ev(),
    jQ = $t(),
    GQ = $b(),
    $Q = Mb(),
    zQ = jd()
  Lb()
  var tv = class extends FQ.BaseClient {
    constructor(t) {
      $Q.addTracingExtensions(), super(t)
    }
    eventFromException(t, n) {
      return dr.resolvedSyncPromise(
        dr.eventFromUnknownInput(
          jQ.getCurrentHub,
          this._options.stackParser,
          t,
          n,
        ),
      )
    }
    eventFromMessage(t, n = 'info', r) {
      return dr.resolvedSyncPromise(
        dr.eventFromMessage(
          this._options.stackParser,
          t,
          n,
          r,
          this._options.attachStacktrace,
        ),
      )
    }
    captureException(t, n, r) {
      if (this._options.autoSessionTracking && this._sessionFlusher && r) {
        let s = r.getRequestSession()
        s && s.status === 'ok' && (s.status = 'errored')
      }
      return super.captureException(t, n, r)
    }
    captureEvent(t, n, r) {
      if (
        this._options.autoSessionTracking &&
        this._sessionFlusher &&
        r &&
        (t.type || 'exception') === 'exception' &&
        t.exception &&
        t.exception.values &&
        t.exception.values.length > 0
      ) {
        let i = r.getRequestSession()
        i && i.status === 'ok' && (i.status = 'errored')
      }
      return super.captureEvent(t, n, r)
    }
    close(t) {
      return (
        this._sessionFlusher && this._sessionFlusher.close(), super.close(t)
      )
    }
    initSessionFlusher() {
      let { release: t, environment: n } = this._options
      t
        ? (this._sessionFlusher = new GQ.SessionFlusher(this, {
            release: t,
            environment: n,
          }))
        : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          dr.logger.warn(
            'Cannot initialise an instance of SessionFlusher if no release is provided!',
          )
    }
    captureCheckIn(t, n, r) {
      let s =
        t.status !== 'in_progress' && t.checkInId ? t.checkInId : dr.uuid4()
      if (!this._isEnabled())
        return (
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            dr.logger.warn('SDK not enabled, will not capture checkin.'),
          s
        )
      let o = this.getOptions(),
        { release: i, environment: a, tunnel: c } = o,
        u = {
          check_in_id: s,
          monitor_slug: t.monitorSlug,
          status: t.status,
          release: i,
          environment: a,
        }
      t.status !== 'in_progress' && (u.duration = t.duration),
        n &&
          (u.monitor_config = {
            schedule: n.schedule,
            checkin_margin: n.checkinMargin,
            max_runtime: n.maxRuntime,
            timezone: n.timezone,
          })
      let [d, p] = this._getTraceInfoFromScope(r)
      p && (u.contexts = { trace: p })
      let _ = BQ.createCheckInEnvelope(
        u,
        d,
        this.getSdkMetadata(),
        c,
        this.getDsn(),
      )
      return (
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          dr.logger.info('Sending checkin:', t.monitorSlug, t.status),
        this._sendEnvelope(_),
        s
      )
    }
    _captureRequestSession() {
      this._sessionFlusher
        ? this._sessionFlusher.incrementSessionStatusCount()
        : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          dr.logger.warn(
            'Discarded request mode session because autoSessionTracking option was disabled',
          )
    }
    _prepareEvent(t, n, r) {
      return (
        this._options.platform &&
          (t.platform = t.platform || this._options.platform),
        this._options.runtime &&
          (t.contexts = {
            ...t.contexts,
            runtime: (t.contexts || {}).runtime || this._options.runtime,
          }),
        this._options.serverName &&
          (t.server_name = t.server_name || this._options.serverName),
        super._prepareEvent(t, n, r)
      )
    }
    _getTraceInfoFromScope(t) {
      if (!t) return [void 0, void 0]
      let n = t.getSpan()
      if (n)
        return [
          n.transaction ? n.transaction.getDynamicSamplingContext() : void 0,
          n.getTraceContext(),
        ]
      let {
          traceId: r,
          spanId: s,
          parentSpanId: o,
          dsc: i,
        } = t.getPropagationContext(),
        a = { trace_id: r, span_id: s, parent_span_id: o }
      return i
        ? [i, a]
        : [zQ.getDynamicSamplingContextFromClient(r, this, t), a]
    }
  }
  nv.ServerRuntimeClient = tv
})
var kN = l((rv) => {
  Object.defineProperty(rv, '__esModule', { value: !0 })
  var HQ = O(),
    VQ = $t()
  function YQ(e, t) {
    t.debug === !0 &&
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__
        ? HQ.logger.enable()
        : console.warn(
            '[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.',
          ))
    let n = VQ.getCurrentHub()
    n.getScope().update(t.initialScope)
    let s = new e(t)
    n.bindClient(s)
  }
  rv.initAndBind = YQ
})
var UN = l((Lm) => {
  Object.defineProperty(Lm, '__esModule', { value: !0 })
  var mt = O(),
    LN = 30
  function WQ(e, t, n = mt.makePromiseBuffer(e.bufferSize || LN)) {
    let r = {},
      s = (i) => n.drain(i)
    function o(i) {
      let a = []
      if (
        (mt.forEachEnvelopeItem(i, (p, _) => {
          let f = mt.envelopeItemTypeToDataCategory(_)
          if (mt.isRateLimited(r, f)) {
            let h = MN(p, _)
            e.recordDroppedEvent('ratelimit_backoff', f, h)
          } else a.push(p)
        }),
        a.length === 0)
      )
        return mt.resolvedSyncPromise()
      let c = mt.createEnvelope(i[0], a),
        u = (p) => {
          mt.forEachEnvelopeItem(c, (_, f) => {
            let h = MN(_, f)
            e.recordDroppedEvent(p, mt.envelopeItemTypeToDataCategory(f), h)
          })
        },
        d = () =>
          t({ body: mt.serializeEnvelope(c, e.textEncoder) }).then(
            (p) => (
              p.statusCode !== void 0 &&
                (p.statusCode < 200 || p.statusCode >= 300) &&
                (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                mt.logger.warn(
                  `Sentry responded with status code ${p.statusCode} to sent event.`,
                ),
              (r = mt.updateRateLimits(r, p)),
              p
            ),
            (p) => {
              throw (u('network_error'), p)
            },
          )
      return n.add(d).then(
        (p) => p,
        (p) => {
          if (p instanceof mt.SentryError)
            return (
              (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                mt.logger.error(
                  'Skipped sending event because buffer is full.',
                ),
              u('queue_overflow'),
              mt.resolvedSyncPromise()
            )
          throw p
        },
      )
    }
    return (o.__sentry__baseTransport__ = !0), { send: o, flush: s }
  }
  function MN(e, t) {
    if (!(t !== 'event' && t !== 'transaction'))
      return Array.isArray(e) ? e[1] : void 0
  }
  Lm.DEFAULT_TRANSPORT_BUFFER_SIZE = LN
  Lm.createTransport = WQ
})
var BN = l((Yd) => {
  Object.defineProperty(Yd, '__esModule', { value: !0 })
  var ov = O(),
    FN = 100,
    iv = 5e3,
    KQ = 36e5
  function sv(e, t) {
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      ov.logger.info(`[Offline]: ${e}`, t)
  }
  function XQ(e) {
    return (t) => {
      let n = e(t),
        r = t.createStore ? t.createStore(t) : void 0,
        s = iv,
        o
      function i(d, p, _) {
        return ov.envelopeContainsItemType(d, [
          'replay_event',
          'replay_recording',
          'client_report',
        ])
          ? !1
          : t.shouldStore
            ? t.shouldStore(d, p, _)
            : !0
      }
      function a(d) {
        r &&
          (o && clearTimeout(o),
          (o = setTimeout(async () => {
            o = void 0
            let p = await r.pop()
            p &&
              (sv('Attempting to send previously queued event'),
              u(p).catch((_) => {
                sv('Failed to retry sending', _)
              }))
          }, d)),
          typeof o != 'number' && o.unref && o.unref())
      }
      function c() {
        o || (a(s), (s = Math.min(s * 2, KQ)))
      }
      async function u(d) {
        try {
          let p = await n.send(d),
            _ = FN
          if (p) {
            if (p.headers && p.headers['retry-after'])
              _ = ov.parseRetryAfterHeader(p.headers['retry-after'])
            else if ((p.statusCode || 0) >= 400) return p
          }
          return a(_), (s = iv), p
        } catch (p) {
          if (r && (await i(d, p, s)))
            return (
              await r.insert(d), c(), sv('Error sending. Event queued', p), {}
            )
          throw p
        }
      }
      return t.flushAtStartup && c(), { send: u, flush: (d) => n.flush(d) }
    }
  }
  Yd.MIN_DELAY = FN
  Yd.START_DELAY = iv
  Yd.makeOfflineTransport = XQ
})
var GN = l((Um) => {
  Object.defineProperty(Um, '__esModule', { value: !0 })
  var jN = O(),
    JQ = km()
  function av(e, t) {
    let n
    return (
      jN.forEachEnvelopeItem(
        e,
        (r, s) => (
          t.includes(s) && (n = Array.isArray(r) ? r[1] : void 0), !!n
        ),
      ),
      n
    )
  }
  function QQ(e, t) {
    return (n) => {
      let r = e(n)
      return {
        send: async (s) => {
          let o = av(s, ['event', 'transaction', 'profile', 'replay_event'])
          return o && (o.release = t), r.send(s)
        },
        flush: (s) => r.flush(s),
      }
    }
  }
  function ZQ(e, t) {
    return (n) => {
      let r = e(n),
        s = {}
      function o(c, u) {
        let d = u ? `${c}:${u}` : c
        if (!s[d]) {
          let p = jN.dsnFromString(c)
          if (!p) return
          let _ = JQ.getEnvelopeEndpointWithUrlEncodedAuth(p)
          s[d] = u ? QQ(e, u)({ ...n, url: _ }) : e({ ...n, url: _ })
        }
        return s[d]
      }
      async function i(c) {
        function u(_) {
          let f = _ && _.length ? _ : ['event']
          return av(c, f)
        }
        let d = t({ envelope: c, getEvent: u })
          .map((_) =>
            typeof _ == 'string' ? o(_, void 0) : o(_.dsn, _.release),
          )
          .filter((_) => !!_)
        return (
          d.length === 0 && d.push(r),
          (await Promise.all(d.map((_) => _.send(c))))[0]
        )
      }
      async function a(c) {
        let u = [...Object.keys(s).map((p) => s[p]), r]
        return (await Promise.all(u.map((p) => p.flush(c)))).every((p) => p)
      }
      return { send: i, flush: a }
    }
  }
  Um.eventFromEnvelope = av
  Um.makeMultiplexedTransport = ZQ
})
var $N = l((cv) => {
  Object.defineProperty(cv, '__esModule', { value: !0 })
  var eZ = '7.74.1'
  cv.SDK_VERSION = eZ
})
var uv = l((dv) => {
  Object.defineProperty(dv, '__esModule', { value: !0 })
  var tZ = O(),
    zN,
    Fm = class e {
      static __initStatic() {
        this.id = 'FunctionToString'
      }
      constructor() {
        this.name = e.id
      }
      setupOnce() {
        zN = Function.prototype.toString
        try {
          Function.prototype.toString = function (...t) {
            let n = tZ.getOriginalFunction(this) || this
            return zN.apply(n, t)
          }
        } catch {}
      }
    }
  Fm.__initStatic()
  dv.FunctionToString = Fm
})
var lv = l((Wd) => {
  Object.defineProperty(Wd, '__esModule', { value: !0 })
  var je = O(),
    nZ = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/],
    rZ = [
      /^.*\/healthcheck$/,
      /^.*\/healthy$/,
      /^.*\/live$/,
      /^.*\/ready$/,
      /^.*\/heartbeat$/,
      /^.*\/health$/,
      /^.*\/healthz$/,
    ],
    Bm = class e {
      static __initStatic() {
        this.id = 'InboundFilters'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._options = t)
      }
      setupOnce(t, n) {}
      processEvent(t, n, r) {
        let s = r.getOptions(),
          o = HN(this._options, s)
        return VN(t, o) ? null : t
      }
    }
  Bm.__initStatic()
  function HN(e = {}, t = {}) {
    return {
      allowUrls: [...(e.allowUrls || []), ...(t.allowUrls || [])],
      denyUrls: [...(e.denyUrls || []), ...(t.denyUrls || [])],
      ignoreErrors: [
        ...(e.ignoreErrors || []),
        ...(t.ignoreErrors || []),
        ...(e.disableErrorDefaults ? [] : nZ),
      ],
      ignoreTransactions: [
        ...(e.ignoreTransactions || []),
        ...(t.ignoreTransactions || []),
        ...(e.disableTransactionDefaults ? [] : rZ),
      ],
      ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0,
    }
  }
  function VN(e, t) {
    return t.ignoreInternal && dZ(e)
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          je.logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${je.getEventDescription(e)}`),
        !0)
      : sZ(e, t.ignoreErrors)
        ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            je.logger
              .warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${je.getEventDescription(e)}`),
          !0)
        : oZ(e, t.ignoreTransactions)
          ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              je.logger
                .warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${je.getEventDescription(e)}`),
            !0)
          : iZ(e, t.denyUrls)
            ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                je.logger
                  .warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${je.getEventDescription(e)}.
Url: ${jm(e)}`),
              !0)
            : aZ(e, t.allowUrls)
              ? !1
              : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  je.logger
                    .warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${je.getEventDescription(e)}.
Url: ${jm(e)}`),
                !0)
  }
  function sZ(e, t) {
    return e.type || !t || !t.length
      ? !1
      : cZ(e).some((n) => je.stringMatchesSomePattern(n, t))
  }
  function oZ(e, t) {
    if (e.type !== 'transaction' || !t || !t.length) return !1
    let n = e.transaction
    return n ? je.stringMatchesSomePattern(n, t) : !1
  }
  function iZ(e, t) {
    if (!t || !t.length) return !1
    let n = jm(e)
    return n ? je.stringMatchesSomePattern(n, t) : !1
  }
  function aZ(e, t) {
    if (!t || !t.length) return !0
    let n = jm(e)
    return n ? je.stringMatchesSomePattern(n, t) : !0
  }
  function cZ(e) {
    let t = []
    e.message && t.push(e.message)
    let n
    try {
      n = e.exception.values[e.exception.values.length - 1]
    } catch {}
    return (
      n &&
        n.value &&
        (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`)),
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        t.length === 0 &&
        je.logger.error(
          `Could not extract message for event ${je.getEventDescription(e)}`,
        ),
      t
    )
  }
  function dZ(e) {
    try {
      return e.exception.values[0].type === 'SentryError'
    } catch {}
    return !1
  }
  function uZ(e = []) {
    for (let t = e.length - 1; t >= 0; t--) {
      let n = e[t]
      if (n && n.filename !== '<anonymous>' && n.filename !== '[native code]')
        return n.filename || null
    }
    return null
  }
  function jm(e) {
    try {
      let t
      try {
        t = e.exception.values[0].stacktrace.frames
      } catch {}
      return t ? uZ(t) : null
    } catch {
      return (
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          je.logger.error(
            `Cannot extract url for event ${je.getEventDescription(e)}`,
          ),
        null
      )
    }
  }
  Wd.InboundFilters = Bm
  Wd._mergeOptions = HN
  Wd._shouldDropEvent = VN
})
var YN = l((Gm) => {
  Object.defineProperty(Gm, '__esModule', { value: !0 })
  var lZ = uv(),
    mZ = lv()
  Gm.FunctionToString = lZ.FunctionToString
  Gm.InboundFilters = mZ.InboundFilters
})
var KN = l((mv) => {
  Object.defineProperty(mv, '__esModule', { value: !0 })
  function pZ(e, t) {
    let n = t.getClient(),
      r = n && n.getDsn(),
      s = n && n.getOptions().tunnel
    return fZ(e, r) || _Z(e, s)
  }
  function _Z(e, t) {
    return t ? WN(e) === WN(t) : !1
  }
  function fZ(e, t) {
    return t ? e.includes(t.host) : !1
  }
  function WN(e) {
    return e[e.length - 1] === '/' ? e.slice(0, -1) : e
  }
  mv.isSentryRequestUrl = pZ
})
var ZN = l((Kd) => {
  Object.defineProperty(Kd, '__esModule', { value: !0 })
  var pv = O(),
    JN = new Map(),
    XN = new Set()
  function hZ(e) {
    if (pv.GLOBAL_OBJ._sentryModuleMetadata)
      for (let t of Object.keys(pv.GLOBAL_OBJ._sentryModuleMetadata)) {
        let n = pv.GLOBAL_OBJ._sentryModuleMetadata[t]
        if (XN.has(t)) continue
        XN.add(t)
        let r = e(t)
        for (let s of r.reverse())
          if (s.filename) {
            JN.set(s.filename, n)
            break
          }
      }
  }
  function QN(e, t) {
    return hZ(e), JN.get(t)
  }
  function gZ(e, t) {
    try {
      t.exception.values.forEach((n) => {
        if (n.stacktrace)
          for (let r of n.stacktrace.frames || []) {
            if (!r.filename) continue
            let s = QN(e, r.filename)
            s && (r.module_metadata = s)
          }
      })
    } catch {}
  }
  function yZ(e) {
    try {
      e.exception.values.forEach((t) => {
        if (t.stacktrace)
          for (let n of t.stacktrace.frames || []) delete n.module_metadata
      })
    } catch {}
  }
  Kd.addMetadataToStackFrames = gZ
  Kd.getMetadataForUrl = QN
  Kd.stripMetadataFromStackFrames = yZ
})
var tq = l((_v) => {
  Object.defineProperty(_v, '__esModule', { value: !0 })
  var EZ = O(),
    eq = ZN(),
    $m = class e {
      static __initStatic() {
        this.id = 'ModuleMetadata'
      }
      constructor() {
        this.name = e.id
      }
      setupOnce(t, n) {
        let r = n().getClient()
        if (!r || typeof r.on != 'function') return
        r.on('beforeEnvelope', (o) => {
          EZ.forEachEnvelopeItem(o, (i, a) => {
            if (a === 'event') {
              let c = Array.isArray(i) ? i[1] : void 0
              c && (eq.stripMetadataFromStackFrames(c), (i[1] = c))
            }
          })
        })
        let s = r.getOptions().stackParser
        t((o) => (eq.addMetadataToStackFrames(s, o), o))
      }
    }
  $m.__initStatic()
  _v.ModuleMetadata = $m
})
var we = l((N) => {
  Object.defineProperty(N, '__esModule', { value: !0 })
  var nq = Mb(),
    rq = Nb(),
    sq = Pm(),
    SZ = Rm(),
    bZ = xm(),
    vZ = Lb(),
    io = gN(),
    CZ = jd(),
    TZ = yN(),
    We = EN(),
    ur = $t(),
    fv = Ld(),
    wZ = $b(),
    IZ = Tm(),
    xZ = qd(),
    oq = km(),
    PZ = Jb(),
    RZ = qN(),
    DZ = kN(),
    AZ = UN(),
    OZ = BN(),
    NZ = GN(),
    qZ = $N(),
    iq = Yb(),
    kZ = YN(),
    MZ = Wb(),
    LZ = ev(),
    UZ = Om(),
    FZ = KN(),
    BZ = Od(),
    jZ = tq(),
    GZ = uv(),
    $Z = lv(),
    zZ = O()
  N.addTracingExtensions = nq.addTracingExtensions
  N.startIdleTransaction = nq.startIdleTransaction
  N.IdleTransaction = rq.IdleTransaction
  N.TRACING_DEFAULTS = rq.TRACING_DEFAULTS
  N.Span = sq.Span
  N.spanStatusfromHttpCode = sq.spanStatusfromHttpCode
  N.Transaction = SZ.Transaction
  N.getActiveTransaction = bZ.getActiveTransaction
  Object.defineProperty(N, 'SpanStatus', {
    enumerable: !0,
    get: () => vZ.SpanStatus,
  })
  N.continueTrace = io.continueTrace
  N.getActiveSpan = io.getActiveSpan
  N.startActiveSpan = io.startActiveSpan
  N.startInactiveSpan = io.startInactiveSpan
  N.startSpan = io.startSpan
  N.startSpanManual = io.startSpanManual
  N.trace = io.trace
  N.getDynamicSamplingContextFromClient = CZ.getDynamicSamplingContextFromClient
  N.setMeasurement = TZ.setMeasurement
  N.addBreadcrumb = We.addBreadcrumb
  N.captureCheckIn = We.captureCheckIn
  N.captureEvent = We.captureEvent
  N.captureException = We.captureException
  N.captureMessage = We.captureMessage
  N.close = We.close
  N.configureScope = We.configureScope
  N.flush = We.flush
  N.lastEventId = We.lastEventId
  N.setContext = We.setContext
  N.setExtra = We.setExtra
  N.setExtras = We.setExtras
  N.setTag = We.setTag
  N.setTags = We.setTags
  N.setUser = We.setUser
  N.startTransaction = We.startTransaction
  N.withScope = We.withScope
  N.Hub = ur.Hub
  N.ensureHubOnCarrier = ur.ensureHubOnCarrier
  N.getCurrentHub = ur.getCurrentHub
  N.getHubFromCarrier = ur.getHubFromCarrier
  N.getMainCarrier = ur.getMainCarrier
  N.makeMain = ur.makeMain
  N.runWithAsyncContext = ur.runWithAsyncContext
  N.setAsyncContextStrategy = ur.setAsyncContextStrategy
  N.setHubOnCarrier = ur.setHubOnCarrier
  N.closeSession = fv.closeSession
  N.makeSession = fv.makeSession
  N.updateSession = fv.updateSession
  N.SessionFlusher = wZ.SessionFlusher
  N.Scope = IZ.Scope
  N.addGlobalEventProcessor = xZ.addGlobalEventProcessor
  N.getEnvelopeEndpointWithUrlEncodedAuth =
    oq.getEnvelopeEndpointWithUrlEncodedAuth
  N.getReportDialogEndpoint = oq.getReportDialogEndpoint
  N.BaseClient = PZ.BaseClient
  N.ServerRuntimeClient = RZ.ServerRuntimeClient
  N.initAndBind = DZ.initAndBind
  N.createTransport = AZ.createTransport
  N.makeOfflineTransport = OZ.makeOfflineTransport
  N.makeMultiplexedTransport = NZ.makeMultiplexedTransport
  N.SDK_VERSION = qZ.SDK_VERSION
  N.addIntegration = iq.addIntegration
  N.getIntegrationsToSetup = iq.getIntegrationsToSetup
  N.Integrations = kZ
  N.prepareEvent = MZ.prepareEvent
  N.createCheckInEnvelope = LZ.createCheckInEnvelope
  N.hasTracingEnabled = UZ.hasTracingEnabled
  N.isSentryRequestUrl = FZ.isSentryRequestUrl
  N.DEFAULT_ENVIRONMENT = BZ.DEFAULT_ENVIRONMENT
  N.ModuleMetadata = jZ.ModuleMetadata
  N.FunctionToString = GZ.FunctionToString
  N.InboundFilters = $Z.InboundFilters
  N.extractTraceparentData = zZ.extractTraceparentData
})
var Kr = l((hv) => {
  var { _optionalChain: aq } = Se()
  Object.defineProperty(hv, '__esModule', { value: !0 })
  function HZ(e) {
    let t = aq([
      e,
      'call',
      (r) => r(),
      'access',
      (r) => r.getClient,
      'call',
      (r) => r(),
      'optionalAccess',
      (r) => r.getOptions,
      'call',
      (r) => r(),
    ])
    return (
      (aq([t, 'optionalAccess', (r) => r.instrumenter]) || 'sentry') !==
      'sentry'
    )
  }
  hv.shouldDisableAutoInstrumentation = HZ
})
var lq = l((Xd) => {
  var { _optionalChain: Cn } = Se()
  Object.defineProperty(Xd, '__esModule', { value: !0 })
  var dn = O(),
    VZ = Kr(),
    zm = class e {
      static __initStatic() {
        this.id = 'Express'
      }
      constructor(t = {}) {
        ;(this.name = e.id),
          (this._router = t.router || t.app),
          (this._methods = (Array.isArray(t.methods) ? t.methods : []).concat(
            'use',
          ))
      }
      setupOnce(t, n) {
        if (!this._router) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            dn.logger.error('ExpressIntegration is missing an Express instance')
          return
        }
        if (VZ.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            dn.logger.log(
              'Express Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        KZ(this._router, this._methods), XZ(this._router)
      }
    }
  zm.__initStatic()
  function cq(e, t) {
    let n = e.length
    switch (n) {
      case 2:
        return function (r, s) {
          let o = s.__sentry_transaction
          if (o) {
            let i = o.startChild({
              description: e.name,
              op: `middleware.express.${t}`,
              origin: 'auto.middleware.express',
            })
            s.once('finish', () => {
              i.finish()
            })
          }
          return e.call(this, r, s)
        }
      case 3:
        return function (r, s, o) {
          let i = s.__sentry_transaction,
            a = Cn([
              i,
              'optionalAccess',
              (c) => c.startChild,
              'call',
              (c) =>
                c({
                  description: e.name,
                  op: `middleware.express.${t}`,
                  origin: 'auto.middleware.express',
                }),
            ])
          e.call(this, r, s, function (...c) {
            Cn([a, 'optionalAccess', (u) => u.finish, 'call', (u) => u()]),
              o.call(this, ...c)
          })
        }
      case 4:
        return function (r, s, o, i) {
          let a = o.__sentry_transaction,
            c = Cn([
              a,
              'optionalAccess',
              (u) => u.startChild,
              'call',
              (u) =>
                u({
                  description: e.name,
                  op: `middleware.express.${t}`,
                  origin: 'auto.middleware.express',
                }),
            ])
          e.call(this, r, s, o, function (...u) {
            Cn([c, 'optionalAccess', (d) => d.finish, 'call', (d) => d()]),
              i.call(this, ...u)
          })
        }
      default:
        throw new Error(`Express middleware takes 2-4 arguments. Got: ${n}`)
    }
  }
  function YZ(e, t) {
    return e.map((n) =>
      typeof n == 'function'
        ? cq(n, t)
        : Array.isArray(n)
          ? n.map((r) => (typeof r == 'function' ? cq(r, t) : r))
          : n,
    )
  }
  function WZ(e, t) {
    let n = e[t]
    return (
      (e[t] = function (...r) {
        return n.call(this, ...YZ(r, t))
      }),
      e
    )
  }
  function KZ(e, t = []) {
    t.forEach((n) => WZ(e, n))
  }
  function XZ(e) {
    let t = 'settings' in e
    t && e._router === void 0 && e.lazyrouter && e.lazyrouter()
    let n = t ? e._router : e
    if (!n) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        dn.logger.debug(
          'Cannot instrument router for URL Parameterization (did not find a valid router).',
        ),
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          dn.logger.debug(
            'Routing instrumentation is currently only supported in Express 4.',
          )
      return
    }
    let r = Object.getPrototypeOf(n),
      s = r.process_params
    r.process_params = function (i, a, c, u, d) {
      c._reconstructedRoute || (c._reconstructedRoute = '')
      let {
        layerRoutePath: p,
        isRegex: _,
        isArray: f,
        numExtraSegments: h,
      } = JZ(i)
      ;(p || _ || f) && (c._hasParameters = !0)
      let y
      p ? (y = p) : (y = uq(c.originalUrl, c._reconstructedRoute, i.path) || '')
      let E = y
        .split('/')
        .filter((se) => se.length > 0 && (_ || f || !se.includes('*')))
        .join('/')
      E && E.length > 0 && (c._reconstructedRoute += `/${E}${_ ? '/' : ''}`)
      let C = dn.getNumberOfUrlSegments(c.originalUrl || '') + h,
        A = dn.getNumberOfUrlSegments(c._reconstructedRoute)
      if (C === A) {
        c._hasParameters ||
          (c._reconstructedRoute !== c.originalUrl &&
            (c._reconstructedRoute = c.originalUrl
              ? dn.stripUrlQueryAndFragment(c.originalUrl)
              : c.originalUrl))
        let se = u.__sentry_transaction
        if (se && se.metadata.source !== 'custom') {
          let Q = c._reconstructedRoute || '/'
          se.setName(
            ...dn.extractPathForTransaction(c, {
              path: !0,
              method: !0,
              customRoute: Q,
            }),
          )
        }
      }
      return s.call(this, i, a, c, u, d)
    }
  }
  var dq = (e, t, n) => {
    if (
      !e ||
      !t ||
      !n ||
      Object.keys(n).length === 0 ||
      !Cn([n, 'access', (u) => u[0], 'optionalAccess', (u) => u.offset])
    )
      return
    let r = n.sort((u, d) => u.offset - d.offset),
      o = new RegExp(t, `${t.flags}d`).exec(e)
    if (!o || !o.indices) return
    let [, ...i] = o.indices
    if (i.length !== r.length) return
    let a = e,
      c = 0
    return (
      i.forEach(([u, d], p) => {
        let _ = a.substring(0, u - c),
          f = `:${r[p].name}`,
          h = a.substring(d - c)
        ;(a = _ + f + h), (c = c + (d - u - f.length))
      }),
      a
    )
  }
  function JZ(e) {
    let t = Cn([e, 'access', (i) => i.route, 'optionalAccess', (i) => i.path]),
      n = dn.isRegExp(t),
      r = Array.isArray(t)
    if (!t) {
      let [i] = process.versions.node.split('.').map(Number)
      i >= 16 && (t = dq(e.path, e.regexp, e.keys))
    }
    if (!t) return { isRegex: n, isArray: r, numExtraSegments: 0 }
    let s = r ? Math.max(QZ(t) - dn.getNumberOfUrlSegments(e.path || ''), 0) : 0
    return {
      layerRoutePath: ZZ(r, t),
      isRegex: n,
      isArray: r,
      numExtraSegments: s,
    }
  }
  function QZ(e) {
    return e.reduce((t, n) => t + dn.getNumberOfUrlSegments(n.toString()), 0)
  }
  function ZZ(e, t) {
    return e ? t.map((n) => n.toString()).join(',') : t && t.toString()
  }
  function uq(e, t, n) {
    let r = Cn([
        e,
        'optionalAccess',
        (a) => a.split,
        'call',
        (a) => a('/'),
        'access',
        (a) => a.filter,
        'call',
        (a) => a((c) => !!c),
      ]),
      s = 0,
      o =
        Cn([
          t,
          'optionalAccess',
          (a) => a.split,
          'call',
          (a) => a('/'),
          'access',
          (a) => a.filter,
          'call',
          (a) => a((c) => !!c),
          'access',
          (a) => a.length,
        ]) || 0
    return Cn([
      n,
      'optionalAccess',
      (a) => a.split,
      'call',
      (a) => a('/'),
      'access',
      (a) => a.filter,
      'call',
      (a) =>
        a((c) =>
          Cn([r, 'optionalAccess', (u) => u[o + s]]) === c
            ? ((s += 1), !0)
            : !1,
        ),
      'access',
      (a) => a.join,
      'call',
      (a) => a('/'),
    ])
  }
  Xd.Express = zm
  Xd.extractOriginalRoute = dq
  Xd.preventDuplicateSegments = uq
})
var mq = l((gv) => {
  var { _optionalChain: Ei } = Se()
  Object.defineProperty(gv, '__esModule', { value: !0 })
  var Si = O(),
    eee = Kr(),
    Hm = class e {
      static __initStatic() {
        this.id = 'Postgres'
      }
      constructor(t = {}) {
        ;(this.name = e.id),
          (this._usePgNative = !!t.usePgNative),
          (this._module = t.module)
      }
      loadDependency() {
        return (this._module = this._module || Si.loadModule('pg'))
      }
      setupOnce(t, n) {
        if (eee.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Si.logger.log(
              'Postgres Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let r = this.loadDependency()
        if (!r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Si.logger.error(
              'Postgres Integration was unable to require `pg` package.',
            )
          return
        }
        let s = this._usePgNative
          ? Ei([
              r,
              'access',
              (o) => o.native,
              'optionalAccess',
              (o) => o.Client,
            ])
          : r.Client
        if (!s) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Si.logger.error(
              "Postgres Integration was unable to access 'pg-native' bindings.",
            )
          return
        }
        Si.fill(s.prototype, 'query', function (o) {
          return function (i, a, c) {
            let d = n().getScope().getSpan(),
              p = { 'db.system': 'postgresql' }
            try {
              this.database && (p['db.name'] = this.database),
                this.host && (p['server.address'] = this.host),
                this.port && (p['server.port'] = this.port),
                this.user && (p['db.user'] = this.user)
            } catch {}
            let _ = Ei([
              d,
              'optionalAccess',
              (h) => h.startChild,
              'call',
              (h) =>
                h({
                  description: typeof i == 'string' ? i : i.text,
                  op: 'db',
                  origin: 'auto.db.postgres',
                  data: p,
                }),
            ])
            if (typeof c == 'function')
              return o.call(this, i, a, function (h, y) {
                Ei([_, 'optionalAccess', (E) => E.finish, 'call', (E) => E()]),
                  c(h, y)
              })
            if (typeof a == 'function')
              return o.call(this, i, function (h, y) {
                Ei([_, 'optionalAccess', (E) => E.finish, 'call', (E) => E()]),
                  a(h, y)
              })
            let f = typeof a < 'u' ? o.call(this, i, a) : o.call(this, i)
            return Si.isThenable(f)
              ? f.then(
                  (h) => (
                    Ei([
                      _,
                      'optionalAccess',
                      (y) => y.finish,
                      'call',
                      (y) => y(),
                    ]),
                    h
                  ),
                )
              : (Ei([_, 'optionalAccess', (h) => h.finish, 'call', (h) => h()]),
                f)
          }
        })
      }
    }
  Hm.__initStatic()
  gv.Postgres = Hm
})
var pq = l((yv) => {
  var { _optionalChain: tee } = Se()
  Object.defineProperty(yv, '__esModule', { value: !0 })
  var Jd = O(),
    nee = Kr(),
    Vm = class e {
      static __initStatic() {
        this.id = 'Mysql'
      }
      constructor() {
        this.name = e.id
      }
      loadDependency() {
        return (this._module =
          this._module || Jd.loadModule('mysql/lib/Connection.js'))
      }
      setupOnce(t, n) {
        if (nee.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Jd.logger.log(
              'Mysql Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let r = this.loadDependency()
        if (!r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Jd.logger.error(
              'Mysql Integration was unable to require `mysql` package.',
            )
          return
        }
        let s
        try {
          r.prototype.connect = new Proxy(r.prototype.connect, {
            apply(a, c, u) {
              return s || (s = c.config), a.apply(c, u)
            },
          })
        } catch {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Jd.logger.error(
              'Mysql Integration was unable to instrument `mysql` config.',
            )
        }
        function o() {
          return s
            ? {
                'server.address': s.host,
                'server.port': s.port,
                'db.user': s.user,
              }
            : {}
        }
        function i(a) {
          if (!a || a.endTimestamp) return
          let c = o()
          Object.keys(c).forEach((u) => {
            a.setData(u, c[u])
          }),
            a.finish()
        }
        Jd.fill(r, 'createQuery', function (a) {
          return function (c, u, d) {
            let _ = n().getScope().getSpan(),
              f = tee([
                _,
                'optionalAccess',
                (y) => y.startChild,
                'call',
                (y) =>
                  y({
                    description: typeof c == 'string' ? c : c.sql,
                    op: 'db',
                    origin: 'auto.db.mysql',
                    data: { 'db.system': 'mysql' },
                  }),
              ])
            if (typeof d == 'function')
              return a.call(this, c, u, function (y, E, C) {
                i(f), d(y, E, C)
              })
            if (typeof u == 'function')
              return a.call(this, c, function (y, E, C) {
                i(f), u(y, E, C)
              })
            let h = a.call(this, c, u)
            return (
              h.on('end', () => {
                i(f)
              }),
              h
            )
          }
        })
      }
    }
  Vm.__initStatic()
  yv.Mysql = Vm
})
var _q = l((Ev) => {
  var { _optionalChain: ao } = Se()
  Object.defineProperty(Ev, '__esModule', { value: !0 })
  var Qd = O(),
    ree = Kr(),
    see = [
      'aggregate',
      'bulkWrite',
      'countDocuments',
      'createIndex',
      'createIndexes',
      'deleteMany',
      'deleteOne',
      'distinct',
      'drop',
      'dropIndex',
      'dropIndexes',
      'estimatedDocumentCount',
      'find',
      'findOne',
      'findOneAndDelete',
      'findOneAndReplace',
      'findOneAndUpdate',
      'indexes',
      'indexExists',
      'indexInformation',
      'initializeOrderedBulkOp',
      'insertMany',
      'insertOne',
      'isCapped',
      'mapReduce',
      'options',
      'parallelCollectionScan',
      'rename',
      'replaceOne',
      'stats',
      'updateMany',
      'updateOne',
    ],
    oee = {
      bulkWrite: ['operations'],
      countDocuments: ['query'],
      createIndex: ['fieldOrSpec'],
      createIndexes: ['indexSpecs'],
      deleteMany: ['filter'],
      deleteOne: ['filter'],
      distinct: ['key', 'query'],
      dropIndex: ['indexName'],
      find: ['query'],
      findOne: ['query'],
      findOneAndDelete: ['filter'],
      findOneAndReplace: ['filter', 'replacement'],
      findOneAndUpdate: ['filter', 'update'],
      indexExists: ['indexes'],
      insertMany: ['docs'],
      insertOne: ['doc'],
      mapReduce: ['map', 'reduce'],
      rename: ['newName'],
      replaceOne: ['filter', 'doc'],
      updateMany: ['filter', 'update'],
      updateOne: ['filter', 'update'],
    }
  function iee(e) {
    return e && typeof e == 'object' && e.once && typeof e.once == 'function'
  }
  var Ym = class e {
    static __initStatic() {
      this.id = 'Mongo'
    }
    constructor(t = {}) {
      ;(this.name = e.id),
        (this._operations = Array.isArray(t.operations) ? t.operations : see),
        (this._describeOperations =
          'describeOperations' in t ? t.describeOperations : !0),
        (this._useMongoose = !!t.useMongoose)
    }
    loadDependency() {
      let t = this._useMongoose ? 'mongoose' : 'mongodb'
      return (this._module = this._module || Qd.loadModule(t))
    }
    setupOnce(t, n) {
      if (ree.shouldDisableAutoInstrumentation(n)) {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Qd.logger.log(
            'Mongo Integration is skipped because of instrumenter configuration.',
          )
        return
      }
      let r = this.loadDependency()
      if (!r) {
        let s = this._useMongoose ? 'mongoose' : 'mongodb'
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Qd.logger.error(
            `Mongo Integration was unable to require \`${s}\` package.`,
          )
        return
      }
      this._instrumentOperations(r.Collection, this._operations, n)
    }
    _instrumentOperations(t, n, r) {
      n.forEach((s) => this._patchOperation(t, s, r))
    }
    _patchOperation(t, n, r) {
      if (!(n in t.prototype)) return
      let s = this._getSpanContextFromOperationArguments.bind(this)
      Qd.fill(t.prototype, n, function (o) {
        return function (...i) {
          let a = i[i.length - 1],
            u = r().getScope().getSpan()
          if (typeof a != 'function' || (n === 'mapReduce' && i.length === 2)) {
            let p = ao([
                u,
                'optionalAccess',
                (f) => f.startChild,
                'call',
                (f) => f(s(this, n, i)),
              ]),
              _ = o.call(this, ...i)
            if (Qd.isThenable(_))
              return _.then(
                (f) => (
                  ao([
                    p,
                    'optionalAccess',
                    (h) => h.finish,
                    'call',
                    (h) => h(),
                  ]),
                  f
                ),
              )
            if (iee(_)) {
              let f = _
              try {
                f.once('close', () => {
                  ao([p, 'optionalAccess', (h) => h.finish, 'call', (h) => h()])
                })
              } catch {
                ao([p, 'optionalAccess', (y) => y.finish, 'call', (y) => y()])
              }
              return f
            } else
              return (
                ao([p, 'optionalAccess', (f) => f.finish, 'call', (f) => f()]),
                _
              )
          }
          let d = ao([
            u,
            'optionalAccess',
            (p) => p.startChild,
            'call',
            (p) => p(s(this, n, i.slice(0, -1))),
          ])
          return o.call(this, ...i.slice(0, -1), function (p, _) {
            ao([d, 'optionalAccess', (f) => f.finish, 'call', (f) => f()]),
              a(p, _)
          })
        }
      })
    }
    _getSpanContextFromOperationArguments(t, n, r) {
      let s = {
          'db.system': 'mongodb',
          'db.name': t.dbName,
          'db.operation': n,
          'db.mongodb.collection': t.collectionName,
        },
        o = { op: 'db', origin: 'auto.db.mongo', description: n, data: s },
        i = oee[n],
        a = Array.isArray(this._describeOperations)
          ? this._describeOperations.includes(n)
          : this._describeOperations
      if (!i || !a) return o
      try {
        if (n === 'mapReduce') {
          let [c, u] = r
          ;(s[i[0]] = typeof c == 'string' ? c : c.name || '<anonymous>'),
            (s[i[1]] = typeof u == 'string' ? u : u.name || '<anonymous>')
        } else
          for (let c = 0; c < i.length; c++)
            s[`db.mongodb.${i[c]}`] = JSON.stringify(r[c])
      } catch {}
      return o
    }
  }
  Ym.__initStatic()
  Ev.Mongo = Ym
})
var gq = l((Sv) => {
  Object.defineProperty(Sv, '__esModule', { value: !0 })
  var fq = we(),
    hq = O(),
    aee = Kr()
  function cee(e) {
    return !!e && !!e.$use
  }
  var Wm = class e {
    static __initStatic() {
      this.id = 'Prisma'
    }
    constructor(t = {}) {
      if (
        ((this.name = e.id), cee(t.client) && !t.client._sentryInstrumented)
      ) {
        hq.addNonEnumerableProperty(t.client, '_sentryInstrumented', !0)
        let n = {}
        try {
          let r = t.client._engineConfig
          if (r) {
            let { activeProvider: s, clientVersion: o } = r
            s && (n['db.system'] = s), o && (n['db.prisma.version'] = o)
          }
        } catch {}
        t.client.$use((r, s) => {
          if (aee.shouldDisableAutoInstrumentation(fq.getCurrentHub))
            return s(r)
          let o = r.action,
            i = r.model
          return fq.trace(
            {
              name: i ? `${i} ${o}` : o,
              op: 'db.sql.prisma',
              origin: 'auto.db.prisma',
              data: { ...n, 'db.operation': o },
            },
            () => s(r),
          )
        })
      } else
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          hq.logger.warn(
            'Unsupported Prisma client provided to PrismaIntegration. Provided client:',
            t.client,
          )
    }
    setupOnce() {}
  }
  Wm.__initStatic()
  Sv.Prisma = Wm
})
var yq = l((bv) => {
  var { _optionalChain: bi } = Se()
  Object.defineProperty(bv, '__esModule', { value: !0 })
  var Zd = O(),
    dee = Kr(),
    Km = class e {
      static __initStatic() {
        this.id = 'GraphQL'
      }
      constructor() {
        this.name = e.id
      }
      loadDependency() {
        return (this._module =
          this._module || Zd.loadModule('graphql/execution/execute.js'))
      }
      setupOnce(t, n) {
        if (dee.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Zd.logger.log(
              'GraphQL Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let r = this.loadDependency()
        if (!r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Zd.logger.error(
              'GraphQL Integration was unable to require graphql/execution package.',
            )
          return
        }
        Zd.fill(r, 'execute', function (s) {
          return function (...o) {
            let i = n().getScope(),
              a = i.getSpan(),
              c = bi([
                a,
                'optionalAccess',
                (d) => d.startChild,
                'call',
                (d) =>
                  d({
                    description: 'execute',
                    op: 'graphql.execute',
                    origin: 'auto.graphql.graphql',
                  }),
              ])
            bi([i, 'optionalAccess', (d) => d.setSpan, 'call', (d) => d(c)])
            let u = s.call(this, ...o)
            return Zd.isThenable(u)
              ? u.then(
                  (d) => (
                    bi([
                      c,
                      'optionalAccess',
                      (p) => p.finish,
                      'call',
                      (p) => p(),
                    ]),
                    bi([
                      i,
                      'optionalAccess',
                      (p) => p.setSpan,
                      'call',
                      (p) => p(a),
                    ]),
                    d
                  ),
                )
              : (bi([c, 'optionalAccess', (d) => d.finish, 'call', (d) => d()]),
                bi([
                  i,
                  'optionalAccess',
                  (d) => d.setSpan,
                  'call',
                  (d) => d(a),
                ]),
                u)
          }
        })
      }
    }
  Km.__initStatic()
  bv.GraphQL = Km
})
var Sq = l((Cv) => {
  var { _optionalChain: vv } = Se()
  Object.defineProperty(Cv, '__esModule', { value: !0 })
  var tt = O(),
    uee = Kr(),
    Xm = class e {
      static __initStatic() {
        this.id = 'Apollo'
      }
      constructor(t = { useNestjs: !1 }) {
        ;(this.name = e.id), (this._useNest = !!t.useNestjs)
      }
      loadDependency() {
        return (
          this._useNest
            ? (this._module = this._module || tt.loadModule('@nestjs/graphql'))
            : (this._module =
                this._module || tt.loadModule('apollo-server-core')),
          this._module
        )
      }
      setupOnce(t, n) {
        if (uee.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            tt.logger.log(
              'Apollo Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        if (this._useNest) {
          let r = this.loadDependency()
          if (!r) {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              tt.logger.error(
                'Apollo-NestJS Integration was unable to require @nestjs/graphql package.',
              )
            return
          }
          tt.fill(r.GraphQLFactory.prototype, 'mergeWithSchema', function (s) {
            return function (...o) {
              return (
                tt.fill(this.resolversExplorerService, 'explore', function (i) {
                  return function () {
                    let a = tt.arrayify(i.call(this))
                    return Eq(a, n)
                  }
                }),
                s.call(this, ...o)
              )
            }
          })
        } else {
          let r = this.loadDependency()
          if (!r) {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              tt.logger.error(
                'Apollo Integration was unable to require apollo-server-core package.',
              )
            return
          }
          tt.fill(
            r.ApolloServerBase.prototype,
            'constructSchema',
            function (s) {
              return function () {
                if (!this.config.resolvers)
                  return (
                    (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                      (this.config.schema
                        ? (tt.logger.warn(
                            'Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead.',
                          ),
                          tt.logger.warn())
                        : this.config.modules &&
                          tt.logger.warn(
                            'Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.',
                          ),
                      tt.logger.error(
                        'Skipping tracing as no resolvers found on the `ApolloServer` instance.',
                      )),
                    s.call(this)
                  )
                let o = tt.arrayify(this.config.resolvers)
                return (this.config.resolvers = Eq(o, n)), s.call(this)
              }
            },
          )
        }
      }
    }
  Xm.__initStatic()
  function Eq(e, t) {
    return e.map(
      (n) => (
        Object.keys(n).forEach((r) => {
          Object.keys(n[r]).forEach((s) => {
            typeof n[r][s] == 'function' && lee(n, r, s, t)
          })
        }),
        n
      ),
    )
  }
  function lee(e, t, n, r) {
    tt.fill(e[t], n, function (s) {
      return function (...o) {
        let a = r().getScope().getSpan(),
          c = vv([
            a,
            'optionalAccess',
            (d) => d.startChild,
            'call',
            (d) =>
              d({
                description: `${t}.${n}`,
                op: 'graphql.resolve',
                origin: 'auto.graphql.apollo',
              }),
          ]),
          u = s.call(this, ...o)
        return tt.isThenable(u)
          ? u.then(
              (d) => (
                vv([c, 'optionalAccess', (p) => p.finish, 'call', (p) => p()]),
                d
              ),
            )
          : (vv([c, 'optionalAccess', (d) => d.finish, 'call', (d) => d()]), u)
      }
    })
  }
  Cv.Apollo = Xm
})
var bq = l((Tv, Xr) => {
  Object.defineProperty(Tv, '__esModule', { value: !0 })
  var co = O(),
    mee = [
      () => {
        let e = co.dynamicRequire(Xr, './apollo')
        return new e.Apollo()
      },
      () => {
        let e = co.dynamicRequire(Xr, './apollo')
        return new e.Apollo({ useNestjs: !0 })
      },
      () => {
        let e = co.dynamicRequire(Xr, './graphql')
        return new e.GraphQL()
      },
      () => {
        let e = co.dynamicRequire(Xr, './mongo')
        return new e.Mongo()
      },
      () => {
        let e = co.dynamicRequire(Xr, './mongo')
        return new e.Mongo({ mongoose: !0 })
      },
      () => {
        let e = co.dynamicRequire(Xr, './mysql')
        return new e.Mysql()
      },
      () => {
        let e = co.dynamicRequire(Xr, './postgres')
        return new e.Postgres()
      },
    ]
  Tv.lazyLoadedNodePerformanceMonitoringIntegrations = mee
})
var lr = l((wv) => {
  Object.defineProperty(wv, '__esModule', { value: !0 })
  var pee = O(),
    _ee = pee.GLOBAL_OBJ
  wv.WINDOW = _ee
})
var Cq = l((Iv) => {
  Object.defineProperty(Iv, '__esModule', { value: !0 })
  var fee = we(),
    vq = O(),
    Jm = lr()
  function hee() {
    Jm.WINDOW && Jm.WINDOW.document
      ? Jm.WINDOW.document.addEventListener('visibilitychange', () => {
          let e = fee.getActiveTransaction()
          if (Jm.WINDOW.document.hidden && e) {
            let t = 'cancelled'
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              vq.logger.log(
                `[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${e.op}`,
              ),
              e.status || e.setStatus(t),
              e.setTag('visibilitychange', 'document.hidden'),
              e.finish()
          }
        })
      : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        vq.logger.warn(
          '[Tracing] Could not set up background tab detection due to lack of global document',
        )
  }
  Iv.registerBackgroundTabDetection = hee
})
var Qm = l((xv) => {
  Object.defineProperty(xv, '__esModule', { value: !0 })
  var gee = (e, t, n) => {
    let r, s
    return (o) => {
      t.value >= 0 &&
        (o || n) &&
        ((s = t.value - (r || 0)),
        (s || r === void 0) && ((r = t.value), (t.delta = s), e(t)))
    }
  }
  xv.bindReporter = gee
})
var Tq = l((Pv) => {
  Object.defineProperty(Pv, '__esModule', { value: !0 })
  var yee = () =>
    `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`
  Pv.generateUniqueID = yee
})
var Dv = l((Rv) => {
  Object.defineProperty(Rv, '__esModule', { value: !0 })
  var eu = lr(),
    Eee = () => {
      let e = eu.WINDOW.performance.timing,
        t = eu.WINDOW.performance.navigation.type,
        n = {
          entryType: 'navigation',
          startTime: 0,
          type: t == 2 ? 'back_forward' : t === 1 ? 'reload' : 'navigate',
        }
      for (let r in e)
        r !== 'navigationStart' &&
          r !== 'toJSON' &&
          (n[r] = Math.max(e[r] - e.navigationStart, 0))
      return n
    },
    See = () =>
      eu.WINDOW.__WEB_VITALS_POLYFILL__
        ? eu.WINDOW.performance &&
          ((performance.getEntriesByType &&
            performance.getEntriesByType('navigation')[0]) ||
            Eee())
        : eu.WINDOW.performance &&
          performance.getEntriesByType &&
          performance.getEntriesByType('navigation')[0]
  Rv.getNavigationEntry = See
})
var Ov = l((Av) => {
  Object.defineProperty(Av, '__esModule', { value: !0 })
  var bee = Dv(),
    vee = () => {
      let e = bee.getNavigationEntry()
      return (e && e.activationStart) || 0
    }
  Av.getActivationStart = vee
})
var Zm = l((Nv) => {
  Object.defineProperty(Nv, '__esModule', { value: !0 })
  var Cee = lr(),
    Tee = Tq(),
    wee = Ov(),
    Iee = Dv(),
    xee = (e, t) => {
      let n = Iee.getNavigationEntry(),
        r = 'navigate'
      return (
        n &&
          (Cee.WINDOW.document.prerendering || wee.getActivationStart() > 0
            ? (r = 'prerender')
            : (r = n.type.replace(/_/g, '-'))),
        {
          name: e,
          value: typeof t > 'u' ? -1 : t,
          rating: 'good',
          delta: 0,
          entries: [],
          id: Tee.generateUniqueID(),
          navigationType: r,
        }
      )
    }
  Nv.initMetric = xee
})
var tu = l((qv) => {
  Object.defineProperty(qv, '__esModule', { value: !0 })
  var Pee = (e, t, n) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(e)) {
        let r = new PerformanceObserver((s) => {
          t(s.getEntries())
        })
        return r.observe(Object.assign({ type: e, buffered: !0 }, n || {})), r
      }
    } catch {}
  }
  qv.observe = Pee
})
var nu = l((kv) => {
  Object.defineProperty(kv, '__esModule', { value: !0 })
  var Ree = lr(),
    Dee = (e, t) => {
      let n = (r) => {
        ;(r.type === 'pagehide' ||
          Ree.WINDOW.document.visibilityState === 'hidden') &&
          (e(r),
          t &&
            (removeEventListener('visibilitychange', n, !0),
            removeEventListener('pagehide', n, !0)))
      }
      addEventListener('visibilitychange', n, !0),
        addEventListener('pagehide', n, !0)
    }
  kv.onHidden = Dee
})
var wq = l((Mv) => {
  Object.defineProperty(Mv, '__esModule', { value: !0 })
  var Aee = Qm(),
    Oee = Zm(),
    Nee = tu(),
    qee = nu(),
    kee = (e) => {
      let t = Oee.initMetric('CLS', 0),
        n,
        r = 0,
        s = [],
        o = (a) => {
          a.forEach((c) => {
            if (!c.hadRecentInput) {
              let u = s[0],
                d = s[s.length - 1]
              r &&
              s.length !== 0 &&
              c.startTime - d.startTime < 1e3 &&
              c.startTime - u.startTime < 5e3
                ? ((r += c.value), s.push(c))
                : ((r = c.value), (s = [c])),
                r > t.value && ((t.value = r), (t.entries = s), n && n())
            }
          })
        },
        i = Nee.observe('layout-shift', o)
      if (i) {
        n = Aee.bindReporter(e, t)
        let a = () => {
          o(i.takeRecords()), n(!0)
        }
        return qee.onHidden(a), a
      }
    }
  Mv.onCLS = kee
})
var tp = l((Lv) => {
  Object.defineProperty(Lv, '__esModule', { value: !0 })
  var Iq = lr(),
    Mee = nu(),
    ep = -1,
    Lee = () =>
      Iq.WINDOW.document.visibilityState === 'hidden' &&
      !Iq.WINDOW.document.prerendering
        ? 0
        : 1 / 0,
    Uee = () => {
      Mee.onHidden(({ timeStamp: e }) => {
        ep = e
      }, !0)
    },
    Fee = () => (
      ep < 0 && ((ep = Lee()), Uee()),
      {
        get firstHiddenTime() {
          return ep
        },
      }
    )
  Lv.getVisibilityWatcher = Fee
})
var xq = l((Uv) => {
  Object.defineProperty(Uv, '__esModule', { value: !0 })
  var Bee = Qm(),
    jee = tp(),
    Gee = Zm(),
    $ee = tu(),
    zee = nu(),
    Hee = (e) => {
      let t = jee.getVisibilityWatcher(),
        n = Gee.initMetric('FID'),
        r,
        s = (a) => {
          a.startTime < t.firstHiddenTime &&
            ((n.value = a.processingStart - a.startTime),
            n.entries.push(a),
            r(!0))
        },
        o = (a) => {
          a.forEach(s)
        },
        i = $ee.observe('first-input', o)
      ;(r = Bee.bindReporter(e, n)),
        i &&
          zee.onHidden(() => {
            o(i.takeRecords()), i.disconnect()
          }, !0)
    }
  Uv.onFID = Hee
})
var Rq = l((Fv) => {
  Object.defineProperty(Fv, '__esModule', { value: !0 })
  var Vee = Qm(),
    Yee = Ov(),
    Wee = tp(),
    Kee = Zm(),
    Xee = tu(),
    Jee = nu(),
    Pq = {},
    Qee = (e) => {
      let t = Wee.getVisibilityWatcher(),
        n = Kee.initMetric('LCP'),
        r,
        s = (i) => {
          let a = i[i.length - 1]
          if (a) {
            let c = Math.max(a.startTime - Yee.getActivationStart(), 0)
            c < t.firstHiddenTime && ((n.value = c), (n.entries = [a]), r())
          }
        },
        o = Xee.observe('largest-contentful-paint', s)
      if (o) {
        r = Vee.bindReporter(e, n)
        let i = () => {
          Pq[n.id] ||
            (s(o.takeRecords()), o.disconnect(), (Pq[n.id] = !0), r(!0))
        }
        return (
          ['keydown', 'click'].forEach((a) => {
            addEventListener(a, i, { once: !0, capture: !0 })
          }),
          Jee.onHidden(i, !0),
          i
        )
      }
    }
  Fv.onLCP = Qee
})
var Dq = l((np) => {
  Object.defineProperty(np, '__esModule', { value: !0 })
  function Zee(e) {
    return typeof e == 'number' && isFinite(e)
  }
  function ete(e, { startTimestamp: t, ...n }) {
    return (
      t && e.startTimestamp > t && (e.startTimestamp = t),
      e.startChild({ startTimestamp: t, ...n })
    )
  }
  np._startChild = ete
  np.isMeasurementValue = Zee
})
var Lq = l((Jr) => {
  Object.defineProperty(Jr, '__esModule', { value: !0 })
  var Oq = we(),
    Ue = O(),
    uo = lr(),
    tte = wq(),
    nte = xq(),
    rte = Rq(),
    ste = tp(),
    Nq = tu(),
    mr = Dq()
  function Fe(e) {
    return e / 1e3
  }
  function qq() {
    return uo.WINDOW && uo.WINDOW.addEventListener && uo.WINDOW.performance
  }
  var Aq = 0,
    Pe = {},
    Tn,
    ru
  function ote() {
    let e = qq()
    if (e && Ue.browserPerformanceTimeOrigin) {
      e.mark && uo.WINDOW.performance.mark('sentry-tracing-init'), ute()
      let t = cte(),
        n = dte()
      return () => {
        t && t(), n && n()
      }
    }
    return () => {}
  }
  function ite() {
    let e = (t) => {
      for (let n of t) {
        let r = Oq.getActiveTransaction()
        if (!r) return
        let s = Fe(Ue.browserPerformanceTimeOrigin + n.startTime),
          o = Fe(n.duration)
        r.startChild({
          description: 'Main UI thread blocked',
          op: 'ui.long-task',
          origin: 'auto.ui.browser.metrics',
          startTimestamp: s,
          endTimestamp: s + o,
        })
      }
    }
    Nq.observe('longtask', e)
  }
  function ate() {
    let e = (t) => {
      for (let n of t) {
        let r = Oq.getActiveTransaction()
        if (!r) return
        if (n.name === 'click') {
          let s = Fe(Ue.browserPerformanceTimeOrigin + n.startTime),
            o = Fe(n.duration)
          r.startChild({
            description: Ue.htmlTreeAsString(n.target),
            op: `ui.interaction.${n.name}`,
            origin: 'auto.ui.browser.metrics',
            startTimestamp: s,
            endTimestamp: s + o,
          })
        }
      }
    }
    Nq.observe('event', e, { durationThreshold: 0 })
  }
  function cte() {
    return tte.onCLS((e) => {
      let t = e.entries.pop()
      t &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Ue.logger.log('[Measurements] Adding CLS'),
        (Pe.cls = { value: e.value, unit: '' }),
        (ru = t))
    })
  }
  function dte() {
    return rte.onLCP((e) => {
      let t = e.entries.pop()
      t &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Ue.logger.log('[Measurements] Adding LCP'),
        (Pe.lcp = { value: e.value, unit: 'millisecond' }),
        (Tn = t))
    })
  }
  function ute() {
    nte.onFID((e) => {
      let t = e.entries.pop()
      if (!t) return
      let n = Fe(Ue.browserPerformanceTimeOrigin),
        r = Fe(t.startTime)
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Ue.logger.log('[Measurements] Adding FID'),
        (Pe.fid = { value: e.value, unit: 'millisecond' }),
        (Pe['mark.fid'] = { value: n + r, unit: 'second' })
    })
  }
  function lte(e) {
    let t = qq()
    if (
      !t ||
      !uo.WINDOW.performance.getEntries ||
      !Ue.browserPerformanceTimeOrigin
    )
      return
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      Ue.logger.log('[Tracing] Adding & adjusting spans using Performance API')
    let n = Fe(Ue.browserPerformanceTimeOrigin),
      r = t.getEntries(),
      s,
      o
    if (
      (r.slice(Aq).forEach((i) => {
        let a = Fe(i.startTime),
          c = Fe(i.duration)
        if (!(e.op === 'navigation' && n + a < e.startTimestamp))
          switch (i.entryType) {
            case 'navigation': {
              mte(e, i, n),
                (s = n + Fe(i.responseStart)),
                (o = n + Fe(i.requestStart))
              break
            }
            case 'mark':
            case 'paint':
            case 'measure': {
              kq(e, i, a, c, n)
              let u = ste.getVisibilityWatcher(),
                d = i.startTime < u.firstHiddenTime
              i.name === 'first-paint' &&
                d &&
                ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  Ue.logger.log('[Measurements] Adding FP'),
                (Pe.fp = { value: i.startTime, unit: 'millisecond' })),
                i.name === 'first-contentful-paint' &&
                  d &&
                  ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                    Ue.logger.log('[Measurements] Adding FCP'),
                  (Pe.fcp = { value: i.startTime, unit: 'millisecond' }))
              break
            }
            case 'resource': {
              let u = i.name.replace(uo.WINDOW.location.origin, '')
              Mq(e, i, u, a, c, n)
              break
            }
          }
      }),
      (Aq = Math.max(r.length - 1, 0)),
      _te(e),
      e.op === 'pageload')
    ) {
      typeof s == 'number' &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Ue.logger.log('[Measurements] Adding TTFB'),
        (Pe.ttfb = {
          value: (s - e.startTimestamp) * 1e3,
          unit: 'millisecond',
        }),
        typeof o == 'number' &&
          o <= s &&
          (Pe['ttfb.requestTime'] = {
            value: (s - o) * 1e3,
            unit: 'millisecond',
          })),
        ['fcp', 'fp', 'lcp'].forEach((a) => {
          if (!Pe[a] || n >= e.startTimestamp) return
          let c = Pe[a].value,
            u = n + Fe(c),
            d = Math.abs((u - e.startTimestamp) * 1e3),
            p = d - c
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Ue.logger.log(
              `[Measurements] Normalized ${a} from ${c} to ${d} (${p})`,
            ),
            (Pe[a].value = d)
        })
      let i = Pe['mark.fid']
      i &&
        Pe.fid &&
        (mr._startChild(e, {
          description: 'first input delay',
          endTimestamp: i.value + Fe(Pe.fid.value),
          op: 'ui.action',
          origin: 'auto.ui.browser.metrics',
          startTimestamp: i.value,
        }),
        delete Pe['mark.fid']),
        'fcp' in Pe || delete Pe.cls,
        Object.keys(Pe).forEach((a) => {
          e.setMeasurement(a, Pe[a].value, Pe[a].unit)
        }),
        fte(e)
    }
    ;(Tn = void 0), (ru = void 0), (Pe = {})
  }
  function kq(e, t, n, r, s) {
    let o = s + n,
      i = o + r
    return (
      mr._startChild(e, {
        description: t.name,
        endTimestamp: i,
        op: t.entryType,
        origin: 'auto.resource.browser.metrics',
        startTimestamp: o,
      }),
      o
    )
  }
  function mte(e, t, n) {
    ;[
      'unloadEvent',
      'redirect',
      'domContentLoadedEvent',
      'loadEvent',
      'connect',
    ].forEach((r) => {
      rp(e, t, r, n)
    }),
      rp(e, t, 'secureConnection', n, 'TLS/SSL', 'connectEnd'),
      rp(e, t, 'fetch', n, 'cache', 'domainLookupStart'),
      rp(e, t, 'domainLookup', n, 'DNS'),
      pte(e, t, n)
  }
  function rp(e, t, n, r, s, o) {
    let i = o ? t[o] : t[`${n}End`],
      a = t[`${n}Start`]
    !a ||
      !i ||
      mr._startChild(e, {
        op: 'browser',
        origin: 'auto.browser.browser.metrics',
        description: s || n,
        startTimestamp: r + Fe(a),
        endTimestamp: r + Fe(i),
      })
  }
  function pte(e, t, n) {
    mr._startChild(e, {
      op: 'browser',
      origin: 'auto.browser.browser.metrics',
      description: 'request',
      startTimestamp: n + Fe(t.requestStart),
      endTimestamp: n + Fe(t.responseEnd),
    }),
      mr._startChild(e, {
        op: 'browser',
        origin: 'auto.browser.browser.metrics',
        description: 'response',
        startTimestamp: n + Fe(t.responseStart),
        endTimestamp: n + Fe(t.responseEnd),
      })
  }
  function Mq(e, t, n, r, s, o) {
    if (t.initiatorType === 'xmlhttprequest' || t.initiatorType === 'fetch')
      return
    let i = {}
    'transferSize' in t && (i['http.response_transfer_size'] = t.transferSize),
      'encodedBodySize' in t &&
        (i['http.response_content_length'] = t.encodedBodySize),
      'decodedBodySize' in t &&
        (i['http.decoded_response_content_length'] = t.decodedBodySize),
      'renderBlockingStatus' in t &&
        (i['resource.render_blocking_status'] = t.renderBlockingStatus)
    let a = o + r,
      c = a + s
    mr._startChild(e, {
      description: n,
      endTimestamp: c,
      op: t.initiatorType ? `resource.${t.initiatorType}` : 'resource.other',
      origin: 'auto.resource.browser.metrics',
      startTimestamp: a,
      data: i,
    })
  }
  function _te(e) {
    let t = uo.WINDOW.navigator
    if (!t) return
    let n = t.connection
    n &&
      (n.effectiveType && e.setTag('effectiveConnectionType', n.effectiveType),
      n.type && e.setTag('connectionType', n.type),
      mr.isMeasurementValue(n.rtt) &&
        (Pe['connection.rtt'] = { value: n.rtt, unit: 'millisecond' })),
      mr.isMeasurementValue(t.deviceMemory) &&
        e.setTag('deviceMemory', `${t.deviceMemory} GB`),
      mr.isMeasurementValue(t.hardwareConcurrency) &&
        e.setTag('hardwareConcurrency', String(t.hardwareConcurrency))
  }
  function fte(e) {
    Tn &&
      ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Ue.logger.log('[Measurements] Adding LCP Data'),
      Tn.element && e.setTag('lcp.element', Ue.htmlTreeAsString(Tn.element)),
      Tn.id && e.setTag('lcp.id', Tn.id),
      Tn.url && e.setTag('lcp.url', Tn.url.trim().slice(0, 200)),
      e.setTag('lcp.size', Tn.size)),
      ru &&
        ru.sources &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Ue.logger.log('[Measurements] Adding CLS Data'),
        ru.sources.forEach((t, n) =>
          e.setTag(`cls.source.${n + 1}`, Ue.htmlTreeAsString(t.node)),
        ))
  }
  Jr._addMeasureSpans = kq
  Jr._addResourceSpans = Mq
  Jr.addPerformanceEntries = lte
  Jr.startTrackingInteractions = ate
  Jr.startTrackingLongTasks = ite
  Jr.startTrackingWebVitals = ote
})
var jv = l((In) => {
  Object.defineProperty(In, '__esModule', { value: !0 })
  var vi = we(),
    nt = O(),
    sp = ['localhost', /^\/(?!\/)/],
    Bv = {
      traceFetch: !0,
      traceXHR: !0,
      enableHTTPTimings: !0,
      tracingOrigins: sp,
      tracePropagationTargets: sp,
    }
  function hte(e) {
    let {
        traceFetch: t,
        traceXHR: n,
        tracePropagationTargets: r,
        tracingOrigins: s,
        shouldCreateSpanForRequest: o,
        enableHTTPTimings: i,
      } = { traceFetch: Bv.traceFetch, traceXHR: Bv.traceXHR, ...e },
      a = typeof o == 'function' ? o : (d) => !0,
      c = (d) => jq(d, r || s),
      u = {}
    t &&
      nt.addInstrumentationHandler('fetch', (d) => {
        let p = Gq(d, a, c, u)
        i && p && Uq(p)
      }),
      n &&
        nt.addInstrumentationHandler('xhr', (d) => {
          let p = zq(d, a, c, u)
          i && p && Uq(p)
        })
  }
  function gte(e) {
    return (
      e.entryType === 'resource' &&
      'initiatorType' in e &&
      typeof e.nextHopProtocol == 'string' &&
      (e.initiatorType === 'fetch' || e.initiatorType === 'xmlhttprequest')
    )
  }
  function Uq(e) {
    let t = e.data.url,
      n = new PerformanceObserver((r) => {
        r.getEntries().forEach((o) => {
          gte(o) &&
            o.name.endsWith(t) &&
            (yte(o).forEach((a) => e.setData(...a)), n.disconnect())
        })
      })
    n.observe({ entryTypes: ['resource'] })
  }
  function Bq(e) {
    let t = 'unknown',
      n = 'unknown',
      r = ''
    for (let s of e) {
      if (s === '/') {
        ;[t, n] = e.split('/')
        break
      }
      if (!isNaN(Number(s))) {
        ;(t = r === 'h' ? 'http' : r), (n = e.split(r)[1])
        break
      }
      r += s
    }
    return r === e && (t = r), { name: t, version: n }
  }
  function wn(e = 0) {
    return (
      ((nt.browserPerformanceTimeOrigin || performance.timeOrigin) + e) / 1e3
    )
  }
  function yte(e) {
    let { name: t, version: n } = Bq(e.nextHopProtocol),
      r = []
    return (
      r.push(['network.protocol.version', n], ['network.protocol.name', t]),
      nt.browserPerformanceTimeOrigin
        ? [
            ...r,
            ['http.request.redirect_start', wn(e.redirectStart)],
            ['http.request.fetch_start', wn(e.fetchStart)],
            ['http.request.domain_lookup_start', wn(e.domainLookupStart)],
            ['http.request.domain_lookup_end', wn(e.domainLookupEnd)],
            ['http.request.connect_start', wn(e.connectStart)],
            [
              'http.request.secure_connection_start',
              wn(e.secureConnectionStart),
            ],
            ['http.request.connection_end', wn(e.connectEnd)],
            ['http.request.request_start', wn(e.requestStart)],
            ['http.request.response_start', wn(e.responseStart)],
            ['http.request.response_end', wn(e.responseEnd)],
          ]
        : r
    )
  }
  function jq(e, t) {
    return nt.stringMatchesSomePattern(e, t || sp)
  }
  function Gq(e, t, n, r) {
    if (!vi.hasTracingEnabled() || !e.fetchData) return
    let s = t(e.fetchData.url)
    if (e.endTimestamp && s) {
      let _ = e.fetchData.__span
      if (!_) return
      let f = r[_]
      if (f) {
        if (e.response) {
          f.setHttpStatus(e.response.status)
          let h =
              e.response &&
              e.response.headers &&
              e.response.headers.get('content-length'),
            y = parseInt(h)
          y > 0 && f.setData('http.response_content_length', y)
        } else e.error && f.setStatus('internal_error')
        f.finish(), delete r[_]
      }
      return
    }
    let o = vi.getCurrentHub(),
      i = o.getScope(),
      a = o.getClient(),
      c = i.getSpan(),
      { method: u, url: d } = e.fetchData,
      p =
        s && c
          ? c.startChild({
              data: { url: d, type: 'fetch', 'http.method': u },
              description: `${u} ${d}`,
              op: 'http.client',
              origin: 'auto.http.browser',
            })
          : void 0
    if (
      (p && ((e.fetchData.__span = p.spanId), (r[p.spanId] = p)),
      n(e.fetchData.url) && a)
    ) {
      let _ = e.args[0]
      e.args[1] = e.args[1] || {}
      let f = e.args[1]
      f.headers = $q(_, a, i, f, p)
    }
    return p
  }
  function $q(e, t, n, r, s) {
    let o = s || n.getSpan(),
      i = o && o.transaction,
      { traceId: a, sampled: c, dsc: u } = n.getPropagationContext(),
      d = o ? o.toTraceparent() : nt.generateSentryTraceHeader(a, void 0, c),
      p = i
        ? i.getDynamicSamplingContext()
        : u || vi.getDynamicSamplingContextFromClient(a, t, n),
      _ = nt.dynamicSamplingContextToSentryBaggageHeader(p),
      f =
        typeof Request < 'u' && nt.isInstanceOf(e, Request)
          ? e.headers
          : r.headers
    if (f)
      if (typeof Headers < 'u' && nt.isInstanceOf(f, Headers)) {
        let h = new Headers(f)
        return (
          h.append('sentry-trace', d),
          _ && h.append(nt.BAGGAGE_HEADER_NAME, _),
          h
        )
      } else if (Array.isArray(f)) {
        let h = [...f, ['sentry-trace', d]]
        return _ && h.push([nt.BAGGAGE_HEADER_NAME, _]), h
      } else {
        let h = 'baggage' in f ? f.baggage : void 0,
          y = []
        return (
          Array.isArray(h) ? y.push(...h) : h && y.push(h),
          _ && y.push(_),
          {
            ...f,
            'sentry-trace': d,
            baggage: y.length > 0 ? y.join(',') : void 0,
          }
        )
      }
    else return { 'sentry-trace': d, baggage: _ }
  }
  function zq(e, t, n, r) {
    let s = e.xhr,
      o = s && s[nt.SENTRY_XHR_DATA_KEY]
    if (!vi.hasTracingEnabled() || (s && s.__sentry_own_request__) || !s || !o)
      return
    let i = t(o.url)
    if (e.endTimestamp && i) {
      let p = s.__sentry_xhr_span_id__
      if (!p) return
      let _ = r[p]
      _ && (_.setHttpStatus(o.status_code), _.finish(), delete r[p])
      return
    }
    let a = vi.getCurrentHub(),
      c = a.getScope(),
      u = c.getSpan(),
      d =
        i && u
          ? u.startChild({
              data: {
                ...o.data,
                type: 'xhr',
                'http.method': o.method,
                url: o.url,
              },
              description: `${o.method} ${o.url}`,
              op: 'http.client',
              origin: 'auto.http.browser',
            })
          : void 0
    if (
      (d &&
        ((s.__sentry_xhr_span_id__ = d.spanId),
        (r[s.__sentry_xhr_span_id__] = d)),
      s.setRequestHeader && n(o.url))
    )
      if (d) {
        let p = d && d.transaction,
          _ = p && p.getDynamicSamplingContext(),
          f = nt.dynamicSamplingContextToSentryBaggageHeader(_)
        Fq(s, d.toTraceparent(), f)
      } else {
        let p = a.getClient(),
          { traceId: _, sampled: f, dsc: h } = c.getPropagationContext(),
          y = nt.generateSentryTraceHeader(_, void 0, f),
          E =
            h || (p ? vi.getDynamicSamplingContextFromClient(_, p, c) : void 0),
          C = nt.dynamicSamplingContextToSentryBaggageHeader(E)
        Fq(s, y, C)
      }
    return d
  }
  function Fq(e, t, n) {
    try {
      e.setRequestHeader('sentry-trace', t),
        n && e.setRequestHeader(nt.BAGGAGE_HEADER_NAME, n)
    } catch {}
  }
  In.DEFAULT_TRACE_PROPAGATION_TARGETS = sp
  In.addTracingHeadersToFetchRequest = $q
  In.defaultRequestInstrumentationOptions = Bv
  In.extractNetworkProtocol = Bq
  In.fetchCallback = Gq
  In.instrumentOutgoingRequests = hte
  In.shouldAttachHeaders = jq
  In.xhrCallback = zq
})
var Hq = l((Gv) => {
  Object.defineProperty(Gv, '__esModule', { value: !0 })
  var su = O(),
    ou = lr()
  function Ete(e, t = !0, n = !0) {
    if (!ou.WINDOW || !ou.WINDOW.location) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        su.logger.warn(
          'Could not initialize routing instrumentation due to invalid location',
        )
      return
    }
    let r = ou.WINDOW.location.href,
      s
    t &&
      (s = e({
        name: ou.WINDOW.location.pathname,
        startTimestamp: su.browserPerformanceTimeOrigin
          ? su.browserPerformanceTimeOrigin / 1e3
          : void 0,
        op: 'pageload',
        origin: 'auto.pageload.browser',
        metadata: { source: 'url' },
      })),
      n &&
        su.addInstrumentationHandler('history', ({ to: o, from: i }) => {
          if (i === void 0 && r && r.indexOf(o) !== -1) {
            r = void 0
            return
          }
          i !== o &&
            ((r = void 0),
            s &&
              ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                su.logger.log(
                  `[Tracing] Finishing current transaction with op: ${s.op}`,
                ),
              s.finish()),
            (s = e({
              name: ou.WINDOW.location.pathname,
              op: 'navigation',
              origin: 'auto.navigation.browser',
              metadata: { source: 'url' },
            })))
        })
  }
  Gv.instrumentRoutingWithDefaults = Ete
})
var Kq = l((au) => {
  Object.defineProperty(au, '__esModule', { value: !0 })
  var iu = we(),
    pr = O(),
    Ste = Cq(),
    op = Lq(),
    Yq = jv(),
    bte = Hq(),
    Vq = lr(),
    Wq = 'BrowserTracing',
    vte = {
      ...iu.TRACING_DEFAULTS,
      markBackgroundTransactions: !0,
      routingInstrumentation: bte.instrumentRoutingWithDefaults,
      startTransactionOnLocationChange: !0,
      startTransactionOnPageLoad: !0,
      enableLongTask: !0,
      _experiments: {},
      ...Yq.defaultRequestInstrumentationOptions,
    },
    $v = class {
      constructor(t) {
        ;(this.name = Wq),
          (this._hasSetTracePropagationTargets = !1),
          iu.addTracingExtensions(),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            (this._hasSetTracePropagationTargets = !!(
              t &&
              (t.tracePropagationTargets || t.tracingOrigins)
            )),
          (this.options = { ...vte, ...t }),
          this.options._experiments.enableLongTask !== void 0 &&
            (this.options.enableLongTask =
              this.options._experiments.enableLongTask),
          t &&
            !t.tracePropagationTargets &&
            t.tracingOrigins &&
            (this.options.tracePropagationTargets = t.tracingOrigins),
          (this._collectWebVitals = op.startTrackingWebVitals()),
          this.options.enableLongTask && op.startTrackingLongTasks(),
          this.options._experiments.enableInteractions &&
            op.startTrackingInteractions()
      }
      setupOnce(t, n) {
        this._getCurrentHub = n
        let s = n().getClient(),
          o = s && s.getOptions(),
          {
            routingInstrumentation: i,
            startTransactionOnLocationChange: a,
            startTransactionOnPageLoad: c,
            markBackgroundTransactions: u,
            traceFetch: d,
            traceXHR: p,
            shouldCreateSpanForRequest: _,
            enableHTTPTimings: f,
            _experiments: h,
          } = this.options,
          y = o && o.tracePropagationTargets,
          E = y || this.options.tracePropagationTargets
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          this._hasSetTracePropagationTargets &&
          y &&
          pr.logger.warn(
            '[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.',
          ),
          i(
            (C) => {
              let A = this._createRouteTransaction(C)
              return (
                this.options._experiments.onStartRouteTransaction &&
                  this.options._experiments.onStartRouteTransaction(A, C, n),
                A
              )
            },
            c,
            a,
          ),
          u && Ste.registerBackgroundTabDetection(),
          h.enableInteractions && this._registerInteractionListener(),
          Yq.instrumentOutgoingRequests({
            traceFetch: d,
            traceXHR: p,
            tracePropagationTargets: E,
            shouldCreateSpanForRequest: _,
            enableHTTPTimings: f,
          })
      }
      _createRouteTransaction(t) {
        if (!this._getCurrentHub) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            pr.logger.warn(
              `[Tracing] Did not create ${t.op} transaction because _getCurrentHub is invalid.`,
            )
          return
        }
        let n = this._getCurrentHub(),
          {
            beforeNavigate: r,
            idleTimeout: s,
            finalTimeout: o,
            heartbeatInterval: i,
          } = this.options,
          a = t.op === 'pageload',
          c = a ? zv('sentry-trace') : '',
          u = a ? zv('baggage') : '',
          {
            traceparentData: d,
            dynamicSamplingContext: p,
            propagationContext: _,
          } = pr.tracingContextFromHeaders(c, u),
          f = {
            ...t,
            ...d,
            metadata: {
              ...t.metadata,
              dynamicSamplingContext: d && !p ? {} : p,
            },
            trimEnd: !0,
          },
          h = typeof r == 'function' ? r(f) : f,
          y = h === void 0 ? { ...f, sampled: !1 } : h
        ;(y.metadata =
          y.name !== f.name ? { ...y.metadata, source: 'custom' } : y.metadata),
          (this._latestRouteName = y.name),
          (this._latestRouteSource = y.metadata && y.metadata.source),
          y.sampled === !1 &&
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            pr.logger.log(
              `[Tracing] Will not send ${y.op} transaction because of beforeNavigate.`,
            ),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            pr.logger.log(`[Tracing] Starting ${y.op} transaction on scope`)
        let { location: E } = Vq.WINDOW,
          C = iu.startIdleTransaction(n, y, s, o, !0, { location: E }, i),
          A = n.getScope()
        return (
          a && d
            ? A.setPropagationContext(_)
            : A.setPropagationContext({
                traceId: C.traceId,
                spanId: C.spanId,
                parentSpanId: C.parentSpanId,
                sampled: C.sampled,
              }),
          C.registerBeforeFinishCallback((se) => {
            this._collectWebVitals(), op.addPerformanceEntries(se)
          }),
          C
        )
      }
      _registerInteractionListener() {
        let t,
          n = () => {
            let {
                idleTimeout: r,
                finalTimeout: s,
                heartbeatInterval: o,
              } = this.options,
              i = 'ui.action.click',
              a = iu.getActiveTransaction()
            if (a && a.op && ['navigation', 'pageload'].includes(a.op)) {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                pr.logger.warn(
                  `[Tracing] Did not create ${i} transaction because a pageload or navigation transaction is in progress.`,
                )
              return
            }
            if (
              (t &&
                (t.setFinishReason('interactionInterrupted'),
                t.finish(),
                (t = void 0)),
              !this._getCurrentHub)
            ) {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                pr.logger.warn(
                  `[Tracing] Did not create ${i} transaction because _getCurrentHub is invalid.`,
                )
              return
            }
            if (!this._latestRouteName) {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                pr.logger.warn(
                  `[Tracing] Did not create ${i} transaction because _latestRouteName is missing.`,
                )
              return
            }
            let c = this._getCurrentHub(),
              { location: u } = Vq.WINDOW,
              d = {
                name: this._latestRouteName,
                op: i,
                trimEnd: !0,
                metadata: { source: this._latestRouteSource || 'url' },
              }
            t = iu.startIdleTransaction(c, d, r, s, !0, { location: u }, o)
          }
        ;['click'].forEach((r) => {
          addEventListener(r, n, { once: !1, capture: !0 })
        })
      }
    }
  function zv(e) {
    let t = pr.getDomElement(`meta[name=${e}]`)
    return t ? t.getAttribute('content') : void 0
  }
  au.BROWSER_TRACING_INTEGRATION_ID = Wq
  au.BrowserTracing = $v
  au.getMetaContent = zv
})
var Jq = l((Hv, cu) => {
  Object.defineProperty(Hv, '__esModule', { value: !0 })
  var Xq = we(),
    Ci = O()
  function Cte() {
    let e = Xq.getMainCarrier()
    if (!e.__SENTRY__) return
    let t = {
        mongodb() {
          let r = Ci.dynamicRequire(cu, './node/integrations/mongo')
          return new r.Mongo()
        },
        mongoose() {
          let r = Ci.dynamicRequire(cu, './node/integrations/mongo')
          return new r.Mongo()
        },
        mysql() {
          let r = Ci.dynamicRequire(cu, './node/integrations/mysql')
          return new r.Mysql()
        },
        pg() {
          let r = Ci.dynamicRequire(cu, './node/integrations/postgres')
          return new r.Postgres()
        },
      },
      n = Object.keys(t)
        .filter((r) => !!Ci.loadModule(r))
        .map((r) => {
          try {
            return t[r]()
          } catch {
            return
          }
        })
        .filter((r) => r)
    n.length > 0 &&
      (e.__SENTRY__.integrations = [...(e.__SENTRY__.integrations || []), ...n])
  }
  function Tte() {
    Xq.addTracingExtensions(), Ci.isNodeEnv() && Cte()
  }
  Hv.addExtensionMethods = Tte
})
var Yv = l((ge) => {
  Object.defineProperty(ge, '__esModule', { value: !0 })
  var _r = we(),
    Qq = O(),
    wte = lq(),
    Ite = mq(),
    xte = pq(),
    Pte = _q(),
    Rte = gq(),
    Dte = yq(),
    Ate = Sq(),
    Ote = bq(),
    Zq = Kq(),
    Vv = jv(),
    Nte = Jq()
  ge.IdleTransaction = _r.IdleTransaction
  ge.Span = _r.Span
  ge.SpanStatus = _r.SpanStatus
  ge.Transaction = _r.Transaction
  ge.extractTraceparentData = _r.extractTraceparentData
  ge.getActiveTransaction = _r.getActiveTransaction
  ge.hasTracingEnabled = _r.hasTracingEnabled
  ge.spanStatusfromHttpCode = _r.spanStatusfromHttpCode
  ge.startIdleTransaction = _r.startIdleTransaction
  ge.TRACEPARENT_REGEXP = Qq.TRACEPARENT_REGEXP
  ge.stripUrlQueryAndFragment = Qq.stripUrlQueryAndFragment
  ge.Express = wte.Express
  ge.Postgres = Ite.Postgres
  ge.Mysql = xte.Mysql
  ge.Mongo = Pte.Mongo
  ge.Prisma = Rte.Prisma
  ge.GraphQL = Dte.GraphQL
  ge.Apollo = Ate.Apollo
  ge.lazyLoadedNodePerformanceMonitoringIntegrations =
    Ote.lazyLoadedNodePerformanceMonitoringIntegrations
  ge.BROWSER_TRACING_INTEGRATION_ID = Zq.BROWSER_TRACING_INTEGRATION_ID
  ge.BrowserTracing = Zq.BrowserTracing
  ge.addTracingHeadersToFetchRequest = Vv.addTracingHeadersToFetchRequest
  ge.defaultRequestInstrumentationOptions =
    Vv.defaultRequestInstrumentationOptions
  ge.instrumentOutgoingRequests = Vv.instrumentOutgoingRequests
  ge.addExtensionMethods = Nte.addExtensionMethods
})
var e1 = l((Wv) => {
  Object.defineProperty(Wv, '__esModule', { value: !0 })
  var qte = Yv(),
    kte = O()
  function Mte() {
    let e = qte.lazyLoadedNodePerformanceMonitoringIntegrations
      .map((t) => {
        try {
          return t()
        } catch {
          return
        }
      })
      .filter((t) => !!t)
    return (
      e.length === 0 &&
        kte.logger.warn(
          'Performance monitoring integrations could not be automatically loaded.',
        ),
      e.filter((t) => !!t.loadDependency())
    )
  }
  Wv.autoDiscoverNodePerformanceMonitoringIntegrations = Mte
})
var Qv = l((Jv) => {
  Object.defineProperty(Jv, '__esModule', { value: !0 })
  var Kv = we(),
    Lte = require('os'),
    Ute = require('util'),
    Xv = class extends Kv.ServerRuntimeClient {
      constructor(t) {
        ;(t._metadata = t._metadata || {}),
          (t._metadata.sdk = t._metadata.sdk || {
            name: 'sentry.javascript.node',
            packages: [{ name: 'npm:@sentry/node', version: Kv.SDK_VERSION }],
            version: Kv.SDK_VERSION,
          }),
          (t.transportOptions = {
            textEncoder: new Ute.TextEncoder(),
            ...t.transportOptions,
          })
        let n = {
          ...t,
          platform: 'node',
          runtime: { name: 'node', version: global.process.version },
          serverName:
            t.serverName || global.process.env.SENTRY_NAME || Lte.hostname(),
        }
        super(n)
      }
    }
  Jv.NodeClient = Xv
})
var n1 = l((iFe, t1) => {
  var Ti = 1e3,
    wi = Ti * 60,
    Ii = wi * 60,
    lo = Ii * 24,
    Fte = lo * 7,
    Bte = lo * 365.25
  t1.exports = function (e, t) {
    t = t || {}
    var n = typeof e
    if (n === 'string' && e.length > 0) return jte(e)
    if (n === 'number' && isFinite(e)) return t.long ? $te(e) : Gte(e)
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(e),
    )
  }
  function jte(e) {
    if (((e = String(e)), !(e.length > 100))) {
      var t =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          e,
        )
      if (t) {
        var n = parseFloat(t[1]),
          r = (t[2] || 'ms').toLowerCase()
        switch (r) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * Bte
          case 'weeks':
          case 'week':
          case 'w':
            return n * Fte
          case 'days':
          case 'day':
          case 'd':
            return n * lo
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * Ii
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * wi
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * Ti
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n
          default:
            return
        }
      }
    }
  }
  function Gte(e) {
    var t = Math.abs(e)
    return t >= lo
      ? Math.round(e / lo) + 'd'
      : t >= Ii
        ? Math.round(e / Ii) + 'h'
        : t >= wi
          ? Math.round(e / wi) + 'm'
          : t >= Ti
            ? Math.round(e / Ti) + 's'
            : e + 'ms'
  }
  function $te(e) {
    var t = Math.abs(e)
    return t >= lo
      ? ip(e, t, lo, 'day')
      : t >= Ii
        ? ip(e, t, Ii, 'hour')
        : t >= wi
          ? ip(e, t, wi, 'minute')
          : t >= Ti
            ? ip(e, t, Ti, 'second')
            : e + ' ms'
  }
  function ip(e, t, n, r) {
    var s = t >= n * 1.5
    return Math.round(e / n) + ' ' + r + (s ? 's' : '')
  }
})
var Zv = l((aFe, r1) => {
  function zte(e) {
    ;(n.debug = n),
      (n.default = n),
      (n.coerce = c),
      (n.disable = o),
      (n.enable = s),
      (n.enabled = i),
      (n.humanize = n1()),
      (n.destroy = u),
      Object.keys(e).forEach((d) => {
        n[d] = e[d]
      }),
      (n.names = []),
      (n.skips = []),
      (n.formatters = {})
    function t(d) {
      let p = 0
      for (let _ = 0; _ < d.length; _++)
        (p = (p << 5) - p + d.charCodeAt(_)), (p |= 0)
      return n.colors[Math.abs(p) % n.colors.length]
    }
    n.selectColor = t
    function n(d) {
      let p,
        _ = null,
        f,
        h
      function y(...E) {
        if (!y.enabled) return
        let C = y,
          A = Number(new Date()),
          se = A - (p || A)
        ;(C.diff = se),
          (C.prev = p),
          (C.curr = A),
          (p = A),
          (E[0] = n.coerce(E[0])),
          typeof E[0] != 'string' && E.unshift('%O')
        let Q = 0
        ;(E[0] = E[0].replace(/%([a-zA-Z%])/g, (ee, Ae) => {
          if (ee === '%%') return '%'
          Q++
          let Et = n.formatters[Ae]
          if (typeof Et == 'function') {
            let Xs = E[Q]
            ;(ee = Et.call(C, Xs)), E.splice(Q, 1), Q--
          }
          return ee
        })),
          n.formatArgs.call(C, E),
          (C.log || n.log).apply(C, E)
      }
      return (
        (y.namespace = d),
        (y.useColors = n.useColors()),
        (y.color = n.selectColor(d)),
        (y.extend = r),
        (y.destroy = n.destroy),
        Object.defineProperty(y, 'enabled', {
          enumerable: !0,
          configurable: !1,
          get: () =>
            _ !== null
              ? _
              : (f !== n.namespaces && ((f = n.namespaces), (h = n.enabled(d))),
                h),
          set: (E) => {
            _ = E
          },
        }),
        typeof n.init == 'function' && n.init(y),
        y
      )
    }
    function r(d, p) {
      let _ = n(this.namespace + (typeof p > 'u' ? ':' : p) + d)
      return (_.log = this.log), _
    }
    function s(d) {
      n.save(d), (n.namespaces = d), (n.names = []), (n.skips = [])
      let p,
        _ = (typeof d == 'string' ? d : '').split(/[\s,]+/),
        f = _.length
      for (p = 0; p < f; p++)
        _[p] &&
          ((d = _[p].replace(/\*/g, '.*?')),
          d[0] === '-'
            ? n.skips.push(new RegExp('^' + d.slice(1) + '$'))
            : n.names.push(new RegExp('^' + d + '$')))
    }
    function o() {
      let d = [...n.names.map(a), ...n.skips.map(a).map((p) => '-' + p)].join(
        ',',
      )
      return n.enable(''), d
    }
    function i(d) {
      if (d[d.length - 1] === '*') return !0
      let p, _
      for (p = 0, _ = n.skips.length; p < _; p++)
        if (n.skips[p].test(d)) return !1
      for (p = 0, _ = n.names.length; p < _; p++)
        if (n.names[p].test(d)) return !0
      return !1
    }
    function a(d) {
      return d
        .toString()
        .substring(2, d.toString().length - 2)
        .replace(/\.\*\?$/, '*')
    }
    function c(d) {
      return d instanceof Error ? d.stack || d.message : d
    }
    function u() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
      )
    }
    return n.enable(n.load()), n
  }
  r1.exports = zte
})
var s1 = l((vt, ap) => {
  vt.formatArgs = Vte
  vt.save = Yte
  vt.load = Wte
  vt.useColors = Hte
  vt.storage = Kte()
  vt.destroy = (() => {
    let e = !1
    return () => {
      e ||
        ((e = !0),
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
        ))
    }
  })()
  vt.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33',
  ]
  function Hte() {
    return typeof window < 'u' &&
      window.process &&
      (window.process.type === 'renderer' || window.process.__nwjs)
      ? !0
      : typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ? !1
        : (typeof document < 'u' &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          (typeof window < 'u' &&
            window.console &&
            (window.console.firebug ||
              (window.console.exception && window.console.table))) ||
          (typeof navigator < 'u' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
            parseInt(RegExp.$1, 10) >= 31) ||
          (typeof navigator < 'u' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
  }
  function Vte(e) {
    if (
      ((e[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        e[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        ap.exports.humanize(this.diff)),
      !this.useColors)
    )
      return
    let t = 'color: ' + this.color
    e.splice(1, 0, t, 'color: inherit')
    let n = 0,
      r = 0
    e[0].replace(/%[a-zA-Z%]/g, (s) => {
      s !== '%%' && (n++, s === '%c' && (r = n))
    }),
      e.splice(r, 0, t)
  }
  vt.log = console.debug || console.log || (() => {})
  function Yte(e) {
    try {
      e ? vt.storage.setItem('debug', e) : vt.storage.removeItem('debug')
    } catch {}
  }
  function Wte() {
    let e
    try {
      e = vt.storage.getItem('debug')
    } catch {}
    return (
      !e && typeof process < 'u' && 'env' in process && (e = process.env.DEBUG),
      e
    )
  }
  function Kte() {
    try {
      return localStorage
    } catch {}
  }
  ap.exports = Zv()(vt)
  var { formatters: Xte } = ap.exports
  Xte.j = function (e) {
    try {
      return JSON.stringify(e)
    } catch (t) {
      return '[UnexpectedJSONParseError]: ' + t.message
    }
  }
})
var i1 = l((cFe, o1) => {
  'use strict'
  o1.exports = (e, t = process.argv) => {
    let n = e.startsWith('-') ? '' : e.length === 1 ? '-' : '--',
      r = t.indexOf(n + e),
      s = t.indexOf('--')
    return r !== -1 && (s === -1 || r < s)
  }
})
var d1 = l((dFe, c1) => {
  'use strict'
  var Jte = require('os'),
    a1 = require('tty'),
    zt = i1(),
    { env: Ge } = process,
    Qr
  zt('no-color') || zt('no-colors') || zt('color=false') || zt('color=never')
    ? (Qr = 0)
    : (zt('color') || zt('colors') || zt('color=true') || zt('color=always')) &&
      (Qr = 1)
  'FORCE_COLOR' in Ge &&
    (Ge.FORCE_COLOR === 'true'
      ? (Qr = 1)
      : Ge.FORCE_COLOR === 'false'
        ? (Qr = 0)
        : (Qr =
            Ge.FORCE_COLOR.length === 0
              ? 1
              : Math.min(parseInt(Ge.FORCE_COLOR, 10), 3)))
  function eC(e) {
    return e === 0
      ? !1
      : { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }
  }
  function tC(e, t) {
    if (Qr === 0) return 0
    if (zt('color=16m') || zt('color=full') || zt('color=truecolor')) return 3
    if (zt('color=256')) return 2
    if (e && !t && Qr === void 0) return 0
    let n = Qr || 0
    if (Ge.TERM === 'dumb') return n
    if (process.platform === 'win32') {
      let r = Jte.release().split('.')
      return Number(r[0]) >= 10 && Number(r[2]) >= 10586
        ? Number(r[2]) >= 14931
          ? 3
          : 2
        : 1
    }
    if ('CI' in Ge)
      return [
        'TRAVIS',
        'CIRCLECI',
        'APPVEYOR',
        'GITLAB_CI',
        'GITHUB_ACTIONS',
        'BUILDKITE',
      ].some((r) => r in Ge) || Ge.CI_NAME === 'codeship'
        ? 1
        : n
    if ('TEAMCITY_VERSION' in Ge)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ge.TEAMCITY_VERSION) ? 1 : 0
    if (Ge.COLORTERM === 'truecolor') return 3
    if ('TERM_PROGRAM' in Ge) {
      let r = parseInt((Ge.TERM_PROGRAM_VERSION || '').split('.')[0], 10)
      switch (Ge.TERM_PROGRAM) {
        case 'iTerm.app':
          return r >= 3 ? 3 : 2
        case 'Apple_Terminal':
          return 2
      }
    }
    return /-256(color)?$/i.test(Ge.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            Ge.TERM,
          ) || 'COLORTERM' in Ge
        ? 1
        : n
  }
  function Qte(e) {
    let t = tC(e, e && e.isTTY)
    return eC(t)
  }
  c1.exports = {
    supportsColor: Qte,
    stdout: eC(tC(!0, a1.isatty(1))),
    stderr: eC(tC(!0, a1.isatty(2))),
  }
})
var l1 = l((Ke, dp) => {
  var Zte = require('tty'),
    cp = require('util')
  Ke.init = ine
  Ke.log = rne
  Ke.formatArgs = tne
  Ke.save = sne
  Ke.load = one
  Ke.useColors = ene
  Ke.destroy = cp.deprecate(
    () => {},
    'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
  )
  Ke.colors = [6, 2, 3, 4, 5, 1]
  try {
    let e = d1()
    e &&
      (e.stderr || e).level >= 2 &&
      (Ke.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,
        68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,
        129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
      ])
  } catch {}
  Ke.inspectOpts = Object.keys(process.env)
    .filter((e) => /^debug_/i.test(e))
    .reduce((e, t) => {
      let n = t
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (s, o) => o.toUpperCase()),
        r = process.env[t]
      return (
        /^(yes|on|true|enabled)$/i.test(r)
          ? (r = !0)
          : /^(no|off|false|disabled)$/i.test(r)
            ? (r = !1)
            : r === 'null'
              ? (r = null)
              : (r = Number(r)),
        (e[n] = r),
        e
      )
    }, {})
  function ene() {
    return 'colors' in Ke.inspectOpts
      ? !!Ke.inspectOpts.colors
      : Zte.isatty(process.stderr.fd)
  }
  function tne(e) {
    let { namespace: t, useColors: n } = this
    if (n) {
      let r = this.color,
        s = '\x1B[3' + (r < 8 ? r : '8;5;' + r),
        o = `  ${s};1m${t} \x1B[0m`
      ;(e[0] =
        o +
        e[0]
          .split(
            `
`,
          )
          .join(
            `
` + o,
          )),
        e.push(s + 'm+' + dp.exports.humanize(this.diff) + '\x1B[0m')
    } else e[0] = nne() + t + ' ' + e[0]
  }
  function nne() {
    return Ke.inspectOpts.hideDate ? '' : new Date().toISOString() + ' '
  }
  function rne(...e) {
    return process.stderr.write(
      cp.format(...e) +
        `
`,
    )
  }
  function sne(e) {
    e ? (process.env.DEBUG = e) : delete process.env.DEBUG
  }
  function one() {
    return process.env.DEBUG
  }
  function ine(e) {
    e.inspectOpts = {}
    let t = Object.keys(Ke.inspectOpts)
    for (let n = 0; n < t.length; n++)
      e.inspectOpts[t[n]] = Ke.inspectOpts[t[n]]
  }
  dp.exports = Zv()(Ke)
  var { formatters: u1 } = dp.exports
  u1.o = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      cp
        .inspect(e, this.inspectOpts)
        .split(
          `
`,
        )
        .map((t) => t.trim())
        .join(' ')
    )
  }
  u1.O = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      cp.inspect(e, this.inspectOpts)
    )
  }
})
var up = l((uFe, nC) => {
  typeof process > 'u' ||
  process.type === 'renderer' ||
  process.browser === !0 ||
  process.__nwjs
    ? (nC.exports = s1())
    : (nC.exports = l1())
})
var m1 = l((rC) => {
  'use strict'
  Object.defineProperty(rC, '__esModule', { value: !0 })
  function ane(e) {
    return function (t, n) {
      return new Promise((r, s) => {
        e.call(this, t, n, (o, i) => {
          o ? s(o) : r(i)
        })
      })
    }
  }
  rC.default = ane
})
var f1 = l((oC, _1) => {
  'use strict'
  var p1 =
      (oC && oC.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e }
      },
    cne = require('events'),
    dne = p1(up()),
    une = p1(m1()),
    du = dne.default('agent-base')
  function lne(e) {
    return !!e && typeof e.addRequest == 'function'
  }
  function sC() {
    let { stack: e } = new Error()
    return typeof e != 'string'
      ? !1
      : e
          .split(
            `
`,
          )
          .some(
            (t) =>
              t.indexOf('(https.js:') !== -1 || t.indexOf('node:https:') !== -1,
          )
  }
  function lp(e, t) {
    return new lp.Agent(e, t)
  }
  ;(function (e) {
    class t extends cne.EventEmitter {
      constructor(r, s) {
        super()
        let o = s
        typeof r == 'function' ? (this.callback = r) : r && (o = r),
          (this.timeout = null),
          o && typeof o.timeout == 'number' && (this.timeout = o.timeout),
          (this.maxFreeSockets = 1),
          (this.maxSockets = 1),
          (this.maxTotalSockets = 1 / 0),
          (this.sockets = {}),
          (this.freeSockets = {}),
          (this.requests = {}),
          (this.options = {})
      }
      get defaultPort() {
        return typeof this.explicitDefaultPort == 'number'
          ? this.explicitDefaultPort
          : sC()
            ? 443
            : 80
      }
      set defaultPort(r) {
        this.explicitDefaultPort = r
      }
      get protocol() {
        return typeof this.explicitProtocol == 'string'
          ? this.explicitProtocol
          : sC()
            ? 'https:'
            : 'http:'
      }
      set protocol(r) {
        this.explicitProtocol = r
      }
      callback(r, s, o) {
        throw new Error(
          '"agent-base" has no default implementation, you must subclass and override `callback()`',
        )
      }
      addRequest(r, s) {
        let o = Object.assign({}, s)
        typeof o.secureEndpoint != 'boolean' && (o.secureEndpoint = sC()),
          o.host == null && (o.host = 'localhost'),
          o.port == null && (o.port = o.secureEndpoint ? 443 : 80),
          o.protocol == null &&
            (o.protocol = o.secureEndpoint ? 'https:' : 'http:'),
          o.host && o.path && delete o.path,
          delete o.agent,
          delete o.hostname,
          delete o._defaultAgent,
          delete o.defaultPort,
          delete o.createConnection,
          (r._last = !0),
          (r.shouldKeepAlive = !1)
        let i = !1,
          a = null,
          c = o.timeout || this.timeout,
          u = (f) => {
            r._hadError || (r.emit('error', f), (r._hadError = !0))
          },
          d = () => {
            ;(a = null), (i = !0)
            let f = new Error(
              `A "socket" was not created for HTTP request before ${c}ms`,
            )
            ;(f.code = 'ETIMEOUT'), u(f)
          },
          p = (f) => {
            i || (a !== null && (clearTimeout(a), (a = null)), u(f))
          },
          _ = (f) => {
            if (i) return
            if ((a != null && (clearTimeout(a), (a = null)), lne(f))) {
              du(
                'Callback returned another Agent instance %o',
                f.constructor.name,
              ),
                f.addRequest(r, o)
              return
            }
            if (f) {
              f.once('free', () => {
                this.freeSocket(f, o)
              }),
                r.onSocket(f)
              return
            }
            let h = new Error(
              `no Duplex stream was returned to agent-base for \`${r.method} ${r.path}\``,
            )
            u(h)
          }
        if (typeof this.callback != 'function') {
          u(new Error('`callback` is not defined'))
          return
        }
        this.promisifiedCallback ||
          (this.callback.length >= 3
            ? (du('Converting legacy callback function to promise'),
              (this.promisifiedCallback = une.default(this.callback)))
            : (this.promisifiedCallback = this.callback)),
          typeof c == 'number' && c > 0 && (a = setTimeout(d, c)),
          'port' in o && typeof o.port != 'number' && (o.port = Number(o.port))
        try {
          du(
            'Resolving socket for %o request: %o',
            o.protocol,
            `${r.method} ${r.path}`,
          ),
            Promise.resolve(this.promisifiedCallback(r, o)).then(_, p)
        } catch (f) {
          Promise.reject(f).catch(p)
        }
      }
      freeSocket(r, s) {
        du('Freeing socket %o %o', r.constructor.name, s), r.destroy()
      }
      destroy() {
        du('Destroying agent %o', this.constructor.name)
      }
    }
    ;(e.Agent = t), (e.prototype = e.Agent.prototype)
  })(lp || (lp = {}))
  _1.exports = lp
})
var h1 = l((lu) => {
  'use strict'
  var mne =
    (lu && lu.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e }
    }
  Object.defineProperty(lu, '__esModule', { value: !0 })
  var pne = mne(up()),
    uu = pne.default('https-proxy-agent:parse-proxy-response')
  function _ne(e) {
    return new Promise((t, n) => {
      let r = 0,
        s = []
      function o() {
        let p = e.read()
        p ? d(p) : e.once('readable', o)
      }
      function i() {
        e.removeListener('end', c),
          e.removeListener('error', u),
          e.removeListener('close', a),
          e.removeListener('readable', o)
      }
      function a(p) {
        uu('onclose had error %o', p)
      }
      function c() {
        uu('onend')
      }
      function u(p) {
        i(), uu('onerror %o', p), n(p)
      }
      function d(p) {
        s.push(p), (r += p.length)
        let _ = Buffer.concat(s, r)
        if (
          _.indexOf(`\r
\r
`) === -1
        ) {
          uu('have not received end of HTTP headers yet...'), o()
          return
        }
        let h = _.toString(
            'ascii',
            0,
            _.indexOf(`\r
`),
          ),
          y = +h.split(' ')[1]
        uu('got proxy server response: %o', h),
          t({ statusCode: y, buffered: _ })
      }
      e.on('error', u), e.on('close', a), e.on('end', c), o()
    })
  }
  lu.default = _ne
})
var E1 = l((mo) => {
  'use strict'
  var fne =
      (mo && mo.__awaiter) ||
      function (e, t, n, r) {
        function s(o) {
          return o instanceof n
            ? o
            : new n(function (i) {
                i(o)
              })
        }
        return new (n || (n = Promise))(function (o, i) {
          function a(d) {
            try {
              u(r.next(d))
            } catch (p) {
              i(p)
            }
          }
          function c(d) {
            try {
              u(r.throw(d))
            } catch (p) {
              i(p)
            }
          }
          function u(d) {
            d.done ? o(d.value) : s(d.value).then(a, c)
          }
          u((r = r.apply(e, t || [])).next())
        })
      },
    xi =
      (mo && mo.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e }
      }
  Object.defineProperty(mo, '__esModule', { value: !0 })
  var g1 = xi(require('net')),
    y1 = xi(require('tls')),
    hne = xi(require('url')),
    gne = xi(require('assert')),
    yne = xi(up()),
    Ene = f1(),
    Sne = xi(h1()),
    mu = yne.default('https-proxy-agent:agent'),
    iC = class extends Ene.Agent {
      constructor(t) {
        let n
        if ((typeof t == 'string' ? (n = hne.default.parse(t)) : (n = t), !n))
          throw new Error(
            'an HTTP(S) proxy server `host` and `port` must be specified!',
          )
        mu('creating new HttpsProxyAgent instance: %o', n), super(n)
        let r = Object.assign({}, n)
        ;(this.secureProxy = n.secureProxy || Cne(r.protocol)),
          (r.host = r.hostname || r.host),
          typeof r.port == 'string' && (r.port = parseInt(r.port, 10)),
          !r.port && r.host && (r.port = this.secureProxy ? 443 : 80),
          this.secureProxy &&
            !('ALPNProtocols' in r) &&
            (r.ALPNProtocols = ['http 1.1']),
          r.host && r.path && (delete r.path, delete r.pathname),
          (this.proxy = r)
      }
      callback(t, n) {
        return fne(this, void 0, void 0, function* () {
          let { proxy: r, secureProxy: s } = this,
            o
          s
            ? (mu('Creating `tls.Socket`: %o', r), (o = y1.default.connect(r)))
            : (mu('Creating `net.Socket`: %o', r), (o = g1.default.connect(r)))
          let i = Object.assign({}, r.headers),
            c = `CONNECT ${`${n.host}:${n.port}`} HTTP/1.1\r
`
          r.auth &&
            (i['Proxy-Authorization'] = `Basic ${Buffer.from(r.auth).toString(
              'base64',
            )}`)
          let { host: u, port: d, secureEndpoint: p } = n
          vne(d, p) || (u += `:${d}`), (i.Host = u), (i.Connection = 'close')
          for (let E of Object.keys(i))
            c += `${E}: ${i[E]}\r
`
          let _ = Sne.default(o)
          o.write(`${c}\r
`)
          let { statusCode: f, buffered: h } = yield _
          if (f === 200) {
            if ((t.once('socket', bne), n.secureEndpoint)) {
              mu('Upgrading socket connection to TLS')
              let E = n.servername || n.host
              return y1.default.connect(
                Object.assign(
                  Object.assign({}, Tne(n, 'host', 'hostname', 'path', 'port')),
                  { socket: o, servername: E },
                ),
              )
            }
            return o
          }
          o.destroy()
          let y = new g1.default.Socket({ writable: !1 })
          return (
            (y.readable = !0),
            t.once('socket', (E) => {
              mu('replaying proxy buffer for failed request'),
                gne.default(E.listenerCount('data') > 0),
                E.push(h),
                E.push(null)
            }),
            y
          )
        })
      }
    }
  mo.default = iC
  function bne(e) {
    e.resume()
  }
  function vne(e, t) {
    return !!((!t && e === 80) || (t && e === 443))
  }
  function Cne(e) {
    return typeof e == 'string' ? /^https:?$/i.test(e) : !1
  }
  function Tne(e, ...t) {
    let n = {},
      r
    for (r in e) t.includes(r) || (n[r] = e[r])
    return n
  }
})
var b1 = l((dC, S1) => {
  'use strict'
  var wne =
      (dC && dC.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e }
      },
    aC = wne(E1())
  function cC(e) {
    return new aC.default(e)
  }
  ;(function (e) {
    ;(e.HttpsProxyAgent = aC.default), (e.prototype = aC.default.prototype)
  })(cC || (cC = {}))
  S1.exports = cC
})
var mC = l((lC) => {
  var { _nullishCoalesce: uC } = Se()
  Object.defineProperty(lC, '__esModule', { value: !0 })
  var v1 = we(),
    Ine = require('http'),
    xne = require('https'),
    Pne = b1(),
    Rne = require('stream'),
    C1 = require('url'),
    Dne = require('zlib'),
    Ane = 1024 * 32
  function One(e) {
    return new Rne.Readable({
      read() {
        this.push(e), this.push(null)
      },
    })
  }
  function Nne(e) {
    let t
    try {
      t = new C1.URL(e.url)
    } catch {
      return (
        console.warn(
          '[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.',
        ),
        v1.createTransport(e, () => Promise.resolve({}))
      )
    }
    let n = t.protocol === 'https:',
      r = qne(
        t,
        e.proxy ||
          (n ? process.env.https_proxy : void 0) ||
          process.env.http_proxy,
      ),
      s = n ? xne : Ine,
      o = e.keepAlive === void 0 ? !1 : e.keepAlive,
      i = r
        ? new Pne.HttpsProxyAgent(r)
        : new s.Agent({ keepAlive: o, maxSockets: 30, timeout: 2e3 }),
      a = kne(
        e,
        uC(e.httpModule, () => s),
        i,
      )
    return v1.createTransport(e, a)
  }
  function qne(e, t) {
    let { no_proxy: n } = process.env
    if (
      !(
        n &&
        n.split(',').some((s) => e.host.endsWith(s) || e.hostname.endsWith(s))
      )
    )
      return t
  }
  function kne(e, t, n) {
    let {
      hostname: r,
      pathname: s,
      port: o,
      protocol: i,
      search: a,
    } = new C1.URL(e.url)
    return function (u) {
      return new Promise((d, p) => {
        let _ = One(u.body),
          f = { ...e.headers }
        u.body.length > Ane &&
          ((f['content-encoding'] = 'gzip'), (_ = _.pipe(Dne.createGzip())))
        let h = t.request(
          {
            method: 'POST',
            agent: n,
            headers: f,
            hostname: r,
            path: `${s}${a}`,
            port: o,
            protocol: i,
            ca: e.caCerts,
          },
          (y) => {
            y.on('data', () => {}), y.on('end', () => {}), y.setEncoding('utf8')
            let E = uC(y.headers['retry-after'], () => null),
              C = uC(y.headers['x-sentry-rate-limits'], () => null)
            d({
              statusCode: y.statusCode,
              headers: {
                'retry-after': E,
                'x-sentry-rate-limits': Array.isArray(C) ? C[0] : C,
              },
            })
          },
        )
        h.on('error', p), _.pipe(h)
      })
    }
  }
  lC.makeNodeTransport = Nne
})
var mp = l((pC) => {
  Object.defineProperty(pC, '__esModule', { value: !0 })
  var T1 = require('path'),
    Mne = T1.sep === '\\'
  function Lne(e) {
    return e.replace(/^[A-Z]:/, '').replace(/\\/g, '/')
  }
  function Une(e, t = Mne) {
    if (!e) return
    let n = t ? Lne(e) : e,
      { root: r, dir: s, base: o, ext: i } = T1.posix.parse(n),
      c = `${
        (require && require.main && require.main.filename && s) ||
        global.process.cwd()
      }/`,
      u = o
    ;(i === '.js' || i === '.mjs' || i === '.cjs') &&
      (u = u.slice(0, i.length * -1)),
      !r && !s && (s = '.')
    let d = s.lastIndexOf('/node_modules/')
    if (d > -1) return `${s.slice(d + 14).replace(/\//g, '.')}:${u}`
    if (((d = `${s}/`.lastIndexOf(c, 0)), d === 0)) {
      let p = s.slice(c.length).replace(/\//g, '.')
      return p && (p += ':'), (p += u), p
    }
    return u
  }
  pC.getModuleFromFilename = Une
})
var I1 = l((gC) => {
  Object.defineProperty(gC, '__esModule', { value: !0 })
  var hC = require('crypto'),
    Fne = require('events'),
    Bne = require('http'),
    jne = require('url'),
    pp = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      TERMINATE: 8,
      PING: 9,
      PONG: 10,
    },
    Gne = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
  function w1(e) {
    return Buffer.byteLength(e.payload) >= e.payloadLength
  }
  function _C(e, t, n) {
    if (t === void 0) return e
    for (let r = 0; r < e.length; r++) e[r] ^= t[(n + r) & 3]
    return e
  }
  function $ne(e) {
    let { opcode: t, fin: n, data: r } = e,
      s = 6,
      o = r.length
    o >= 65536 ? ((s += 8), (o = 127)) : o > 125 && ((s += 2), (o = 126))
    let i = Buffer.allocUnsafe(s)
    ;(i[0] = n ? t | 128 : t),
      (i[1] = o),
      o === 126
        ? i.writeUInt16BE(r.length, 2)
        : o === 127 && (i.writeUInt32BE(0, 2), i.writeUInt32BE(r.length, 6))
    let a = hC.randomBytes(4)
    ;(i[1] |= 128),
      (i[s - 4] = a[0]),
      (i[s - 3] = a[1]),
      (i[s - 2] = a[2]),
      (i[s - 1] = a[3])
    let c = Buffer.alloc(o)
    for (let u = 0; u < o; ++u) c[u] = r[u] ^ a[u & 3]
    return Buffer.concat([i, c])
  }
  function zne(e) {
    let t = e.readUInt8(0),
      n = !!((t >>> 7) & 1),
      r = t & 15,
      s = e.readUInt8(1),
      o = !!((s >>> 7) & 1),
      i = 2,
      a = s & 127
    if (a > 125)
      if (a === 126) (a = e.readUInt16BE(i)), (i += 2)
      else if (a === 127) {
        let d = e.readUInt32BE(i)
        if (((i += 4), d >= Number.MAX_SAFE_INTEGER))
          throw new Error(
            'Unsupported WebSocket frame: payload length > 2^53 - 1',
          )
        let p = e.readUInt32BE(i)
        ;(i += 4), (a = d * Math.pow(2, 32) + p)
      } else throw new Error('Unknown payload length')
    let c
    o && ((c = e.slice(i, i + 4)), (i += 4))
    let u = _C(e.slice(i), c, 0)
    return { fin: n, opcode: r, mask: c, payload: u, payloadLength: a }
  }
  function Hne(e) {
    return hC.createHash('sha1').update(`${e}${Gne}`).digest('base64')
  }
  var fC = class extends Fne.EventEmitter {
    constructor(t) {
      super(),
        (this._unfinishedFrame = void 0),
        (this._incompleteFrame = void 0),
        (this._socket = t),
        (this._alive = !0),
        t.on('data', (n) => {
          this._addBuffer(n)
        }),
        t.on('error', (n) => {
          n.code === 'ECONNRESET' ? this.emit('close') : this.emit('error')
        }),
        t.on('close', () => {
          this.end()
        })
    }
    end() {
      this._alive &&
        ((this._alive = !1), this.emit('close'), this._socket.end())
    }
    send(t) {
      this._sendFrame({ opcode: pp.TEXT, fin: !0, data: Buffer.from(t) })
    }
    _sendFrame(t) {
      this._socket.write($ne(t))
    }
    _completeFrame(t) {
      let { _unfinishedFrame: n } = this
      if (n !== void 0)
        if (t.opcode === pp.CONTINUATION) {
          ;(n.payload = Buffer.concat([
            n.payload,
            _C(t.payload, n.mask, n.payload.length),
          ])),
            t.fin && ((this._unfinishedFrame = void 0), this._completeFrame(n))
          return
        } else this._unfinishedFrame = void 0
      if (t.fin)
        if (t.opcode === pp.PING)
          this._sendFrame({ opcode: pp.PONG, fin: !0, data: t.payload })
        else {
          let r
          t.payload.length > t.payloadLength &&
            ((r = t.payload.slice(t.payloadLength)),
            (t.payload = t.payload.slice(0, t.payloadLength))),
            this.emit('message', t.payload),
            r !== void 0 && this._addBuffer(r)
        }
      else this._unfinishedFrame = t
    }
    _addBufferToIncompleteFrame(t, n) {
      ;(t.payload = Buffer.concat([
        t.payload,
        _C(n, t.mask, t.payload.length),
      ])),
        w1(t) && ((this._incompleteFrame = void 0), this._completeFrame(t))
    }
    _addBuffer(t) {
      let { _incompleteFrame: n } = this
      if (n !== void 0) {
        this._addBufferToIncompleteFrame(n, t)
        return
      }
      let r = zne(t)
      w1(r) ? this._completeFrame(r) : (this._incompleteFrame = r)
    }
  }
  async function Vne(e) {
    let t = jne.parse(e)
    return new Promise((n, r) => {
      let s = hC.randomBytes(16).toString('base64'),
        o = Hne(s),
        i = Bne.request({
          hostname: t.hostname,
          port: t.port,
          path: t.path,
          method: 'GET',
          headers: {
            Connection: 'Upgrade',
            Upgrade: 'websocket',
            'Sec-WebSocket-Key': s,
            'Sec-WebSocket-Version': '13',
          },
        })
      i.on('response', (a) => {
        a.statusCode &&
          a.statusCode >= 400 &&
          process.stderr.write(`Unexpected HTTP code: ${a.statusCode}
`),
          a.pipe(process.stderr)
      }),
        i.on('upgrade', (a, c) => {
          if (a.headers['sec-websocket-accept'] !== o) {
            c.end(),
              r(
                new Error(
                  `Digest mismatch ${o} !== ${a.headers['sec-websocket-accept']}`,
                ),
              )
            return
          }
          let u = new fC(c)
          n(u)
        }),
        i.on('error', (a) => {
          r(a)
        }),
        i.end()
    })
  }
  gC.createWebSocketClient = Vne
})
var x1 = l((yC) => {
  Object.defineProperty(yC, '__esModule', { value: !0 })
  var Yne = O(),
    Wne = mp(),
    Kne = I1()
  async function Xne(e, t) {
    let n = 0,
      r = await Kne.createWebSocketClient(e)
    return (
      r.on('message', (s) => {
        let o = JSON.parse(s.toString())
        t(o)
      }),
      (s) => {
        r.send(JSON.stringify({ id: n++, method: s }))
      }
    )
  }
  async function Jne(e, t) {
    let n = await Xne(
      e,
      Yne.createDebugPauseMessageHandler(
        (r) => n(r),
        Wne.getModuleFromFilename,
        t,
      ),
    )
    return () => {
      n('Debugger.enable'), n('Debugger.pause')
    }
  }
  yC.captureStackTrace = Jne
})
var SC = l((fp) => {
  Object.defineProperty(fp, '__esModule', { value: !0 })
  var _p = O(),
    Qne = require('child_process'),
    Zne = x1(),
    EC = we(),
    ere = 50,
    tre = 5e3
  function P1(e, t) {
    let n = {
      level: 'error',
      exception: {
        values: [
          {
            type: 'ApplicationNotResponding',
            value: `Application Not Responding for at least ${e} ms`,
            stacktrace: { frames: t },
            mechanism: { type: 'ANR' },
          },
        ],
      },
    }
    EC.captureEvent(n),
      EC.flush(3e3).then(() => {
        process.exit()
      })
  }
  function nre(e = 9229) {
    let t = require('inspector'),
      n,
      r = e
    for (; n === void 0 && r < e + 100; ) t.open(r), (n = t.url()), r++
    return n
  }
  function rre(e) {
    function t(n, ...r) {
      _p.logger.log(`[ANR] ${n}`, ...r)
    }
    try {
      let n = { ...process.env }
      ;(n.SENTRY_ANR_CHILD_PROCESS = 'true'),
        e.captureStackTrace && (n.SENTRY_INSPECT_URL = nre()),
        t(
          `Spawning child process with execPath:'${process.execPath}' and entryScript'${e.entryScript}'`,
        )
      let r = Qne.spawn(process.execPath, [e.entryScript], {
        env: n,
        stdio: _p.logger.isEnabled()
          ? ['inherit', 'inherit', 'inherit', 'ipc']
          : ['ignore', 'ignore', 'ignore', 'ipc'],
      })
      r.unref()
      let s = setInterval(() => {
          try {
            r.send('ping')
          } catch {}
        }, e.pollInterval),
        o =
          (i) =>
          (...a) => {
            clearInterval(s), t(`Child process ${i}`, ...a)
          }
      r.on('error', o('error')),
        r.on('disconnect', o('disconnect')),
        r.on('exit', o('exit'))
    } catch (n) {
      t('Failed to start child process', n)
    }
  }
  function sre() {
    let e = process.hrtime()
    return {
      getTimeMs: () => {
        let [t, n] = process.hrtime(e)
        return Math.floor(t * 1e3 + n / 1e6)
      },
      reset: () => {
        e = process.hrtime()
      },
    }
  }
  function ore(e) {
    function t(o) {
      _p.logger.log(`[ANR child process] ${o}`)
    }
    ;(process.title = 'sentry-anr'),
      t('Started'),
      EC.addGlobalEventProcessor(
        (o) => (
          delete o.sdkProcessingMetadata,
          (o.tags = { ...o.tags, 'process.name': 'ANR' }),
          o
        ),
      )
    let n
    process.env.SENTRY_INSPECT_URL &&
      (t('Connecting to debugger'),
      (n = Zne.captureStackTrace(process.env.SENTRY_INSPECT_URL, (o) => {
        t('Capturing event with stack frames'), P1(e.anrThreshold, o)
      })))
    async function r() {
      t('Watchdog timeout')
      let o = await n
      o
        ? (t('Pausing debugger to capture stack trace'), o())
        : (t('Capturing event'), P1(e.anrThreshold))
    }
    let { poll: s } = _p.watchdogTimer(sre, e.pollInterval, e.anrThreshold, r)
    process.on('message', () => {
      s()
    })
  }
  function R1() {
    return !!process.send && !!process.env.SENTRY_ANR_CHILD_PROCESS
  }
  function ire(e) {
    let n = {
      entryScript: e.entryScript || process.env.pm_exec_path || process.argv[1],
      pollInterval: e.pollInterval || ere,
      anrThreshold: e.anrThreshold || tre,
      captureStackTrace: !!e.captureStackTrace,
      debug: !!e.debug,
    }
    return R1() ? (ore(n), new Promise(() => {})) : (rre(n), Promise.resolve())
  }
  fp.enableAnrDetection = ire
  fp.isAnrChildProcess = R1
})
var Pi = l((bC) => {
  Object.defineProperty(bC, '__esModule', { value: !0 })
  var are = O(),
    cre = are.parseSemver(process.versions.node)
  bC.NODE_VERSION = cre
})
var O1 = l((vC) => {
  var { _optionalChain: dre } = Se()
  Object.defineProperty(vC, '__esModule', { value: !0 })
  var po = we(),
    D1 = require('domain')
  function A1() {
    return D1.active
  }
  function ure() {
    let e = A1()
    if (e) return po.ensureHubOnCarrier(e), po.getHubFromCarrier(e)
  }
  function lre(e) {
    let t = {}
    return po.ensureHubOnCarrier(t, e), po.getHubFromCarrier(t)
  }
  function mre(e, t) {
    let n = A1()
    if (n && dre([t, 'optionalAccess', (i) => i.reuseExisting])) return e()
    let r = D1.create(),
      s = n ? po.getHubFromCarrier(n) : void 0,
      o = lre(s)
    return po.setHubOnCarrier(r, o), r.bind(() => e())()
  }
  function pre() {
    po.setAsyncContextStrategy({ getCurrentHub: ure, runWithAsyncContext: mre })
  }
  vC.setDomainAsyncContextStrategy = pre
})
var N1 = l((TC) => {
  var { _optionalChain: _re } = Se()
  Object.defineProperty(TC, '__esModule', { value: !0 })
  var CC = we(),
    fre = require('async_hooks'),
    hp
  function hre() {
    hp || (hp = new fre.AsyncLocalStorage())
    function e() {
      return hp.getStore()
    }
    function t(r) {
      let s = {}
      return CC.ensureHubOnCarrier(s, r), CC.getHubFromCarrier(s)
    }
    function n(r, s) {
      let o = e()
      if (o && _re([s, 'optionalAccess', (a) => a.reuseExisting])) return r()
      let i = t(o)
      return hp.run(i, () => r())
    }
    CC.setAsyncContextStrategy({ getCurrentHub: e, runWithAsyncContext: n })
  }
  TC.setHooksAsyncContextStrategy = hre
})
var k1 = l((wC) => {
  Object.defineProperty(wC, '__esModule', { value: !0 })
  var q1 = Pi(),
    gre = O1(),
    yre = N1()
  function Ere() {
    q1.NODE_VERSION.major && q1.NODE_VERSION.major >= 14
      ? yre.setHooksAsyncContextStrategy()
      : gre.setDomainAsyncContextStrategy()
  }
  wC.setNodeAsyncContextStrategy = Ere
})
var xC = l((IC) => {
  Object.defineProperty(IC, '__esModule', { value: !0 })
  var Sre = we(),
    M1 = O(),
    bre = require('util'),
    gp = class e {
      constructor() {
        e.prototype.__init.call(this)
      }
      static __initStatic() {
        this.id = 'Console'
      }
      __init() {
        this.name = e.id
      }
      setupOnce() {
        M1.addInstrumentationHandler('console', ({ args: t, level: n }) => {
          let r = Sre.getCurrentHub()
          r.getIntegration(e) &&
            r.addBreadcrumb(
              {
                category: 'console',
                level: M1.severityLevelFromString(n),
                message: bre.format.apply(void 0, t),
              },
              { input: [...t], level: n },
            )
        })
      }
    }
  gp.__initStatic()
  IC.Console = gp
})
var pu = l((yp) => {
  ;(function (e, t) {
    let n = typeof yp == 'object' ? yp : typeof e == 'object' ? e : {}
    t(n), typeof define == 'function' && define.amd && define('lru', n)
  })(yp, function (e) {
    let t = Symbol('newer'),
      n = Symbol('older')
    function r(c, u) {
      typeof c != 'number' && ((u = c), (c = 0)),
        (this.size = 0),
        (this.limit = c),
        (this.oldest = this.newest = void 0),
        (this._keymap = new Map()),
        u && (this.assign(u), c < 1 && (this.limit = this.size))
    }
    e.LRUMap = r
    function s(c, u) {
      ;(this.key = c), (this.value = u), (this[t] = void 0), (this[n] = void 0)
    }
    ;(r.prototype._markEntryAsUsed = function (c) {
      c !== this.newest &&
        (c[t] && (c === this.oldest && (this.oldest = c[t]), (c[t][n] = c[n])),
        c[n] && (c[n][t] = c[t]),
        (c[t] = void 0),
        (c[n] = this.newest),
        this.newest && (this.newest[t] = c),
        (this.newest = c))
    }),
      (r.prototype.assign = function (c) {
        let u,
          d = this.limit || Number.MAX_VALUE
        this._keymap.clear()
        let p = c[Symbol.iterator]()
        for (let _ = p.next(); !_.done; _ = p.next()) {
          let f = new s(_.value[0], _.value[1])
          if (
            (this._keymap.set(f.key, f),
            u ? ((u[t] = f), (f[n] = u)) : (this.oldest = f),
            (u = f),
            d-- == 0)
          )
            throw new Error('overflow')
        }
        ;(this.newest = u), (this.size = this._keymap.size)
      }),
      (r.prototype.get = function (c) {
        var u = this._keymap.get(c)
        if (u) return this._markEntryAsUsed(u), u.value
      }),
      (r.prototype.set = function (c, u) {
        var d = this._keymap.get(c)
        return d
          ? ((d.value = u), this._markEntryAsUsed(d), this)
          : (this._keymap.set(c, (d = new s(c, u))),
            this.newest
              ? ((this.newest[t] = d), (d[n] = this.newest))
              : (this.oldest = d),
            (this.newest = d),
            ++this.size,
            this.size > this.limit && this.shift(),
            this)
      }),
      (r.prototype.shift = function () {
        var c = this.oldest
        if (c)
          return (
            this.oldest[t]
              ? ((this.oldest = this.oldest[t]), (this.oldest[n] = void 0))
              : ((this.oldest = void 0), (this.newest = void 0)),
            (c[t] = c[n] = void 0),
            this._keymap.delete(c.key),
            --this.size,
            [c.key, c.value]
          )
      }),
      (r.prototype.find = function (c) {
        let u = this._keymap.get(c)
        return u ? u.value : void 0
      }),
      (r.prototype.has = function (c) {
        return this._keymap.has(c)
      }),
      (r.prototype.delete = function (c) {
        var u = this._keymap.get(c)
        if (u)
          return (
            this._keymap.delete(u.key),
            u[t] && u[n]
              ? ((u[n][t] = u[t]), (u[t][n] = u[n]))
              : u[t]
                ? ((u[t][n] = void 0), (this.oldest = u[t]))
                : u[n]
                  ? ((u[n][t] = void 0), (this.newest = u[n]))
                  : (this.oldest = this.newest = void 0),
            this.size--,
            u.value
          )
      }),
      (r.prototype.clear = function () {
        ;(this.oldest = this.newest = void 0),
          (this.size = 0),
          this._keymap.clear()
      })
    function o(c) {
      this.entry = c
    }
    ;(o.prototype[Symbol.iterator] = function () {
      return this
    }),
      (o.prototype.next = function () {
        let c = this.entry
        return c
          ? ((this.entry = c[t]), { done: !1, value: [c.key, c.value] })
          : { done: !0, value: void 0 }
      })
    function i(c) {
      this.entry = c
    }
    ;(i.prototype[Symbol.iterator] = function () {
      return this
    }),
      (i.prototype.next = function () {
        let c = this.entry
        return c
          ? ((this.entry = c[t]), { done: !1, value: c.key })
          : { done: !0, value: void 0 }
      })
    function a(c) {
      this.entry = c
    }
    ;(a.prototype[Symbol.iterator] = function () {
      return this
    }),
      (a.prototype.next = function () {
        let c = this.entry
        return c
          ? ((this.entry = c[t]), { done: !1, value: c.value })
          : { done: !0, value: void 0 }
      }),
      (r.prototype.keys = function () {
        return new i(this.oldest)
      }),
      (r.prototype.values = function () {
        return new a(this.oldest)
      }),
      (r.prototype.entries = function () {
        return this
      }),
      (r.prototype[Symbol.iterator] = function () {
        return new o(this.oldest)
      }),
      (r.prototype.forEach = function (c, u) {
        typeof u != 'object' && (u = this)
        let d = this.oldest
        for (; d; ) c.call(u, d.value, d.key, this), (d = d[t])
      }),
      (r.prototype.toJSON = function () {
        for (var c = new Array(this.size), u = 0, d = this.oldest; d; )
          (c[u++] = { key: d.key, value: d.value }), (d = d[t])
        return c
      }),
      (r.prototype.toString = function () {
        for (var c = '', u = this.oldest; u; )
          (c += String(u.key) + ':' + u.value), (u = u[t]), u && (c += ' < ')
        return c
      })
  })
})
var B1 = l((_o) => {
  var { _optionalChain: xn } = Se()
  Object.defineProperty(_o, '__esModule', { value: !0 })
  var PC = require('url'),
    L1 = Pi()
  function vre(e) {
    let { protocol: t, hostname: n, port: r } = F1(e),
      s = e.path ? e.path : '/'
    return `${t}//${n}${r}${s}`
  }
  function U1(e) {
    let { protocol: t, hostname: n, port: r } = F1(e),
      s = e.pathname || '/',
      o = e.auth ? Cre(e.auth) : ''
    return `${t}//${o}${n}${r}${s}`
  }
  function Cre(e) {
    let [t, n] = e.split(':')
    return `${t ? '[Filtered]' : ''}:${n ? '[Filtered]' : ''}@`
  }
  function Tre(e, t, n) {
    if (!e) return e
    let [r, s] = e.split(' ')
    return (
      t.host &&
        !t.protocol &&
        ((t.protocol = xn([
          n,
          'optionalAccess',
          (o) => o.agent,
          'optionalAccess',
          (o) => o.protocol,
        ])),
        (s = U1(t))),
      xn([s, 'optionalAccess', (o) => o.startsWith, 'call', (o) => o('///')]) &&
        (s = s.slice(2)),
      `${r} ${s}`
    )
  }
  function RC(e) {
    let t = {
      protocol: e.protocol,
      hostname:
        typeof e.hostname == 'string' && e.hostname.startsWith('[')
          ? e.hostname.slice(1, -1)
          : e.hostname,
      hash: e.hash,
      search: e.search,
      pathname: e.pathname,
      path: `${e.pathname || ''}${e.search || ''}`,
      href: e.href,
    }
    return (
      e.port !== '' && (t.port = Number(e.port)),
      (e.username || e.password) && (t.auth = `${e.username}:${e.password}`),
      t
    )
  }
  function wre(e, t) {
    let n, r
    if (
      (typeof t[t.length - 1] == 'function' && (n = t.pop()),
      typeof t[0] == 'string')
    )
      r = RC(new PC.URL(t[0]))
    else if (t[0] instanceof PC.URL) r = RC(t[0])
    else {
      r = t[0]
      try {
        let s = new PC.URL(
          r.path || '',
          `${r.protocol || 'http:'}//${r.hostname}`,
        )
        r = { pathname: s.pathname, search: s.search, hash: s.hash, ...r }
      } catch {}
    }
    return (
      t.length === 2 && (r = { ...r, ...t[1] }),
      r.protocol === void 0 &&
        (L1.NODE_VERSION.major && L1.NODE_VERSION.major > 8
          ? (r.protocol =
              xn([
                xn([e, 'optionalAccess', (s) => s.globalAgent]),
                'optionalAccess',
                (s) => s.protocol,
              ]) ||
              xn([r.agent, 'optionalAccess', (s) => s.protocol]) ||
              xn([r._defaultAgent, 'optionalAccess', (s) => s.protocol]))
          : (r.protocol =
              xn([r.agent, 'optionalAccess', (s) => s.protocol]) ||
              xn([r._defaultAgent, 'optionalAccess', (s) => s.protocol]) ||
              xn([
                xn([e, 'optionalAccess', (s) => s.globalAgent]),
                'optionalAccess',
                (s) => s.protocol,
              ]))),
      n ? [r, n] : [r]
    )
  }
  function F1(e) {
    let t = e.protocol || '',
      n = e.hostname || e.host || '',
      r =
        !e.port || e.port === 80 || e.port === 443 || /^(.*):(\d+)$/.test(n)
          ? ''
          : `:${e.port}`
    return { protocol: t, hostname: n, port: r }
  }
  _o.cleanSpanDescription = Tre
  _o.extractRawUrl = vre
  _o.extractUrl = U1
  _o.normalizeRequestArgs = wre
  _o.urlToOptions = RC
})
var AC = l((DC) => {
  var { _optionalChain: fo } = Se()
  Object.defineProperty(DC, '__esModule', { value: !0 })
  var Ri = we(),
    Pn = O(),
    j1 = pu(),
    G1 = Pi(),
    _u = B1(),
    fu = class e {
      static __initStatic() {
        this.id = 'Http'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          (this._breadcrumbs = typeof t.breadcrumbs > 'u' ? !0 : t.breadcrumbs),
          (this._tracing = t.tracing
            ? t.tracing === !0
              ? {}
              : t.tracing
            : void 0)
      }
      setupOnce(t, n) {
        if (!this._breadcrumbs && !this._tracing) return
        let r = fo([
          n,
          'call',
          (c) => c(),
          'access',
          (c) => c.getClient,
          'call',
          (c) => c(),
          'optionalAccess',
          (c) => c.getOptions,
          'call',
          (c) => c(),
        ])
        if (r && r.instrumenter !== 'sentry') {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Pn.logger.log(
              'HTTP Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let s =
            fo([
              this,
              'access',
              (c) => c._tracing,
              'optionalAccess',
              (c) => c.shouldCreateSpanForRequest,
            ]) ||
            fo([r, 'optionalAccess', (c) => c.shouldCreateSpanForRequest]),
          o =
            fo([r, 'optionalAccess', (c) => c.tracePropagationTargets]) ||
            fo([
              this,
              'access',
              (c) => c._tracing,
              'optionalAccess',
              (c) => c.tracePropagationTargets,
            ]),
          i = require('http'),
          a = $1(i, this._breadcrumbs, s, o)
        if (
          (Pn.fill(i, 'get', a),
          Pn.fill(i, 'request', a),
          G1.NODE_VERSION.major && G1.NODE_VERSION.major > 8)
        ) {
          let c = require('https'),
            u = $1(c, this._breadcrumbs, s, o)
          Pn.fill(c, 'get', u), Pn.fill(c, 'request', u)
        }
      }
    }
  fu.__initStatic()
  function $1(e, t, n, r) {
    let s = new j1.LRUMap(100),
      o = new j1.LRUMap(100),
      i = (u) => {
        if (n === void 0) return !0
        let d = s.get(u)
        if (d !== void 0) return d
        let p = n(u)
        return s.set(u, p), p
      },
      a = (u) => {
        if (r === void 0) return !0
        let d = o.get(u)
        if (d !== void 0) return d
        let p = Pn.stringMatchesSomePattern(u, r)
        return o.set(u, p), p
      }
    function c(u, d, p, _) {
      Ri.getCurrentHub().getIntegration(fu) &&
        Ri.getCurrentHub().addBreadcrumb(
          {
            category: 'http',
            data: { status_code: _ && _.statusCode, ...d },
            type: 'http',
          },
          { event: u, request: p, response: _ },
        )
    }
    return function (d) {
      return function (..._) {
        let f = _u.normalizeRequestArgs(e, _),
          h = f[0],
          y = _u.extractRawUrl(h),
          E = _u.extractUrl(h)
        if (Ri.isSentryRequestUrl(E, Ri.getCurrentHub())) return d.apply(e, f)
        let C = Ri.getCurrentHub(),
          A = C.getScope(),
          se = A.getSpan(),
          Q = Ire(E, h),
          be = i(y)
            ? fo([
                se,
                'optionalAccess',
                (ee) => ee.startChild,
                'call',
                (ee) =>
                  ee({
                    op: 'http.client',
                    origin: 'auto.http.node.http',
                    description: `${Q['http.method']} ${Q.url}`,
                    data: Q,
                  }),
              ])
            : void 0
        if (a(y))
          if (be) {
            let ee = be.toTraceparent(),
              Ae = fo([
                be,
                'optionalAccess',
                (Et) => Et.transaction,
                'optionalAccess',
                (Et) => Et.getDynamicSamplingContext,
                'call',
                (Et) => Et(),
              ])
            z1(h, E, ee, Ae)
          } else {
            let ee = C.getClient(),
              { traceId: Ae, sampled: Et, dsc: Xs } = A.getPropagationContext(),
              St = Pn.generateSentryTraceHeader(Ae, void 0, Et),
              Te =
                Xs ||
                (ee
                  ? Ri.getDynamicSamplingContextFromClient(Ae, ee, A)
                  : void 0)
            z1(h, E, St, Te)
          }
        else
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Pn.logger.log(
              `[Tracing] Not adding sentry-trace header to outgoing request (${E}) due to mismatching tracePropagationTargets option.`,
            )
        return d
          .apply(e, f)
          .once('response', function (ee) {
            let Ae = this
            t && c('response', Q, Ae, ee),
              be &&
                (ee.statusCode && be.setHttpStatus(ee.statusCode),
                (be.description = _u.cleanSpanDescription(
                  be.description,
                  h,
                  Ae,
                )),
                be.finish())
          })
          .once('error', function () {
            let ee = this
            t && c('error', Q, ee),
              be &&
                (be.setHttpStatus(500),
                (be.description = _u.cleanSpanDescription(
                  be.description,
                  h,
                  ee,
                )),
                be.finish())
          })
      }
    }
  }
  function z1(e, t, n, r) {
    if ((e.headers || {})['sentry-trace']) return
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      Pn.logger.log(
        `[Tracing] Adding sentry-trace header ${n} to outgoing request to "${t}": `,
      )
    let o = Pn.dynamicSamplingContextToSentryBaggageHeader(r),
      i = o && o.length > 0 ? xre(e, o) : void 0
    e.headers = { ...e.headers, 'sentry-trace': n, ...(i && { baggage: i }) }
  }
  function Ire(e, t) {
    let n = t.method || 'GET',
      r = { url: e, 'http.method': n }
    return (
      t.hash && (r['http.fragment'] = t.hash.substring(1)),
      t.search && (r['http.query'] = t.search.substring(1)),
      r
    )
  }
  function xre(e, t) {
    if (!e.headers || !e.headers.baggage) return t
    if (t) {
      if (Array.isArray(e.headers.baggage)) return [...e.headers.baggage, t]
    } else return e.headers.baggage
    return [e.headers.baggage, t]
  }
  DC.Http = fu
})
var qC = l((NC) => {
  Object.defineProperty(NC, '__esModule', { value: !0 })
  var Pre = we(),
    OC = O(),
    Rre = 2e3
  function Dre(e) {
    console.error(e)
    let t = Pre.getCurrentHub().getClient()
    t === void 0 &&
      ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        OC.logger.warn(
          'No NodeClient was defined, we are exiting the process now.',
        ),
      global.process.exit(1))
    let n = t.getOptions(),
      r =
        (n &&
          n.shutdownTimeout &&
          n.shutdownTimeout > 0 &&
          n.shutdownTimeout) ||
        Rre
    t.close(r).then(
      (s) => {
        s ||
          ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            OC.logger.warn(
              'We reached the timeout for emptying the request buffer, still exiting now!',
            )),
          global.process.exit(1)
      },
      (s) => {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          OC.logger.error(s)
      },
    )
  }
  NC.logAndExitProcess = Dre
})
var MC = l((kC) => {
  Object.defineProperty(kC, '__esModule', { value: !0 })
  var H1 = we(),
    Are = O(),
    V1 = qC(),
    Ep = class e {
      static __initStatic() {
        this.id = 'OnUncaughtException'
      }
      __init() {
        this.name = e.id
      }
      __init2() {
        this.handler = this._makeErrorHandler()
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          e.prototype.__init2.call(this),
          (this._options = { exitEvenIfOtherHandlersAreRegistered: !0, ...t })
      }
      setupOnce() {
        global.process.on('uncaughtException', this.handler)
      }
      _makeErrorHandler() {
        let n = !1,
          r = !1,
          s = !1,
          o
        return (i) => {
          let a = V1.logAndExitProcess,
            c = H1.getCurrentHub().getClient()
          this._options.onFatalError
            ? (a = this._options.onFatalError)
            : c &&
              c.getOptions().onFatalError &&
              (a = c.getOptions().onFatalError)
          let d =
              global.process
                .listeners('uncaughtException')
                .reduce(
                  (_, f) =>
                    f.name === 'domainUncaughtExceptionClear' ||
                    (f.tag && f.tag === 'sentry_tracingErrorCallback') ||
                    f === this.handler
                      ? _
                      : _ + 1,
                  0,
                ) === 0,
            p = this._options.exitEvenIfOtherHandlersAreRegistered || d
          if (n)
            p &&
              (s
                ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                    Are.logger.warn(
                      'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',
                    ),
                  V1.logAndExitProcess(i))
                : r ||
                  ((r = !0),
                  setTimeout(() => {
                    s || ((s = !0), a(o, i))
                  }, 2e3)))
          else {
            let _ = H1.getCurrentHub()
            ;(o = i),
              (n = !0),
              _.getIntegration(e)
                ? _.withScope((f) => {
                    f.setLevel('fatal'),
                      _.captureException(i, {
                        originalException: i,
                        data: {
                          mechanism: {
                            handled: !1,
                            type: 'onuncaughtexception',
                          },
                        },
                      }),
                      !s && p && ((s = !0), a(i))
                  })
                : !s && p && ((s = !0), a(i))
          }
        }
      }
    }
  Ep.__initStatic()
  kC.OnUncaughtException = Ep
})
var UC = l((LC) => {
  Object.defineProperty(LC, '__esModule', { value: !0 })
  var Ore = we(),
    Y1 = O(),
    Nre = qC(),
    Sp = class e {
      static __initStatic() {
        this.id = 'OnUnhandledRejection'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = { mode: 'warn' }) {
        ;(this._options = t), e.prototype.__init.call(this)
      }
      setupOnce() {
        global.process.on(
          'unhandledRejection',
          this.sendUnhandledPromise.bind(this),
        )
      }
      sendUnhandledPromise(t, n) {
        let r = Ore.getCurrentHub()
        r.getIntegration(e) &&
          r.withScope((s) => {
            s.setExtra('unhandledPromiseRejection', !0),
              r.captureException(t, {
                originalException: n,
                data: {
                  mechanism: { handled: !1, type: 'onunhandledrejection' },
                },
              })
          }),
          this._handleRejection(t)
      }
      _handleRejection(t) {
        let n =
          'This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:'
        this._options.mode === 'warn'
          ? Y1.consoleSandbox(() => {
              console.warn(n), console.error(t && t.stack ? t.stack : t)
            })
          : this._options.mode === 'strict' &&
            (Y1.consoleSandbox(() => {
              console.warn(n)
            }),
            Nre.logAndExitProcess(t))
      }
    }
  Sp.__initStatic()
  LC.OnUnhandledRejection = Sp
})
var BC = l((FC) => {
  Object.defineProperty(FC, '__esModule', { value: !0 })
  var W1 = O(),
    qre = 'cause',
    kre = 5,
    bp = class e {
      static __initStatic() {
        this.id = 'LinkedErrors'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          (this._key = t.key || qre),
          (this._limit = t.limit || kre)
      }
      setupOnce() {}
      preprocessEvent(t, n, r) {
        let s = r.getOptions()
        W1.applyAggregateErrorsToEvent(
          W1.exceptionFromError,
          s.stackParser,
          s.maxValueLength,
          this._key,
          this._limit,
          t,
          n,
        )
      }
    }
  bp.__initStatic()
  FC.LinkedErrors = bp
})
var $C = l((GC) => {
  Object.defineProperty(GC, '__esModule', { value: !0 })
  var K1 = require('fs'),
    X1 = require('path'),
    jC
  function Mre() {
    try {
      return require.cache ? Object.keys(require.cache) : []
    } catch {
      return []
    }
  }
  function Lre() {
    let e = (require.main && require.main.paths) || [],
      t = Mre(),
      n = {},
      r = {}
    return (
      t.forEach((s) => {
        let o = s,
          i = () => {
            let a = o
            if (((o = X1.dirname(a)), !o || a === o || r[a])) return
            if (e.indexOf(o) < 0) return i()
            let c = X1.join(a, 'package.json')
            if (((r[a] = !0), !K1.existsSync(c))) return i()
            try {
              let u = JSON.parse(K1.readFileSync(c, 'utf8'))
              n[u.name] = u.version
            } catch {}
          }
        i()
      }),
      n
    )
  }
  var vp = class e {
    constructor() {
      e.prototype.__init.call(this)
    }
    static __initStatic() {
      this.id = 'Modules'
    }
    __init() {
      this.name = e.id
    }
    setupOnce(t, n) {
      t((r) =>
        n().getIntegration(e)
          ? { ...r, modules: { ...r.modules, ...this._getModules() } }
          : r,
      )
    }
    _getModules() {
      return jC || (jC = Lre()), jC
    }
  }
  vp.__initStatic()
  GC.Modules = vp
})
var VC = l((HC) => {
  var { _optionalChain: zC } = Se()
  Object.defineProperty(HC, '__esModule', { value: !0 })
  var Ure = O(),
    Fre = require('fs'),
    Bre = pu(),
    Cp = new Bre.LRUMap(100),
    jre = 7
  function Gre(e) {
    return new Promise((t, n) => {
      Fre.readFile(e, 'utf8', (r, s) => {
        r ? n(r) : t(s)
      })
    })
  }
  var Tp = class e {
    static __initStatic() {
      this.id = 'ContextLines'
    }
    __init() {
      this.name = e.id
    }
    constructor(t = {}) {
      ;(this._options = t), e.prototype.__init.call(this)
    }
    get _contextLines() {
      return this._options.frameContextLines !== void 0
        ? this._options.frameContextLines
        : jre
    }
    setupOnce(t, n) {
      t((r) => (n().getIntegration(e) ? this.addSourceContext(r) : r))
    }
    async addSourceContext(t) {
      let n = {},
        r = []
      if (
        this._contextLines > 0 &&
        zC([t, 'access', (s) => s.exception, 'optionalAccess', (s) => s.values])
      ) {
        for (let s of t.exception.values)
          if (
            zC([
              s,
              'access',
              (o) => o.stacktrace,
              'optionalAccess',
              (o) => o.frames,
            ])
          )
            for (let o = s.stacktrace.frames.length - 1; o >= 0; o--) {
              let i = s.stacktrace.frames[o]
              i.filename &&
                !n[i.filename] &&
                !Cp.get(i.filename) &&
                (r.push($re(i.filename)), (n[i.filename] = 1))
            }
      }
      if (
        (r.length > 0 && (await Promise.all(r)),
        this._contextLines > 0 &&
          zC([
            t,
            'access',
            (s) => s.exception,
            'optionalAccess',
            (s) => s.values,
          ]))
      )
        for (let s of t.exception.values)
          s.stacktrace &&
            s.stacktrace.frames &&
            (await this.addSourceContextToFrames(s.stacktrace.frames))
      return t
    }
    addSourceContextToFrames(t) {
      for (let n of t)
        if (n.filename && n.context_line === void 0) {
          let r = Cp.get(n.filename)
          if (r)
            try {
              Ure.addContextToFrame(r, n, this._contextLines)
            } catch {}
        }
    }
  }
  Tp.__initStatic()
  async function $re(e) {
    let t = Cp.get(e)
    if (t === null) return null
    if (t !== void 0) return t
    let n = null
    try {
      n = (await Gre(e)).split(`
`)
    } catch {}
    return Cp.set(e, n), n
  }
  HC.ContextLines = Tp
})
var YC = l((Di) => {
  var { _optionalChain: ho } = Se()
  Object.defineProperty(Di, '__esModule', { value: !0 })
  var zre = require('child_process'),
    Q1 = require('fs'),
    Ht = require('os'),
    Hre = require('path'),
    Z1 = require('util'),
    ek = Z1.promisify(Q1.readFile),
    tk = Z1.promisify(Q1.readdir),
    wp = class e {
      static __initStatic() {
        this.id = 'Context'
      }
      __init() {
        this.name = e.id
      }
      constructor(
        t = { app: !0, os: !0, device: !0, culture: !0, cloudResource: !0 },
      ) {
        ;(this._options = t), e.prototype.__init.call(this)
      }
      setupOnce(t) {
        t((n) => this.addContext(n))
      }
      async addContext(t) {
        this._cachedContext === void 0 &&
          (this._cachedContext = this._getContexts())
        let n = this._updateContext(await this._cachedContext)
        return (
          (t.contexts = {
            ...t.contexts,
            app: {
              ...n.app,
              ...ho([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.app,
              ]),
            },
            os: {
              ...n.os,
              ...ho([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.os,
              ]),
            },
            device: {
              ...n.device,
              ...ho([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.device,
              ]),
            },
            culture: {
              ...n.culture,
              ...ho([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.culture,
              ]),
            },
            cloud_resource: {
              ...n.cloud_resource,
              ...ho([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.cloud_resource,
              ]),
            },
          }),
          t
        )
      }
      _updateContext(t) {
        return (
          ho([
            t,
            'optionalAccess',
            (n) => n.app,
            'optionalAccess',
            (n) => n.app_memory,
          ]) && (t.app.app_memory = process.memoryUsage().rss),
          ho([
            t,
            'optionalAccess',
            (n) => n.device,
            'optionalAccess',
            (n) => n.free_memory,
          ]) && (t.device.free_memory = Ht.freemem()),
          t
        )
      }
      async _getContexts() {
        let t = {}
        if (
          (this._options.os && (t.os = await Vre()),
          this._options.app && (t.app = Wre()),
          this._options.device && (t.device = nk(this._options.device)),
          this._options.culture)
        ) {
          let n = Yre()
          n && (t.culture = n)
        }
        return this._options.cloudResource && (t.cloud_resource = ese()), t
      }
    }
  wp.__initStatic()
  async function Vre() {
    let e = Ht.platform()
    switch (e) {
      case 'darwin':
        return Qre()
      case 'linux':
        return Zre()
      default:
        return { name: Kre[e] || e, version: Ht.release() }
    }
  }
  function Yre() {
    try {
      if (typeof process.versions.icu != 'string') return
      let e = new Date(9e8)
      if (
        new Intl.DateTimeFormat('es', { month: 'long' }).format(e) === 'enero'
      ) {
        let n = Intl.DateTimeFormat().resolvedOptions()
        return { locale: n.locale, timezone: n.timeZone }
      }
    } catch {}
  }
  function Wre() {
    let e = process.memoryUsage().rss
    return {
      app_start_time: new Date(
        Date.now() - process.uptime() * 1e3,
      ).toISOString(),
      app_memory: e,
    }
  }
  function nk(e) {
    let t = {},
      n
    try {
      n = Ht.uptime && Ht.uptime()
    } catch {}
    if (
      (typeof n == 'number' &&
        (t.boot_time = new Date(Date.now() - n * 1e3).toISOString()),
      (t.arch = Ht.arch()),
      (e === !0 || e.memory) &&
        ((t.memory_size = Ht.totalmem()), (t.free_memory = Ht.freemem())),
      e === !0 || e.cpu)
    ) {
      let r = Ht.cpus()
      if (r && r.length) {
        let s = r[0]
        ;(t.processor_count = r.length),
          (t.cpu_description = s.model),
          (t.processor_frequency = s.speed)
      }
    }
    return t
  }
  var Kre = {
      aix: 'IBM AIX',
      freebsd: 'FreeBSD',
      openbsd: 'OpenBSD',
      sunos: 'SunOS',
      win32: 'Windows',
    },
    Xre = [
      { name: 'fedora-release', distros: ['Fedora'] },
      { name: 'redhat-release', distros: ['Red Hat Linux', 'Centos'] },
      { name: 'redhat_version', distros: ['Red Hat Linux'] },
      { name: 'SuSE-release', distros: ['SUSE Linux'] },
      { name: 'lsb-release', distros: ['Ubuntu Linux', 'Arch Linux'] },
      { name: 'debian_version', distros: ['Debian'] },
      { name: 'debian_release', distros: ['Debian'] },
      { name: 'arch-release', distros: ['Arch Linux'] },
      { name: 'gentoo-release', distros: ['Gentoo Linux'] },
      { name: 'novell-release', distros: ['SUSE Linux'] },
      { name: 'alpine-release', distros: ['Alpine Linux'] },
    ],
    Jre = {
      alpine: (e) => e,
      arch: (e) => Rn(/distrib_release=(.*)/, e),
      centos: (e) => Rn(/release ([^ ]+)/, e),
      debian: (e) => e,
      fedora: (e) => Rn(/release (..)/, e),
      mint: (e) => Rn(/distrib_release=(.*)/, e),
      red: (e) => Rn(/release ([^ ]+)/, e),
      suse: (e) => Rn(/VERSION = (.*)\n/, e),
      ubuntu: (e) => Rn(/distrib_release=(.*)/, e),
    }
  function Rn(e, t) {
    let n = e.exec(t)
    return n ? n[1] : void 0
  }
  async function Qre() {
    let e = {
      kernel_version: Ht.release(),
      name: 'Mac OS X',
      version: `10.${Number(Ht.release().split('.')[0]) - 4}`,
    }
    try {
      let t = await new Promise((n, r) => {
        zre.execFile('/usr/bin/sw_vers', (s, o) => {
          if (s) {
            r(s)
            return
          }
          n(o)
        })
      })
      ;(e.name = Rn(/^ProductName:\s+(.*)$/m, t)),
        (e.version = Rn(/^ProductVersion:\s+(.*)$/m, t)),
        (e.build = Rn(/^BuildVersion:\s+(.*)$/m, t))
    } catch {}
    return e
  }
  function J1(e) {
    return e.split(' ')[0].toLowerCase()
  }
  async function Zre() {
    let e = { kernel_version: Ht.release(), name: 'Linux' }
    try {
      let t = await tk('/etc'),
        n = Xre.find((a) => t.includes(a.name))
      if (!n) return e
      let r = Hre.join('/etc', n.name),
        s = (await ek(r, { encoding: 'utf-8' })).toLowerCase(),
        { distros: o } = n
      e.name = o.find((a) => s.indexOf(J1(a)) >= 0) || o[0]
      let i = J1(e.name)
      e.version = Jre[i](s)
    } catch {}
    return e
  }
  function ese() {
    return process.env.VERCEL
      ? {
          'cloud.provider': 'vercel',
          'cloud.region': process.env.VERCEL_REGION,
        }
      : process.env.AWS_REGION
        ? {
            'cloud.provider': 'aws',
            'cloud.region': process.env.AWS_REGION,
            'cloud.platform': process.env.AWS_EXECUTION_ENV,
          }
        : process.env.GCP_PROJECT
          ? { 'cloud.provider': 'gcp' }
          : process.env.ALIYUN_REGION_ID
            ? {
                'cloud.provider': 'alibaba_cloud',
                'cloud.region': process.env.ALIYUN_REGION_ID,
              }
            : process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME
              ? {
                  'cloud.provider': 'azure',
                  'cloud.region': process.env.REGION_NAME,
                }
              : process.env.IBM_CLOUD_REGION
                ? {
                    'cloud.provider': 'ibm_cloud',
                    'cloud.region': process.env.IBM_CLOUD_REGION,
                  }
                : process.env.TENCENTCLOUD_REGION
                  ? {
                      'cloud.provider': 'tencent_cloud',
                      'cloud.region': process.env.TENCENTCLOUD_REGION,
                      'cloud.account.id': process.env.TENCENTCLOUD_APPID,
                      'cloud.availability_zone': process.env.TENCENTCLOUD_ZONE,
                    }
                  : process.env.NETLIFY
                    ? { 'cloud.provider': 'netlify' }
                    : process.env.FLY_REGION
                      ? {
                          'cloud.provider': 'fly.io',
                          'cloud.region': process.env.FLY_REGION,
                        }
                      : process.env.DYNO
                        ? { 'cloud.provider': 'heroku' }
                        : void 0
  }
  Di.Context = wp
  Di.getDeviceContext = nk
  Di.readDirAsync = tk
  Di.readFileAsync = ek
})
var rk = l((WC) => {
  'use strict'
  WC.parse = nse
  WC.serialize = rse
  var tse = Object.prototype.toString,
    Ip = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/
  function nse(e, t) {
    if (typeof e != 'string')
      throw new TypeError('argument str must be a string')
    for (var n = {}, r = t || {}, s = r.decode || sse, o = 0; o < e.length; ) {
      var i = e.indexOf('=', o)
      if (i === -1) break
      var a = e.indexOf(';', o)
      if (a === -1) a = e.length
      else if (a < i) {
        o = e.lastIndexOf(';', i - 1) + 1
        continue
      }
      var c = e.slice(o, i).trim()
      if (n[c] === void 0) {
        var u = e.slice(i + 1, a).trim()
        u.charCodeAt(0) === 34 && (u = u.slice(1, -1)), (n[c] = ase(u, s))
      }
      o = a + 1
    }
    return n
  }
  function rse(e, t, n) {
    var r = n || {},
      s = r.encode || ose
    if (typeof s != 'function') throw new TypeError('option encode is invalid')
    if (!Ip.test(e)) throw new TypeError('argument name is invalid')
    var o = s(t)
    if (o && !Ip.test(o)) throw new TypeError('argument val is invalid')
    var i = e + '=' + o
    if (r.maxAge != null) {
      var a = r.maxAge - 0
      if (isNaN(a) || !isFinite(a))
        throw new TypeError('option maxAge is invalid')
      i += '; Max-Age=' + Math.floor(a)
    }
    if (r.domain) {
      if (!Ip.test(r.domain)) throw new TypeError('option domain is invalid')
      i += '; Domain=' + r.domain
    }
    if (r.path) {
      if (!Ip.test(r.path)) throw new TypeError('option path is invalid')
      i += '; Path=' + r.path
    }
    if (r.expires) {
      var c = r.expires
      if (!ise(c) || isNaN(c.valueOf()))
        throw new TypeError('option expires is invalid')
      i += '; Expires=' + c.toUTCString()
    }
    if (
      (r.httpOnly && (i += '; HttpOnly'),
      r.secure && (i += '; Secure'),
      r.priority)
    ) {
      var u =
        typeof r.priority == 'string' ? r.priority.toLowerCase() : r.priority
      switch (u) {
        case 'low':
          i += '; Priority=Low'
          break
        case 'medium':
          i += '; Priority=Medium'
          break
        case 'high':
          i += '; Priority=High'
          break
        default:
          throw new TypeError('option priority is invalid')
      }
    }
    if (r.sameSite) {
      var d =
        typeof r.sameSite == 'string' ? r.sameSite.toLowerCase() : r.sameSite
      switch (d) {
        case !0:
          i += '; SameSite=Strict'
          break
        case 'lax':
          i += '; SameSite=Lax'
          break
        case 'strict':
          i += '; SameSite=Strict'
          break
        case 'none':
          i += '; SameSite=None'
          break
        default:
          throw new TypeError('option sameSite is invalid')
      }
    }
    return i
  }
  function sse(e) {
    return e.indexOf('%') !== -1 ? decodeURIComponent(e) : e
  }
  function ose(e) {
    return encodeURIComponent(e)
  }
  function ise(e) {
    return tse.call(e) === '[object Date]' || e instanceof Date
  }
  function ase(e, t) {
    try {
      return t(e)
    } catch {
      return e
    }
  }
})
var hu = l((Ai) => {
  var { _optionalChain: cse } = Se()
  Object.defineProperty(Ai, '__esModule', { value: !0 })
  var xp = O(),
    dse = rk(),
    use = require('url'),
    lse = { ip: !1, request: !0, transaction: !0, user: !0 },
    mse = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'],
    sk = ['id', 'username', 'email']
  function KC(e, t = {}) {
    let n = e.method && e.method.toUpperCase(),
      r = '',
      s = 'url'
    t.customRoute || e.route
      ? ((r = t.customRoute || `${e.baseUrl || ''}${e.route && e.route.path}`),
        (s = 'route'))
      : (e.originalUrl || e.url) &&
        (r = xp.stripUrlQueryAndFragment(e.originalUrl || e.url || ''))
    let o = ''
    return (
      t.method && n && (o += n),
      t.method && t.path && (o += ' '),
      t.path && r && (o += r),
      [o, s]
    )
  }
  function pse(e, t) {
    switch (t) {
      case 'path':
        return KC(e, { path: !0 })[0]
      case 'handler':
        return (
          (e.route &&
            e.route.stack &&
            e.route.stack[0] &&
            e.route.stack[0].name) ||
          '<anonymous>'
        )
      case 'methodPath':
      default: {
        let n = e._reconstructedRoute ? e._reconstructedRoute : void 0
        return KC(e, { path: !0, method: !0, customRoute: n })[0]
      }
    }
  }
  function _se(e, t) {
    let n = {}
    return (
      (Array.isArray(t) ? t : sk).forEach((s) => {
        e && s in e && (n[s] = e[s])
      }),
      n
    )
  }
  function XC(e, t) {
    let { include: n = mse } = t || {},
      r = {},
      s = e.headers || {},
      o = e.method,
      i = e.hostname || e.host || s.host || '<no host>',
      a =
        e.protocol === 'https' || (e.socket && e.socket.encrypted)
          ? 'https'
          : 'http',
      c = e.originalUrl || e.url || '',
      u = c.startsWith(a) ? c : `${a}://${i}${c}`
    return (
      n.forEach((d) => {
        switch (d) {
          case 'headers': {
            ;(r.headers = s), n.includes('cookies') || delete r.headers.cookie
            break
          }
          case 'method': {
            r.method = o
            break
          }
          case 'url': {
            r.url = u
            break
          }
          case 'cookies': {
            r.cookies = e.cookies || (s.cookie && dse.parse(s.cookie)) || {}
            break
          }
          case 'query_string': {
            r.query_string = hse(e)
            break
          }
          case 'data': {
            if (o === 'GET' || o === 'HEAD') break
            e.body !== void 0 &&
              (r.data = xp.isString(e.body)
                ? e.body
                : JSON.stringify(xp.normalize(e.body)))
            break
          }
          default:
            ;({}).hasOwnProperty.call(e, d) && (r[d] = e[d])
        }
      }),
      r
    )
  }
  function fse(e, t, n) {
    let r = { ...lse, ...cse([n, 'optionalAccess', (s) => s.include]) }
    if (r.request) {
      let s = Array.isArray(r.request) ? XC(t, { include: r.request }) : XC(t)
      e.request = { ...e.request, ...s }
    }
    if (r.user) {
      let s = t.user && xp.isPlainObject(t.user) ? _se(t.user, r.user) : {}
      Object.keys(s).length && (e.user = { ...e.user, ...s })
    }
    if (r.ip) {
      let s = t.ip || (t.socket && t.socket.remoteAddress)
      s && (e.user = { ...e.user, ip_address: s })
    }
    return (
      r.transaction &&
        !e.transaction &&
        (e.transaction = pse(t, r.transaction)),
      e
    )
  }
  function hse(e) {
    let t = e.originalUrl || e.url || ''
    if (t)
      return (
        t.startsWith('/') && (t = `http://dogs.are.great${t}`),
        e.query || new use.URL(t).search.replace('?', '') || void 0
      )
  }
  Ai.DEFAULT_USER_INCLUDES = sk
  Ai.addRequestDataToEvent = fse
  Ai.extractPathForTransaction = KC
  Ai.extractRequestData = XC
})
var ZC = l((QC) => {
  Object.defineProperty(QC, '__esModule', { value: !0 })
  var gse = O(),
    yse = hu(),
    JC = {
      include: {
        cookies: !0,
        data: !0,
        headers: !0,
        ip: !1,
        query_string: !0,
        url: !0,
        user: { id: !0, username: !0, email: !0 },
      },
      transactionNamingScheme: 'methodPath',
    },
    Pp = class e {
      static __initStatic() {
        this.id = 'RequestData'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          (this._addRequestData = yse.addRequestDataToEvent),
          (this._options = {
            ...JC,
            ...t,
            include: {
              method: !0,
              ...JC.include,
              ...t.include,
              user:
                t.include && typeof t.include.user == 'boolean'
                  ? t.include.user
                  : { ...JC.include.user, ...(t.include || {}).user },
            },
          })
      }
      setupOnce(t, n) {
        let { transactionNamingScheme: r } = this._options
        t((s) => {
          let o = n(),
            i = o.getIntegration(e),
            { sdkProcessingMetadata: a = {} } = s,
            c = a.request
          if (!i || !c) return s
          let u =
              a.requestDataOptionsFromExpressHandler ||
              a.requestDataOptionsFromGCPWrapper ||
              Ese(this._options),
            d = this._addRequestData(s, c, u)
          if (s.type === 'transaction' || r === 'handler') return d
          let _ = c._sentryTransaction
          if (_) {
            let f =
                Sse(o) === 'sentry.javascript.nextjs'
                  ? _.name.startsWith('/api')
                  : r !== 'path',
              [h] = gse.extractPathForTransaction(c, {
                path: !0,
                method: f,
                customRoute: _.name,
              })
            d.transaction = h
          }
          return d
        })
      }
    }
  Pp.__initStatic()
  function Ese(e) {
    let {
        transactionNamingScheme: t,
        include: { ip: n, user: r, ...s },
      } = e,
      o = []
    for (let [a, c] of Object.entries(s)) c && o.push(a)
    let i
    if (r === void 0) i = !0
    else if (typeof r == 'boolean') i = r
    else {
      let a = []
      for (let [c, u] of Object.entries(r)) u && a.push(c)
      i = a
    }
    return {
      include: {
        ip: n,
        user: i,
        request: o.length !== 0 ? o : void 0,
        transaction: t,
      },
    }
  }
  function Sse(e) {
    try {
      return e.getClient().getOptions()._metadata.sdk.name
    } catch {
      return
    }
  }
  QC.RequestData = Pp
})
var r0 = l((gu) => {
  var { _optionalChain: Ie } = Se()
  Object.defineProperty(gu, '__esModule', { value: !0 })
  var e0 = O(),
    bse = pu(),
    vse = Pi()
  function ik(e, t, n) {
    let r = 0,
      s = 5,
      o = 0
    return (
      setInterval(() => {
        o === 0
          ? r > e && ((s *= 2), n(s), s > 86400 && (s = 86400), (o = s))
          : ((o -= 1), o === 0 && t()),
          (r = 0)
      }, 1e3).unref(),
      () => {
        r += 1
      }
    )
  }
  function n0(e) {
    let t = [],
      n = !1
    function r(i) {
      ;(t = []), !n && ((n = !0), e(i))
    }
    t.push(r)
    function s(i) {
      t.push(i)
    }
    function o(i) {
      let a = t.pop() || r
      try {
        a(i)
      } catch {
        r(i)
      }
    }
    return { add: s, next: o }
  }
  var t0 = class {
    constructor() {
      let { Session: t } = require('inspector')
      this._session = new t()
    }
    configureAndConnect(t, n) {
      this._session.connect(),
        this._session.on('Debugger.paused', (r) => {
          t(r, () => {
            this._session.post('Debugger.resume')
          })
        }),
        this._session.post('Debugger.enable'),
        this._session.post('Debugger.setPauseOnExceptions', {
          state: n ? 'all' : 'uncaught',
        })
    }
    setPauseOnExceptions(t) {
      this._session.post('Debugger.setPauseOnExceptions', {
        state: t ? 'all' : 'uncaught',
      })
    }
    getLocalVariables(t, n) {
      this._getProperties(t, (r) => {
        let { add: s, next: o } = n0(n)
        for (let i of r)
          if (
            Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'optionalAccess',
              (a) => a.objectId,
            ]) &&
            Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'access',
              (a) => a.className,
            ]) === 'Array'
          ) {
            let a = i.value.objectId
            s((c) => this._unrollArray(a, i.name, c, o))
          } else if (
            Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'optionalAccess',
              (a) => a.objectId,
            ]) &&
            Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'optionalAccess',
              (a) => a.className,
            ]) === 'Object'
          ) {
            let a = i.value.objectId
            s((c) => this._unrollObject(a, i.name, c, o))
          } else
            (Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'optionalAccess',
              (a) => a.value,
            ]) ||
              Ie([
                i,
                'optionalAccess',
                (a) => a.value,
                'optionalAccess',
                (a) => a.description,
              ])) &&
              s((a) => this._unrollOther(i, a, o))
        o({})
      })
    }
    _getProperties(t, n) {
      this._session.post(
        'Runtime.getProperties',
        { objectId: t, ownProperties: !0 },
        (r, s) => {
          n(r ? [] : s.result)
        },
      )
    }
    _unrollArray(t, n, r, s) {
      this._getProperties(t, (o) => {
        ;(r[n] = o
          .filter((i) => i.name !== 'length' && !isNaN(parseInt(i.name, 10)))
          .sort((i, a) => parseInt(i.name, 10) - parseInt(a.name, 10))
          .map((i) =>
            Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'optionalAccess',
              (a) => a.value,
            ]),
          )),
          s(r)
      })
    }
    _unrollObject(t, n, r, s) {
      this._getProperties(t, (o) => {
        ;(r[n] = o
          .map((i) => [
            i.name,
            Ie([
              i,
              'optionalAccess',
              (a) => a.value,
              'optionalAccess',
              (a) => a.value,
            ]),
          ])
          .reduce((i, [a, c]) => ((i[a] = c), i), {})),
          s(r)
      })
    }
    _unrollOther(t, n, r) {
      Ie([
        t,
        'optionalAccess',
        (s) => s.value,
        'optionalAccess',
        (s) => s.value,
      ])
        ? (n[t.name] = t.value.value)
        : Ie([
            t,
            'optionalAccess',
            (s) => s.value,
            'optionalAccess',
            (s) => s.description,
          ]) &&
          Ie([
            t,
            'optionalAccess',
            (s) => s.value,
            'optionalAccess',
            (s) => s.type,
          ]) !== 'function' &&
          (n[t.name] = `<${t.value.description}>`),
        r(n)
    }
  }
  function Cse() {
    try {
      return new t0()
    } catch {
      return
    }
  }
  function ok(e) {
    return e !== void 0 && ['', '?', '<anonymous>'].includes(e)
  }
  function Tse(e, t) {
    return e === t || (ok(e) && ok(t))
  }
  function ak(e) {
    if (e !== void 0)
      return e
        .slice(-10)
        .reduce((t, n) => `${t},${n.function},${n.lineno},${n.colno}`, '')
  }
  function wse(e, t) {
    if (t !== void 0) return ak(e(t, 1))
  }
  var Rp = class e {
    static __initStatic() {
      this.id = 'LocalVariables'
    }
    __init() {
      this.name = e.id
    }
    __init2() {
      this._cachedFrames = new bse.LRUMap(20)
    }
    constructor(t = {}, n = Cse()) {
      ;(this._options = t),
        (this._session = n),
        e.prototype.__init.call(this),
        e.prototype.__init2.call(this)
    }
    setupOnce(t, n) {
      this._setup(
        t,
        Ie([
          n,
          'call',
          (r) => r(),
          'access',
          (r) => r.getClient,
          'call',
          (r) => r(),
          'optionalAccess',
          (r) => r.getOptions,
          'call',
          (r) => r(),
        ]),
      )
    }
    _setup(t, n) {
      if (
        this._session &&
        Ie([n, 'optionalAccess', (r) => r.includeLocalVariables])
      ) {
        if ((vse.NODE_VERSION.major || 0) < 18) {
          e0.logger.log(
            'The `LocalVariables` integration is only supported on Node >= v18.',
          )
          return
        }
        let s = this._options.captureAllExceptions !== !1
        if (
          (this._session.configureAndConnect(
            (o, i) => this._handlePaused(n.stackParser, o, i),
            s,
          ),
          s)
        ) {
          let o = this._options.maxExceptionsPerSecond || 50
          this._rateLimiter = ik(
            o,
            () => {
              e0.logger.log('Local variables rate-limit lifted.'),
                Ie([
                  this,
                  'access',
                  (i) => i._session,
                  'optionalAccess',
                  (i) => i.setPauseOnExceptions,
                  'call',
                  (i) => i(!0),
                ])
            },
            (i) => {
              e0.logger.log(
                `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${i} seconds.`,
              ),
                Ie([
                  this,
                  'access',
                  (a) => a._session,
                  'optionalAccess',
                  (a) => a.setPauseOnExceptions,
                  'call',
                  (a) => a(!1),
                ])
            },
          )
        }
        t(async (o) => this._addLocalVariables(o))
      }
    }
    _handlePaused(t, { params: { reason: n, data: r, callFrames: s } }, o) {
      if (n !== 'exception' && n !== 'promiseRejection') {
        o()
        return
      }
      Ie([this, 'access', (u) => u._rateLimiter, 'optionalCall', (u) => u()])
      let i = wse(t, Ie([r, 'optionalAccess', (u) => u.description]))
      if (i == null) {
        o()
        return
      }
      let { add: a, next: c } = n0((u) => {
        this._cachedFrames.set(i, u), o()
      })
      for (let u = 0; u < Math.min(s.length, 5); u++) {
        let { scopeChain: d, functionName: p, this: _ } = s[u],
          f = d.find((y) => y.type === 'local'),
          h =
            _.className === 'global' || !_.className ? p : `${_.className}.${p}`
        if (
          Ie([
            f,
            'optionalAccess',
            (y) => y.object,
            'access',
            (y) => y.objectId,
          ]) === void 0
        )
          a((y) => {
            ;(y[u] = { function: h }), c(y)
          })
        else {
          let y = f.object.objectId
          a((E) =>
            Ie([
              this,
              'access',
              (C) => C._session,
              'optionalAccess',
              (C) => C.getLocalVariables,
              'call',
              (C) =>
                C(y, (A) => {
                  ;(E[u] = { function: h, vars: A }), c(E)
                }),
            ]),
          )
        }
      }
      c([])
    }
    _addLocalVariables(t) {
      for (let n of Ie([
        t,
        'optionalAccess',
        (r) => r.exception,
        'optionalAccess',
        (r) => r.values,
      ]) || [])
        this._addLocalVariablesToException(n)
      return t
    }
    _addLocalVariablesToException(t) {
      let n = ak(
        Ie([
          t,
          'optionalAccess',
          (o) => o.stacktrace,
          'optionalAccess',
          (o) => o.frames,
        ]),
      )
      if (n === void 0) return
      let r = this._cachedFrames.delete(n)
      if (r === void 0) return
      let s =
        Ie([
          t,
          'access',
          (o) => o.stacktrace,
          'optionalAccess',
          (o) => o.frames,
          'optionalAccess',
          (o) => o.length,
        ]) || 0
      for (let o = 0; o < s; o++) {
        let i = s - o - 1
        if (
          !Ie([
            t,
            'optionalAccess',
            (a) => a.stacktrace,
            'optionalAccess',
            (a) => a.frames,
            'optionalAccess',
            (a) => a[i],
          ]) ||
          !r[o]
        )
          break
        r[o].vars === void 0 ||
          t.stacktrace.frames[i].in_app === !1 ||
          !Tse(t.stacktrace.frames[i].function, r[o].function) ||
          (t.stacktrace.frames[i].vars = r[o].vars)
      }
    }
  }
  Rp.__initStatic()
  gu.LocalVariables = Rp
  gu.createCallbackList = n0
  gu.createRateLimiter = ik
})
var s0 = l((fr, mk) => {
  var { _optionalChain: lk } = Se()
  Object.defineProperty(fr, '__esModule', { value: !0 })
  var go = we(),
    yo = O(),
    ck = pu(),
    dk = Pi()
  fr.ChannelName = void 0
  ;(function (e) {
    let t = 'undici:request:create'
    e.RequestCreate = t
    let n = 'undici:request:headers'
    e.RequestEnd = n
    let r = 'undici:request:error'
    e.RequestError = r
  })(fr.ChannelName || (fr.ChannelName = {}))
  var Dp = class e {
    static __initStatic() {
      this.id = 'Undici'
    }
    __init() {
      this.name = e.id
    }
    __init2() {
      this._createSpanUrlMap = new ck.LRUMap(100)
    }
    __init3() {
      this._headersUrlMap = new ck.LRUMap(100)
    }
    constructor(t = {}) {
      e.prototype.__init.call(this),
        e.prototype.__init2.call(this),
        e.prototype.__init3.call(this),
        e.prototype.__init4.call(this),
        e.prototype.__init5.call(this),
        e.prototype.__init6.call(this),
        (this._options = {
          breadcrumbs: t.breadcrumbs === void 0 ? !0 : t.breadcrumbs,
          shouldCreateSpanForRequest: t.shouldCreateSpanForRequest,
        })
    }
    setupOnce(t) {
      if (dk.NODE_VERSION.major && dk.NODE_VERSION.major < 16) return
      let n
      try {
        n = yo.dynamicRequire(mk, 'diagnostics_channel')
      } catch {}
      !n ||
        !n.subscribe ||
        (n.subscribe(fr.ChannelName.RequestCreate, this._onRequestCreate),
        n.subscribe(fr.ChannelName.RequestEnd, this._onRequestEnd),
        n.subscribe(fr.ChannelName.RequestError, this._onRequestError))
    }
    _shouldCreateSpan(t) {
      if (this._options.shouldCreateSpanForRequest === void 0) return !0
      let n = this._createSpanUrlMap.get(t)
      if (n !== void 0) return n
      let r = this._options.shouldCreateSpanForRequest(t)
      return this._createSpanUrlMap.set(t, r), r
    }
    __init4() {
      this._onRequestCreate = (t) => {
        let n = go.getCurrentHub()
        if (!n.getIntegration(e)) return
        let { request: r } = t,
          s = r.origin ? r.origin.toString() + r.path : r.path
        if (go.isSentryRequestUrl(s, n) || r.__sentry_span__ !== void 0) return
        let o = n.getClient()
        if (!o) return
        let i = o.getOptions(),
          a = n.getScope(),
          c = a.getSpan(),
          u = this._shouldCreateSpan(s) ? Ise(c, r, s) : void 0
        if (
          (u && (r.__sentry_span__ = u),
          ((p) => {
            if (i.tracePropagationTargets === void 0) return !0
            let _ = this._headersUrlMap.get(p)
            if (_ !== void 0) return _
            let f = yo.stringMatchesSomePattern(p, i.tracePropagationTargets)
            return this._headersUrlMap.set(p, f), f
          })(s))
        )
          if (u) {
            let p = lk([
                u,
                'optionalAccess',
                (f) => f.transaction,
                'optionalAccess',
                (f) => f.getDynamicSamplingContext,
                'call',
                (f) => f(),
              ]),
              _ = yo.dynamicSamplingContextToSentryBaggageHeader(p)
            uk(r, u.toTraceparent(), _)
          } else {
            let { traceId: p, sampled: _, dsc: f } = a.getPropagationContext(),
              h = yo.generateSentryTraceHeader(p, void 0, _),
              y = f || go.getDynamicSamplingContextFromClient(p, o, a),
              E = yo.dynamicSamplingContextToSentryBaggageHeader(y)
            uk(r, h, E)
          }
      }
    }
    __init5() {
      this._onRequestEnd = (t) => {
        let n = go.getCurrentHub()
        if (!n.getIntegration(e)) return
        let { request: r, response: s } = t,
          o = r.origin ? r.origin.toString() + r.path : r.path
        if (go.isSentryRequestUrl(o, n)) return
        let i = r.__sentry_span__
        i && (i.setHttpStatus(s.statusCode), i.finish()),
          this._options.breadcrumbs &&
            n.addBreadcrumb(
              {
                category: 'http',
                data: { method: r.method, status_code: s.statusCode, url: o },
                type: 'http',
              },
              { event: 'response', request: r, response: s },
            )
      }
    }
    __init6() {
      this._onRequestError = (t) => {
        let n = go.getCurrentHub()
        if (!n.getIntegration(e)) return
        let { request: r } = t,
          s = r.origin ? r.origin.toString() + r.path : r.path
        if (go.isSentryRequestUrl(s, n)) return
        let o = r.__sentry_span__
        o && (o.setStatus('internal_error'), o.finish()),
          this._options.breadcrumbs &&
            n.addBreadcrumb(
              {
                category: 'http',
                data: { method: r.method, url: s },
                level: 'error',
                type: 'http',
              },
              { event: 'error', request: r },
            )
      }
    }
  }
  Dp.__initStatic()
  function uk(e, t, n) {
    e.__sentry_has_headers__ ||
      (e.addHeader('sentry-trace', t),
      n && e.addHeader('baggage', n),
      (e.__sentry_has_headers__ = !0))
  }
  function Ise(e, t, n) {
    let r = yo.parseUrl(n),
      s = t.method || 'GET',
      o = { 'http.method': s }
    return (
      r.search && (o['http.query'] = r.search),
      r.hash && (o['http.fragment'] = r.hash),
      lk([
        e,
        'optionalAccess',
        (i) => i.startChild,
        'call',
        (i) =>
          i({
            op: 'http.client',
            origin: 'auto.http.node.undici',
            description: `${s} ${yo.getSanitizedUrlString(r)}`,
            data: o,
          }),
      ])
    )
  }
  fr.Undici = Dp
})
var o0 = l((bo) => {
  var { _optionalChain: xse } = Se()
  Object.defineProperty(bo, '__esModule', { value: !0 })
  var Eo = we(),
    So = O(),
    Pse = SC(),
    Rse = k1(),
    Dse = Qv(),
    Ase = xC(),
    Ose = AC(),
    Nse = MC(),
    qse = UC(),
    kse = BC(),
    Mse = $C(),
    Lse = VC(),
    Use = YC(),
    Fse = ZC(),
    Bse = r0(),
    jse = s0(),
    Gse = mp(),
    $se = mC(),
    pk = [
      new Eo.Integrations.InboundFilters(),
      new Eo.Integrations.FunctionToString(),
      new Ase.Console(),
      new Ose.Http(),
      new jse.Undici(),
      new Nse.OnUncaughtException(),
      new qse.OnUnhandledRejection(),
      new Lse.ContextLines(),
      new Bse.LocalVariables(),
      new Use.Context(),
      new Mse.Modules(),
      new Fse.RequestData(),
      new kse.LinkedErrors(),
    ]
  function zse(e = {}) {
    Pse.isAnrChildProcess() &&
      ((e.autoSessionTracking = !1), (e.tracesSampleRate = 0))
    let t = Eo.getMainCarrier()
    Rse.setNodeAsyncContextStrategy()
    let n =
      xse([
        t,
        'access',
        (o) => o.__SENTRY__,
        'optionalAccess',
        (o) => o.integrations,
      ]) || []
    ;(e.defaultIntegrations =
      e.defaultIntegrations === !1
        ? []
        : [
            ...(Array.isArray(e.defaultIntegrations)
              ? e.defaultIntegrations
              : pk),
            ...n,
          ]),
      e.dsn === void 0 &&
        process.env.SENTRY_DSN &&
        (e.dsn = process.env.SENTRY_DSN)
    let r = process.env.SENTRY_TRACES_SAMPLE_RATE
    if (e.tracesSampleRate === void 0 && r) {
      let o = parseFloat(r)
      isFinite(o) && (e.tracesSampleRate = o)
    }
    if (e.release === void 0) {
      let o = _k()
      o !== void 0 ? (e.release = o) : (e.autoSessionTracking = !1)
    }
    e.environment === void 0 &&
      process.env.SENTRY_ENVIRONMENT &&
      (e.environment = process.env.SENTRY_ENVIRONMENT),
      e.autoSessionTracking === void 0 &&
        e.dsn !== void 0 &&
        (e.autoSessionTracking = !0),
      e.instrumenter === void 0 && (e.instrumenter = 'sentry')
    let s = {
      ...e,
      stackParser: So.stackParserFromStackParserOptions(e.stackParser || fk),
      integrations: Eo.getIntegrationsToSetup(e),
      transport: e.transport || $se.makeNodeTransport,
    }
    Eo.initAndBind(e.clientClass || Dse.NodeClient, s),
      e.autoSessionTracking && Vse(),
      Yse()
  }
  function Hse(e) {
    if (e === void 0) return !1
    let t = e && e.getOptions()
    return t && t.autoSessionTracking !== void 0 ? t.autoSessionTracking : !1
  }
  function _k(e) {
    return process.env.SENTRY_RELEASE
      ? process.env.SENTRY_RELEASE
      : So.GLOBAL_OBJ.SENTRY_RELEASE && So.GLOBAL_OBJ.SENTRY_RELEASE.id
        ? So.GLOBAL_OBJ.SENTRY_RELEASE.id
        : process.env.GITHUB_SHA ||
          process.env.COMMIT_REF ||
          process.env.VERCEL_GIT_COMMIT_SHA ||
          process.env.VERCEL_GITHUB_COMMIT_SHA ||
          process.env.VERCEL_GITLAB_COMMIT_SHA ||
          process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
          process.env.ZEIT_GITHUB_COMMIT_SHA ||
          process.env.ZEIT_GITLAB_COMMIT_SHA ||
          process.env.ZEIT_BITBUCKET_COMMIT_SHA ||
          e
  }
  var fk = So.createStackParser(
    So.nodeStackLineParser(Gse.getModuleFromFilename),
  )
  function Vse() {
    let e = Eo.getCurrentHub()
    e.startSession(),
      process.on('beforeExit', () => {
        let t = e.getScope().getSession()
        t && !['exited', 'crashed'].includes(t.status) && e.endSession()
      })
  }
  function Yse() {
    let e = (process.env.SENTRY_USE_ENVIRONMENT || '').toLowerCase()
    if (!['false', 'n', 'no', 'off', '0'].includes(e)) {
      let t = process.env.SENTRY_TRACE,
        n = process.env.SENTRY_BAGGAGE,
        { propagationContext: r } = So.tracingContextFromHeaders(t, n)
      Eo.getCurrentHub().getScope().setPropagationContext(r)
    }
  }
  bo.defaultIntegrations = pk
  bo.defaultStackParser = fk
  bo.getSentryRelease = _k
  bo.init = zse
  bo.isAutoSessionTrackingEnabled = Hse
})
var hk = l((a0) => {
  Object.defineProperty(a0, '__esModule', { value: !0 })
  var Ap = require('fs'),
    i0 = require('path')
  function Wse(e) {
    let t = i0.resolve(e)
    if (!Ap.existsSync(t))
      throw new Error(`Cannot read contents of ${t}. Directory does not exist.`)
    if (!Ap.statSync(t).isDirectory())
      throw new Error(
        `Cannot read contents of ${t}, because it is not a directory.`,
      )
    let n = (r) =>
      Ap.readdirSync(r).reduce((s, o) => {
        let i = i0.join(r, o)
        return Ap.statSync(i).isDirectory() ? s.concat(n(i)) : (s.push(i), s)
      }, [])
    return n(t).map((r) => i0.relative(t, r))
  }
  a0.deepReadDirSync = Wse
})
var yk = l((Op) => {
  Object.defineProperty(Op, '__esModule', { value: !0 })
  var gk = hu()
  function Kse(e, t) {
    return gk.extractRequestData(e, { include: t })
  }
  function Xse(e, t, n = {}) {
    return gk.addRequestDataToEvent(e, t, { include: n })
  }
  Op.extractRequestData = Kse
  Op.parseRequest = Xse
})
var Sk = l((es) => {
  var { _optionalChain: Oi } = Se()
  Object.defineProperty(es, '__esModule', { value: !0 })
  var un = we(),
    Zr = O(),
    Jse = hu(),
    Np = o0(),
    Ek = yk()
  function Qse() {
    return function (t, n, r) {
      let s = un.getCurrentHub(),
        o = Oi([
          s,
          'access',
          (h) => h.getClient,
          'call',
          (h) => h(),
          'optionalAccess',
          (h) => h.getOptions,
          'call',
          (h) => h(),
        ])
      if (
        !o ||
        o.instrumenter !== 'sentry' ||
        Oi([
          t,
          'access',
          (h) => h.method,
          'optionalAccess',
          (h) => h.toUpperCase,
          'call',
          (h) => h(),
        ]) === 'OPTIONS' ||
        Oi([
          t,
          'access',
          (h) => h.method,
          'optionalAccess',
          (h) => h.toUpperCase,
          'call',
          (h) => h(),
        ]) === 'HEAD'
      )
        return r()
      let i =
          t.headers && Zr.isString(t.headers['sentry-trace'])
            ? t.headers['sentry-trace']
            : void 0,
        a = Oi([
          t,
          'access',
          (h) => h.headers,
          'optionalAccess',
          (h) => h.baggage,
        ]),
        {
          traceparentData: c,
          dynamicSamplingContext: u,
          propagationContext: d,
        } = Zr.tracingContextFromHeaders(i, a)
      if ((s.getScope().setPropagationContext(d), !un.hasTracingEnabled(o)))
        return r()
      let [p, _] = Zr.extractPathForTransaction(t, { path: !0, method: !0 }),
        f = un.startTransaction(
          {
            name: p,
            op: 'http.server',
            origin: 'auto.http.node.tracingHandler',
            ...c,
            metadata: {
              dynamicSamplingContext: c && !u ? {} : u,
              request: t,
              source: _,
            },
          },
          { request: Jse.extractRequestData(t) },
        )
      s.configureScope((h) => {
        h.setSpan(f)
      }),
        (n.__sentry_transaction = f),
        n.once('finish', () => {
          setImmediate(() => {
            Zr.addRequestDataToTransaction(f, t),
              f.setHttpStatus(n.statusCode),
              f.finish()
          })
        }),
        r()
    }
  }
  function Zse(e = {}) {
    let t
    if ('include' in e) t = { include: e.include }
    else {
      let { ip: n, request: r, transaction: s, user: o } = e
      ;(n || r || s || o) &&
        (t = {
          include: Zr.dropUndefinedKeys({
            ip: n,
            request: r,
            transaction: s,
            user: o,
          }),
        })
    }
    return t
  }
  function eoe(e) {
    let t = Zse(e),
      n = un.getCurrentHub(),
      r = n.getClient()
    if (r && Np.isAutoSessionTrackingEnabled(r)) {
      r.initSessionFlusher()
      let s = n.getScope()
      s.getSession() && s.setSession()
    }
    return function (o, i, a) {
      if (e && e.flushTimeout && e.flushTimeout > 0) {
        let c = i.end
        i.end = function (u, d, p) {
          un.flush(e.flushTimeout)
            .then(() => {
              c.call(this, u, d, p)
            })
            .then(null, (_) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Zr.logger.error(_),
                c.call(this, u, d, p)
            })
        }
      }
      un.runWithAsyncContext(() => {
        let c = un.getCurrentHub()
        c.configureScope((u) => {
          u.setSDKProcessingMetadata({
            request: o,
            requestDataOptionsFromExpressHandler: t,
          })
          let d = c.getClient()
          Np.isAutoSessionTrackingEnabled(d) &&
            c.getScope().setRequestSession({ status: 'ok' })
        }),
          i.once('finish', () => {
            let u = c.getClient()
            Np.isAutoSessionTrackingEnabled(u) &&
              setImmediate(() => {
                u && u._captureRequestSession && u._captureRequestSession()
              })
          }),
          a()
      })
    }
  }
  function toe(e) {
    let t =
      e.status ||
      e.statusCode ||
      e.status_code ||
      (e.output && e.output.statusCode)
    return t ? parseInt(t, 10) : 500
  }
  function noe(e) {
    return toe(e) >= 500
  }
  function roe(e) {
    return function (n, r, s, o) {
      if (((e && e.shouldHandleError) || noe)(n)) {
        un.withScope((a) => {
          a.setSDKProcessingMetadata({ request: r })
          let c = s.__sentry_transaction
          c && a.getSpan() === void 0 && a.setSpan(c)
          let u = un.getCurrentHub().getClient()
          if (
            u &&
            Np.isAutoSessionTrackingEnabled(u) &&
            u._sessionFlusher !== void 0
          ) {
            let _ = a.getRequestSession()
            _ && _.status !== void 0 && (_.status = 'crashed')
          }
          a.addEventProcessor(
            (p) => (
              Zr.addExceptionMechanism(p, { type: 'middleware', handled: !1 }),
              p
            ),
          )
          let d = un.captureException(n)
          ;(s.sentry = d), o(n)
        })
        return
      }
      o(n)
    }
  }
  function soe(e = {}) {
    return function ({ path: t, type: n, next: r, rawInput: s }) {
      let o = un.getCurrentHub(),
        i = Oi([
          o,
          'access',
          (c) => c.getClient,
          'call',
          (c) => c(),
          'optionalAccess',
          (c) => c.getOptions,
          'call',
          (c) => c(),
        ]),
        a = o.getScope().getTransaction()
      if (a) {
        a.setName(`trpc/${t}`, 'route'), (a.op = 'rpc.server')
        let c = { procedure_type: n }
        ;(e.attachRpcInput !== void 0
          ? e.attachRpcInput
          : Oi([i, 'optionalAccess', (u) => u.sendDefaultPii])) &&
          (c.input = Zr.normalize(s)),
          a.setContext('trpc', c)
      }
      return r()
    }
  }
  es.extractRequestData = Ek.extractRequestData
  es.parseRequest = Ek.parseRequest
  es.errorHandler = roe
  es.requestHandler = eoe
  es.tracingHandler = Qse
  es.trpcMiddleware = soe
})
var bk = l((Ct) => {
  Object.defineProperty(Ct, '__esModule', { value: !0 })
  var ooe = xC(),
    ioe = AC(),
    aoe = MC(),
    coe = UC(),
    doe = BC(),
    uoe = $C(),
    loe = VC(),
    moe = YC(),
    poe = ZC(),
    _oe = r0(),
    foe = s0()
  Ct.Console = ooe.Console
  Ct.Http = ioe.Http
  Ct.OnUncaughtException = aoe.OnUncaughtException
  Ct.OnUnhandledRejection = coe.OnUnhandledRejection
  Ct.LinkedErrors = doe.LinkedErrors
  Ct.Modules = uoe.Modules
  Ct.ContextLines = loe.ContextLines
  Ct.Context = moe.Context
  Ct.RequestData = poe.RequestData
  Ct.LocalVariables = _oe.LocalVariables
  Ct.Undici = foe.Undici
})
var vk = l((hr) => {
  Object.defineProperty(hr, '__esModule', { value: !0 })
  var vo = Yv()
  hr.Apollo = vo.Apollo
  hr.Express = vo.Express
  hr.GraphQL = vo.GraphQL
  hr.Mongo = vo.Mongo
  hr.Mysql = vo.Mysql
  hr.Postgres = vo.Postgres
  hr.Prisma = vo.Prisma
})
var Dn = l((L) => {
  Object.defineProperty(L, '__esModule', { value: !0 })
  var te = we(),
    hoe = e1(),
    goe = Qv(),
    yoe = mC(),
    qp = o0(),
    c0 = hu(),
    Eoe = hk(),
    Soe = mp(),
    boe = SC(),
    voe = Sk(),
    Coe = bk(),
    Toe = vk(),
    woe = { ...te.Integrations, ...Coe, ...Toe }
  L.Hub = te.Hub
  L.SDK_VERSION = te.SDK_VERSION
  L.Scope = te.Scope
  L.addBreadcrumb = te.addBreadcrumb
  L.addGlobalEventProcessor = te.addGlobalEventProcessor
  L.addIntegration = te.addIntegration
  L.captureCheckIn = te.captureCheckIn
  L.captureEvent = te.captureEvent
  L.captureException = te.captureException
  L.captureMessage = te.captureMessage
  L.close = te.close
  L.configureScope = te.configureScope
  L.continueTrace = te.continueTrace
  L.createTransport = te.createTransport
  L.extractTraceparentData = te.extractTraceparentData
  L.flush = te.flush
  L.getActiveSpan = te.getActiveSpan
  L.getActiveTransaction = te.getActiveTransaction
  L.getCurrentHub = te.getCurrentHub
  L.getHubFromCarrier = te.getHubFromCarrier
  L.lastEventId = te.lastEventId
  L.makeMain = te.makeMain
  L.runWithAsyncContext = te.runWithAsyncContext
  L.setContext = te.setContext
  L.setExtra = te.setExtra
  L.setExtras = te.setExtras
  L.setMeasurement = te.setMeasurement
  L.setTag = te.setTag
  L.setTags = te.setTags
  L.setUser = te.setUser
  L.spanStatusfromHttpCode = te.spanStatusfromHttpCode
  L.startActiveSpan = te.startActiveSpan
  L.startInactiveSpan = te.startInactiveSpan
  L.startSpan = te.startSpan
  L.startSpanManual = te.startSpanManual
  L.startTransaction = te.startTransaction
  L.trace = te.trace
  L.withScope = te.withScope
  L.autoDiscoverNodePerformanceMonitoringIntegrations =
    hoe.autoDiscoverNodePerformanceMonitoringIntegrations
  L.NodeClient = goe.NodeClient
  L.makeNodeTransport = yoe.makeNodeTransport
  L.defaultIntegrations = qp.defaultIntegrations
  L.defaultStackParser = qp.defaultStackParser
  L.getSentryRelease = qp.getSentryRelease
  L.init = qp.init
  L.DEFAULT_USER_INCLUDES = c0.DEFAULT_USER_INCLUDES
  L.addRequestDataToEvent = c0.addRequestDataToEvent
  L.extractRequestData = c0.extractRequestData
  L.deepReadDirSync = Eoe.deepReadDirSync
  L.getModuleFromFilename = Soe.getModuleFromFilename
  L.enableAnrDetection = boe.enableAnrDetection
  L.Handlers = voe
  L.Integrations = woe
})
var u0 = l((d0) => {
  Object.defineProperty(d0, '__esModule', { value: !0 })
  var Ioe = Dn(),
    xoe = O(),
    kp = class e {
      static __initStatic() {
        this.id = 'AWSServices'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._optional = t.optional || !1)
      }
      setupOnce() {
        try {
          let t = require('aws-sdk/global')
          xoe.fill(t.Service.prototype, 'makeRequest', Poe)
        } catch (t) {
          if (!this._optional) throw t
        }
      }
    }
  kp.__initStatic()
  function Poe(e) {
    return function (t, n, r) {
      let s,
        i = Ioe.getCurrentHub().getScope().getTransaction(),
        a = e.call(this, t, n)
      return (
        a.on('afterBuild', () => {
          i &&
            (s = i.startChild({
              description: Roe(this, t, n),
              op: 'http.client',
              origin: 'auto.http.serverless',
            }))
        }),
        a.on('complete', () => {
          s && s.finish()
        }),
        r && a.send(r),
        a
      )
    }
  }
  function Roe(e, t, n) {
    let r = `aws.${e.serviceIdentifier}.${t}`
    if (n === void 0) return r
    switch (e.serviceIdentifier) {
      case 's3':
        r += Aoe(t, n)
        break
      case 'lambda':
        r += Doe(t, n)
        break
    }
    return r
  }
  function Doe(e, t) {
    let n = ''
    return 'FunctionName' in t && (n += ` ${t.FunctionName}`), n
  }
  function Aoe(e, t) {
    let n = ''
    return 'Bucket' in t && (n += ` ${t.Bucket}`), n
  }
  d0.AWSServices = kp
})
var qi = l((Ni) => {
  Object.defineProperty(Ni, '__esModule', { value: !0 })
  var Ooe = we(),
    Ck = O()
  function Noe(e) {
    return Ck.addExceptionMechanism(e, { handled: !1 }), e
  }
  function qoe(e) {
    return (...t) =>
      Ooe.runWithAsyncContext(() => e(...t), { reuseExisting: !0 })
  }
  function koe(e, t, n) {
    let r = t(e),
      s = { apply: (o, i, a) => r.apply(i, a) }
    return (
      n &&
        (s.get = (o, i) =>
          Object.prototype.hasOwnProperty.call(n, i) ? n[i] : o[i]),
      new Proxy(e, s)
    )
  }
  function Moe(e) {
    return (
      e.addEventProcessor(
        (t) => (Ck.addExceptionMechanism(t, { handled: !1 }), t),
      ),
      e
    )
  }
  Ni.domainify = qoe
  Ni.markEventUnhandled = Moe
  Ni.proxyFunction = koe
  Ni.serverlessEventProcessor = Noe
})
var Dk = l((ts) => {
  var { _optionalChain: Tk } = Se()
  Object.defineProperty(ts, '__esModule', { value: !0 })
  var Tt = Dn(),
    Co = O(),
    wk = require('fs'),
    Loe = require('os'),
    Ik = require('path'),
    xk = require('perf_hooks'),
    Uoe = require('util'),
    Foe = u0(),
    l0 = qi(),
    { isPromise: Boe } = Uoe.types,
    Pk = [...Tt.defaultIntegrations, new Foe.AWSServices({ optional: !0 })]
  function joe(e = {}) {
    let t = { _metadata: {}, defaultIntegrations: Pk, ...e }
    ;(t._metadata.sdk = t._metadata.sdk || {
      name: 'sentry.javascript.serverless',
      integrations: ['AWSLambda'],
      packages: [{ name: 'npm:@sentry/serverless', version: Tt.SDK_VERSION }],
      version: Tt.SDK_VERSION,
    }),
      Tt.init(t),
      Tt.addGlobalEventProcessor(l0.serverlessEventProcessor)
  }
  function Goe(e, t, n) {
    let r = Ik.resolve(e, t, n)
    return wk.existsSync(r) || wk.existsSync(`${r}.js`)
      ? require(r)
      : require(require.resolve(n, { paths: [e, t] }))
  }
  function $oe(e) {
    return e.every(
      (t) =>
        Object.prototype.hasOwnProperty.call(t, 'status') &&
        (Object.prototype.hasOwnProperty.call(t, 'value') ||
          Object.prototype.hasOwnProperty.call(t, 'reason')),
    )
  }
  function zoe(e) {
    return e.reduce(
      (t, n) => (n.status === 'rejected' && n.reason && t.push(n.reason), t),
      [],
    )
  }
  function Hoe(e, t) {
    let n = Ik.basename(t),
      r = n.match(/^([^.]*)\.(.*)$/)
    if (!r) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Co.logger.error(`Bad handler ${n}`)
      return
    }
    let [, s, o] = r,
      i
    try {
      let u = t.substring(0, t.indexOf(n))
      i = Goe(e, u, s)
    } catch (u) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Co.logger.error(`Cannot require ${t} in ${e}`, u)
      return
    }
    let a, c
    if (
      (o.split('.').forEach((u) => {
        ;(a = i), (i = i && i[u]), (c = u)
      }),
      !i)
    ) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Co.logger.error(`${t} is undefined or not exported`)
      return
    }
    if (typeof i != 'function') {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Co.logger.error(`${t} is not a function`)
      return
    }
    a[c] = Rk(i)
  }
  function m0(e) {
    return typeof e.getRemainingTimeInMillis == 'function'
      ? e.getRemainingTimeInMillis()
      : 0
  }
  function Voe(e, t, n) {
    e.setContext('aws.lambda', {
      aws_request_id: t.awsRequestId,
      function_name: t.functionName,
      function_version: t.functionVersion,
      invoked_function_arn: t.invokedFunctionArn,
      execution_duration_in_millis: xk.performance.now() - n,
      remaining_time_in_millis: m0(t),
      'sys.argv': process.argv,
    }),
      e.setContext('aws.cloudwatch.logs', {
        log_group: t.logGroupName,
        log_stream: t.logStreamName,
        url: `https://console.aws.amazon.com/cloudwatch/home?region=${
          process.env.AWS_REGION
        }#logsV2:log-groups/log-group/${encodeURIComponent(
          t.logGroupName,
        )}/log-events/${encodeURIComponent(t.logStreamName)}?filterPattern="${
          t.awsRequestId
        }"`,
      })
  }
  function Yoe(e, t) {
    e.setTransactionName(t.functionName),
      e.setTag(
        'server_name',
        process.env._AWS_XRAY_DAEMON_ADDRESS ||
          process.env.SENTRY_NAME ||
          Loe.hostname(),
      ),
      e.setTag('url', `awslambda:///${t.functionName}`)
  }
  function Rk(e, t = {}) {
    let n = xk.performance.now(),
      r = {
        flushTimeout: 2e3,
        callbackWaitsForEmptyEventLoop: !1,
        captureTimeoutWarning: !0,
        timeoutWarningLimit: 500,
        captureAllSettledReasons: !1,
        startTrace: !0,
        ...t,
      },
      s,
      o =
        e.length > 2
          ? (i, a) =>
              new Promise((c, u) => {
                let d = e(i, a, (p, _) => {
                  p == null ? c(_) : u(p)
                })
                Boe(d) && d.then(c, u)
              })
          : e
    return async (i, a) => {
      a.callbackWaitsForEmptyEventLoop = r.callbackWaitsForEmptyEventLoop
      let c = Math.ceil(m0(a) / 1e3),
        u = Math.floor(c / 60),
        d = c % 60,
        p = u > 0 ? `${u}m${d}s` : `${d}s`
      if (r.captureTimeoutWarning) {
        let E = m0(a) - r.timeoutWarningLimit
        s = setTimeout(() => {
          Tt.withScope((C) => {
            C.setTag('timeout', p),
              Tt.captureMessage(
                `Possible function timeout: ${a.functionName}`,
                'warning',
              )
          })
        }, E)
      }
      let _ = Tt.getCurrentHub(),
        f
      if (r.startTrace) {
        let E = i,
          C =
            E.headers && Co.isString(E.headers['sentry-trace'])
              ? E.headers['sentry-trace']
              : void 0,
          A = Tk([
            E,
            'access',
            (ee) => ee.headers,
            'optionalAccess',
            (ee) => ee.baggage,
          ]),
          {
            traceparentData: se,
            dynamicSamplingContext: Q,
            propagationContext: be,
          } = Co.tracingContextFromHeaders(C, A)
        _.getScope().setPropagationContext(be),
          (f = _.startTransaction({
            name: a.functionName,
            op: 'function.aws.lambda',
            origin: 'auto.function.serverless',
            ...se,
            metadata: {
              dynamicSamplingContext: se && !Q ? {} : Q,
              source: 'component',
            },
          }))
      }
      let h = _.pushScope(),
        y
      try {
        Voe(h, a, n),
          r.startTrace && (Yoe(h, a), h.setSpan(f)),
          (y = await o(i, a)),
          r.captureAllSettledReasons &&
            Array.isArray(y) &&
            $oe(y) &&
            zoe(y).forEach((C) => {
              Tt.captureException(C, (A) => l0.markEventUnhandled(A))
            })
      } catch (E) {
        throw (Tt.captureException(E, (C) => l0.markEventUnhandled(C)), E)
      } finally {
        clearTimeout(s),
          Tk([f, 'optionalAccess', (E) => E.finish, 'call', (E) => E()]),
          _.popScope(),
          await Tt.flush(r.flushTimeout).catch((E) => {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Co.logger.error(E)
          })
      }
      return y
    }
  }
  ts.defaultIntegrations = Pk
  ts.init = joe
  ts.tryPatchHandler = Hoe
  ts.wrapHandler = Rk
  for (let e in Tt) e !== 'default' && !ts.hasOwnProperty(e) && (ts[e] = Tt[e])
})
var Nk = l((p0) => {
  var { _optionalChain: Ak } = Se()
  Object.defineProperty(p0, '__esModule', { value: !0 })
  var Woe = Dn(),
    Ok = O(),
    Mp = class e {
      static __initStatic() {
        this.id = 'GoogleCloudGrpc'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._optional = t.optional || !1)
      }
      setupOnce() {
        try {
          let t = require('google-gax')
          Ok.fill(t.GrpcClient.prototype, 'createStub', Koe)
        } catch (t) {
          if (!this._optional) throw t
        }
      }
    }
  Mp.__initStatic()
  function Koe(e) {
    return async function (...t) {
      let n = Ak([
        t,
        'access',
        (o) => o[1],
        'optionalAccess',
        (o) => o.servicePath,
      ])
      if (n == null || n == null) return e.apply(this, t)
      let r = Joe(n),
        s = await e.apply(this, t)
      for (let o of Object.keys(Object.getPrototypeOf(s))) Xoe(s, r, o)
      return s
    }
  }
  function Xoe(e, t, n) {
    let r = e[n]
    if (typeof r != 'function') return
    let s =
      !r.requestStream && !r.responseStream
        ? 'unary call'
        : r.requestStream && !r.responseStream
          ? 'client stream'
          : !r.requestStream && r.responseStream
            ? 'server stream'
            : 'bidi stream'
    s == 'unary call' &&
      Ok.fill(e, n, (o) => (...i) => {
        let a = o.apply(e, i)
        if (typeof Ak([a, 'optionalAccess', (p) => p.on]) != 'function')
          return a
        let c,
          d = Woe.getCurrentHub().getScope().getTransaction()
        return (
          d &&
            (c = d.startChild({
              description: `${s} ${n}`,
              op: `grpc.${t}`,
              origin: 'auto.grpc.serverless',
            })),
          a.on('status', () => {
            c && c.finish()
          }),
          a
        )
      })
  }
  function Joe(e) {
    let t = e.match(/^(\w+)\.googleapis.com$/)
    return t ? t[1] : e
  }
  p0.GoogleCloudGrpc = Mp
})
var qk = l((_0) => {
  Object.defineProperty(_0, '__esModule', { value: !0 })
  var Qoe = Dn(),
    Zoe = O(),
    Lp = class e {
      static __initStatic() {
        this.id = 'GoogleCloudHttp'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._optional = t.optional || !1)
      }
      setupOnce() {
        try {
          let t = require('@google-cloud/common')
          Zoe.fill(t.Service.prototype, 'request', eie)
        } catch (t) {
          if (!this._optional) throw t
        }
      }
    }
  Lp.__initStatic()
  function eie(e) {
    return function (t, n) {
      let r,
        o = Qoe.getCurrentHub().getScope().getTransaction()
      if (o) {
        let i = t.method || 'GET'
        r = o.startChild({
          description: `${i} ${t.uri}`,
          op: `http.client.${tie(this.apiEndpoint)}`,
          origin: 'auto.http.serverless',
        })
      }
      e.call(this, t, (...i) => {
        r && r.finish(), n(...i)
      })
    }
  }
  function tie(e) {
    let t = e.match(/^https:\/\/(\w+)\.googleapis.com$/)
    return t ? t[1] : e.replace(/^(http|https)?:\/\//, '')
  }
  _0.GoogleCloudHttp = Lp
})
var kk = l((h0) => {
  var { _optionalChain: f0 } = Se()
  Object.defineProperty(h0, '__esModule', { value: !0 })
  var Up = Dn(),
    yu = O(),
    Eu = qi()
  function nie(e, t = {}) {
    let n = (o) => Eu.domainify(rie(o, t)),
      r,
      s = e.__emulator_func
    return (
      s && (r = { __emulator_func: Eu.proxyFunction(s, n) }),
      Eu.proxyFunction(e, n, r)
    )
  }
  function rie(e, t = {}) {
    let { parseRequestOptions: n } = t,
      r = {
        flushTimeout: 2e3,
        addRequestDataToEventOptions: n ? { include: n } : {},
        ...t,
      }
    return (s, o) => {
      let i = Up.getCurrentHub(),
        a = (s.method || '').toUpperCase(),
        c = yu.stripUrlQueryAndFragment(s.originalUrl || s.url || ''),
        u =
          s.headers && yu.isString(s.headers['sentry-trace'])
            ? s.headers['sentry-trace']
            : void 0,
        d = f0([
          s,
          'access',
          (C) => C.headers,
          'optionalAccess',
          (C) => C.baggage,
        ]),
        {
          traceparentData: p,
          dynamicSamplingContext: _,
          propagationContext: f,
        } = yu.tracingContextFromHeaders(u, d)
      i.getScope().setPropagationContext(f)
      let h = i.startTransaction({
        name: `${a} ${c}`,
        op: 'function.gcp.http',
        origin: 'auto.function.serverless.gcp_http',
        ...p,
        metadata: { dynamicSamplingContext: p && !_ ? {} : _, source: 'route' },
      })
      i.configureScope((C) => {
        C.setSDKProcessingMetadata({
          request: s,
          requestDataOptionsFromGCPWrapper: r.addRequestDataToEventOptions,
        }),
          C.setSpan(h)
      }),
        (o.__sentry_transaction = h)
      let y = o.end
      o.end = function (C, A, se) {
        f0([
          h,
          'optionalAccess',
          (Q) => Q.setHttpStatus,
          'call',
          (Q) => Q(o.statusCode),
        ]),
          f0([h, 'optionalAccess', (Q) => Q.finish, 'call', (Q) => Q()]),
          Up.flush(r.flushTimeout)
            .then(null, (Q) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                yu.logger.error(Q)
            })
            .then(() => {
              y.call(this, C, A, se)
            })
      }
      let E
      try {
        E = e(s, o)
      } catch (C) {
        throw (Up.captureException(C, (A) => Eu.markEventUnhandled(A)), C)
      }
      return (
        yu.isThenable(E) &&
          E.then(null, (C) => {
            throw (Up.captureException(C, (A) => Eu.markEventUnhandled(A)), C)
          }),
        E
      )
    }
  }
  h0.wrapHttpFunction = nie
})
var Lk = l((g0) => {
  var { _optionalChain: sie } = Se()
  Object.defineProperty(g0, '__esModule', { value: !0 })
  var Su = Dn(),
    Mk = O(),
    ki = qi()
  function oie(e, t = {}) {
    return ki.proxyFunction(e, (n) => ki.domainify(iie(n, t)))
  }
  function iie(e, t = {}) {
    let n = { flushTimeout: 2e3, ...t }
    return (...r) => {
      let [s, o, i] = r,
        a = Su.getCurrentHub(),
        c = a.startTransaction({
          name: o.eventType,
          op: 'function.gcp.event',
          origin: 'auto.function.serverless.gcp_event',
          metadata: { source: 'component' },
        })
      a.configureScope((d) => {
        d.setContext('gcp.function.context', { ...o }), d.setSpan(c)
      })
      let u = ki.domainify((...d) => {
        d[0] !== null &&
          d[0] !== void 0 &&
          Su.captureException(d[0], (p) => ki.markEventUnhandled(p)),
          sie([c, 'optionalAccess', (p) => p.finish, 'call', (p) => p()]),
          Su.flush(n.flushTimeout)
            .then(null, (p) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Mk.logger.error(p)
            })
            .then(() => {
              typeof i == 'function' && i(...d)
            })
      })
      if (e.length > 2) {
        let d
        try {
          d = e(s, o, u)
        } catch (p) {
          throw (Su.captureException(p, (_) => ki.markEventUnhandled(_)), p)
        }
        return (
          Mk.isThenable(d) &&
            d.then(null, (p) => {
              throw (Su.captureException(p, (_) => ki.markEventUnhandled(_)), p)
            }),
          d
        )
      }
      return Promise.resolve()
        .then(() => e(s, o))
        .then(
          (d) => u(null, d),
          (d) => u(d, void 0),
        )
    }
  }
  g0.wrapEventFunction = oie
})
var Fk = l((y0) => {
  var { _optionalChain: aie } = Se()
  Object.defineProperty(y0, '__esModule', { value: !0 })
  var bu = Dn(),
    Uk = O(),
    Mi = qi()
  function cie(e, t = {}) {
    return Mi.proxyFunction(e, (n) => Mi.domainify(die(n, t)))
  }
  function die(e, t = {}) {
    let n = { flushTimeout: 2e3, ...t }
    return (r, s) => {
      let o = bu.getCurrentHub(),
        i = o.startTransaction({
          name: r.type || '<unknown>',
          op: 'function.gcp.cloud_event',
          origin: 'auto.function.serverless.gcp_cloud_event',
          metadata: { source: 'component' },
        })
      o.configureScope((c) => {
        c.setContext('gcp.function.context', { ...r }), c.setSpan(i)
      })
      let a = Mi.domainify((...c) => {
        c[0] !== null &&
          c[0] !== void 0 &&
          bu.captureException(c[0], (u) => Mi.markEventUnhandled(u)),
          aie([i, 'optionalAccess', (u) => u.finish, 'call', (u) => u()]),
          bu
            .flush(n.flushTimeout)
            .then(null, (u) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Uk.logger.error(u)
            })
            .then(() => {
              s(...c)
            })
      })
      if (e.length > 1) {
        let c
        try {
          c = e(r, a)
        } catch (u) {
          throw (bu.captureException(u, (d) => Mi.markEventUnhandled(d)), u)
        }
        return (
          Uk.isThenable(c) &&
            c.then(null, (u) => {
              throw (bu.captureException(u, (d) => Mi.markEventUnhandled(d)), u)
            }),
          c
        )
      }
      return Promise.resolve()
        .then(() => e(r))
        .then(
          (c) => a(null, c),
          (c) => a(c, void 0),
        )
    }
  }
  y0.wrapCloudEventFunction = cie
})
var jk = l((To) => {
  Object.defineProperty(To, '__esModule', { value: !0 })
  var vu = Dn(),
    uie = Nk(),
    lie = qk(),
    mie = qi(),
    pie = kk(),
    _ie = Lk(),
    fie = Fk(),
    Bk = [
      ...vu.defaultIntegrations,
      new lie.GoogleCloudHttp({ optional: !0 }),
      new uie.GoogleCloudGrpc({ optional: !0 }),
    ]
  function hie(e = {}) {
    let t = { _metadata: {}, defaultIntegrations: Bk, ...e }
    ;(t._metadata.sdk = t._metadata.sdk || {
      name: 'sentry.javascript.serverless',
      integrations: ['GCPFunction'],
      packages: [{ name: 'npm:@sentry/serverless', version: vu.SDK_VERSION }],
      version: vu.SDK_VERSION,
    }),
      vu.init(t),
      vu.addGlobalEventProcessor(mie.serverlessEventProcessor)
  }
  To.wrapHttpFunction = pie.wrapHttpFunction
  To.wrapEventFunction = _ie.wrapEventFunction
  To.wrapCloudEventFunction = fie.wrapCloudEventFunction
  To.defaultIntegrations = Bk
  To.init = hie
})
var Gk = l((V) => {
  Object.defineProperty(V, '__esModule', { value: !0 })
  var gie = Dk(),
    yie = jk(),
    Eie = u0(),
    X = Dn()
  V.AWSLambda = gie
  V.GCPFunction = yie
  V.AWSServices = Eie.AWSServices
  V.DEFAULT_USER_INCLUDES = X.DEFAULT_USER_INCLUDES
  V.Handlers = X.Handlers
  V.Hub = X.Hub
  V.Integrations = X.Integrations
  V.NodeClient = X.NodeClient
  V.SDK_VERSION = X.SDK_VERSION
  V.Scope = X.Scope
  V.addBreadcrumb = X.addBreadcrumb
  V.addGlobalEventProcessor = X.addGlobalEventProcessor
  V.addIntegration = X.addIntegration
  V.addRequestDataToEvent = X.addRequestDataToEvent
  V.autoDiscoverNodePerformanceMonitoringIntegrations =
    X.autoDiscoverNodePerformanceMonitoringIntegrations
  V.captureCheckIn = X.captureCheckIn
  V.captureEvent = X.captureEvent
  V.captureException = X.captureException
  V.captureMessage = X.captureMessage
  V.close = X.close
  V.configureScope = X.configureScope
  V.continueTrace = X.continueTrace
  V.createTransport = X.createTransport
  V.deepReadDirSync = X.deepReadDirSync
  V.defaultIntegrations = X.defaultIntegrations
  V.defaultStackParser = X.defaultStackParser
  V.extractRequestData = X.extractRequestData
  V.flush = X.flush
  V.getActiveSpan = X.getActiveSpan
  V.getActiveTransaction = X.getActiveTransaction
  V.getCurrentHub = X.getCurrentHub
  V.getHubFromCarrier = X.getHubFromCarrier
  V.getSentryRelease = X.getSentryRelease
  V.init = X.init
  V.lastEventId = X.lastEventId
  V.makeMain = X.makeMain
  V.makeNodeTransport = X.makeNodeTransport
  V.setContext = X.setContext
  V.setExtra = X.setExtra
  V.setExtras = X.setExtras
  V.setMeasurement = X.setMeasurement
  V.setTag = X.setTag
  V.setTags = X.setTags
  V.setUser = X.setUser
  V.startActiveSpan = X.startActiveSpan
  V.startInactiveSpan = X.startInactiveSpan
  V.startSpan = X.startSpan
  V.startSpanManual = X.startSpanManual
  V.startTransaction = X.startTransaction
  V.withScope = X.withScope
})
var I = {}
fd(I, {
  __addDisposableResource: () => _M,
  __assign: () => Fp,
  __asyncDelegator: () => iM,
  __asyncGenerator: () => oM,
  __asyncValues: () => aM,
  __await: () => Li,
  __awaiter: () => Zk,
  __classPrivateFieldGet: () => lM,
  __classPrivateFieldIn: () => pM,
  __classPrivateFieldSet: () => mM,
  __createBinding: () => jp,
  __decorate: () => Xk,
  __disposeResources: () => fM,
  __esDecorate: () => Sie,
  __exportStar: () => tM,
  __extends: () => Wk,
  __generator: () => eM,
  __importDefault: () => uM,
  __importStar: () => dM,
  __makeTemplateObject: () => cM,
  __metadata: () => Qk,
  __param: () => Jk,
  __propKey: () => vie,
  __read: () => S0,
  __rest: () => Kk,
  __runInitializers: () => bie,
  __setFunctionName: () => Cie,
  __spread: () => nM,
  __spreadArray: () => sM,
  __spreadArrays: () => rM,
  __values: () => Bp,
  default: () => Iie,
})
function Wk(e, t) {
  if (typeof t != 'function' && t !== null)
    throw new TypeError(
      'Class extends value ' + String(t) + ' is not a constructor or null',
    )
  E0(e, t)
  function n() {
    this.constructor = e
  }
  e.prototype =
    t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
}
function Kk(e, t) {
  var n = {}
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++)
      t.indexOf(r[s]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[s]) &&
        (n[r[s]] = e[r[s]])
  return n
}
function Xk(e, t, n, r) {
  var s = arguments.length,
    o =
      s < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
    i
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    o = Reflect.decorate(e, t, n, r)
  else
    for (var a = e.length - 1; a >= 0; a--)
      (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o)
  return s > 3 && o && Object.defineProperty(t, n, o), o
}
function Jk(e, t) {
  return function (n, r) {
    t(n, r, e)
  }
}
function Sie(e, t, n, r, s, o) {
  function i(C) {
    if (C !== void 0 && typeof C != 'function')
      throw new TypeError('Function expected')
    return C
  }
  for (
    var a = r.kind,
      c = a === 'getter' ? 'get' : a === 'setter' ? 'set' : 'value',
      u = !t && e ? (r.static ? e : e.prototype) : null,
      d = t || (u ? Object.getOwnPropertyDescriptor(u, r.name) : {}),
      p,
      _ = !1,
      f = n.length - 1;
    f >= 0;
    f--
  ) {
    var h = {}
    for (var y in r) h[y] = y === 'access' ? {} : r[y]
    for (var y in r.access) h.access[y] = r.access[y]
    h.addInitializer = function (C) {
      if (_)
        throw new TypeError(
          'Cannot add initializers after decoration has completed',
        )
      o.push(i(C || null))
    }
    var E = (0, n[f])(a === 'accessor' ? { get: d.get, set: d.set } : d[c], h)
    if (a === 'accessor') {
      if (E === void 0) continue
      if (E === null || typeof E != 'object')
        throw new TypeError('Object expected')
      ;(p = i(E.get)) && (d.get = p),
        (p = i(E.set)) && (d.set = p),
        (p = i(E.init)) && s.unshift(p)
    } else (p = i(E)) && (a === 'field' ? s.unshift(p) : (d[c] = p))
  }
  u && Object.defineProperty(u, r.name, d), (_ = !0)
}
function bie(e, t, n) {
  for (var r = arguments.length > 2, s = 0; s < t.length; s++)
    n = r ? t[s].call(e, n) : t[s].call(e)
  return r ? n : void 0
}
function vie(e) {
  return typeof e == 'symbol' ? e : ''.concat(e)
}
function Cie(e, t, n) {
  return (
    typeof t == 'symbol' &&
      (t = t.description ? '['.concat(t.description, ']') : ''),
    Object.defineProperty(e, 'name', {
      configurable: !0,
      value: n ? ''.concat(n, ' ', t) : t,
    })
  )
}
function Qk(e, t) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(e, t)
}
function Zk(e, t, n, r) {
  function s(o) {
    return o instanceof n
      ? o
      : new n(function (i) {
          i(o)
        })
  }
  return new (n || (n = Promise))(function (o, i) {
    function a(d) {
      try {
        u(r.next(d))
      } catch (p) {
        i(p)
      }
    }
    function c(d) {
      try {
        u(r.throw(d))
      } catch (p) {
        i(p)
      }
    }
    function u(d) {
      d.done ? o(d.value) : s(d.value).then(a, c)
    }
    u((r = r.apply(e, t || [])).next())
  })
}
function eM(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1]
        return o[1]
      },
      trys: [],
      ops: [],
    },
    r,
    s,
    o,
    i
  return (
    (i = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == 'function' &&
      (i[Symbol.iterator] = function () {
        return this
      }),
    i
  )
  function a(u) {
    return function (d) {
      return c([u, d])
    }
  }
  function c(u) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; i && ((i = 0), u[0] && (n = 0)), n; )
      try {
        if (
          ((r = 1),
          s &&
            (o =
              u[0] & 2
                ? s.return
                : u[0]
                  ? s.throw || ((o = s.return) && o.call(s), 0)
                  : s.next) &&
            !(o = o.call(s, u[1])).done)
        )
          return o
        switch (((s = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
          case 0:
          case 1:
            o = u
            break
          case 4:
            return n.label++, { value: u[1], done: !1 }
          case 5:
            n.label++, (s = u[1]), (u = [0])
            continue
          case 7:
            ;(u = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((o = n.trys),
              !(o = o.length > 0 && o[o.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              n = 0
              continue
            }
            if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
              n.label = u[1]
              break
            }
            if (u[0] === 6 && n.label < o[1]) {
              ;(n.label = o[1]), (o = u)
              break
            }
            if (o && n.label < o[2]) {
              ;(n.label = o[2]), n.ops.push(u)
              break
            }
            o[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        u = t.call(e, n)
      } catch (d) {
        ;(u = [6, d]), (s = 0)
      } finally {
        r = o = 0
      }
    if (u[0] & 5) throw u[1]
    return { value: u[0] ? u[1] : void 0, done: !0 }
  }
}
function tM(e, t) {
  for (var n in e)
    n !== 'default' &&
      !Object.prototype.hasOwnProperty.call(t, n) &&
      jp(t, e, n)
}
function Bp(e) {
  var t = typeof Symbol == 'function' && Symbol.iterator,
    n = t && e[t],
    r = 0
  if (n) return n.call(e)
  if (e && typeof e.length == 'number')
    return {
      next: function () {
        return (
          e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
        )
      },
    }
  throw new TypeError(
    t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
  )
}
function S0(e, t) {
  var n = typeof Symbol == 'function' && e[Symbol.iterator]
  if (!n) return e
  var r = n.call(e),
    s,
    o = [],
    i
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; ) o.push(s.value)
  } catch (a) {
    i = { error: a }
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r)
    } finally {
      if (i) throw i.error
    }
  }
  return o
}
function nM() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(S0(arguments[t]))
  return e
}
function rM() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++)
    e += arguments[t].length
  for (var r = Array(e), s = 0, t = 0; t < n; t++)
    for (var o = arguments[t], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i]
  return r
}
function sM(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = t.length, o; r < s; r++)
      (o || !(r in t)) &&
        (o || (o = Array.prototype.slice.call(t, 0, r)), (o[r] = t[r]))
  return e.concat(o || Array.prototype.slice.call(t))
}
function Li(e) {
  return this instanceof Li ? ((this.v = e), this) : new Li(e)
}
function oM(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var r = n.apply(e, t || []),
    s,
    o = []
  return (
    (s = {}),
    i('next'),
    i('throw'),
    i('return'),
    (s[Symbol.asyncIterator] = function () {
      return this
    }),
    s
  )
  function i(_) {
    r[_] &&
      (s[_] = function (f) {
        return new Promise(function (h, y) {
          o.push([_, f, h, y]) > 1 || a(_, f)
        })
      })
  }
  function a(_, f) {
    try {
      c(r[_](f))
    } catch (h) {
      p(o[0][3], h)
    }
  }
  function c(_) {
    _.value instanceof Li
      ? Promise.resolve(_.value.v).then(u, d)
      : p(o[0][2], _)
  }
  function u(_) {
    a('next', _)
  }
  function d(_) {
    a('throw', _)
  }
  function p(_, f) {
    _(f), o.shift(), o.length && a(o[0][0], o[0][1])
  }
}
function iM(e) {
  var t, n
  return (
    (t = {}),
    r('next'),
    r('throw', function (s) {
      throw s
    }),
    r('return'),
    (t[Symbol.iterator] = function () {
      return this
    }),
    t
  )
  function r(s, o) {
    t[s] = e[s]
      ? function (i) {
          return (n = !n) ? { value: Li(e[s](i)), done: !1 } : o ? o(i) : i
        }
      : o
  }
}
function aM(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var t = e[Symbol.asyncIterator],
    n
  return t
    ? t.call(e)
    : ((e = typeof Bp == 'function' ? Bp(e) : e[Symbol.iterator]()),
      (n = {}),
      r('next'),
      r('throw'),
      r('return'),
      (n[Symbol.asyncIterator] = function () {
        return this
      }),
      n)
  function r(o) {
    n[o] =
      e[o] &&
      function (i) {
        return new Promise(function (a, c) {
          ;(i = e[o](i)), s(a, c, i.done, i.value)
        })
      }
  }
  function s(o, i, a, c) {
    Promise.resolve(c).then(function (u) {
      o({ value: u, done: a })
    }, i)
  }
}
function cM(e, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(e, 'raw', { value: t })
      : (e.raw = t),
    e
  )
}
function dM(e) {
  if (e && e.__esModule) return e
  var t = {}
  if (e != null)
    for (var n in e)
      n !== 'default' &&
        Object.prototype.hasOwnProperty.call(e, n) &&
        jp(t, e, n)
  return Tie(t, e), t
}
function uM(e) {
  return e && e.__esModule ? e : { default: e }
}
function lM(e, t, n, r) {
  if (n === 'a' && !r)
    throw new TypeError('Private accessor was defined without a getter')
  if (typeof t == 'function' ? e !== t || !r : !t.has(e))
    throw new TypeError(
      'Cannot read private member from an object whose class did not declare it',
    )
  return n === 'm' ? r : n === 'a' ? r.call(e) : r ? r.value : t.get(e)
}
function mM(e, t, n, r, s) {
  if (r === 'm') throw new TypeError('Private method is not writable')
  if (r === 'a' && !s)
    throw new TypeError('Private accessor was defined without a setter')
  if (typeof t == 'function' ? e !== t || !s : !t.has(e))
    throw new TypeError(
      'Cannot write private member to an object whose class did not declare it',
    )
  return r === 'a' ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n
}
function pM(e, t) {
  if (t === null || (typeof t != 'object' && typeof t != 'function'))
    throw new TypeError("Cannot use 'in' operator on non-object")
  return typeof e == 'function' ? t === e : e.has(t)
}
function _M(e, t, n) {
  if (t != null) {
    if (typeof t != 'object' && typeof t != 'function')
      throw new TypeError('Object expected.')
    var r
    if (n) {
      if (!Symbol.asyncDispose)
        throw new TypeError('Symbol.asyncDispose is not defined.')
      r = t[Symbol.asyncDispose]
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError('Symbol.dispose is not defined.')
      r = t[Symbol.dispose]
    }
    if (typeof r != 'function') throw new TypeError('Object not disposable.')
    e.stack.push({ value: t, dispose: r, async: n })
  } else n && e.stack.push({ async: !0 })
  return t
}
function fM(e) {
  function t(r) {
    ;(e.error = e.hasError
      ? new wie(r, e.error, 'An error was suppressed during disposal.')
      : r),
      (e.hasError = !0)
  }
  function n() {
    for (; e.stack.length; ) {
      var r = e.stack.pop()
      try {
        var s = r.dispose && r.dispose.call(r.value)
        if (r.async)
          return Promise.resolve(s).then(n, function (o) {
            return t(o), n()
          })
      } catch (o) {
        t(o)
      }
    }
    if (e.hasError) throw e.error
  }
  return n()
}
var E0,
  Fp,
  jp,
  Tie,
  wie,
  Iie,
  x = ue(() => {
    E0 = function (e, t) {
      return (
        (E0 =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (n, r) {
              n.__proto__ = r
            }) ||
          function (n, r) {
            for (var s in r)
              Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s])
          }),
        E0(e, t)
      )
    }
    Fp = function () {
      return (
        (Fp =
          Object.assign ||
          function (t) {
            for (var n, r = 1, s = arguments.length; r < s; r++) {
              n = arguments[r]
              for (var o in n)
                Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o])
            }
            return t
          }),
        Fp.apply(this, arguments)
      )
    }
    jp = Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n)
          var s = Object.getOwnPropertyDescriptor(t, n)
          ;(!s ||
            ('get' in s ? !t.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return t[n]
              },
            }),
            Object.defineProperty(e, r, s)
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n])
        }
    Tie = Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t })
        }
      : function (e, t) {
          e.default = t
        }
    wie =
      typeof SuppressedError == 'function'
        ? SuppressedError
        : function (e, t, n) {
            var r = new Error(n)
            return (
              (r.name = 'SuppressedError'), (r.error = e), (r.suppressed = t), r
            )
          }
    Iie = {
      __extends: Wk,
      __assign: Fp,
      __rest: Kk,
      __decorate: Xk,
      __param: Jk,
      __metadata: Qk,
      __awaiter: Zk,
      __generator: eM,
      __createBinding: jp,
      __exportStar: tM,
      __values: Bp,
      __read: S0,
      __spread: nM,
      __spreadArrays: rM,
      __spreadArray: sM,
      __await: Li,
      __asyncGenerator: oM,
      __asyncDelegator: iM,
      __asyncValues: aM,
      __makeTemplateObject: cM,
      __importStar: dM,
      __importDefault: uM,
      __classPrivateFieldGet: lM,
      __classPrivateFieldSet: mM,
      __classPrivateFieldIn: pM,
      __addDisposableResource: _M,
      __disposeResources: fM,
    }
  })
var yM = l((Gp) => {
  'use strict'
  Object.defineProperty(Gp, '__esModule', { value: !0 })
  Gp.NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = void 0
  var hM = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'],
    b0 = 'endpoint_discovery_enabled',
    gM = (e) => ['false', '0'].indexOf(e) >= 0
  Gp.NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => {
      for (let t = 0; t < hM.length; t++) {
        let n = hM[t]
        if (n in e) {
          let r = e[n]
          if (r === '')
            throw Error(
              `Environment variable ${n} can't be empty of undefined, got "${r}"`,
            )
          return !gM(r)
        }
      }
    },
    configFileSelector: (e) => {
      if (b0 in e) {
        let t = e[b0]
        if (t === void 0)
          throw Error(
            `Shared config entry ${b0} can't be undefined, got "${t}"`,
          )
        return !gM(t)
      }
    },
    default: void 0,
  }
})
var EM = l((Ui) => {
  'use strict'
  Object.defineProperty(Ui, '__esModule', { value: !0 })
  Ui.resolveHttpHandlerRuntimeConfig = Ui.getHttpHandlerExtensionConfiguration =
    void 0
  var xie = (e) => {
    let t = e.httpHandler
    return {
      setHttpHandler(n) {
        t = n
      },
      httpHandler() {
        return t
      },
      updateHttpClientConfig(n, r) {
        t.updateHttpClientConfig(n, r)
      },
      httpHandlerConfigs() {
        return t.httpHandlerConfigs()
      },
    }
  }
  Ui.getHttpHandlerExtensionConfiguration = xie
  var Pie = (e) => ({ httpHandler: e.httpHandler() })
  Ui.resolveHttpHandlerRuntimeConfig = Pie
})
var SM = l((v0) => {
  'use strict'
  Object.defineProperty(v0, '__esModule', { value: !0 })
  var Rie = (x(), w(I))
  Rie.__exportStar(EM(), v0)
})
var vM = l((bM) => {
  'use strict'
  Object.defineProperty(bM, '__esModule', { value: !0 })
})
var CM = l((Cu) => {
  'use strict'
  Object.defineProperty(Cu, '__esModule', { value: !0 })
  Cu.HttpAuthLocation = void 0
  var Die
  ;(function (e) {
    ;(e.HEADER = 'header'), (e.QUERY = 'query')
  })((Die = Cu.HttpAuthLocation || (Cu.HttpAuthLocation = {})))
})
var wM = l((TM) => {
  'use strict'
  Object.defineProperty(TM, '__esModule', { value: !0 })
})
var xM = l((IM) => {
  'use strict'
  Object.defineProperty(IM, '__esModule', { value: !0 })
})
var RM = l((PM) => {
  'use strict'
  Object.defineProperty(PM, '__esModule', { value: !0 })
})
var AM = l((DM) => {
  'use strict'
  Object.defineProperty(DM, '__esModule', { value: !0 })
})
var NM = l((OM) => {
  'use strict'
  Object.defineProperty(OM, '__esModule', { value: !0 })
})
var kM = l((qM) => {
  'use strict'
  Object.defineProperty(qM, '__esModule', { value: !0 })
})
var LM = l((MM) => {
  'use strict'
  Object.defineProperty(MM, '__esModule', { value: !0 })
})
var UM = l((Tu) => {
  'use strict'
  Object.defineProperty(Tu, '__esModule', { value: !0 })
  var C0 = (x(), w(I))
  C0.__exportStar(NM(), Tu)
  C0.__exportStar(kM(), Tu)
  C0.__exportStar(LM(), Tu)
})
var BM = l((FM) => {
  'use strict'
  Object.defineProperty(FM, '__esModule', { value: !0 })
})
var GM = l((jM) => {
  'use strict'
  Object.defineProperty(jM, '__esModule', { value: !0 })
})
var $M = l((wu) => {
  'use strict'
  Object.defineProperty(wu, '__esModule', { value: !0 })
  wu.EndpointURLScheme = void 0
  var Aie
  ;(function (e) {
    ;(e.HTTP = 'http'), (e.HTTPS = 'https')
  })((Aie = wu.EndpointURLScheme || (wu.EndpointURLScheme = {})))
})
var HM = l((zM) => {
  'use strict'
  Object.defineProperty(zM, '__esModule', { value: !0 })
})
var YM = l((VM) => {
  'use strict'
  Object.defineProperty(VM, '__esModule', { value: !0 })
})
var KM = l((WM) => {
  'use strict'
  Object.defineProperty(WM, '__esModule', { value: !0 })
})
var JM = l((XM) => {
  'use strict'
  Object.defineProperty(XM, '__esModule', { value: !0 })
})
var ZM = l((QM) => {
  'use strict'
  Object.defineProperty(QM, '__esModule', { value: !0 })
})
var eL = l((wo) => {
  'use strict'
  Object.defineProperty(wo, '__esModule', { value: !0 })
  var Iu = (x(), w(I))
  Iu.__exportStar(HM(), wo)
  Iu.__exportStar(YM(), wo)
  Iu.__exportStar(KM(), wo)
  Iu.__exportStar(JM(), wo)
  Iu.__exportStar(ZM(), wo)
})
var nL = l((tL) => {
  'use strict'
  Object.defineProperty(tL, '__esModule', { value: !0 })
})
var w0 = l((gr) => {
  'use strict'
  Object.defineProperty(gr, '__esModule', { value: !0 })
  gr.resolveChecksumRuntimeConfig =
    gr.getChecksumConfiguration =
    gr.AlgorithmId =
      void 0
  var T0
  ;(function (e) {
    ;(e.MD5 = 'md5'),
      (e.CRC32 = 'crc32'),
      (e.CRC32C = 'crc32c'),
      (e.SHA1 = 'sha1'),
      (e.SHA256 = 'sha256')
  })((T0 = gr.AlgorithmId || (gr.AlgorithmId = {})))
  var Oie = (e) => {
    let t = []
    return (
      e.sha256 !== void 0 &&
        t.push({
          algorithmId: () => T0.SHA256,
          checksumConstructor: () => e.sha256,
        }),
      e.md5 != null &&
        t.push({ algorithmId: () => T0.MD5, checksumConstructor: () => e.md5 }),
      {
        _checksumAlgorithms: t,
        addChecksumAlgorithm(n) {
          this._checksumAlgorithms.push(n)
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms
        },
      }
    )
  }
  gr.getChecksumConfiguration = Oie
  var Nie = (e) => {
    let t = {}
    return (
      e.checksumAlgorithms().forEach((n) => {
        t[n.algorithmId()] = n.checksumConstructor()
      }),
      t
    )
  }
  gr.resolveChecksumRuntimeConfig = Nie
})
var sL = l((Fi) => {
  'use strict'
  Object.defineProperty(Fi, '__esModule', { value: !0 })
  Fi.resolveDefaultRuntimeConfig = Fi.getDefaultClientConfiguration = void 0
  var rL = w0(),
    qie = (e) => ({ ...(0, rL.getChecksumConfiguration)(e) })
  Fi.getDefaultClientConfiguration = qie
  var kie = (e) => ({ ...(0, rL.resolveChecksumRuntimeConfig)(e) })
  Fi.resolveDefaultRuntimeConfig = kie
})
var iL = l((oL) => {
  'use strict'
  Object.defineProperty(oL, '__esModule', { value: !0 })
})
var cL = l((Bi) => {
  'use strict'
  Object.defineProperty(Bi, '__esModule', { value: !0 })
  Bi.AlgorithmId = void 0
  var aL = (x(), w(I))
  aL.__exportStar(sL(), Bi)
  aL.__exportStar(iL(), Bi)
  var Mie = w0()
  Object.defineProperty(Bi, 'AlgorithmId', {
    enumerable: !0,
    get: function () {
      return Mie.AlgorithmId
    },
  })
})
var dL = l((xu) => {
  'use strict'
  Object.defineProperty(xu, '__esModule', { value: !0 })
  xu.FieldPosition = void 0
  var Lie
  ;(function (e) {
    ;(e[(e.HEADER = 0)] = 'HEADER'), (e[(e.TRAILER = 1)] = 'TRAILER')
  })((Lie = xu.FieldPosition || (xu.FieldPosition = {})))
})
var lL = l((uL) => {
  'use strict'
  Object.defineProperty(uL, '__esModule', { value: !0 })
})
var pL = l((mL) => {
  'use strict'
  Object.defineProperty(mL, '__esModule', { value: !0 })
})
var fL = l(($p) => {
  'use strict'
  Object.defineProperty($p, '__esModule', { value: !0 })
  var _L = (x(), w(I))
  _L.__exportStar(lL(), $p)
  _L.__exportStar(pL(), $p)
})
var gL = l((hL) => {
  'use strict'
  Object.defineProperty(hL, '__esModule', { value: !0 })
})
var yL = l((zp) => {
  'use strict'
  Object.defineProperty(zp, '__esModule', { value: !0 })
  zp.SMITHY_CONTEXT_KEY = void 0
  zp.SMITHY_CONTEXT_KEY = '__smithy_context'
})
var SL = l((EL) => {
  'use strict'
  Object.defineProperty(EL, '__esModule', { value: !0 })
})
var bL = l((Pu) => {
  'use strict'
  Object.defineProperty(Pu, '__esModule', { value: !0 })
  Pu.IniSectionType = void 0
  var Uie
  ;(function (e) {
    ;(e.PROFILE = 'profile'),
      (e.SSO_SESSION = 'sso-session'),
      (e.SERVICES = 'services')
  })((Uie = Pu.IniSectionType || (Pu.IniSectionType = {})))
})
var CL = l((vL) => {
  'use strict'
  Object.defineProperty(vL, '__esModule', { value: !0 })
})
var wL = l((TL) => {
  'use strict'
  Object.defineProperty(TL, '__esModule', { value: !0 })
})
var xL = l((IL) => {
  'use strict'
  Object.defineProperty(IL, '__esModule', { value: !0 })
})
var RL = l((PL) => {
  'use strict'
  Object.defineProperty(PL, '__esModule', { value: !0 })
})
var AL = l((DL) => {
  'use strict'
  Object.defineProperty(DL, '__esModule', { value: !0 })
})
var NL = l((OL) => {
  'use strict'
  Object.defineProperty(OL, '__esModule', { value: !0 })
})
var kL = l((qL) => {
  'use strict'
  Object.defineProperty(qL, '__esModule', { value: !0 })
})
var LL = l((ML) => {
  'use strict'
  Object.defineProperty(ML, '__esModule', { value: !0 })
})
var FL = l((UL) => {
  'use strict'
  Object.defineProperty(UL, '__esModule', { value: !0 })
})
var BL = l((Ru) => {
  'use strict'
  Object.defineProperty(Ru, '__esModule', { value: !0 })
  Ru.RequestHandlerProtocol = void 0
  var Fie
  ;(function (e) {
    ;(e.HTTP_0_9 = 'http/0.9'),
      (e.HTTP_1_0 = 'http/1.0'),
      (e.TDS_8_0 = 'tds/8.0')
  })((Fie = Ru.RequestHandlerProtocol || (Ru.RequestHandlerProtocol = {})))
})
var GL = l((jL) => {
  'use strict'
  Object.defineProperty(jL, '__esModule', { value: !0 })
})
var zL = l(($L) => {
  'use strict'
  Object.defineProperty($L, '__esModule', { value: !0 })
})
var VL = l((HL) => {
  'use strict'
  Object.defineProperty(HL, '__esModule', { value: !0 })
})
var WL = l((YL) => {
  'use strict'
  Object.defineProperty(YL, '__esModule', { value: !0 })
})
var XL = l((KL) => {
  'use strict'
  Object.defineProperty(KL, '__esModule', { value: !0 })
})
var D = l((oe) => {
  'use strict'
  Object.defineProperty(oe, '__esModule', { value: !0 })
  var ie = (x(), w(I))
  ie.__exportStar(vM(), oe)
  ie.__exportStar(CM(), oe)
  ie.__exportStar(wM(), oe)
  ie.__exportStar(xM(), oe)
  ie.__exportStar(RM(), oe)
  ie.__exportStar(AM(), oe)
  ie.__exportStar(UM(), oe)
  ie.__exportStar(BM(), oe)
  ie.__exportStar(GM(), oe)
  ie.__exportStar($M(), oe)
  ie.__exportStar(eL(), oe)
  ie.__exportStar(nL(), oe)
  ie.__exportStar(cL(), oe)
  ie.__exportStar(dL(), oe)
  ie.__exportStar(fL(), oe)
  ie.__exportStar(gL(), oe)
  ie.__exportStar(yL(), oe)
  ie.__exportStar(SL(), oe)
  ie.__exportStar(bL(), oe)
  ie.__exportStar(CL(), oe)
  ie.__exportStar(wL(), oe)
  ie.__exportStar(xL(), oe)
  ie.__exportStar(RL(), oe)
  ie.__exportStar(AL(), oe)
  ie.__exportStar(NL(), oe)
  ie.__exportStar(kL(), oe)
  ie.__exportStar(LL(), oe)
  ie.__exportStar(FL(), oe)
  ie.__exportStar(BL(), oe)
  ie.__exportStar(GL(), oe)
  ie.__exportStar(zL(), oe)
  ie.__exportStar(VL(), oe)
  ie.__exportStar(WL(), oe)
  ie.__exportStar(XL(), oe)
})
var JL = l((Hp) => {
  'use strict'
  Object.defineProperty(Hp, '__esModule', { value: !0 })
  Hp.Field = void 0
  var Bie = D(),
    I0 = class {
      constructor({
        name: t,
        kind: n = Bie.FieldPosition.HEADER,
        values: r = [],
      }) {
        ;(this.name = t), (this.kind = n), (this.values = r)
      }
      add(t) {
        this.values.push(t)
      }
      set(t) {
        this.values = t
      }
      remove(t) {
        this.values = this.values.filter((n) => n !== t)
      }
      toString() {
        return this.values
          .map((t) => (t.includes(',') || t.includes(' ') ? `"${t}"` : t))
          .join(', ')
      }
      get() {
        return this.values
      }
    }
  Hp.Field = I0
})
var QL = l((Vp) => {
  'use strict'
  Object.defineProperty(Vp, '__esModule', { value: !0 })
  Vp.Fields = void 0
  var x0 = class {
    constructor({ fields: t = [], encoding: n = 'utf-8' }) {
      ;(this.entries = {}),
        t.forEach(this.setField.bind(this)),
        (this.encoding = n)
    }
    setField(t) {
      this.entries[t.name.toLowerCase()] = t
    }
    getField(t) {
      return this.entries[t.toLowerCase()]
    }
    removeField(t) {
      delete this.entries[t.toLowerCase()]
    }
    getByType(t) {
      return Object.values(this.entries).filter((n) => n.kind === t)
    }
  }
  Vp.Fields = x0
})
var eU = l((ZL) => {
  'use strict'
  Object.defineProperty(ZL, '__esModule', { value: !0 })
})
var tU = l((Yp) => {
  'use strict'
  Object.defineProperty(Yp, '__esModule', { value: !0 })
  Yp.HttpRequest = void 0
  var P0 = class e {
    constructor(t) {
      ;(this.method = t.method || 'GET'),
        (this.hostname = t.hostname || 'localhost'),
        (this.port = t.port),
        (this.query = t.query || {}),
        (this.headers = t.headers || {}),
        (this.body = t.body),
        (this.protocol = t.protocol
          ? t.protocol.slice(-1) !== ':'
            ? `${t.protocol}:`
            : t.protocol
          : 'https:'),
        (this.path = t.path
          ? t.path.charAt(0) !== '/'
            ? `/${t.path}`
            : t.path
          : '/'),
        (this.username = t.username),
        (this.password = t.password),
        (this.fragment = t.fragment)
    }
    static isInstance(t) {
      if (!t) return !1
      let n = t
      return (
        'method' in n &&
        'protocol' in n &&
        'hostname' in n &&
        'path' in n &&
        typeof n.query == 'object' &&
        typeof n.headers == 'object'
      )
    }
    clone() {
      let t = new e({ ...this, headers: { ...this.headers } })
      return t.query && (t.query = jie(t.query)), t
    }
  }
  Yp.HttpRequest = P0
  function jie(e) {
    return Object.keys(e).reduce((t, n) => {
      let r = e[n]
      return { ...t, [n]: Array.isArray(r) ? [...r] : r }
    }, {})
  }
})
var nU = l((Wp) => {
  'use strict'
  Object.defineProperty(Wp, '__esModule', { value: !0 })
  Wp.HttpResponse = void 0
  var R0 = class {
    constructor(t) {
      ;(this.statusCode = t.statusCode),
        (this.reason = t.reason),
        (this.headers = t.headers || {}),
        (this.body = t.body)
    }
    static isInstance(t) {
      if (!t) return !1
      let n = t
      return typeof n.statusCode == 'number' && typeof n.headers == 'object'
    }
  }
  Wp.HttpResponse = R0
})
var rU = l((Kp) => {
  'use strict'
  Object.defineProperty(Kp, '__esModule', { value: !0 })
  Kp.isValidHostname = void 0
  function Gie(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e)
  }
  Kp.isValidHostname = Gie
})
var oU = l((sU) => {
  'use strict'
  Object.defineProperty(sU, '__esModule', { value: !0 })
})
var Oe = l((An) => {
  'use strict'
  Object.defineProperty(An, '__esModule', { value: !0 })
  var ns = (x(), w(I))
  ns.__exportStar(SM(), An)
  ns.__exportStar(JL(), An)
  ns.__exportStar(QL(), An)
  ns.__exportStar(eU(), An)
  ns.__exportStar(tU(), An)
  ns.__exportStar(nU(), An)
  ns.__exportStar(rU(), An)
  ns.__exportStar(oU(), An)
})
var iU = l((Xp) => {
  'use strict'
  Object.defineProperty(Xp, '__esModule', { value: !0 })
  Xp.getCacheKey = void 0
  var $ie = async (e, t, n) => {
    let { accessKeyId: r } = await t.credentials(),
      { identifiers: s } = n
    return JSON.stringify({
      ...(r && { accessKeyId: r }),
      ...(s && {
        commandName: e,
        identifiers: Object.entries(s)
          .sort()
          .reduce((o, [i, a]) => ({ ...o, [i]: a }), {}),
      }),
    })
  }
  Xp.getCacheKey = $ie
})
var aU = l((Jp) => {
  'use strict'
  Object.defineProperty(Jp, '__esModule', { value: !0 })
  Jp.updateDiscoveredEndpointInCache = void 0
  var yr = {},
    zie = async (e, t) =>
      new Promise((n, r) => {
        let { endpointCache: s } = e,
          { cacheKey: o, commandName: i, identifiers: a } = t,
          c = s.get(o)
        if (c && c.length === 1 && c[0].Address === '')
          t.isDiscoveredEndpointRequired
            ? (yr[o] || (yr[o] = []), yr[o].push({ resolve: n, reject: r }))
            : n()
        else if (c && c.length > 0) n()
        else {
          let u = [{ Address: '', CachePeriodInMinutes: 1 }]
          s.set(o, u)
          let d = new t.endpointDiscoveryCommandCtor({
            Operation: i.slice(0, -7),
            Identifiers: a,
          })
          d.resolveMiddleware(
            t.clientStack,
            e,
            t.options,
          )(d)
            .then((_) => {
              s.set(o, _.output.Endpoints),
                yr[o] &&
                  (yr[o].forEach(({ resolve: f }) => {
                    f()
                  }),
                  delete yr[o]),
                n()
            })
            .catch((_) => {
              s.delete(o)
              let f = Object.assign(
                new Error(
                  'The operation to discover endpoint failed. Please retry, or provide a custom endpoint and disable endpoint discovery to proceed.',
                ),
                { reason: _ },
              )
              yr[o] &&
                (yr[o].forEach(({ reject: h }) => {
                  h(f)
                }),
                delete yr[o]),
                t.isDiscoveredEndpointRequired ? r(f) : (s.set(o, u), n())
            })
        }
      })
  Jp.updateDiscoveredEndpointInCache = zie
})
var dU = l((Qp) => {
  'use strict'
  Object.defineProperty(Qp, '__esModule', { value: !0 })
  Qp.endpointDiscoveryMiddleware = void 0
  var Hie = Oe(),
    Vie = iU(),
    cU = aU(),
    Yie = (e, t) => (n, r) => async (s) => {
      if (e.isCustomEndpoint) {
        if (e.isClientEndpointDiscoveryEnabled)
          throw new Error(
            'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.',
          )
        return n(s)
      }
      let { endpointDiscoveryCommandCtor: o } = e,
        { isDiscoveredEndpointRequired: i, identifiers: a } = t,
        c = r.clientName,
        u = r.commandName,
        d = await e.endpointDiscoveryEnabled(),
        p = await (0, Vie.getCacheKey)(u, e, { identifiers: a })
      if (i) {
        if (d === !1)
          throw new Error(
            `Endpoint Discovery is disabled but ${u} on ${c} requires it. Please check your configurations.`,
          )
        await (0, cU.updateDiscoveredEndpointInCache)(e, {
          ...t,
          commandName: u,
          cacheKey: p,
          endpointDiscoveryCommandCtor: o,
        })
      } else
        d &&
          (0, cU.updateDiscoveredEndpointInCache)(e, {
            ...t,
            commandName: u,
            cacheKey: p,
            endpointDiscoveryCommandCtor: o,
          })
      let { request: _ } = s
      if (p && Hie.HttpRequest.isInstance(_)) {
        let f = e.endpointCache.getEndpoint(p)
        f && (_.hostname = f)
      }
      return n(s)
    }
  Qp.endpointDiscoveryMiddleware = Yie
})
var uU = l((wt) => {
  'use strict'
  Object.defineProperty(wt, '__esModule', { value: !0 })
  wt.getEndpointDiscoveryOptionalPlugin =
    wt.getEndpointDiscoveryRequiredPlugin =
    wt.getEndpointDiscoveryPlugin =
    wt.endpointDiscoveryMiddlewareOptions =
      void 0
  var D0 = dU()
  wt.endpointDiscoveryMiddlewareOptions = {
    name: 'endpointDiscoveryMiddleware',
    step: 'build',
    tags: ['ENDPOINT_DISCOVERY'],
    override: !0,
  }
  var Wie = (e, t) => ({
    applyToStack: (n) => {
      n.add(
        (0, D0.endpointDiscoveryMiddleware)(e, t),
        wt.endpointDiscoveryMiddlewareOptions,
      )
    },
  })
  wt.getEndpointDiscoveryPlugin = Wie
  var Kie = (e, t) => ({
    applyToStack: (n) => {
      n.add(
        (0, D0.endpointDiscoveryMiddleware)(e, {
          ...t,
          isDiscoveredEndpointRequired: !0,
        }),
        wt.endpointDiscoveryMiddlewareOptions,
      )
    },
  })
  wt.getEndpointDiscoveryRequiredPlugin = Kie
  var Xie = (e, t) => ({
    applyToStack: (n) => {
      n.add(
        (0, D0.endpointDiscoveryMiddleware)(e, {
          ...t,
          isDiscoveredEndpointRequired: !1,
        }),
        wt.endpointDiscoveryMiddlewareOptions,
      )
    },
  })
  wt.getEndpointDiscoveryOptionalPlugin = Xie
})
var mU = l((lU) => {
  'use strict'
  Object.defineProperty(lU, '__esModule', { value: !0 })
})
var _U = l((fje, pU) => {
  function Er(e) {
    Object.defineProperty(this, '_next', {
      writable: !1,
      enumerable: !1,
      value: e,
    }),
      (this.done = !1)
  }
  Er.prototype.next = function () {
    if (this.done) return { done: !0 }
    var e = this._next()
    return e.done && (this.done = !0), e
  }
  typeof Symbol < 'u' &&
    (Er.prototype[Symbol.iterator] = function () {
      return this
    })
  Er.of = function () {
    var e = arguments,
      t = e.length,
      n = 0
    return new Er(function () {
      return n >= t ? { done: !0 } : { done: !1, value: e[n++] }
    })
  }
  Er.empty = function () {
    var e = new Er(null)
    return (e.done = !0), e
  }
  Er.is = function (e) {
    return e instanceof Er
      ? !0
      : typeof e == 'object' && e !== null && typeof e.next == 'function'
  }
  pU.exports = Er
})
var A0 = l((hje, yU) => {
  var fU = typeof ArrayBuffer < 'u',
    hU = typeof Symbol < 'u'
  function gU(e, t) {
    var n, r, s, o, i
    if (!e) throw new Error('obliterator/forEach: invalid iterable.')
    if (typeof t != 'function')
      throw new Error('obliterator/forEach: expecting a callback.')
    if (
      Array.isArray(e) ||
      (fU && ArrayBuffer.isView(e)) ||
      typeof e == 'string' ||
      e.toString() === '[object Arguments]'
    ) {
      for (s = 0, o = e.length; s < o; s++) t(e[s], s)
      return
    }
    if (typeof e.forEach == 'function') {
      e.forEach(t)
      return
    }
    if (
      (hU &&
        Symbol.iterator in e &&
        typeof e.next != 'function' &&
        (e = e[Symbol.iterator]()),
      typeof e.next == 'function')
    ) {
      for (n = e, s = 0; (i = n.next()), i.done !== !0; ) t(i.value, s), s++
      return
    }
    for (r in e) e.hasOwnProperty(r) && t(e[r], r)
  }
  gU.forEachWithNullKeys = function (e, t) {
    var n, r, s, o, i
    if (!e)
      throw new Error('obliterator/forEachWithNullKeys: invalid iterable.')
    if (typeof t != 'function')
      throw new Error('obliterator/forEachWithNullKeys: expecting a callback.')
    if (
      Array.isArray(e) ||
      (fU && ArrayBuffer.isView(e)) ||
      typeof e == 'string' ||
      e.toString() === '[object Arguments]'
    ) {
      for (s = 0, o = e.length; s < o; s++) t(e[s], null)
      return
    }
    if (e instanceof Set) {
      e.forEach(function (a) {
        t(a, null)
      })
      return
    }
    if (typeof e.forEach == 'function') {
      e.forEach(t)
      return
    }
    if (
      (hU &&
        Symbol.iterator in e &&
        typeof e.next != 'function' &&
        (e = e[Symbol.iterator]()),
      typeof e.next == 'function')
    ) {
      for (n = e, s = 0; (i = n.next()), i.done !== !0; ) t(i.value, null), s++
      return
    }
    for (r in e) e.hasOwnProperty(r) && t(e[r], r)
  }
  yU.exports = gU
})
var O0 = l((On) => {
  var Jie = Math.pow(2, 8) - 1,
    Qie = Math.pow(2, 16) - 1,
    Zie = Math.pow(2, 32) - 1,
    eae = Math.pow(2, 7) - 1,
    tae = Math.pow(2, 15) - 1,
    nae = Math.pow(2, 31) - 1
  On.getPointerArray = function (e) {
    var t = e - 1
    return t <= Jie
      ? Uint8Array
      : t <= Qie
        ? Uint16Array
        : t <= Zie
          ? Uint32Array
          : Float64Array
  }
  On.getSignedPointerArray = function (e) {
    var t = e - 1
    return t <= eae
      ? Int8Array
      : t <= tae
        ? Int16Array
        : t <= nae
          ? Int32Array
          : Float64Array
  }
  On.getNumberType = function (e) {
    return e === (e | 0)
      ? Math.sign(e) === -1
        ? e <= 127 && e >= -128
          ? Int8Array
          : e <= 32767 && e >= -32768
            ? Int16Array
            : Int32Array
        : e <= 255
          ? Uint8Array
          : e <= 65535
            ? Uint16Array
            : Uint32Array
      : Float64Array
  }
  var rae = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8,
  }
  On.getMinimalRepresentation = function (e, t) {
    var n = null,
      r = 0,
      s,
      o,
      i,
      a,
      c
    for (a = 0, c = e.length; a < c; a++)
      (i = t ? t(e[a]) : e[a]),
        (o = On.getNumberType(i)),
        (s = rae[o.name]),
        s > r && ((r = s), (n = o))
    return n
  }
  On.isTypedArray = function (e) {
    return typeof ArrayBuffer < 'u' && ArrayBuffer.isView(e)
  }
  On.concat = function () {
    var e = 0,
      t,
      n,
      r
    for (t = 0, r = arguments.length; t < r; t++) e += arguments[t].length
    var s = new arguments[0].constructor(e)
    for (t = 0, n = 0; t < r; t++)
      s.set(arguments[t], n), (n += arguments[t].length)
    return s
  }
  On.indices = function (e) {
    for (var t = On.getPointerArray(e), n = new t(e), r = 0; r < e; r++)
      n[r] = r
    return n
  }
})
var bU = l((Du) => {
  var EU = A0(),
    SU = O0()
  function sae(e) {
    return Array.isArray(e) || SU.isTypedArray(e)
  }
  function N0(e) {
    if (typeof e.length == 'number') return e.length
    if (typeof e.size == 'number') return e.size
  }
  function oae(e) {
    var t = N0(e),
      n = typeof t == 'number' ? new Array(t) : [],
      r = 0
    return (
      EU(e, function (s) {
        n[r++] = s
      }),
      n
    )
  }
  function iae(e) {
    var t = N0(e),
      n = typeof t == 'number' ? SU.getPointerArray(t) : Array,
      r = typeof t == 'number' ? new Array(t) : [],
      s = typeof t == 'number' ? new n(t) : [],
      o = 0
    return (
      EU(e, function (i) {
        ;(r[o] = i), (s[o] = o++)
      }),
      [r, s]
    )
  }
  Du.isArrayLike = sae
  Du.guessLength = N0
  Du.toArray = oae
  Du.toArrayWithIndices = iae
})
var CU = l((Eje, vU) => {
  var q0 = _U(),
    aae = A0(),
    cae = O0(),
    dae = bU()
  function Ne(e, t, n) {
    if (
      (arguments.length < 2 && ((n = e), (e = null), (t = null)),
      (this.capacity = n),
      typeof this.capacity != 'number' || this.capacity <= 0)
    )
      throw new Error(
        'mnemonist/lru-cache: capacity should be positive number.',
      )
    var r = cae.getPointerArray(n)
    ;(this.forward = new r(n)),
      (this.backward = new r(n)),
      (this.K = typeof e == 'function' ? new e(n) : new Array(n)),
      (this.V = typeof t == 'function' ? new t(n) : new Array(n)),
      (this.size = 0),
      (this.head = 0),
      (this.tail = 0),
      (this.items = {})
  }
  Ne.prototype.clear = function () {
    ;(this.size = 0), (this.head = 0), (this.tail = 0), (this.items = {})
  }
  Ne.prototype.splayOnTop = function (e) {
    var t = this.head
    if (this.head === e) return this
    var n = this.backward[e],
      r = this.forward[e]
    return (
      this.tail === e ? (this.tail = n) : (this.backward[r] = n),
      (this.forward[n] = r),
      (this.backward[t] = e),
      (this.head = e),
      (this.forward[e] = t),
      this
    )
  }
  Ne.prototype.set = function (e, t) {
    var n = this.items[e]
    if (typeof n < 'u') {
      this.splayOnTop(n), (this.V[n] = t)
      return
    }
    this.size < this.capacity
      ? (n = this.size++)
      : ((n = this.tail),
        (this.tail = this.backward[n]),
        delete this.items[this.K[n]]),
      (this.items[e] = n),
      (this.K[n] = e),
      (this.V[n] = t),
      (this.forward[n] = this.head),
      (this.backward[this.head] = n),
      (this.head = n)
  }
  Ne.prototype.setpop = function (e, t) {
    var n = null,
      r = null,
      s = this.items[e]
    return typeof s < 'u'
      ? (this.splayOnTop(s),
        (n = this.V[s]),
        (this.V[s] = t),
        { evicted: !1, key: e, value: n })
      : (this.size < this.capacity
          ? (s = this.size++)
          : ((s = this.tail),
            (this.tail = this.backward[s]),
            (n = this.V[s]),
            (r = this.K[s]),
            delete this.items[this.K[s]]),
        (this.items[e] = s),
        (this.K[s] = e),
        (this.V[s] = t),
        (this.forward[s] = this.head),
        (this.backward[this.head] = s),
        (this.head = s),
        r ? { evicted: !0, key: r, value: n } : null)
  }
  Ne.prototype.has = function (e) {
    return e in this.items
  }
  Ne.prototype.get = function (e) {
    var t = this.items[e]
    if (!(typeof t > 'u')) return this.splayOnTop(t), this.V[t]
  }
  Ne.prototype.peek = function (e) {
    var t = this.items[e]
    if (!(typeof t > 'u')) return this.V[t]
  }
  Ne.prototype.forEach = function (e, t) {
    t = arguments.length > 1 ? t : this
    for (
      var n = 0,
        r = this.size,
        s = this.head,
        o = this.K,
        i = this.V,
        a = this.forward;
      n < r;

    )
      e.call(t, i[s], o[s], this), (s = a[s]), n++
  }
  Ne.prototype.keys = function () {
    var e = 0,
      t = this.size,
      n = this.head,
      r = this.K,
      s = this.forward
    return new q0(function () {
      if (e >= t) return { done: !0 }
      var o = r[n]
      return e++, e < t && (n = s[n]), { done: !1, value: o }
    })
  }
  Ne.prototype.values = function () {
    var e = 0,
      t = this.size,
      n = this.head,
      r = this.V,
      s = this.forward
    return new q0(function () {
      if (e >= t) return { done: !0 }
      var o = r[n]
      return e++, e < t && (n = s[n]), { done: !1, value: o }
    })
  }
  Ne.prototype.entries = function () {
    var e = 0,
      t = this.size,
      n = this.head,
      r = this.K,
      s = this.V,
      o = this.forward
    return new q0(function () {
      if (e >= t) return { done: !0 }
      var i = r[n],
        a = s[n]
      return e++, e < t && (n = o[n]), { done: !1, value: [i, a] }
    })
  }
  typeof Symbol < 'u' && (Ne.prototype[Symbol.iterator] = Ne.prototype.entries)
  Ne.prototype.inspect = function () {
    for (var e = new Map(), t = this.entries(), n; (n = t.next()), !n.done; )
      e.set(n.value[0], n.value[1])
    return (
      Object.defineProperty(e, 'constructor', { value: Ne, enumerable: !1 }), e
    )
  }
  typeof Symbol < 'u' &&
    (Ne.prototype[Symbol.for('nodejs.util.inspect.custom')] =
      Ne.prototype.inspect)
  Ne.from = function (e, t, n, r) {
    if (arguments.length < 2) {
      if (((r = dae.guessLength(e)), typeof r != 'number'))
        throw new Error(
          'mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.',
        )
    } else arguments.length === 2 && ((r = t), (t = null), (n = null))
    var s = new Ne(t, n, r)
    return (
      aae(e, function (o, i) {
        s.set(i, o)
      }),
      s
    )
  }
  vU.exports = Ne
})
var TU = l((Zp) => {
  'use strict'
  Object.defineProperty(Zp, '__esModule', { value: !0 })
  Zp.EndpointCache = void 0
  var uae = (x(), w(I)),
    lae = uae.__importDefault(CU()),
    k0 = class {
      constructor(t) {
        this.cache = new lae.default(t)
      }
      getEndpoint(t) {
        let n = this.get(t)
        if (!n || n.length === 0) return
        let r = n.map((s) => s.Address)
        return r[Math.floor(Math.random() * r.length)]
      }
      get(t) {
        if (!this.has(t)) return
        let n = this.cache.get(t)
        if (!n) return
        let r = Date.now(),
          s = n.filter((o) => r < o.Expires)
        if (s.length === 0) {
          this.delete(t)
          return
        }
        return s
      }
      set(t, n) {
        let r = Date.now()
        this.cache.set(
          t,
          n.map(({ Address: s, CachePeriodInMinutes: o }) => ({
            Address: s,
            Expires: r + o * 60 * 1e3,
          })),
        )
      }
      delete(t) {
        this.cache.set(t, [])
      }
      has(t) {
        if (!this.cache.has(t)) return !1
        let n = this.cache.peek(t)
        return n ? n.length > 0 : !1
      }
      clear() {
        this.cache.clear()
      }
    }
  Zp.EndpointCache = k0
})
var IU = l((e_) => {
  'use strict'
  Object.defineProperty(e_, '__esModule', { value: !0 })
  var wU = (x(), w(I))
  wU.__exportStar(mU(), e_)
  wU.__exportStar(TU(), e_)
})
var xU = l((t_) => {
  'use strict'
  Object.defineProperty(t_, '__esModule', { value: !0 })
  t_.resolveEndpointDiscoveryConfig = void 0
  var mae = IU(),
    pae = (e, { endpointDiscoveryCommandCtor: t }) => {
      var n
      return {
        ...e,
        endpointDiscoveryCommandCtor: t,
        endpointCache: new mae.EndpointCache(
          (n = e.endpointCacheSize) !== null && n !== void 0 ? n : 1e3,
        ),
        endpointDiscoveryEnabled:
          e.endpointDiscoveryEnabled !== void 0
            ? () => Promise.resolve(e.endpointDiscoveryEnabled)
            : e.endpointDiscoveryEnabledProvider,
        isClientEndpointDiscoveryEnabled: e.endpointDiscoveryEnabled !== void 0,
      }
    }
  t_.resolveEndpointDiscoveryConfig = pae
})
var L0 = l((Au) => {
  'use strict'
  Object.defineProperty(Au, '__esModule', { value: !0 })
  var M0 = (x(), w(I))
  M0.__exportStar(yM(), Au)
  M0.__exportStar(uU(), Au)
  M0.__exportStar(xU(), Au)
})
var Ou = l((Vt) => {
  'use strict'
  Object.defineProperty(Vt, '__esModule', { value: !0 })
  Vt.getHostHeaderPlugin =
    Vt.hostHeaderMiddlewareOptions =
    Vt.hostHeaderMiddleware =
    Vt.resolveHostHeaderConfig =
      void 0
  var _ae = Oe()
  function fae(e) {
    return e
  }
  Vt.resolveHostHeaderConfig = fae
  var hae = (e) => (t) => async (n) => {
    if (!_ae.HttpRequest.isInstance(n.request)) return t(n)
    let { request: r } = n,
      { handlerProtocol: s = '' } = e.requestHandler.metadata || {}
    if (s.indexOf('h2') >= 0 && !r.headers[':authority'])
      delete r.headers.host,
        (r.headers[':authority'] = r.hostname + (r.port ? ':' + r.port : ''))
    else if (!r.headers.host) {
      let o = r.hostname
      r.port != null && (o += `:${r.port}`), (r.headers.host = o)
    }
    return t(n)
  }
  Vt.hostHeaderMiddleware = hae
  Vt.hostHeaderMiddlewareOptions = {
    name: 'hostHeaderMiddleware',
    step: 'build',
    priority: 'low',
    tags: ['HOST'],
    override: !0,
  }
  var gae = (e) => ({
    applyToStack: (t) => {
      t.add((0, Vt.hostHeaderMiddleware)(e), Vt.hostHeaderMiddlewareOptions)
    },
  })
  Vt.getHostHeaderPlugin = gae
})
var PU = l((Nn) => {
  'use strict'
  Object.defineProperty(Nn, '__esModule', { value: !0 })
  Nn.getLoggerPlugin = Nn.loggerMiddlewareOptions = Nn.loggerMiddleware = void 0
  var yae = () => (e, t) => async (n) => {
    var r, s
    try {
      let o = await e(n),
        {
          clientName: i,
          commandName: a,
          logger: c,
          dynamoDbDocumentClientOptions: u = {},
        } = t,
        {
          overrideInputFilterSensitiveLog: d,
          overrideOutputFilterSensitiveLog: p,
        } = u,
        _ = d ?? t.inputFilterSensitiveLog,
        f = p ?? t.outputFilterSensitiveLog,
        { $metadata: h, ...y } = o.output
      return (
        (r = c?.info) === null ||
          r === void 0 ||
          r.call(c, {
            clientName: i,
            commandName: a,
            input: _(n.input),
            output: f(y),
            metadata: h,
          }),
        o
      )
    } catch (o) {
      let {
          clientName: i,
          commandName: a,
          logger: c,
          dynamoDbDocumentClientOptions: u = {},
        } = t,
        { overrideInputFilterSensitiveLog: d } = u,
        p = d ?? t.inputFilterSensitiveLog
      throw (
        ((s = c?.error) === null ||
          s === void 0 ||
          s.call(c, {
            clientName: i,
            commandName: a,
            input: p(n.input),
            error: o,
            metadata: o.$metadata,
          }),
        o)
      )
    }
  }
  Nn.loggerMiddleware = yae
  Nn.loggerMiddlewareOptions = {
    name: 'loggerMiddleware',
    tags: ['LOGGER'],
    step: 'initialize',
    override: !0,
  }
  var Eae = (e) => ({
    applyToStack: (t) => {
      t.add((0, Nn.loggerMiddleware)(), Nn.loggerMiddlewareOptions)
    },
  })
  Nn.getLoggerPlugin = Eae
})
var Nu = l((U0) => {
  'use strict'
  Object.defineProperty(U0, '__esModule', { value: !0 })
  var Sae = (x(), w(I))
  Sae.__exportStar(PU(), U0)
})
var qu = l((qn) => {
  'use strict'
  Object.defineProperty(qn, '__esModule', { value: !0 })
  qn.getRecursionDetectionPlugin =
    qn.addRecursionDetectionMiddlewareOptions =
    qn.recursionDetectionMiddleware =
      void 0
  var bae = Oe(),
    RU = 'X-Amzn-Trace-Id',
    vae = 'AWS_LAMBDA_FUNCTION_NAME',
    Cae = '_X_AMZN_TRACE_ID',
    Tae = (e) => (t) => async (n) => {
      let { request: r } = n
      if (
        !bae.HttpRequest.isInstance(r) ||
        e.runtime !== 'node' ||
        r.headers.hasOwnProperty(RU)
      )
        return t(n)
      let s = process.env[vae],
        o = process.env[Cae],
        i = (a) => typeof a == 'string' && a.length > 0
      return i(s) && i(o) && (r.headers[RU] = o), t({ ...n, request: r })
    }
  qn.recursionDetectionMiddleware = Tae
  qn.addRecursionDetectionMiddlewareOptions = {
    step: 'build',
    tags: ['RECURSION_DETECTION'],
    name: 'recursionDetectionMiddleware',
    override: !0,
    priority: 'low',
  }
  var wae = (e) => ({
    applyToStack: (t) => {
      t.add(
        (0, qn.recursionDetectionMiddleware)(e),
        qn.addRecursionDetectionMiddlewareOptions,
      )
    },
  })
  qn.getRecursionDetectionPlugin = wae
})
var ku = l((n_) => {
  'use strict'
  Object.defineProperty(n_, '__esModule', { value: !0 })
  n_.ProviderError = void 0
  var F0 = class e extends Error {
    constructor(t, n = !0) {
      super(t),
        (this.tryNextLink = n),
        (this.name = 'ProviderError'),
        Object.setPrototypeOf(this, e.prototype)
    }
    static from(t, n = !0) {
      return Object.assign(new this(t.message, n), t)
    }
  }
  n_.ProviderError = F0
})
var DU = l((r_) => {
  'use strict'
  Object.defineProperty(r_, '__esModule', { value: !0 })
  r_.CredentialsProviderError = void 0
  var Iae = ku(),
    B0 = class e extends Iae.ProviderError {
      constructor(t, n = !0) {
        super(t, n),
          (this.tryNextLink = n),
          (this.name = 'CredentialsProviderError'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  r_.CredentialsProviderError = B0
})
var AU = l((s_) => {
  'use strict'
  Object.defineProperty(s_, '__esModule', { value: !0 })
  s_.TokenProviderError = void 0
  var xae = ku(),
    j0 = class e extends xae.ProviderError {
      constructor(t, n = !0) {
        super(t, n),
          (this.tryNextLink = n),
          (this.name = 'TokenProviderError'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  s_.TokenProviderError = j0
})
var OU = l((o_) => {
  'use strict'
  Object.defineProperty(o_, '__esModule', { value: !0 })
  o_.chain = void 0
  var Pae = ku(),
    Rae =
      (...e) =>
      async () => {
        if (e.length === 0) throw new Pae.ProviderError('No providers in chain')
        let t
        for (let n of e)
          try {
            return await n()
          } catch (r) {
            if (((t = r), r?.tryNextLink)) continue
            throw r
          }
        throw t
      }
  o_.chain = Rae
})
var NU = l((i_) => {
  'use strict'
  Object.defineProperty(i_, '__esModule', { value: !0 })
  i_.fromStatic = void 0
  var Dae = (e) => () => Promise.resolve(e)
  i_.fromStatic = Dae
})
var qU = l((a_) => {
  'use strict'
  Object.defineProperty(a_, '__esModule', { value: !0 })
  a_.memoize = void 0
  var Aae = (e, t, n) => {
    let r,
      s,
      o,
      i = !1,
      a = async () => {
        s || (s = e())
        try {
          ;(r = await s), (o = !0), (i = !1)
        } finally {
          s = void 0
        }
        return r
      }
    return t === void 0
      ? async (c) => ((!o || c?.forceRefresh) && (r = await a()), r)
      : async (c) => (
          (!o || c?.forceRefresh) && (r = await a()),
          i ? r : n && !n(r) ? ((i = !0), r) : (t(r) && (await a()), r)
        )
  }
  a_.memoize = Aae
})
var ye = l((rs) => {
  'use strict'
  Object.defineProperty(rs, '__esModule', { value: !0 })
  var ji = (x(), w(I))
  ji.__exportStar(DU(), rs)
  ji.__exportStar(ku(), rs)
  ji.__exportStar(AU(), rs)
  ji.__exportStar(OU(), rs)
  ji.__exportStar(NU(), rs)
  ji.__exportStar(qU(), rs)
})
var H0 = {}
fd(H0, {
  __assign: () => $0,
  __asyncDelegator: () => zae,
  __asyncGenerator: () => $ae,
  __asyncValues: () => Hae,
  __await: () => Mu,
  __awaiter: () => Lae,
  __classPrivateFieldGet: () => Kae,
  __classPrivateFieldSet: () => Xae,
  __createBinding: () => Fae,
  __decorate: () => qae,
  __exportStar: () => Bae,
  __extends: () => Oae,
  __generator: () => Uae,
  __importDefault: () => Wae,
  __importStar: () => Yae,
  __makeTemplateObject: () => Vae,
  __metadata: () => Mae,
  __param: () => kae,
  __read: () => kU,
  __rest: () => Nae,
  __spread: () => jae,
  __spreadArrays: () => Gae,
  __values: () => z0,
})
function Oae(e, t) {
  G0(e, t)
  function n() {
    this.constructor = e
  }
  e.prototype =
    t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
}
function Nae(e, t) {
  var n = {}
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++)
      t.indexOf(r[s]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[s]) &&
        (n[r[s]] = e[r[s]])
  return n
}
function qae(e, t, n, r) {
  var s = arguments.length,
    o =
      s < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
    i
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    o = Reflect.decorate(e, t, n, r)
  else
    for (var a = e.length - 1; a >= 0; a--)
      (i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o)
  return s > 3 && o && Object.defineProperty(t, n, o), o
}
function kae(e, t) {
  return function (n, r) {
    t(n, r, e)
  }
}
function Mae(e, t) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(e, t)
}
function Lae(e, t, n, r) {
  function s(o) {
    return o instanceof n
      ? o
      : new n(function (i) {
          i(o)
        })
  }
  return new (n || (n = Promise))(function (o, i) {
    function a(d) {
      try {
        u(r.next(d))
      } catch (p) {
        i(p)
      }
    }
    function c(d) {
      try {
        u(r.throw(d))
      } catch (p) {
        i(p)
      }
    }
    function u(d) {
      d.done ? o(d.value) : s(d.value).then(a, c)
    }
    u((r = r.apply(e, t || [])).next())
  })
}
function Uae(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1]
        return o[1]
      },
      trys: [],
      ops: [],
    },
    r,
    s,
    o,
    i
  return (
    (i = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == 'function' &&
      (i[Symbol.iterator] = function () {
        return this
      }),
    i
  )
  function a(u) {
    return function (d) {
      return c([u, d])
    }
  }
  function c(u) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; n; )
      try {
        if (
          ((r = 1),
          s &&
            (o =
              u[0] & 2
                ? s.return
                : u[0]
                  ? s.throw || ((o = s.return) && o.call(s), 0)
                  : s.next) &&
            !(o = o.call(s, u[1])).done)
        )
          return o
        switch (((s = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
          case 0:
          case 1:
            o = u
            break
          case 4:
            return n.label++, { value: u[1], done: !1 }
          case 5:
            n.label++, (s = u[1]), (u = [0])
            continue
          case 7:
            ;(u = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((o = n.trys),
              !(o = o.length > 0 && o[o.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              n = 0
              continue
            }
            if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
              n.label = u[1]
              break
            }
            if (u[0] === 6 && n.label < o[1]) {
              ;(n.label = o[1]), (o = u)
              break
            }
            if (o && n.label < o[2]) {
              ;(n.label = o[2]), n.ops.push(u)
              break
            }
            o[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        u = t.call(e, n)
      } catch (d) {
        ;(u = [6, d]), (s = 0)
      } finally {
        r = o = 0
      }
    if (u[0] & 5) throw u[1]
    return { value: u[0] ? u[1] : void 0, done: !0 }
  }
}
function Fae(e, t, n, r) {
  r === void 0 && (r = n), (e[r] = t[n])
}
function Bae(e, t) {
  for (var n in e) n !== 'default' && !t.hasOwnProperty(n) && (t[n] = e[n])
}
function z0(e) {
  var t = typeof Symbol == 'function' && Symbol.iterator,
    n = t && e[t],
    r = 0
  if (n) return n.call(e)
  if (e && typeof e.length == 'number')
    return {
      next: function () {
        return (
          e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
        )
      },
    }
  throw new TypeError(
    t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
  )
}
function kU(e, t) {
  var n = typeof Symbol == 'function' && e[Symbol.iterator]
  if (!n) return e
  var r = n.call(e),
    s,
    o = [],
    i
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; ) o.push(s.value)
  } catch (a) {
    i = { error: a }
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r)
    } finally {
      if (i) throw i.error
    }
  }
  return o
}
function jae() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(kU(arguments[t]))
  return e
}
function Gae() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++)
    e += arguments[t].length
  for (var r = Array(e), s = 0, t = 0; t < n; t++)
    for (var o = arguments[t], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i]
  return r
}
function Mu(e) {
  return this instanceof Mu ? ((this.v = e), this) : new Mu(e)
}
function $ae(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var r = n.apply(e, t || []),
    s,
    o = []
  return (
    (s = {}),
    i('next'),
    i('throw'),
    i('return'),
    (s[Symbol.asyncIterator] = function () {
      return this
    }),
    s
  )
  function i(_) {
    r[_] &&
      (s[_] = function (f) {
        return new Promise(function (h, y) {
          o.push([_, f, h, y]) > 1 || a(_, f)
        })
      })
  }
  function a(_, f) {
    try {
      c(r[_](f))
    } catch (h) {
      p(o[0][3], h)
    }
  }
  function c(_) {
    _.value instanceof Mu
      ? Promise.resolve(_.value.v).then(u, d)
      : p(o[0][2], _)
  }
  function u(_) {
    a('next', _)
  }
  function d(_) {
    a('throw', _)
  }
  function p(_, f) {
    _(f), o.shift(), o.length && a(o[0][0], o[0][1])
  }
}
function zae(e) {
  var t, n
  return (
    (t = {}),
    r('next'),
    r('throw', function (s) {
      throw s
    }),
    r('return'),
    (t[Symbol.iterator] = function () {
      return this
    }),
    t
  )
  function r(s, o) {
    t[s] = e[s]
      ? function (i) {
          return (n = !n)
            ? { value: Mu(e[s](i)), done: s === 'return' }
            : o
              ? o(i)
              : i
        }
      : o
  }
}
function Hae(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var t = e[Symbol.asyncIterator],
    n
  return t
    ? t.call(e)
    : ((e = typeof z0 == 'function' ? z0(e) : e[Symbol.iterator]()),
      (n = {}),
      r('next'),
      r('throw'),
      r('return'),
      (n[Symbol.asyncIterator] = function () {
        return this
      }),
      n)
  function r(o) {
    n[o] =
      e[o] &&
      function (i) {
        return new Promise(function (a, c) {
          ;(i = e[o](i)), s(a, c, i.done, i.value)
        })
      }
  }
  function s(o, i, a, c) {
    Promise.resolve(c).then(function (u) {
      o({ value: u, done: a })
    }, i)
  }
}
function Vae(e, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(e, 'raw', { value: t })
      : (e.raw = t),
    e
  )
}
function Yae(e) {
  if (e && e.__esModule) return e
  var t = {}
  if (e != null)
    for (var n in e) Object.hasOwnProperty.call(e, n) && (t[n] = e[n])
  return (t.default = e), t
}
function Wae(e) {
  return e && e.__esModule ? e : { default: e }
}
function Kae(e, t) {
  if (!t.has(e))
    throw new TypeError('attempted to get private field on non-instance')
  return t.get(e)
}
function Xae(e, t, n) {
  if (!t.has(e))
    throw new TypeError('attempted to set private field on non-instance')
  return t.set(e, n), n
}
var G0,
  $0,
  V0 = ue(() => {
    G0 = function (e, t) {
      return (
        (G0 =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (n, r) {
              n.__proto__ = r
            }) ||
          function (n, r) {
            for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s])
          }),
        G0(e, t)
      )
    }
    $0 = function () {
      return (
        ($0 =
          Object.assign ||
          function (t) {
            for (var n, r = 1, s = arguments.length; r < s; r++) {
              n = arguments[r]
              for (var o in n)
                Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o])
            }
            return t
          }),
        $0.apply(this, arguments)
      )
    }
  })
var MU = l((Gi) => {
  'use strict'
  Object.defineProperty(Gi, '__esModule', { value: !0 })
  Gi.toUtf8 = Gi.fromUtf8 = void 0
  var Jae = (e) => {
    let t = []
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e.charCodeAt(n)
      if (s < 128) t.push(s)
      else if (s < 2048) t.push((s >> 6) | 192, (s & 63) | 128)
      else if (
        n + 1 < e.length &&
        (s & 64512) === 55296 &&
        (e.charCodeAt(n + 1) & 64512) === 56320
      ) {
        let o = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++n) & 1023)
        t.push(
          (o >> 18) | 240,
          ((o >> 12) & 63) | 128,
          ((o >> 6) & 63) | 128,
          (o & 63) | 128,
        )
      } else t.push((s >> 12) | 224, ((s >> 6) & 63) | 128, (s & 63) | 128)
    }
    return Uint8Array.from(t)
  }
  Gi.fromUtf8 = Jae
  var Qae = (e) => {
    let t = ''
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e[n]
      if (s < 128) t += String.fromCharCode(s)
      else if (192 <= s && s < 224) {
        let o = e[++n]
        t += String.fromCharCode(((s & 31) << 6) | (o & 63))
      } else if (240 <= s && s < 365) {
        let i =
          '%' + [s, e[++n], e[++n], e[++n]].map((a) => a.toString(16)).join('%')
        t += decodeURIComponent(i)
      } else
        t += String.fromCharCode(
          ((s & 15) << 12) | ((e[++n] & 63) << 6) | (e[++n] & 63),
        )
    }
    return t
  }
  Gi.toUtf8 = Qae
})
var LU = l(($i) => {
  'use strict'
  Object.defineProperty($i, '__esModule', { value: !0 })
  $i.toUtf8 = $i.fromUtf8 = void 0
  function Zae(e) {
    return new TextEncoder().encode(e)
  }
  $i.fromUtf8 = Zae
  function ece(e) {
    return new TextDecoder('utf-8').decode(e)
  }
  $i.toUtf8 = ece
})
var BU = l((zi) => {
  'use strict'
  Object.defineProperty(zi, '__esModule', { value: !0 })
  zi.toUtf8 = zi.fromUtf8 = void 0
  var UU = MU(),
    FU = LU(),
    tce = (e) =>
      typeof TextEncoder == 'function'
        ? (0, FU.fromUtf8)(e)
        : (0, UU.fromUtf8)(e)
  zi.fromUtf8 = tce
  var nce = (e) =>
    typeof TextDecoder == 'function' ? (0, FU.toUtf8)(e) : (0, UU.toUtf8)(e)
  zi.toUtf8 = nce
})
var jU = l((c_) => {
  'use strict'
  Object.defineProperty(c_, '__esModule', { value: !0 })
  c_.convertToBuffer = void 0
  var rce = BU(),
    sce =
      typeof Buffer < 'u' && Buffer.from
        ? function (e) {
            return Buffer.from(e, 'utf8')
          }
        : rce.fromUtf8
  function oce(e) {
    return e instanceof Uint8Array
      ? e
      : typeof e == 'string'
        ? sce(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
            )
          : new Uint8Array(e)
  }
  c_.convertToBuffer = oce
})
var GU = l((d_) => {
  'use strict'
  Object.defineProperty(d_, '__esModule', { value: !0 })
  d_.isEmptyData = void 0
  function ice(e) {
    return typeof e == 'string' ? e.length === 0 : e.byteLength === 0
  }
  d_.isEmptyData = ice
})
var $U = l((u_) => {
  'use strict'
  Object.defineProperty(u_, '__esModule', { value: !0 })
  u_.numToUint8 = void 0
  function ace(e) {
    return new Uint8Array([
      (e & 4278190080) >> 24,
      (e & 16711680) >> 16,
      (e & 65280) >> 8,
      e & 255,
    ])
  }
  u_.numToUint8 = ace
})
var zU = l((l_) => {
  'use strict'
  Object.defineProperty(l_, '__esModule', { value: !0 })
  l_.uint32ArrayFrom = void 0
  function cce(e) {
    if (!Uint32Array.from) {
      for (var t = new Uint32Array(e.length), n = 0; n < e.length; )
        (t[n] = e[n]), (n += 1)
      return t
    }
    return Uint32Array.from(e)
  }
  l_.uint32ArrayFrom = cce
})
var Y0 = l((kn) => {
  'use strict'
  Object.defineProperty(kn, '__esModule', { value: !0 })
  kn.uint32ArrayFrom =
    kn.numToUint8 =
    kn.isEmptyData =
    kn.convertToBuffer =
      void 0
  var dce = jU()
  Object.defineProperty(kn, 'convertToBuffer', {
    enumerable: !0,
    get: function () {
      return dce.convertToBuffer
    },
  })
  var uce = GU()
  Object.defineProperty(kn, 'isEmptyData', {
    enumerable: !0,
    get: function () {
      return uce.isEmptyData
    },
  })
  var lce = $U()
  Object.defineProperty(kn, 'numToUint8', {
    enumerable: !0,
    get: function () {
      return lce.numToUint8
    },
  })
  var mce = zU()
  Object.defineProperty(kn, 'uint32ArrayFrom', {
    enumerable: !0,
    get: function () {
      return mce.uint32ArrayFrom
    },
  })
})
var YU = l((m_) => {
  'use strict'
  Object.defineProperty(m_, '__esModule', { value: !0 })
  m_.AwsCrc32 = void 0
  var HU = (V0(), w(H0)),
    W0 = Y0(),
    VU = p_(),
    pce = (function () {
      function e() {
        this.crc32 = new VU.Crc32()
      }
      return (
        (e.prototype.update = function (t) {
          ;(0, W0.isEmptyData)(t) ||
            this.crc32.update((0, W0.convertToBuffer)(t))
        }),
        (e.prototype.digest = function () {
          return HU.__awaiter(this, void 0, void 0, function () {
            return HU.__generator(this, function (t) {
              return [2, (0, W0.numToUint8)(this.crc32.digest())]
            })
          })
        }),
        (e.prototype.reset = function () {
          this.crc32 = new VU.Crc32()
        }),
        e
      )
    })()
  m_.AwsCrc32 = pce
})
var p_ = l((ss) => {
  'use strict'
  Object.defineProperty(ss, '__esModule', { value: !0 })
  ss.AwsCrc32 = ss.Crc32 = ss.crc32 = void 0
  var _ce = (V0(), w(H0)),
    fce = Y0()
  function hce(e) {
    return new WU().update(e).digest()
  }
  ss.crc32 = hce
  var WU = (function () {
    function e() {
      this.checksum = 4294967295
    }
    return (
      (e.prototype.update = function (t) {
        var n, r
        try {
          for (var s = _ce.__values(t), o = s.next(); !o.done; o = s.next()) {
            var i = o.value
            this.checksum =
              (this.checksum >>> 8) ^ yce[(this.checksum ^ i) & 255]
          }
        } catch (a) {
          n = { error: a }
        } finally {
          try {
            o && !o.done && (r = s.return) && r.call(s)
          } finally {
            if (n) throw n.error
          }
        }
        return this
      }),
      (e.prototype.digest = function () {
        return (this.checksum ^ 4294967295) >>> 0
      }),
      e
    )
  })()
  ss.Crc32 = WU
  var gce = [
      0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685,
      2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995,
      2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648,
      2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990,
      1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755,
      2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145,
      1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206,
      2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980,
      1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705,
      3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527,
      1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772,
      4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
      251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719,
      3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925,
      453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202,
      4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960,
      984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733,
      3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467,
      855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048,
      3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054,
      702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443,
      3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945,
      2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430,
      2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
      2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225,
      1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
      2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732,
      1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850,
      2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135,
      1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109,
      3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954,
      1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920,
      3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877,
      83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603,
      3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992,
      534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
      4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795,
      376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105,
      3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270,
      936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108,
      3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449,
      601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471,
      3272380065, 1510334235, 755167117,
    ],
    yce = (0, fce.uint32ArrayFrom)(gce),
    Ece = YU()
  Object.defineProperty(ss, 'AwsCrc32', {
    enumerable: !0,
    get: function () {
      return Ece.AwsCrc32
    },
  })
})
var Vi = l((Hi) => {
  'use strict'
  Object.defineProperty(Hi, '__esModule', { value: !0 })
  Hi.toHex = Hi.fromHex = void 0
  var KU = {},
    K0 = {}
  for (let e = 0; e < 256; e++) {
    let t = e.toString(16).toLowerCase()
    t.length === 1 && (t = `0${t}`), (KU[e] = t), (K0[t] = e)
  }
  function Sce(e) {
    if (e.length % 2 !== 0)
      throw new Error('Hex encoded strings must have an even number length')
    let t = new Uint8Array(e.length / 2)
    for (let n = 0; n < e.length; n += 2) {
      let r = e.slice(n, n + 2).toLowerCase()
      if (r in K0) t[n / 2] = K0[r]
      else
        throw new Error(
          `Cannot decode unrecognized sequence ${r} as hexadecimal`,
        )
    }
    return t
  }
  Hi.fromHex = Sce
  function bce(e) {
    let t = ''
    for (let n = 0; n < e.byteLength; n++) t += KU[e[n]]
    return t
  }
  Hi.toHex = bce
})
var J0 = l((__) => {
  'use strict'
  Object.defineProperty(__, '__esModule', { value: !0 })
  __.Int64 = void 0
  var vce = Vi(),
    X0 = class e {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error('Int64 buffers must be exactly 8 bytes')
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          )
        let n = new Uint8Array(8)
        for (
          let r = 7, s = Math.abs(Math.round(t));
          r > -1 && s > 0;
          r--, s /= 256
        )
          n[r] = s
        return t < 0 && XU(n), new e(n)
      }
      valueOf() {
        let t = this.bytes.slice(0),
          n = t[0] & 128
        return n && XU(t), parseInt((0, vce.toHex)(t), 16) * (n ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    }
  __.Int64 = X0
  function XU(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
})
var eT = l((f_) => {
  'use strict'
  Object.defineProperty(f_, '__esModule', { value: !0 })
  f_.HeaderMarshaller = void 0
  var Yi = Vi(),
    Q0 = J0(),
    Z0 = class {
      constructor(t, n) {
        ;(this.toUtf8 = t), (this.fromUtf8 = n)
      }
      format(t) {
        let n = []
        for (let o of Object.keys(t)) {
          let i = this.fromUtf8(o)
          n.push(
            Uint8Array.from([i.byteLength]),
            i,
            this.formatHeaderValue(t[o]),
          )
        }
        let r = new Uint8Array(n.reduce((o, i) => o + i.byteLength, 0)),
          s = 0
        for (let o of n) r.set(o, s), (s += o.byteLength)
        return r
      }
      formatHeaderValue(t) {
        switch (t.type) {
          case 'boolean':
            return Uint8Array.from([t.value ? 0 : 1])
          case 'byte':
            return Uint8Array.from([2, t.value])
          case 'short':
            let n = new DataView(new ArrayBuffer(3))
            return (
              n.setUint8(0, 3),
              n.setInt16(1, t.value, !1),
              new Uint8Array(n.buffer)
            )
          case 'integer':
            let r = new DataView(new ArrayBuffer(5))
            return (
              r.setUint8(0, 4),
              r.setInt32(1, t.value, !1),
              new Uint8Array(r.buffer)
            )
          case 'long':
            let s = new Uint8Array(9)
            return (s[0] = 5), s.set(t.value.bytes, 1), s
          case 'binary':
            let o = new DataView(new ArrayBuffer(3 + t.value.byteLength))
            o.setUint8(0, 6), o.setUint16(1, t.value.byteLength, !1)
            let i = new Uint8Array(o.buffer)
            return i.set(t.value, 3), i
          case 'string':
            let a = this.fromUtf8(t.value),
              c = new DataView(new ArrayBuffer(3 + a.byteLength))
            c.setUint8(0, 7), c.setUint16(1, a.byteLength, !1)
            let u = new Uint8Array(c.buffer)
            return u.set(a, 3), u
          case 'timestamp':
            let d = new Uint8Array(9)
            return (
              (d[0] = 8),
              d.set(Q0.Int64.fromNumber(t.value.valueOf()).bytes, 1),
              d
            )
          case 'uuid':
            if (!Ace.test(t.value))
              throw new Error(`Invalid UUID received: ${t.value}`)
            let p = new Uint8Array(17)
            return (
              (p[0] = 9),
              p.set((0, Yi.fromHex)(t.value.replace(/\-/g, '')), 1),
              p
            )
        }
      }
      parse(t) {
        let n = {},
          r = 0
        for (; r < t.byteLength; ) {
          let s = t.getUint8(r++),
            o = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + r, s))
          switch (((r += s), t.getUint8(r++))) {
            case 0:
              n[o] = { type: QU, value: !0 }
              break
            case 1:
              n[o] = { type: QU, value: !1 }
              break
            case 2:
              n[o] = { type: Cce, value: t.getInt8(r++) }
              break
            case 3:
              ;(n[o] = { type: Tce, value: t.getInt16(r, !1) }), (r += 2)
              break
            case 4:
              ;(n[o] = { type: wce, value: t.getInt32(r, !1) }), (r += 4)
              break
            case 5:
              ;(n[o] = {
                type: Ice,
                value: new Q0.Int64(
                  new Uint8Array(t.buffer, t.byteOffset + r, 8),
                ),
              }),
                (r += 8)
              break
            case 6:
              let i = t.getUint16(r, !1)
              ;(r += 2),
                (n[o] = {
                  type: xce,
                  value: new Uint8Array(t.buffer, t.byteOffset + r, i),
                }),
                (r += i)
              break
            case 7:
              let a = t.getUint16(r, !1)
              ;(r += 2),
                (n[o] = {
                  type: Pce,
                  value: this.toUtf8(
                    new Uint8Array(t.buffer, t.byteOffset + r, a),
                  ),
                }),
                (r += a)
              break
            case 8:
              ;(n[o] = {
                type: Rce,
                value: new Date(
                  new Q0.Int64(
                    new Uint8Array(t.buffer, t.byteOffset + r, 8),
                  ).valueOf(),
                ),
              }),
                (r += 8)
              break
            case 9:
              let c = new Uint8Array(t.buffer, t.byteOffset + r, 16)
              ;(r += 16),
                (n[o] = {
                  type: Dce,
                  value: `${(0, Yi.toHex)(c.subarray(0, 4))}-${(0, Yi.toHex)(
                    c.subarray(4, 6),
                  )}-${(0, Yi.toHex)(c.subarray(6, 8))}-${(0, Yi.toHex)(
                    c.subarray(8, 10),
                  )}-${(0, Yi.toHex)(c.subarray(10))}`,
                })
              break
            default:
              throw new Error('Unrecognized header type tag')
          }
        }
        return n
      }
    }
  f_.HeaderMarshaller = Z0
  var JU
  ;(function (e) {
    ;(e[(e.boolTrue = 0)] = 'boolTrue'),
      (e[(e.boolFalse = 1)] = 'boolFalse'),
      (e[(e.byte = 2)] = 'byte'),
      (e[(e.short = 3)] = 'short'),
      (e[(e.integer = 4)] = 'integer'),
      (e[(e.long = 5)] = 'long'),
      (e[(e.byteArray = 6)] = 'byteArray'),
      (e[(e.string = 7)] = 'string'),
      (e[(e.timestamp = 8)] = 'timestamp'),
      (e[(e.uuid = 9)] = 'uuid')
  })(JU || (JU = {}))
  var QU = 'boolean',
    Cce = 'byte',
    Tce = 'short',
    wce = 'integer',
    Ice = 'long',
    xce = 'binary',
    Pce = 'string',
    Rce = 'timestamp',
    Dce = 'uuid',
    Ace = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/
})
var eF = l((h_) => {
  'use strict'
  Object.defineProperty(h_, '__esModule', { value: !0 })
  h_.splitMessage = void 0
  var Oce = p_(),
    ZU = 4,
    os = ZU * 2,
    Io = 4,
    Nce = os + Io * 2
  function qce({ byteLength: e, byteOffset: t, buffer: n }) {
    if (e < Nce)
      throw new Error(
        'Provided message too short to accommodate event stream message overhead',
      )
    let r = new DataView(n, t, e),
      s = r.getUint32(0, !1)
    if (e !== s)
      throw new Error(
        'Reported message length does not match received message length',
      )
    let o = r.getUint32(ZU, !1),
      i = r.getUint32(os, !1),
      a = r.getUint32(e - Io, !1),
      c = new Oce.Crc32().update(new Uint8Array(n, t, os))
    if (i !== c.digest())
      throw new Error(
        `The prelude checksum specified in the message (${i}) does not match the calculated CRC32 checksum (${c.digest()})`,
      )
    if ((c.update(new Uint8Array(n, t + os, e - (os + Io))), a !== c.digest()))
      throw new Error(
        `The message checksum (${c.digest()}) did not match the expected value of ${a}`,
      )
    return {
      headers: new DataView(n, t + os + Io, o),
      body: new Uint8Array(n, t + os + Io + o, s - o - (os + Io + Io)),
    }
  }
  h_.splitMessage = qce
})
var tF = l((g_) => {
  'use strict'
  Object.defineProperty(g_, '__esModule', { value: !0 })
  g_.EventStreamCodec = void 0
  var kce = p_(),
    Mce = eT(),
    Lce = eF(),
    tT = class {
      constructor(t, n) {
        ;(this.headerMarshaller = new Mce.HeaderMarshaller(t, n)),
          (this.messageBuffer = []),
          (this.isEndOfStream = !1)
      }
      feed(t) {
        this.messageBuffer.push(this.decode(t))
      }
      endOfStream() {
        this.isEndOfStream = !0
      }
      getMessage() {
        let t = this.messageBuffer.pop(),
          n = this.isEndOfStream
        return {
          getMessage() {
            return t
          },
          isEndOfStream() {
            return n
          },
        }
      }
      getAvailableMessages() {
        let t = this.messageBuffer
        this.messageBuffer = []
        let n = this.isEndOfStream
        return {
          getMessages() {
            return t
          },
          isEndOfStream() {
            return n
          },
        }
      }
      encode({ headers: t, body: n }) {
        let r = this.headerMarshaller.format(t),
          s = r.byteLength + n.byteLength + 16,
          o = new Uint8Array(s),
          i = new DataView(o.buffer, o.byteOffset, o.byteLength),
          a = new kce.Crc32()
        return (
          i.setUint32(0, s, !1),
          i.setUint32(4, r.byteLength, !1),
          i.setUint32(8, a.update(o.subarray(0, 8)).digest(), !1),
          o.set(r, 12),
          o.set(n, r.byteLength + 12),
          i.setUint32(s - 4, a.update(o.subarray(8, s - 4)).digest(), !1),
          o
        )
      }
      decode(t) {
        let { headers: n, body: r } = (0, Lce.splitMessage)(t)
        return { headers: this.headerMarshaller.parse(n), body: r }
      }
      formatHeaders(t) {
        return this.headerMarshaller.format(t)
      }
    }
  g_.EventStreamCodec = tT
})
var rF = l((nF) => {
  'use strict'
  Object.defineProperty(nF, '__esModule', { value: !0 })
})
var sF = l((y_) => {
  'use strict'
  Object.defineProperty(y_, '__esModule', { value: !0 })
  y_.MessageDecoderStream = void 0
  var nT = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.inputStream)
        yield this.options.decoder.decode(t)
    }
  }
  y_.MessageDecoderStream = nT
})
var oF = l((E_) => {
  'use strict'
  Object.defineProperty(E_, '__esModule', { value: !0 })
  E_.MessageEncoderStream = void 0
  var rT = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.messageStream)
        yield this.options.encoder.encode(t)
      this.options.includeEndFrame && (yield new Uint8Array(0))
    }
  }
  E_.MessageEncoderStream = rT
})
var iF = l((S_) => {
  'use strict'
  Object.defineProperty(S_, '__esModule', { value: !0 })
  S_.SmithyMessageDecoderStream = void 0
  var sT = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.messageStream) {
        let n = await this.options.deserializer(t)
        n !== void 0 && (yield n)
      }
    }
  }
  S_.SmithyMessageDecoderStream = sT
})
var aF = l((b_) => {
  'use strict'
  Object.defineProperty(b_, '__esModule', { value: !0 })
  b_.SmithyMessageEncoderStream = void 0
  var oT = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.inputStream)
        yield this.options.serializer(t)
    }
  }
  b_.SmithyMessageEncoderStream = oT
})
var cF = l((Mn) => {
  'use strict'
  Object.defineProperty(Mn, '__esModule', { value: !0 })
  var is = (x(), w(I))
  is.__exportStar(tF(), Mn)
  is.__exportStar(eT(), Mn)
  is.__exportStar(J0(), Mn)
  is.__exportStar(rF(), Mn)
  is.__exportStar(sF(), Mn)
  is.__exportStar(oF(), Mn)
  is.__exportStar(iF(), Mn)
  is.__exportStar(aF(), Mn)
})
var uF = l((v_) => {
  'use strict'
  Object.defineProperty(v_, '__esModule', { value: !0 })
  v_.getSmithyContext = void 0
  var dF = D(),
    Uce = (e) => e[dF.SMITHY_CONTEXT_KEY] || (e[dF.SMITHY_CONTEXT_KEY] = {})
  v_.getSmithyContext = Uce
})
var lF = l((C_) => {
  'use strict'
  Object.defineProperty(C_, '__esModule', { value: !0 })
  C_.normalizeProvider = void 0
  var Fce = (e) => {
    if (typeof e == 'function') return e
    let t = Promise.resolve(e)
    return () => t
  }
  C_.normalizeProvider = Fce
})
var xo = l((T_) => {
  'use strict'
  Object.defineProperty(T_, '__esModule', { value: !0 })
  var mF = (x(), w(I))
  mF.__exportStar(uF(), T_)
  mF.__exportStar(lF(), T_)
})
var iT = l((w_) => {
  'use strict'
  Object.defineProperty(w_, '__esModule', { value: !0 })
  w_.isArrayBuffer = void 0
  var Bce = (e) =>
    (typeof ArrayBuffer == 'function' && e instanceof ArrayBuffer) ||
    Object.prototype.toString.call(e) === '[object ArrayBuffer]'
  w_.isArrayBuffer = Bce
})
var Po = l((Wi) => {
  'use strict'
  Object.defineProperty(Wi, '__esModule', { value: !0 })
  Wi.fromString = Wi.fromArrayBuffer = void 0
  var jce = iT(),
    aT = require('buffer'),
    Gce = (e, t = 0, n = e.byteLength - t) => {
      if (!(0, jce.isArrayBuffer)(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
        )
      return aT.Buffer.from(e, t, n)
    }
  Wi.fromArrayBuffer = Gce
  var $ce = (e, t) => {
    if (typeof e != 'string')
      throw new TypeError(
        `The "input" argument must be of type string. Received type ${typeof e} (${e})`,
      )
    return t ? aT.Buffer.from(e, t) : aT.Buffer.from(e)
  }
  Wi.fromString = $ce
})
var cT = l((I_) => {
  'use strict'
  Object.defineProperty(I_, '__esModule', { value: !0 })
  I_.fromUtf8 = void 0
  var zce = Po(),
    Hce = (e) => {
      let t = (0, zce.fromString)(e, 'utf8')
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
      )
    }
  I_.fromUtf8 = Hce
})
var pF = l((x_) => {
  'use strict'
  Object.defineProperty(x_, '__esModule', { value: !0 })
  x_.toUint8Array = void 0
  var Vce = cT(),
    Yce = (e) =>
      typeof e == 'string'
        ? (0, Vce.fromUtf8)(e)
        : ArrayBuffer.isView(e)
          ? new Uint8Array(
              e.buffer,
              e.byteOffset,
              e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
            )
          : new Uint8Array(e)
  x_.toUint8Array = Yce
})
var _F = l((P_) => {
  'use strict'
  Object.defineProperty(P_, '__esModule', { value: !0 })
  P_.toUtf8 = void 0
  var Wce = Po(),
    Kce = (e) =>
      (0, Wce.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength).toString(
        'utf8',
      )
  P_.toUtf8 = Kce
})
var Ln = l((Lu) => {
  'use strict'
  Object.defineProperty(Lu, '__esModule', { value: !0 })
  var dT = (x(), w(I))
  dT.__exportStar(cT(), Lu)
  dT.__exportStar(pF(), Lu)
  dT.__exportStar(_F(), Lu)
})
var Ro = l((M) => {
  'use strict'
  Object.defineProperty(M, '__esModule', { value: !0 })
  M.MAX_PRESIGNED_TTL =
    M.KEY_TYPE_IDENTIFIER =
    M.MAX_CACHE_SIZE =
    M.UNSIGNED_PAYLOAD =
    M.EVENT_ALGORITHM_IDENTIFIER =
    M.ALGORITHM_IDENTIFIER_V4A =
    M.ALGORITHM_IDENTIFIER =
    M.UNSIGNABLE_PATTERNS =
    M.SEC_HEADER_PATTERN =
    M.PROXY_HEADER_PATTERN =
    M.ALWAYS_UNSIGNABLE_HEADERS =
    M.HOST_HEADER =
    M.TOKEN_HEADER =
    M.SHA256_HEADER =
    M.SIGNATURE_HEADER =
    M.GENERATED_HEADERS =
    M.DATE_HEADER =
    M.AMZ_DATE_HEADER =
    M.AUTH_HEADER =
    M.REGION_SET_PARAM =
    M.TOKEN_QUERY_PARAM =
    M.SIGNATURE_QUERY_PARAM =
    M.EXPIRES_QUERY_PARAM =
    M.SIGNED_HEADERS_QUERY_PARAM =
    M.AMZ_DATE_QUERY_PARAM =
    M.CREDENTIAL_QUERY_PARAM =
    M.ALGORITHM_QUERY_PARAM =
      void 0
  M.ALGORITHM_QUERY_PARAM = 'X-Amz-Algorithm'
  M.CREDENTIAL_QUERY_PARAM = 'X-Amz-Credential'
  M.AMZ_DATE_QUERY_PARAM = 'X-Amz-Date'
  M.SIGNED_HEADERS_QUERY_PARAM = 'X-Amz-SignedHeaders'
  M.EXPIRES_QUERY_PARAM = 'X-Amz-Expires'
  M.SIGNATURE_QUERY_PARAM = 'X-Amz-Signature'
  M.TOKEN_QUERY_PARAM = 'X-Amz-Security-Token'
  M.REGION_SET_PARAM = 'X-Amz-Region-Set'
  M.AUTH_HEADER = 'authorization'
  M.AMZ_DATE_HEADER = M.AMZ_DATE_QUERY_PARAM.toLowerCase()
  M.DATE_HEADER = 'date'
  M.GENERATED_HEADERS = [M.AUTH_HEADER, M.AMZ_DATE_HEADER, M.DATE_HEADER]
  M.SIGNATURE_HEADER = M.SIGNATURE_QUERY_PARAM.toLowerCase()
  M.SHA256_HEADER = 'x-amz-content-sha256'
  M.TOKEN_HEADER = M.TOKEN_QUERY_PARAM.toLowerCase()
  M.HOST_HEADER = 'host'
  M.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: !0,
    'cache-control': !0,
    connection: !0,
    expect: !0,
    from: !0,
    'keep-alive': !0,
    'max-forwards': !0,
    pragma: !0,
    referer: !0,
    te: !0,
    trailer: !0,
    'transfer-encoding': !0,
    upgrade: !0,
    'user-agent': !0,
    'x-amzn-trace-id': !0,
  }
  M.PROXY_HEADER_PATTERN = /^proxy-/
  M.SEC_HEADER_PATTERN = /^sec-/
  M.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i]
  M.ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256'
  M.ALGORITHM_IDENTIFIER_V4A = 'AWS4-ECDSA-P256-SHA256'
  M.EVENT_ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256-PAYLOAD'
  M.UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'
  M.MAX_CACHE_SIZE = 50
  M.KEY_TYPE_IDENTIFIER = 'aws4_request'
  M.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7
})
var lT = l((as) => {
  'use strict'
  Object.defineProperty(as, '__esModule', { value: !0 })
  as.clearCredentialCache = as.getSigningKey = as.createScope = void 0
  var Xce = Vi(),
    Jce = Ln(),
    uT = Ro(),
    Ki = {},
    R_ = [],
    Qce = (e, t, n) => `${e}/${t}/${n}/${uT.KEY_TYPE_IDENTIFIER}`
  as.createScope = Qce
  var Zce = async (e, t, n, r, s) => {
    let o = await fF(e, t.secretAccessKey, t.accessKeyId),
      i = `${n}:${r}:${s}:${(0, Xce.toHex)(o)}:${t.sessionToken}`
    if (i in Ki) return Ki[i]
    for (R_.push(i); R_.length > uT.MAX_CACHE_SIZE; ) delete Ki[R_.shift()]
    let a = `AWS4${t.secretAccessKey}`
    for (let c of [n, r, s, uT.KEY_TYPE_IDENTIFIER]) a = await fF(e, a, c)
    return (Ki[i] = a)
  }
  as.getSigningKey = Zce
  var ede = () => {
    ;(R_.length = 0),
      Object.keys(Ki).forEach((e) => {
        delete Ki[e]
      })
  }
  as.clearCredentialCache = ede
  var fF = (e, t, n) => {
    let r = new e(t)
    return r.update((0, Jce.toUint8Array)(n)), r.digest()
  }
})
var pT = l((D_) => {
  'use strict'
  Object.defineProperty(D_, '__esModule', { value: !0 })
  D_.getCanonicalHeaders = void 0
  var mT = Ro(),
    tde = ({ headers: e }, t, n) => {
      let r = {}
      for (let s of Object.keys(e).sort()) {
        if (e[s] == null) continue
        let o = s.toLowerCase()
        ;((o in mT.ALWAYS_UNSIGNABLE_HEADERS ||
          t?.has(o) ||
          mT.PROXY_HEADER_PATTERN.test(o) ||
          mT.SEC_HEADER_PATTERN.test(o)) &&
          (!n || (n && !n.has(o)))) ||
          (r[o] = e[s].trim().replace(/\s+/g, ' '))
      }
      return r
    }
  D_.getCanonicalHeaders = tde
})
var _T = l((A_) => {
  'use strict'
  Object.defineProperty(A_, '__esModule', { value: !0 })
  A_.escapeUri = void 0
  var nde = (e) => encodeURIComponent(e).replace(/[!'()*]/g, rde)
  A_.escapeUri = nde
  var rde = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
})
var hF = l((O_) => {
  'use strict'
  Object.defineProperty(O_, '__esModule', { value: !0 })
  O_.escapeUriPath = void 0
  var sde = _T(),
    ode = (e) => e.split('/').map(sde.escapeUri).join('/')
  O_.escapeUriPath = ode
})
var fT = l((N_) => {
  'use strict'
  Object.defineProperty(N_, '__esModule', { value: !0 })
  var gF = (x(), w(I))
  gF.__exportStar(_T(), N_)
  gF.__exportStar(hF(), N_)
})
var hT = l((k_) => {
  'use strict'
  Object.defineProperty(k_, '__esModule', { value: !0 })
  k_.getCanonicalQuery = void 0
  var q_ = fT(),
    ide = Ro(),
    ade = ({ query: e = {} }) => {
      let t = [],
        n = {}
      for (let r of Object.keys(e).sort()) {
        if (r.toLowerCase() === ide.SIGNATURE_HEADER) continue
        t.push(r)
        let s = e[r]
        typeof s == 'string'
          ? (n[r] = `${(0, q_.escapeUri)(r)}=${(0, q_.escapeUri)(s)}`)
          : Array.isArray(s) &&
            (n[r] = s
              .slice(0)
              .reduce(
                (o, i) =>
                  o.concat([`${(0, q_.escapeUri)(r)}=${(0, q_.escapeUri)(i)}`]),
                [],
              )
              .sort()
              .join('&'))
      }
      return t
        .map((r) => n[r])
        .filter((r) => r)
        .join('&')
    }
  k_.getCanonicalQuery = ade
})
var gT = l((M_) => {
  'use strict'
  Object.defineProperty(M_, '__esModule', { value: !0 })
  M_.getPayloadHash = void 0
  var cde = iT(),
    dde = Vi(),
    ude = Ln(),
    yF = Ro(),
    lde = async ({ headers: e, body: t }, n) => {
      for (let r of Object.keys(e))
        if (r.toLowerCase() === yF.SHA256_HEADER) return e[r]
      if (t == null)
        return 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
      if (
        typeof t == 'string' ||
        ArrayBuffer.isView(t) ||
        (0, cde.isArrayBuffer)(t)
      ) {
        let r = new n()
        return (
          r.update((0, ude.toUint8Array)(t)), (0, dde.toHex)(await r.digest())
        )
      }
      return yF.UNSIGNED_PAYLOAD
    }
  M_.getPayloadHash = lde
})
var EF = l((cs) => {
  'use strict'
  Object.defineProperty(cs, '__esModule', { value: !0 })
  cs.deleteHeader = cs.getHeaderValue = cs.hasHeader = void 0
  var mde = (e, t) => {
    e = e.toLowerCase()
    for (let n of Object.keys(t)) if (e === n.toLowerCase()) return !0
    return !1
  }
  cs.hasHeader = mde
  var pde = (e, t) => {
    e = e.toLowerCase()
    for (let n of Object.keys(t)) if (e === n.toLowerCase()) return t[n]
  }
  cs.getHeaderValue = pde
  var _de = (e, t) => {
    e = e.toLowerCase()
    for (let n of Object.keys(t)) e === n.toLowerCase() && delete t[n]
  }
  cs.deleteHeader = _de
})
var yT = l((Do) => {
  'use strict'
  Object.defineProperty(Do, '__esModule', { value: !0 })
  Do.cloneQuery = Do.cloneRequest = void 0
  var fde = ({ headers: e, query: t, ...n }) => ({
    ...n,
    headers: { ...e },
    query: t ? (0, Do.cloneQuery)(t) : void 0,
  })
  Do.cloneRequest = fde
  var hde = (e) =>
    Object.keys(e).reduce((t, n) => {
      let r = e[n]
      return { ...t, [n]: Array.isArray(r) ? [...r] : r }
    }, {})
  Do.cloneQuery = hde
})
var ET = l((L_) => {
  'use strict'
  Object.defineProperty(L_, '__esModule', { value: !0 })
  L_.moveHeadersToQuery = void 0
  var gde = yT(),
    yde = (e, t = {}) => {
      var n
      let { headers: r, query: s = {} } =
        typeof e.clone == 'function' ? e.clone() : (0, gde.cloneRequest)(e)
      for (let o of Object.keys(r)) {
        let i = o.toLowerCase()
        i.slice(0, 6) === 'x-amz-' &&
          !(
            !((n = t.unhoistableHeaders) === null || n === void 0) && n.has(i)
          ) &&
          ((s[o] = r[o]), delete r[o])
      }
      return { ...e, headers: r, query: s }
    }
  L_.moveHeadersToQuery = yde
})
var ST = l((U_) => {
  'use strict'
  Object.defineProperty(U_, '__esModule', { value: !0 })
  U_.prepareRequest = void 0
  var Ede = yT(),
    Sde = Ro(),
    bde = (e) => {
      e = typeof e.clone == 'function' ? e.clone() : (0, Ede.cloneRequest)(e)
      for (let t of Object.keys(e.headers))
        Sde.GENERATED_HEADERS.indexOf(t.toLowerCase()) > -1 &&
          delete e.headers[t]
      return e
    }
  U_.prepareRequest = bde
})
var SF = l((Ao) => {
  'use strict'
  Object.defineProperty(Ao, '__esModule', { value: !0 })
  Ao.toDate = Ao.iso8601 = void 0
  var vde = (e) =>
    (0, Ao.toDate)(e)
      .toISOString()
      .replace(/\.\d{3}Z$/, 'Z')
  Ao.iso8601 = vde
  var Cde = (e) =>
    typeof e == 'number'
      ? new Date(e * 1e3)
      : typeof e == 'string'
        ? Number(e)
          ? new Date(Number(e) * 1e3)
          : new Date(e)
        : e
  Ao.toDate = Cde
})
var wF = l((G_) => {
  'use strict'
  Object.defineProperty(G_, '__esModule', { value: !0 })
  G_.SignatureV4 = void 0
  var Tde = cF(),
    F_ = Vi(),
    bF = xo(),
    Uu = Ln(),
    Xe = Ro(),
    B_ = lT(),
    vF = pT(),
    wde = hT(),
    bT = gT(),
    Ide = EF(),
    xde = ET(),
    CF = ST(),
    Pde = SF(),
    vT = class {
      constructor({
        applyChecksum: t,
        credentials: n,
        region: r,
        service: s,
        sha256: o,
        uriEscapePath: i = !0,
      }) {
        ;(this.headerMarshaller = new Tde.HeaderMarshaller(
          Uu.toUtf8,
          Uu.fromUtf8,
        )),
          (this.service = s),
          (this.sha256 = o),
          (this.uriEscapePath = i),
          (this.applyChecksum = typeof t == 'boolean' ? t : !0),
          (this.regionProvider = (0, bF.normalizeProvider)(r)),
          (this.credentialProvider = (0, bF.normalizeProvider)(n))
      }
      async presign(t, n = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: s = 3600,
            unsignableHeaders: o,
            unhoistableHeaders: i,
            signableHeaders: a,
            signingRegion: c,
            signingService: u,
          } = n,
          d = await this.credentialProvider()
        this.validateResolvedCredentials(d)
        let p = c ?? (await this.regionProvider()),
          { longDate: _, shortDate: f } = j_(r)
        if (s > Xe.MAX_PRESIGNED_TTL)
          return Promise.reject(
            'Signature version 4 presigned URLs must have an expiration date less than one week in the future',
          )
        let h = (0, B_.createScope)(f, p, u ?? this.service),
          y = (0, xde.moveHeadersToQuery)((0, CF.prepareRequest)(t), {
            unhoistableHeaders: i,
          })
        d.sessionToken && (y.query[Xe.TOKEN_QUERY_PARAM] = d.sessionToken),
          (y.query[Xe.ALGORITHM_QUERY_PARAM] = Xe.ALGORITHM_IDENTIFIER),
          (y.query[Xe.CREDENTIAL_QUERY_PARAM] = `${d.accessKeyId}/${h}`),
          (y.query[Xe.AMZ_DATE_QUERY_PARAM] = _),
          (y.query[Xe.EXPIRES_QUERY_PARAM] = s.toString(10))
        let E = (0, vF.getCanonicalHeaders)(y, o, a)
        return (
          (y.query[Xe.SIGNED_HEADERS_QUERY_PARAM] = TF(E)),
          (y.query[Xe.SIGNATURE_QUERY_PARAM] = await this.getSignature(
            _,
            h,
            this.getSigningKey(d, p, f, u),
            this.createCanonicalRequest(
              y,
              E,
              await (0, bT.getPayloadHash)(t, this.sha256),
            ),
          )),
          y
        )
      }
      async sign(t, n) {
        return typeof t == 'string'
          ? this.signString(t, n)
          : t.headers && t.payload
            ? this.signEvent(t, n)
            : t.message
              ? this.signMessage(t, n)
              : this.signRequest(t, n)
      }
      async signEvent(
        { headers: t, payload: n },
        {
          signingDate: r = new Date(),
          priorSignature: s,
          signingRegion: o,
          signingService: i,
        },
      ) {
        let a = o ?? (await this.regionProvider()),
          { shortDate: c, longDate: u } = j_(r),
          d = (0, B_.createScope)(c, a, i ?? this.service),
          p = await (0, bT.getPayloadHash)(
            { headers: {}, body: n },
            this.sha256,
          ),
          _ = new this.sha256()
        _.update(t)
        let f = (0, F_.toHex)(await _.digest()),
          h = [Xe.EVENT_ALGORITHM_IDENTIFIER, u, d, s, f, p].join(`
`)
        return this.signString(h, {
          signingDate: r,
          signingRegion: a,
          signingService: i,
        })
      }
      async signMessage(
        t,
        { signingDate: n = new Date(), signingRegion: r, signingService: s },
      ) {
        return this.signEvent(
          {
            headers: this.headerMarshaller.format(t.message.headers),
            payload: t.message.body,
          },
          {
            signingDate: n,
            signingRegion: r,
            signingService: s,
            priorSignature: t.priorSignature,
          },
        ).then((i) => ({ message: t.message, signature: i }))
      }
      async signString(
        t,
        {
          signingDate: n = new Date(),
          signingRegion: r,
          signingService: s,
        } = {},
      ) {
        let o = await this.credentialProvider()
        this.validateResolvedCredentials(o)
        let i = r ?? (await this.regionProvider()),
          { shortDate: a } = j_(n),
          c = new this.sha256(await this.getSigningKey(o, i, a, s))
        return (
          c.update((0, Uu.toUint8Array)(t)), (0, F_.toHex)(await c.digest())
        )
      }
      async signRequest(
        t,
        {
          signingDate: n = new Date(),
          signableHeaders: r,
          unsignableHeaders: s,
          signingRegion: o,
          signingService: i,
        } = {},
      ) {
        let a = await this.credentialProvider()
        this.validateResolvedCredentials(a)
        let c = o ?? (await this.regionProvider()),
          u = (0, CF.prepareRequest)(t),
          { longDate: d, shortDate: p } = j_(n),
          _ = (0, B_.createScope)(p, c, i ?? this.service)
        ;(u.headers[Xe.AMZ_DATE_HEADER] = d),
          a.sessionToken && (u.headers[Xe.TOKEN_HEADER] = a.sessionToken)
        let f = await (0, bT.getPayloadHash)(u, this.sha256)
        !(0, Ide.hasHeader)(Xe.SHA256_HEADER, u.headers) &&
          this.applyChecksum &&
          (u.headers[Xe.SHA256_HEADER] = f)
        let h = (0, vF.getCanonicalHeaders)(u, s, r),
          y = await this.getSignature(
            d,
            _,
            this.getSigningKey(a, c, p, i),
            this.createCanonicalRequest(u, h, f),
          )
        return (
          (u.headers[Xe.AUTH_HEADER] = `${Xe.ALGORITHM_IDENTIFIER} Credential=${
            a.accessKeyId
          }/${_}, SignedHeaders=${TF(h)}, Signature=${y}`),
          u
        )
      }
      createCanonicalRequest(t, n, r) {
        let s = Object.keys(n).sort()
        return `${t.method}
${this.getCanonicalPath(t)}
${(0, wde.getCanonicalQuery)(t)}
${s.map((o) => `${o}:${n[o]}`).join(`
`)}

${s.join(';')}
${r}`
      }
      async createStringToSign(t, n, r) {
        let s = new this.sha256()
        s.update((0, Uu.toUint8Array)(r))
        let o = await s.digest()
        return `${Xe.ALGORITHM_IDENTIFIER}
${t}
${n}
${(0, F_.toHex)(o)}`
      }
      getCanonicalPath({ path: t }) {
        if (this.uriEscapePath) {
          let n = []
          for (let o of t.split('/'))
            o?.length !== 0 && o !== '.' && (o === '..' ? n.pop() : n.push(o))
          let r = `${t?.startsWith('/') ? '/' : ''}${n.join('/')}${
            n.length > 0 && t?.endsWith('/') ? '/' : ''
          }`
          return encodeURIComponent(r).replace(/%2F/g, '/')
        }
        return t
      }
      async getSignature(t, n, r, s) {
        let o = await this.createStringToSign(t, n, s),
          i = new this.sha256(await r)
        return (
          i.update((0, Uu.toUint8Array)(o)), (0, F_.toHex)(await i.digest())
        )
      }
      getSigningKey(t, n, r, s) {
        return (0, B_.getSigningKey)(this.sha256, t, r, n, s || this.service)
      }
      validateResolvedCredentials(t) {
        if (
          typeof t != 'object' ||
          typeof t.accessKeyId != 'string' ||
          typeof t.secretAccessKey != 'string'
        )
          throw new Error('Resolved credential object is not valid')
      }
    }
  G_.SignatureV4 = vT
  var j_ = (e) => {
      let t = (0, Pde.iso8601)(e).replace(/[\-:]/g, '')
      return { longDate: t, shortDate: t.slice(0, 8) }
    },
    TF = (e) => Object.keys(e).sort().join(';')
})
var xF = l((pt) => {
  'use strict'
  Object.defineProperty(pt, '__esModule', { value: !0 })
  pt.prepareRequest =
    pt.moveHeadersToQuery =
    pt.getPayloadHash =
    pt.getCanonicalQuery =
    pt.getCanonicalHeaders =
      void 0
  var IF = (x(), w(I))
  IF.__exportStar(wF(), pt)
  var Rde = pT()
  Object.defineProperty(pt, 'getCanonicalHeaders', {
    enumerable: !0,
    get: function () {
      return Rde.getCanonicalHeaders
    },
  })
  var Dde = hT()
  Object.defineProperty(pt, 'getCanonicalQuery', {
    enumerable: !0,
    get: function () {
      return Dde.getCanonicalQuery
    },
  })
  var Ade = gT()
  Object.defineProperty(pt, 'getPayloadHash', {
    enumerable: !0,
    get: function () {
      return Ade.getPayloadHash
    },
  })
  var Ode = ET()
  Object.defineProperty(pt, 'moveHeadersToQuery', {
    enumerable: !0,
    get: function () {
      return Ode.moveHeadersToQuery
    },
  })
  var Nde = ST()
  Object.defineProperty(pt, 'prepareRequest', {
    enumerable: !0,
    get: function () {
      return Nde.prepareRequest
    },
  })
  IF.__exportStar(lT(), pt)
})
var RF = l((Ji) => {
  'use strict'
  Object.defineProperty(Ji, '__esModule', { value: !0 })
  Ji.resolveSigV4AuthConfig = Ji.resolveAwsAuthConfig = void 0
  var qde = ye(),
    CT = xF(),
    Xi = xo(),
    kde = 3e5,
    Mde = (e) => {
      let t = e.credentials
          ? PF(e.credentials)
          : e.credentialDefaultProvider(e),
        {
          signingEscapePath: n = !0,
          systemClockOffset: r = e.systemClockOffset || 0,
          sha256: s,
        } = e,
        o
      return (
        e.signer
          ? (o = (0, Xi.normalizeProvider)(e.signer))
          : e.regionInfoProvider
            ? (o = () =>
                (0, Xi.normalizeProvider)(e.region)()
                  .then(async (i) => [
                    (await e.regionInfoProvider(i, {
                      useFipsEndpoint: await e.useFipsEndpoint(),
                      useDualstackEndpoint: await e.useDualstackEndpoint(),
                    })) || {},
                    i,
                  ])
                  .then(([i, a]) => {
                    let { signingRegion: c, signingService: u } = i
                    ;(e.signingRegion = e.signingRegion || c || a),
                      (e.signingName = e.signingName || u || e.serviceId)
                    let d = {
                        ...e,
                        credentials: t,
                        region: e.signingRegion,
                        service: e.signingName,
                        sha256: s,
                        uriEscapePath: n,
                      },
                      p = e.signerConstructor || CT.SignatureV4
                    return new p(d)
                  }))
            : (o = async (i) => {
                i = Object.assign(
                  {},
                  {
                    name: 'sigv4',
                    signingName: e.signingName || e.defaultSigningName,
                    signingRegion: await (0, Xi.normalizeProvider)(e.region)(),
                    properties: {},
                  },
                  i,
                )
                let a = i.signingRegion,
                  c = i.signingName
                ;(e.signingRegion = e.signingRegion || a),
                  (e.signingName = e.signingName || c || e.serviceId)
                let u = {
                    ...e,
                    credentials: t,
                    region: e.signingRegion,
                    service: e.signingName,
                    sha256: s,
                    uriEscapePath: n,
                  },
                  d = e.signerConstructor || CT.SignatureV4
                return new d(u)
              }),
        {
          ...e,
          systemClockOffset: r,
          signingEscapePath: n,
          credentials: t,
          signer: o,
        }
      )
    }
  Ji.resolveAwsAuthConfig = Mde
  var Lde = (e) => {
    let t = e.credentials ? PF(e.credentials) : e.credentialDefaultProvider(e),
      {
        signingEscapePath: n = !0,
        systemClockOffset: r = e.systemClockOffset || 0,
        sha256: s,
      } = e,
      o
    return (
      e.signer
        ? (o = (0, Xi.normalizeProvider)(e.signer))
        : (o = (0, Xi.normalizeProvider)(
            new CT.SignatureV4({
              credentials: t,
              region: e.region,
              service: e.signingName,
              sha256: s,
              uriEscapePath: n,
            }),
          )),
      {
        ...e,
        systemClockOffset: r,
        signingEscapePath: n,
        credentials: t,
        signer: o,
      }
    )
  }
  Ji.resolveSigV4AuthConfig = Lde
  var PF = (e) =>
    typeof e == 'function'
      ? (0, qde.memoize)(
          e,
          (t) =>
            t.expiration !== void 0 &&
            t.expiration.getTime() - Date.now() < kde,
          (t) => t.expiration !== void 0,
        )
      : (0, Xi.normalizeProvider)(e)
})
var TT = l(($_) => {
  'use strict'
  Object.defineProperty($_, '__esModule', { value: !0 })
  $_.getSkewCorrectedDate = void 0
  var Ude = (e) => new Date(Date.now() + e)
  $_.getSkewCorrectedDate = Ude
})
var DF = l((z_) => {
  'use strict'
  Object.defineProperty(z_, '__esModule', { value: !0 })
  z_.isClockSkewed = void 0
  var Fde = TT(),
    Bde = (e, t) =>
      Math.abs((0, Fde.getSkewCorrectedDate)(t).getTime() - e) >= 3e5
  z_.isClockSkewed = Bde
})
var AF = l((H_) => {
  'use strict'
  Object.defineProperty(H_, '__esModule', { value: !0 })
  H_.getUpdatedSystemClockOffset = void 0
  var jde = DF(),
    Gde = (e, t) => {
      let n = Date.parse(e)
      return (0, jde.isClockSkewed)(n, t) ? n - Date.now() : t
    }
  H_.getUpdatedSystemClockOffset = Gde
})
var kF = l((It) => {
  'use strict'
  Object.defineProperty(It, '__esModule', { value: !0 })
  It.getSigV4AuthPlugin =
    It.getAwsAuthPlugin =
    It.awsAuthMiddlewareOptions =
    It.awsAuthMiddleware =
      void 0
  var qF = Oe(),
    $de = TT(),
    OF = AF(),
    zde = (e) => (t, n) =>
      async function (r) {
        var s, o, i, a
        if (!qF.HttpRequest.isInstance(r.request)) return t(r)
        let c =
            (i =
              (o =
                (s = n.endpointV2) === null || s === void 0
                  ? void 0
                  : s.properties) === null || o === void 0
                ? void 0
                : o.authSchemes) === null || i === void 0
              ? void 0
              : i[0],
          u =
            c?.name === 'sigv4a'
              ? (a = c?.signingRegionSet) === null || a === void 0
                ? void 0
                : a.join(',')
              : void 0,
          d = await e.signer(c),
          p = await t({
            ...r,
            request: await d.sign(r.request, {
              signingDate: (0, $de.getSkewCorrectedDate)(e.systemClockOffset),
              signingRegion: u || n.signing_region,
              signingService: n.signing_service,
            }),
          }).catch((f) => {
            var h
            let y =
              (h = f.ServerTime) !== null && h !== void 0 ? h : NF(f.$response)
            throw (
              (y &&
                (e.systemClockOffset = (0, OF.getUpdatedSystemClockOffset)(
                  y,
                  e.systemClockOffset,
                )),
              f)
            )
          }),
          _ = NF(p.response)
        return (
          _ &&
            (e.systemClockOffset = (0, OF.getUpdatedSystemClockOffset)(
              _,
              e.systemClockOffset,
            )),
          p
        )
      }
  It.awsAuthMiddleware = zde
  var NF = (e) => {
    var t, n, r
    return qF.HttpResponse.isInstance(e)
      ? (n = (t = e.headers) === null || t === void 0 ? void 0 : t.date) !==
          null && n !== void 0
        ? n
        : (r = e.headers) === null || r === void 0
          ? void 0
          : r.Date
      : void 0
  }
  It.awsAuthMiddlewareOptions = {
    name: 'awsAuthMiddleware',
    tags: ['SIGNATURE', 'AWSAUTH'],
    relation: 'after',
    toMiddleware: 'retryMiddleware',
    override: !0,
  }
  var Hde = (e) => ({
    applyToStack: (t) => {
      t.addRelativeTo((0, It.awsAuthMiddleware)(e), It.awsAuthMiddlewareOptions)
    },
  })
  It.getAwsAuthPlugin = Hde
  It.getSigV4AuthPlugin = It.getAwsAuthPlugin
})
var Sr = l((V_) => {
  'use strict'
  Object.defineProperty(V_, '__esModule', { value: !0 })
  var MF = (x(), w(I))
  MF.__exportStar(RF(), V_)
  MF.__exportStar(kF(), V_)
})
var LF = l((Y_) => {
  'use strict'
  Object.defineProperty(Y_, '__esModule', { value: !0 })
  Y_.resolveUserAgentConfig = void 0
  function Vde(e) {
    return {
      ...e,
      customUserAgent:
        typeof e.customUserAgent == 'string'
          ? [[e.customUserAgent]]
          : e.customUserAgent,
    }
  }
  Y_.resolveUserAgentConfig = Vde
})
var UF = l((NGe, Yde) => {
  Yde.exports = {
    partitions: [
      {
        id: 'aws',
        outputs: {
          dnsSuffix: 'amazonaws.com',
          dualStackDnsSuffix: 'api.aws',
          implicitGlobalRegion: 'us-east-1',
          name: 'aws',
          supportsDualStack: !0,
          supportsFIPS: !0,
        },
        regionRegex: '^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$',
        regions: {
          'af-south-1': { description: 'Africa (Cape Town)' },
          'ap-east-1': { description: 'Asia Pacific (Hong Kong)' },
          'ap-northeast-1': { description: 'Asia Pacific (Tokyo)' },
          'ap-northeast-2': { description: 'Asia Pacific (Seoul)' },
          'ap-northeast-3': { description: 'Asia Pacific (Osaka)' },
          'ap-south-1': { description: 'Asia Pacific (Mumbai)' },
          'ap-south-2': { description: 'Asia Pacific (Hyderabad)' },
          'ap-southeast-1': { description: 'Asia Pacific (Singapore)' },
          'ap-southeast-2': { description: 'Asia Pacific (Sydney)' },
          'ap-southeast-3': { description: 'Asia Pacific (Jakarta)' },
          'ap-southeast-4': { description: 'Asia Pacific (Melbourne)' },
          'aws-global': { description: 'AWS Standard global region' },
          'ca-central-1': { description: 'Canada (Central)' },
          'eu-central-1': { description: 'Europe (Frankfurt)' },
          'eu-central-2': { description: 'Europe (Zurich)' },
          'eu-north-1': { description: 'Europe (Stockholm)' },
          'eu-south-1': { description: 'Europe (Milan)' },
          'eu-south-2': { description: 'Europe (Spain)' },
          'eu-west-1': { description: 'Europe (Ireland)' },
          'eu-west-2': { description: 'Europe (London)' },
          'eu-west-3': { description: 'Europe (Paris)' },
          'il-central-1': { description: 'Israel (Tel Aviv)' },
          'me-central-1': { description: 'Middle East (UAE)' },
          'me-south-1': { description: 'Middle East (Bahrain)' },
          'sa-east-1': { description: 'South America (Sao Paulo)' },
          'us-east-1': { description: 'US East (N. Virginia)' },
          'us-east-2': { description: 'US East (Ohio)' },
          'us-west-1': { description: 'US West (N. California)' },
          'us-west-2': { description: 'US West (Oregon)' },
        },
      },
      {
        id: 'aws-cn',
        outputs: {
          dnsSuffix: 'amazonaws.com.cn',
          dualStackDnsSuffix: 'api.amazonwebservices.com.cn',
          implicitGlobalRegion: 'cn-northwest-1',
          name: 'aws-cn',
          supportsDualStack: !0,
          supportsFIPS: !0,
        },
        regionRegex: '^cn\\-\\w+\\-\\d+$',
        regions: {
          'aws-cn-global': { description: 'AWS China global region' },
          'cn-north-1': { description: 'China (Beijing)' },
          'cn-northwest-1': { description: 'China (Ningxia)' },
        },
      },
      {
        id: 'aws-us-gov',
        outputs: {
          dnsSuffix: 'amazonaws.com',
          dualStackDnsSuffix: 'api.aws',
          implicitGlobalRegion: 'us-gov-west-1',
          name: 'aws-us-gov',
          supportsDualStack: !0,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-gov\\-\\w+\\-\\d+$',
        regions: {
          'aws-us-gov-global': {
            description: 'AWS GovCloud (US) global region',
          },
          'us-gov-east-1': { description: 'AWS GovCloud (US-East)' },
          'us-gov-west-1': { description: 'AWS GovCloud (US-West)' },
        },
      },
      {
        id: 'aws-iso',
        outputs: {
          dnsSuffix: 'c2s.ic.gov',
          dualStackDnsSuffix: 'c2s.ic.gov',
          implicitGlobalRegion: 'us-iso-east-1',
          name: 'aws-iso',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-iso\\-\\w+\\-\\d+$',
        regions: {
          'aws-iso-global': { description: 'AWS ISO (US) global region' },
          'us-iso-east-1': { description: 'US ISO East' },
          'us-iso-west-1': { description: 'US ISO WEST' },
        },
      },
      {
        id: 'aws-iso-b',
        outputs: {
          dnsSuffix: 'sc2s.sgov.gov',
          dualStackDnsSuffix: 'sc2s.sgov.gov',
          implicitGlobalRegion: 'us-isob-east-1',
          name: 'aws-iso-b',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-isob\\-\\w+\\-\\d+$',
        regions: {
          'aws-iso-b-global': { description: 'AWS ISOB (US) global region' },
          'us-isob-east-1': { description: 'US ISOB East (Ohio)' },
        },
      },
      {
        id: 'aws-iso-e',
        outputs: {
          dnsSuffix: 'cloud.adc-e.uk',
          dualStackDnsSuffix: 'cloud.adc-e.uk',
          implicitGlobalRegion: 'eu-isoe-west-1',
          name: 'aws-iso-e',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^eu\\-isoe\\-\\w+\\-\\d+$',
        regions: {},
      },
      {
        id: 'aws-iso-f',
        outputs: {
          dnsSuffix: 'csp.hci.ic.gov',
          dualStackDnsSuffix: 'csp.hci.ic.gov',
          implicitGlobalRegion: 'us-isof-south-1',
          name: 'aws-iso-f',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-isof\\-\\w+\\-\\d+$',
        regions: {},
      },
    ],
    version: '1.1',
  }
})
var wT = l((ln) => {
  'use strict'
  Object.defineProperty(ln, '__esModule', { value: !0 })
  ln.getUserAgentPrefix =
    ln.useDefaultPartitionInfo =
    ln.setPartitionInfo =
    ln.partition =
      void 0
  var Wde = (x(), w(I)),
    FF = Wde.__importDefault(UF()),
    BF = FF.default,
    jF = '',
    Kde = (e) => {
      let { partitions: t } = BF
      for (let r of t) {
        let { regions: s, outputs: o } = r
        for (let [i, a] of Object.entries(s)) if (i === e) return { ...o, ...a }
      }
      for (let r of t) {
        let { regionRegex: s, outputs: o } = r
        if (new RegExp(s).test(e)) return { ...o }
      }
      let n = t.find((r) => r.id === 'aws')
      if (!n)
        throw new Error(
          "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.",
        )
      return { ...n.outputs }
    }
  ln.partition = Kde
  var Xde = (e, t = '') => {
    ;(BF = e), (jF = t)
  }
  ln.setPartitionInfo = Xde
  var Jde = () => {
    ;(0, ln.setPartitionInfo)(FF.default, '')
  }
  ln.useDefaultPartitionInfo = Jde
  var Qde = () => jF
  ln.getUserAgentPrefix = Qde
})
var K_ = l((W_) => {
  'use strict'
  Object.defineProperty(W_, '__esModule', { value: !0 })
  W_.isIpAddress = void 0
  var Zde = new RegExp(
      '^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$',
    ),
    eue = (e) => Zde.test(e) || (e.startsWith('[') && e.endsWith(']'))
  W_.isIpAddress = eue
})
var GF = l((X_) => {
  'use strict'
  Object.defineProperty(X_, '__esModule', { value: !0 })
  X_.debugId = void 0
  X_.debugId = 'endpoints'
})
var $F = l((J_) => {
  'use strict'
  Object.defineProperty(J_, '__esModule', { value: !0 })
  J_.toDebugString = void 0
  function IT(e) {
    return typeof e != 'object' || e == null
      ? e
      : 'ref' in e
        ? `$${IT(e.ref)}`
        : 'fn' in e
          ? `${e.fn}(${(e.argv || []).map(IT).join(', ')})`
          : JSON.stringify(e, null, 2)
  }
  J_.toDebugString = IT
})
var Fu = l((Q_) => {
  'use strict'
  Object.defineProperty(Q_, '__esModule', { value: !0 })
  var zF = (x(), w(I))
  zF.__exportStar(GF(), Q_)
  zF.__exportStar($F(), Q_)
})
var HF = l((Z_) => {
  'use strict'
  Object.defineProperty(Z_, '__esModule', { value: !0 })
  Z_.EndpointError = void 0
  var xT = class extends Error {
    constructor(t) {
      super(t), (this.name = 'EndpointError')
    }
  }
  Z_.EndpointError = xT
})
var YF = l((VF) => {
  'use strict'
  Object.defineProperty(VF, '__esModule', { value: !0 })
})
var KF = l((WF) => {
  'use strict'
  Object.defineProperty(WF, '__esModule', { value: !0 })
})
var JF = l((XF) => {
  'use strict'
  Object.defineProperty(XF, '__esModule', { value: !0 })
})
var ZF = l((QF) => {
  'use strict'
  Object.defineProperty(QF, '__esModule', { value: !0 })
})
var tB = l((eB) => {
  'use strict'
  Object.defineProperty(eB, '__esModule', { value: !0 })
})
var Yt = l((ds) => {
  'use strict'
  Object.defineProperty(ds, '__esModule', { value: !0 })
  var Qi = (x(), w(I))
  Qi.__exportStar(HF(), ds)
  Qi.__exportStar(YF(), ds)
  Qi.__exportStar(KF(), ds)
  Qi.__exportStar(JF(), ds)
  Qi.__exportStar(ZF(), ds)
  Qi.__exportStar(tB(), ds)
})
var PT = l((Bu) => {
  'use strict'
  Object.defineProperty(Bu, '__esModule', { value: !0 })
  Bu.isValidHostLabel = void 0
  var tue = new RegExp('^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$'),
    nue = (e, t = !1) => {
      if (!t) return tue.test(e)
      let n = e.split('.')
      for (let r of n) if (!(0, Bu.isValidHostLabel)(r)) return !1
      return !0
    }
  Bu.isValidHostLabel = nue
})
var nB = l((ju) => {
  'use strict'
  Object.defineProperty(ju, '__esModule', { value: !0 })
  ju.isVirtualHostableS3Bucket = void 0
  var rue = K_(),
    sue = PT(),
    oue = (e, t = !1) => {
      if (t) {
        for (let n of e.split('.'))
          if (!(0, ju.isVirtualHostableS3Bucket)(n)) return !1
        return !0
      }
      return !(
        !(0, sue.isValidHostLabel)(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        (0, rue.isIpAddress)(e)
      )
    }
  ju.isVirtualHostableS3Bucket = oue
})
var rB = l((ef) => {
  'use strict'
  Object.defineProperty(ef, '__esModule', { value: !0 })
  ef.parseArn = void 0
  var iue = (e) => {
    let t = e.split(':')
    if (t.length < 6) return null
    let [n, r, s, o, i, ...a] = t
    return n !== 'arn' || r === '' || s === '' || a[0] === ''
      ? null
      : {
          partition: r,
          service: s,
          region: o,
          accountId: i,
          resourceId: a[0].includes('/') ? a[0].split('/') : a,
        }
  }
  ef.parseArn = iue
})
var sB = l((Gu) => {
  'use strict'
  Object.defineProperty(Gu, '__esModule', { value: !0 })
  var RT = (x(), w(I))
  RT.__exportStar(nB(), Gu)
  RT.__exportStar(rB(), Gu)
  RT.__exportStar(wT(), Gu)
})
var oB = l((tf) => {
  'use strict'
  Object.defineProperty(tf, '__esModule', { value: !0 })
  tf.booleanEquals = void 0
  var aue = (e, t) => e === t
  tf.booleanEquals = aue
})
var aB = l((nf) => {
  'use strict'
  Object.defineProperty(nf, '__esModule', { value: !0 })
  nf.getAttrPathList = void 0
  var iB = Yt(),
    cue = (e) => {
      let t = e.split('.'),
        n = []
      for (let r of t) {
        let s = r.indexOf('[')
        if (s !== -1) {
          if (r.indexOf(']') !== r.length - 1)
            throw new iB.EndpointError(`Path: '${e}' does not end with ']'`)
          let o = r.slice(s + 1, -1)
          if (Number.isNaN(parseInt(o)))
            throw new iB.EndpointError(
              `Invalid array index: '${o}' in path: '${e}'`,
            )
          s !== 0 && n.push(r.slice(0, s)), n.push(o)
        } else n.push(r)
      }
      return n
    }
  nf.getAttrPathList = cue
})
var cB = l((rf) => {
  'use strict'
  Object.defineProperty(rf, '__esModule', { value: !0 })
  rf.getAttr = void 0
  var due = Yt(),
    uue = aB(),
    lue = (e, t) =>
      (0, uue.getAttrPathList)(t).reduce((n, r) => {
        if (typeof n != 'object')
          throw new due.EndpointError(
            `Index '${r}' in '${t}' not found in '${JSON.stringify(e)}'`,
          )
        return Array.isArray(n) ? n[parseInt(r)] : n[r]
      }, e)
  rf.getAttr = lue
})
var dB = l((sf) => {
  'use strict'
  Object.defineProperty(sf, '__esModule', { value: !0 })
  sf.isSet = void 0
  var mue = (e) => e != null
  sf.isSet = mue
})
var uB = l((of) => {
  'use strict'
  Object.defineProperty(of, '__esModule', { value: !0 })
  of.not = void 0
  var pue = (e) => !e
  of.not = pue
})
var mB = l((lB) => {
  'use strict'
  Object.defineProperty(lB, '__esModule', { value: !0 })
})
var pB = l((af) => {
  'use strict'
  Object.defineProperty(af, '__esModule', { value: !0 })
  af.HttpAuthLocation = void 0
  var _ue = D()
  Object.defineProperty(af, 'HttpAuthLocation', {
    enumerable: !0,
    get: function () {
      return _ue.HttpAuthLocation
    },
  })
})
var fB = l((_B) => {
  'use strict'
  Object.defineProperty(_B, '__esModule', { value: !0 })
})
var gB = l((hB) => {
  'use strict'
  Object.defineProperty(hB, '__esModule', { value: !0 })
})
var EB = l((yB) => {
  'use strict'
  Object.defineProperty(yB, '__esModule', { value: !0 })
})
var bB = l((SB) => {
  'use strict'
  Object.defineProperty(SB, '__esModule', { value: !0 })
})
var CB = l((vB) => {
  'use strict'
  Object.defineProperty(vB, '__esModule', { value: !0 })
})
var wB = l((TB) => {
  'use strict'
  Object.defineProperty(TB, '__esModule', { value: !0 })
})
var xB = l((IB) => {
  'use strict'
  Object.defineProperty(IB, '__esModule', { value: !0 })
})
var PB = l(($u) => {
  'use strict'
  Object.defineProperty($u, '__esModule', { value: !0 })
  $u.HostAddressType = void 0
  var fue
  ;(function (e) {
    ;(e.AAAA = 'AAAA'), (e.A = 'A')
  })((fue = $u.HostAddressType || ($u.HostAddressType = {})))
})
var DB = l((RB) => {
  'use strict'
  Object.defineProperty(RB, '__esModule', { value: !0 })
})
var AB = l((cf) => {
  'use strict'
  Object.defineProperty(cf, '__esModule', { value: !0 })
  cf.EndpointURLScheme = void 0
  var hue = D()
  Object.defineProperty(cf, 'EndpointURLScheme', {
    enumerable: !0,
    get: function () {
      return hue.EndpointURLScheme
    },
  })
})
var NB = l((OB) => {
  'use strict'
  Object.defineProperty(OB, '__esModule', { value: !0 })
})
var kB = l((qB) => {
  'use strict'
  Object.defineProperty(qB, '__esModule', { value: !0 })
})
var LB = l((MB) => {
  'use strict'
  Object.defineProperty(MB, '__esModule', { value: !0 })
})
var FB = l((UB) => {
  'use strict'
  Object.defineProperty(UB, '__esModule', { value: !0 })
})
var jB = l((BB) => {
  'use strict'
  Object.defineProperty(BB, '__esModule', { value: !0 })
})
var $B = l((GB) => {
  'use strict'
  Object.defineProperty(GB, '__esModule', { value: !0 })
})
var HB = l((zB) => {
  'use strict'
  Object.defineProperty(zB, '__esModule', { value: !0 })
})
var YB = l((VB) => {
  'use strict'
  Object.defineProperty(VB, '__esModule', { value: !0 })
})
var WB = l((Oo) => {
  'use strict'
  Object.defineProperty(Oo, '__esModule', { value: !0 })
  var zu = (x(), w(I))
  zu.__exportStar(FB(), Oo)
  zu.__exportStar(jB(), Oo)
  zu.__exportStar($B(), Oo)
  zu.__exportStar(HB(), Oo)
  zu.__exportStar(YB(), Oo)
})
var XB = l((KB) => {
  'use strict'
  Object.defineProperty(KB, '__esModule', { value: !0 })
})
var QB = l((JB) => {
  'use strict'
  Object.defineProperty(JB, '__esModule', { value: !0 })
})
var ej = l((ZB) => {
  'use strict'
  Object.defineProperty(ZB, '__esModule', { value: !0 })
})
var nj = l((tj) => {
  'use strict'
  Object.defineProperty(tj, '__esModule', { value: !0 })
})
var sj = l((rj) => {
  'use strict'
  Object.defineProperty(rj, '__esModule', { value: !0 })
})
var ij = l((oj) => {
  'use strict'
  Object.defineProperty(oj, '__esModule', { value: !0 })
})
var cj = l((aj) => {
  'use strict'
  Object.defineProperty(aj, '__esModule', { value: !0 })
})
var uj = l((dj) => {
  'use strict'
  Object.defineProperty(dj, '__esModule', { value: !0 })
})
var mj = l((lj) => {
  'use strict'
  Object.defineProperty(lj, '__esModule', { value: !0 })
})
var _j = l((pj) => {
  'use strict'
  Object.defineProperty(pj, '__esModule', { value: !0 })
})
var hj = l((fj) => {
  'use strict'
  Object.defineProperty(fj, '__esModule', { value: !0 })
})
var yj = l((gj) => {
  'use strict'
  Object.defineProperty(gj, '__esModule', { value: !0 })
})
var Ej = l((df) => {
  'use strict'
  Object.defineProperty(df, '__esModule', { value: !0 })
  df.RequestHandlerProtocol = void 0
  var gue = D()
  Object.defineProperty(df, 'RequestHandlerProtocol', {
    enumerable: !0,
    get: function () {
      return gue.RequestHandlerProtocol
    },
  })
})
var bj = l((Sj) => {
  'use strict'
  Object.defineProperty(Sj, '__esModule', { value: !0 })
})
var Cj = l((vj) => {
  'use strict'
  Object.defineProperty(vj, '__esModule', { value: !0 })
})
var wj = l((Tj) => {
  'use strict'
  Object.defineProperty(Tj, '__esModule', { value: !0 })
})
var Ij = l((ae) => {
  'use strict'
  Object.defineProperty(ae, '__esModule', { value: !0 })
  var le = (x(), w(I))
  le.__exportStar(mB(), ae)
  le.__exportStar(pB(), ae)
  le.__exportStar(fB(), ae)
  le.__exportStar(gB(), ae)
  le.__exportStar(EB(), ae)
  le.__exportStar(bB(), ae)
  le.__exportStar(CB(), ae)
  le.__exportStar(wB(), ae)
  le.__exportStar(xB(), ae)
  le.__exportStar(PB(), ae)
  le.__exportStar(DB(), ae)
  le.__exportStar(AB(), ae)
  le.__exportStar(NB(), ae)
  le.__exportStar(kB(), ae)
  le.__exportStar(LB(), ae)
  le.__exportStar(WB(), ae)
  le.__exportStar(XB(), ae)
  le.__exportStar(QB(), ae)
  le.__exportStar(ej(), ae)
  le.__exportStar(nj(), ae)
  le.__exportStar(sj(), ae)
  le.__exportStar(ij(), ae)
  le.__exportStar(cj(), ae)
  le.__exportStar(uj(), ae)
  le.__exportStar(mj(), ae)
  le.__exportStar(_j(), ae)
  le.__exportStar(hj(), ae)
  le.__exportStar(yj(), ae)
  le.__exportStar(Ej(), ae)
  le.__exportStar(bj(), ae)
  le.__exportStar(Cj(), ae)
  le.__exportStar(wj(), ae)
})
var xj = l((uf) => {
  'use strict'
  Object.defineProperty(uf, '__esModule', { value: !0 })
  uf.parseURL = void 0
  var AT = Ij(),
    yue = K_(),
    DT = { [AT.EndpointURLScheme.HTTP]: 80, [AT.EndpointURLScheme.HTTPS]: 443 },
    Eue = (e) => {
      let t = (() => {
        try {
          if (e instanceof URL) return e
          if (typeof e == 'object' && 'hostname' in e) {
            let {
                hostname: _,
                port: f,
                protocol: h = '',
                path: y = '',
                query: E = {},
              } = e,
              C = new URL(`${h}//${_}${f ? `:${f}` : ''}${y}`)
            return (
              (C.search = Object.entries(E)
                .map(([A, se]) => `${A}=${se}`)
                .join('&')),
              C
            )
          }
          return new URL(e)
        } catch {
          return null
        }
      })()
      if (!t)
        return (
          console.error(
            `Unable to parse ${JSON.stringify(e)} as a whatwg URL.`,
          ),
          null
        )
      let n = t.href,
        { host: r, hostname: s, pathname: o, protocol: i, search: a } = t
      if (a) return null
      let c = i.slice(0, -1)
      if (!Object.values(AT.EndpointURLScheme).includes(c)) return null
      let u = (0, yue.isIpAddress)(s),
        d =
          n.includes(`${r}:${DT[c]}`) ||
          (typeof e == 'string' && e.includes(`${r}:${DT[c]}`)),
        p = `${r}${d ? `:${DT[c]}` : ''}`
      return {
        scheme: c,
        authority: p,
        path: o,
        normalizedPath: o.endsWith('/') ? o : `${o}/`,
        isIp: u,
      }
    }
  uf.parseURL = Eue
})
var Pj = l((lf) => {
  'use strict'
  Object.defineProperty(lf, '__esModule', { value: !0 })
  lf.stringEquals = void 0
  var Sue = (e, t) => e === t
  lf.stringEquals = Sue
})
var Rj = l((mf) => {
  'use strict'
  Object.defineProperty(mf, '__esModule', { value: !0 })
  mf.substring = void 0
  var bue = (e, t, n, r) =>
    t >= n || e.length < n
      ? null
      : r
        ? e.substring(e.length - n, e.length - t)
        : e.substring(t, n)
  mf.substring = bue
})
var Dj = l((pf) => {
  'use strict'
  Object.defineProperty(pf, '__esModule', { value: !0 })
  pf.uriEncode = void 0
  var vue = (e) =>
    encodeURIComponent(e).replace(
      /[!*'()]/g,
      (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`,
    )
  pf.uriEncode = vue
})
var OT = l((xt) => {
  'use strict'
  Object.defineProperty(xt, '__esModule', { value: !0 })
  xt.aws = void 0
  var Un = (x(), w(I))
  xt.aws = Un.__importStar(sB())
  Un.__exportStar(oB(), xt)
  Un.__exportStar(cB(), xt)
  Un.__exportStar(dB(), xt)
  Un.__exportStar(PT(), xt)
  Un.__exportStar(uB(), xt)
  Un.__exportStar(xj(), xt)
  Un.__exportStar(Pj(), xt)
  Un.__exportStar(Rj(), xt)
  Un.__exportStar(Dj(), xt)
})
var NT = l((_f) => {
  'use strict'
  Object.defineProperty(_f, '__esModule', { value: !0 })
  _f.evaluateTemplate = void 0
  var Cue = OT(),
    Tue = (e, t) => {
      let n = [],
        r = { ...t.endpointParams, ...t.referenceRecord },
        s = 0
      for (; s < e.length; ) {
        let o = e.indexOf('{', s)
        if (o === -1) {
          n.push(e.slice(s))
          break
        }
        n.push(e.slice(s, o))
        let i = e.indexOf('}', o)
        if (i === -1) {
          n.push(e.slice(o))
          break
        }
        e[o + 1] === '{' &&
          e[i + 1] === '}' &&
          (n.push(e.slice(o + 1, i)), (s = i + 2))
        let a = e.substring(o + 1, i)
        if (a.includes('#')) {
          let [c, u] = a.split('#')
          n.push((0, Cue.getAttr)(r[c], u))
        } else n.push(r[a])
        s = i + 1
      }
      return n.join('')
    }
  _f.evaluateTemplate = Tue
})
var Aj = l((ff) => {
  'use strict'
  Object.defineProperty(ff, '__esModule', { value: !0 })
  ff.getReferenceValue = void 0
  var wue = ({ ref: e }, t) =>
    ({ ...t.endpointParams, ...t.referenceRecord })[e]
  ff.getReferenceValue = wue
})
var Hu = l((hf) => {
  'use strict'
  Object.defineProperty(hf, '__esModule', { value: !0 })
  hf.evaluateExpression = void 0
  var Iue = Yt(),
    xue = qT(),
    Pue = NT(),
    Rue = Aj(),
    Due = (e, t, n) => {
      if (typeof e == 'string') return (0, Pue.evaluateTemplate)(e, n)
      if (e.fn) return (0, xue.callFunction)(e, n)
      if (e.ref) return (0, Rue.getReferenceValue)(e, n)
      throw new Iue.EndpointError(
        `'${t}': ${String(e)} is not a string, function or reference.`,
      )
    }
  hf.evaluateExpression = Due
})
var qT = l((gf) => {
  'use strict'
  Object.defineProperty(gf, '__esModule', { value: !0 })
  gf.callFunction = void 0
  var Aue = (x(), w(I)),
    Oue = Aue.__importStar(OT()),
    Nue = Hu(),
    que = ({ fn: e, argv: t }, n) => {
      let r = t.map((s) =>
        ['boolean', 'number'].includes(typeof s)
          ? s
          : (0, Nue.evaluateExpression)(s, 'arg', n),
      )
      return e.split('.').reduce((s, o) => s[o], Oue)(...r)
    }
  gf.callFunction = que
})
var Oj = l((yf) => {
  'use strict'
  Object.defineProperty(yf, '__esModule', { value: !0 })
  yf.evaluateCondition = void 0
  var kT = Fu(),
    kue = Yt(),
    Mue = qT(),
    Lue = ({ assign: e, ...t }, n) => {
      var r, s
      if (e && e in n.referenceRecord)
        throw new kue.EndpointError(
          `'${e}' is already defined in Reference Record.`,
        )
      let o = (0, Mue.callFunction)(t, n)
      return (
        (s = (r = n.logger) === null || r === void 0 ? void 0 : r.debug) ===
          null ||
          s === void 0 ||
          s.call(
            r,
            kT.debugId,
            `evaluateCondition: ${(0, kT.toDebugString)(t)} = ${(0,
            kT.toDebugString)(o)}`,
          ),
        {
          result: o === '' ? !0 : !!o,
          ...(e != null && { toAssign: { name: e, value: o } }),
        }
      )
    }
  yf.evaluateCondition = Lue
})
var Sf = l((Ef) => {
  'use strict'
  Object.defineProperty(Ef, '__esModule', { value: !0 })
  Ef.evaluateConditions = void 0
  var Nj = Fu(),
    Uue = Oj(),
    Fue = (e = [], t) => {
      var n, r
      let s = {}
      for (let o of e) {
        let { result: i, toAssign: a } = (0, Uue.evaluateCondition)(o, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...s },
        })
        if (!i) return { result: i }
        a &&
          ((s[a.name] = a.value),
          (r = (n = t.logger) === null || n === void 0 ? void 0 : n.debug) ===
            null ||
            r === void 0 ||
            r.call(
              n,
              Nj.debugId,
              `assign: ${a.name} := ${(0, Nj.toDebugString)(a.value)}`,
            ))
      }
      return { result: !0, referenceRecord: s }
    }
  Ef.evaluateConditions = Fue
})
var qj = l((bf) => {
  'use strict'
  Object.defineProperty(bf, '__esModule', { value: !0 })
  bf.getEndpointHeaders = void 0
  var Bue = Yt(),
    jue = Hu(),
    Gue = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => ({
          ...n,
          [r]: s.map((o) => {
            let i = (0, jue.evaluateExpression)(o, 'Header value entry', t)
            if (typeof i != 'string')
              throw new Bue.EndpointError(
                `Header '${r}' value '${i}' is not a string`,
              )
            return i
          }),
        }),
        {},
      )
  bf.getEndpointHeaders = Gue
})
var Mj = l((Vu) => {
  'use strict'
  Object.defineProperty(Vu, '__esModule', { value: !0 })
  Vu.getEndpointProperty = void 0
  var kj = Yt(),
    $ue = NT(),
    zue = MT(),
    Hue = (e, t) => {
      if (Array.isArray(e))
        return e.map((n) => (0, Vu.getEndpointProperty)(n, t))
      switch (typeof e) {
        case 'string':
          return (0, $ue.evaluateTemplate)(e, t)
        case 'object':
          if (e === null)
            throw new kj.EndpointError(`Unexpected endpoint property: ${e}`)
          return (0, zue.getEndpointProperties)(e, t)
        case 'boolean':
          return e
        default:
          throw new kj.EndpointError(
            `Unexpected endpoint property type: ${typeof e}`,
          )
      }
    }
  Vu.getEndpointProperty = Hue
})
var MT = l((vf) => {
  'use strict'
  Object.defineProperty(vf, '__esModule', { value: !0 })
  vf.getEndpointProperties = void 0
  var Vue = Mj(),
    Yue = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => ({ ...n, [r]: (0, Vue.getEndpointProperty)(s, t) }),
        {},
      )
  vf.getEndpointProperties = Yue
})
var Lj = l((Cf) => {
  'use strict'
  Object.defineProperty(Cf, '__esModule', { value: !0 })
  Cf.getEndpointUrl = void 0
  var Wue = Yt(),
    Kue = Hu(),
    Xue = (e, t) => {
      let n = (0, Kue.evaluateExpression)(e, 'Endpoint URL', t)
      if (typeof n == 'string')
        try {
          return new URL(n)
        } catch (r) {
          throw (console.error(`Failed to construct URL with ${n}`, r), r)
        }
      throw new Wue.EndpointError(
        `Endpoint URL must be a string, got ${typeof n}`,
      )
    }
  Cf.getEndpointUrl = Xue
})
var Fj = l((Tf) => {
  'use strict'
  Object.defineProperty(Tf, '__esModule', { value: !0 })
  Tf.evaluateEndpointRule = void 0
  var Uj = Fu(),
    Jue = Sf(),
    Que = qj(),
    Zue = MT(),
    ele = Lj(),
    tle = (e, t) => {
      var n, r
      let { conditions: s, endpoint: o } = e,
        { result: i, referenceRecord: a } = (0, Jue.evaluateConditions)(s, t)
      if (!i) return
      let c = { ...t, referenceRecord: { ...t.referenceRecord, ...a } },
        { url: u, properties: d, headers: p } = o
      return (
        (r = (n = t.logger) === null || n === void 0 ? void 0 : n.debug) ===
          null ||
          r === void 0 ||
          r.call(
            n,
            Uj.debugId,
            `Resolving endpoint from template: ${(0, Uj.toDebugString)(o)}`,
          ),
        {
          ...(p != null && { headers: (0, Que.getEndpointHeaders)(p, c) }),
          ...(d != null && {
            properties: (0, Zue.getEndpointProperties)(d, c),
          }),
          url: (0, ele.getEndpointUrl)(u, c),
        }
      )
    }
  Tf.evaluateEndpointRule = tle
})
var Bj = l((wf) => {
  'use strict'
  Object.defineProperty(wf, '__esModule', { value: !0 })
  wf.evaluateErrorRule = void 0
  var nle = Yt(),
    rle = Sf(),
    sle = Hu(),
    ole = (e, t) => {
      let { conditions: n, error: r } = e,
        { result: s, referenceRecord: o } = (0, rle.evaluateConditions)(n, t)
      if (s)
        throw new nle.EndpointError(
          (0, sle.evaluateExpression)(r, 'Error', {
            ...t,
            referenceRecord: { ...t.referenceRecord, ...o },
          }),
        )
    }
  wf.evaluateErrorRule = ole
})
var jj = l((If) => {
  'use strict'
  Object.defineProperty(If, '__esModule', { value: !0 })
  If.evaluateTreeRule = void 0
  var ile = Sf(),
    ale = LT(),
    cle = (e, t) => {
      let { conditions: n, rules: r } = e,
        { result: s, referenceRecord: o } = (0, ile.evaluateConditions)(n, t)
      if (s)
        return (0, ale.evaluateRules)(r, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...o },
        })
    }
  If.evaluateTreeRule = cle
})
var LT = l((xf) => {
  'use strict'
  Object.defineProperty(xf, '__esModule', { value: !0 })
  xf.evaluateRules = void 0
  var Gj = Yt(),
    dle = Fj(),
    ule = Bj(),
    lle = jj(),
    mle = (e, t) => {
      for (let n of e)
        if (n.type === 'endpoint') {
          let r = (0, dle.evaluateEndpointRule)(n, t)
          if (r) return r
        } else if (n.type === 'error') (0, ule.evaluateErrorRule)(n, t)
        else if (n.type === 'tree') {
          let r = (0, lle.evaluateTreeRule)(n, t)
          if (r) return r
        } else throw new Gj.EndpointError(`Unknown endpoint rule: ${n}`)
      throw new Gj.EndpointError('Rules evaluation failed')
    }
  xf.evaluateRules = mle
})
var $j = l((UT) => {
  'use strict'
  Object.defineProperty(UT, '__esModule', { value: !0 })
  var ple = (x(), w(I))
  ple.__exportStar(LT(), UT)
})
var zj = l((Rf) => {
  'use strict'
  Object.defineProperty(Rf, '__esModule', { value: !0 })
  Rf.resolveEndpoint = void 0
  var Pf = Fu(),
    _le = Yt(),
    fle = $j(),
    hle = (e, t) => {
      var n, r, s, o, i, a
      let { endpointParams: c, logger: u } = t,
        { parameters: d, rules: p } = e
      ;(r = (n = t.logger) === null || n === void 0 ? void 0 : n.debug) ===
        null ||
        r === void 0 ||
        r.call(
          n,
          `${Pf.debugId} Initial EndpointParams: ${(0, Pf.toDebugString)(c)}`,
        )
      let _ = Object.entries(d)
        .filter(([, y]) => y.default != null)
        .map(([y, E]) => [y, E.default])
      if (_.length > 0)
        for (let [y, E] of _) c[y] = (s = c[y]) !== null && s !== void 0 ? s : E
      let f = Object.entries(d)
        .filter(([, y]) => y.required)
        .map(([y]) => y)
      for (let y of f)
        if (c[y] == null)
          throw new _le.EndpointError(`Missing required parameter: '${y}'`)
      let h = (0, fle.evaluateRules)(p, {
        endpointParams: c,
        logger: u,
        referenceRecord: {},
      })
      if (!((o = t.endpointParams) === null || o === void 0) && o.Endpoint)
        try {
          let y = new URL(t.endpointParams.Endpoint),
            { protocol: E, port: C } = y
          ;(h.url.protocol = E), (h.url.port = C)
        } catch {}
      return (
        (a = (i = t.logger) === null || i === void 0 ? void 0 : i.debug) ===
          null ||
          a === void 0 ||
          a.call(
            i,
            `${Pf.debugId} Resolved endpoint: ${(0, Pf.toDebugString)(h)}`,
          ),
        h
      )
    }
  Rf.resolveEndpoint = hle
})
var ea = l((Zi) => {
  'use strict'
  Object.defineProperty(Zi, '__esModule', { value: !0 })
  var Df = (x(), w(I))
  Df.__exportStar(wT(), Zi)
  Df.__exportStar(K_(), Zi)
  Df.__exportStar(zj(), Zi)
  Df.__exportStar(Yt(), Zi)
})
var Hj = l((rt) => {
  'use strict'
  Object.defineProperty(rt, '__esModule', { value: !0 })
  rt.UA_ESCAPE_CHAR =
    rt.UA_VALUE_ESCAPE_REGEX =
    rt.UA_NAME_ESCAPE_REGEX =
    rt.UA_NAME_SEPARATOR =
    rt.SPACE =
    rt.X_AMZ_USER_AGENT =
    rt.USER_AGENT =
      void 0
  rt.USER_AGENT = 'user-agent'
  rt.X_AMZ_USER_AGENT = 'x-amz-user-agent'
  rt.SPACE = ' '
  rt.UA_NAME_SEPARATOR = '/'
  rt.UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g
  rt.UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g
  rt.UA_ESCAPE_CHAR = '-'
})
var Vj = l((Fn) => {
  'use strict'
  Object.defineProperty(Fn, '__esModule', { value: !0 })
  Fn.getUserAgentPlugin =
    Fn.getUserAgentMiddlewareOptions =
    Fn.userAgentMiddleware =
      void 0
  var gle = ea(),
    yle = Oe(),
    _t = Hj(),
    Ele = (e) => (t, n) => async (r) => {
      var s, o
      let { request: i } = r
      if (!yle.HttpRequest.isInstance(i)) return t(r)
      let { headers: a } = i,
        c =
          ((s = n?.userAgent) === null || s === void 0 ? void 0 : s.map(FT)) ||
          [],
        u = (await e.defaultUserAgentProvider()).map(FT),
        d =
          ((o = e?.customUserAgent) === null || o === void 0
            ? void 0
            : o.map(FT)) || [],
        p = (0, gle.getUserAgentPrefix)(),
        _ = (p ? [p] : []).concat([...u, ...c, ...d]).join(_t.SPACE),
        f = [...u.filter((h) => h.startsWith('aws-sdk-')), ...d].join(_t.SPACE)
      return (
        e.runtime !== 'browser'
          ? (f &&
              (a[_t.X_AMZ_USER_AGENT] = a[_t.X_AMZ_USER_AGENT]
                ? `${a[_t.USER_AGENT]} ${f}`
                : f),
            (a[_t.USER_AGENT] = _))
          : (a[_t.X_AMZ_USER_AGENT] = _),
        t({ ...r, request: i })
      )
    }
  Fn.userAgentMiddleware = Ele
  var FT = (e) => {
    var t
    let n = e[0]
        .split(_t.UA_NAME_SEPARATOR)
        .map((a) => a.replace(_t.UA_NAME_ESCAPE_REGEX, _t.UA_ESCAPE_CHAR))
        .join(_t.UA_NAME_SEPARATOR),
      r =
        (t = e[1]) === null || t === void 0
          ? void 0
          : t.replace(_t.UA_VALUE_ESCAPE_REGEX, _t.UA_ESCAPE_CHAR),
      s = n.indexOf(_t.UA_NAME_SEPARATOR),
      o = n.substring(0, s),
      i = n.substring(s + 1)
    return (
      o === 'api' && (i = i.toLowerCase()),
      [o, i, r]
        .filter((a) => a && a.length > 0)
        .reduce((a, c, u) => {
          switch (u) {
            case 0:
              return c
            case 1:
              return `${a}/${c}`
            default:
              return `${a}#${c}`
          }
        }, '')
    )
  }
  Fn.getUserAgentMiddlewareOptions = {
    name: 'getUserAgentMiddleware',
    step: 'build',
    priority: 'low',
    tags: ['SET_USER_AGENT', 'USER_AGENT'],
    override: !0,
  }
  var Sle = (e) => ({
    applyToStack: (t) => {
      t.add((0, Fn.userAgentMiddleware)(e), Fn.getUserAgentMiddlewareOptions)
    },
  })
  Fn.getUserAgentPlugin = Sle
})
var Yu = l((Af) => {
  'use strict'
  Object.defineProperty(Af, '__esModule', { value: !0 })
  var Yj = (x(), w(I))
  Yj.__exportStar(LF(), Af)
  Yj.__exportStar(Vj(), Af)
})
var Wj = l((No) => {
  'use strict'
  Object.defineProperty(No, '__esModule', { value: !0 })
  No.booleanSelector = No.SelectorType = void 0
  var ble
  ;(function (e) {
    ;(e.ENV = 'env'), (e.CONFIG = 'shared config entry')
  })((ble = No.SelectorType || (No.SelectorType = {})))
  var vle = (e, t, n) => {
    if (t in e) {
      if (e[t] === 'true') return !0
      if (e[t] === 'false') return !1
      throw new Error(
        `Cannot load ${n} "${t}". Expected "true" or "false", got ${e[t]}.`,
      )
    }
  }
  No.booleanSelector = vle
})
var jT = l((BT) => {
  'use strict'
  Object.defineProperty(BT, '__esModule', { value: !0 })
  var Cle = (x(), w(I))
  Cle.__exportStar(Wj(), BT)
})
var Kj = l((Wt) => {
  'use strict'
  Object.defineProperty(Wt, '__esModule', { value: !0 })
  Wt.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS =
    Wt.DEFAULT_USE_DUALSTACK_ENDPOINT =
    Wt.CONFIG_USE_DUALSTACK_ENDPOINT =
    Wt.ENV_USE_DUALSTACK_ENDPOINT =
      void 0
  var Of = jT()
  Wt.ENV_USE_DUALSTACK_ENDPOINT = 'AWS_USE_DUALSTACK_ENDPOINT'
  Wt.CONFIG_USE_DUALSTACK_ENDPOINT = 'use_dualstack_endpoint'
  Wt.DEFAULT_USE_DUALSTACK_ENDPOINT = !1
  Wt.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) =>
      (0, Of.booleanSelector)(
        e,
        Wt.ENV_USE_DUALSTACK_ENDPOINT,
        Of.SelectorType.ENV,
      ),
    configFileSelector: (e) =>
      (0, Of.booleanSelector)(
        e,
        Wt.CONFIG_USE_DUALSTACK_ENDPOINT,
        Of.SelectorType.CONFIG,
      ),
    default: !1,
  }
})
var Xj = l((Kt) => {
  'use strict'
  Object.defineProperty(Kt, '__esModule', { value: !0 })
  Kt.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS =
    Kt.DEFAULT_USE_FIPS_ENDPOINT =
    Kt.CONFIG_USE_FIPS_ENDPOINT =
    Kt.ENV_USE_FIPS_ENDPOINT =
      void 0
  var Nf = jT()
  Kt.ENV_USE_FIPS_ENDPOINT = 'AWS_USE_FIPS_ENDPOINT'
  Kt.CONFIG_USE_FIPS_ENDPOINT = 'use_fips_endpoint'
  Kt.DEFAULT_USE_FIPS_ENDPOINT = !1
  Kt.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) =>
      (0, Nf.booleanSelector)(e, Kt.ENV_USE_FIPS_ENDPOINT, Nf.SelectorType.ENV),
    configFileSelector: (e) =>
      (0, Nf.booleanSelector)(
        e,
        Kt.CONFIG_USE_FIPS_ENDPOINT,
        Nf.SelectorType.CONFIG,
      ),
    default: !1,
  }
})
var Qj = l((qf) => {
  'use strict'
  Object.defineProperty(qf, '__esModule', { value: !0 })
  qf.resolveCustomEndpointsConfig = void 0
  var Jj = xo(),
    Tle = (e) => {
      var t, n
      let { endpoint: r, urlParser: s } = e
      return {
        ...e,
        tls: (t = e.tls) !== null && t !== void 0 ? t : !0,
        endpoint: (0, Jj.normalizeProvider)(typeof r == 'string' ? s(r) : r),
        isCustomEndpoint: !0,
        useDualstackEndpoint: (0, Jj.normalizeProvider)(
          (n = e.useDualstackEndpoint) !== null && n !== void 0 ? n : !1,
        ),
      }
    }
  qf.resolveCustomEndpointsConfig = Tle
})
var Zj = l((kf) => {
  'use strict'
  Object.defineProperty(kf, '__esModule', { value: !0 })
  kf.getEndpointFromRegion = void 0
  var wle = async (e) => {
    var t
    let { tls: n = !0 } = e,
      r = await e.region()
    if (
      !new RegExp(
        /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/,
      ).test(r)
    )
      throw new Error('Invalid region in client config')
    let o = await e.useDualstackEndpoint(),
      i = await e.useFipsEndpoint(),
      { hostname: a } =
        (t = await e.regionInfoProvider(r, {
          useDualstackEndpoint: o,
          useFipsEndpoint: i,
        })) !== null && t !== void 0
          ? t
          : {}
    if (!a) throw new Error('Cannot resolve hostname from client config')
    return e.urlParser(`${n ? 'https:' : 'http:'}//${a}`)
  }
  kf.getEndpointFromRegion = wle
})
var tG = l((Mf) => {
  'use strict'
  Object.defineProperty(Mf, '__esModule', { value: !0 })
  Mf.resolveEndpointsConfig = void 0
  var eG = xo(),
    Ile = Zj(),
    xle = (e) => {
      var t, n
      let r = (0, eG.normalizeProvider)(
          (t = e.useDualstackEndpoint) !== null && t !== void 0 ? t : !1,
        ),
        { endpoint: s, useFipsEndpoint: o, urlParser: i } = e
      return {
        ...e,
        tls: (n = e.tls) !== null && n !== void 0 ? n : !0,
        endpoint: s
          ? (0, eG.normalizeProvider)(typeof s == 'string' ? i(s) : s)
          : () =>
              (0, Ile.getEndpointFromRegion)({
                ...e,
                useDualstackEndpoint: r,
                useFipsEndpoint: o,
              }),
        isCustomEndpoint: !!s,
        useDualstackEndpoint: r,
      }
    }
  Mf.resolveEndpointsConfig = xle
})
var nG = l((ta) => {
  'use strict'
  Object.defineProperty(ta, '__esModule', { value: !0 })
  var Lf = (x(), w(I))
  Lf.__exportStar(Kj(), ta)
  Lf.__exportStar(Xj(), ta)
  Lf.__exportStar(Qj(), ta)
  Lf.__exportStar(tG(), ta)
})
var rG = l((Xt) => {
  'use strict'
  Object.defineProperty(Xt, '__esModule', { value: !0 })
  Xt.NODE_REGION_CONFIG_FILE_OPTIONS =
    Xt.NODE_REGION_CONFIG_OPTIONS =
    Xt.REGION_INI_NAME =
    Xt.REGION_ENV_NAME =
      void 0
  Xt.REGION_ENV_NAME = 'AWS_REGION'
  Xt.REGION_INI_NAME = 'region'
  Xt.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Xt.REGION_ENV_NAME],
    configFileSelector: (e) => e[Xt.REGION_INI_NAME],
    default: () => {
      throw new Error('Region is missing')
    },
  }
  Xt.NODE_REGION_CONFIG_FILE_OPTIONS = { preferredFile: 'credentials' }
})
var GT = l((Uf) => {
  'use strict'
  Object.defineProperty(Uf, '__esModule', { value: !0 })
  Uf.isFipsRegion = void 0
  var Ple = (e) =>
    typeof e == 'string' && (e.startsWith('fips-') || e.endsWith('-fips'))
  Uf.isFipsRegion = Ple
})
var sG = l((Ff) => {
  'use strict'
  Object.defineProperty(Ff, '__esModule', { value: !0 })
  Ff.getRealRegion = void 0
  var Rle = GT(),
    Dle = (e) =>
      (0, Rle.isFipsRegion)(e)
        ? ['fips-aws-global', 'aws-fips'].includes(e)
          ? 'us-east-1'
          : e.replace(/fips-(dkr-|prod-)?|-fips/, '')
        : e
  Ff.getRealRegion = Dle
})
var iG = l((Bf) => {
  'use strict'
  Object.defineProperty(Bf, '__esModule', { value: !0 })
  Bf.resolveRegionConfig = void 0
  var oG = sG(),
    Ale = GT(),
    Ole = (e) => {
      let { region: t, useFipsEndpoint: n } = e
      if (!t) throw new Error('Region is missing')
      return {
        ...e,
        region: async () => {
          if (typeof t == 'string') return (0, oG.getRealRegion)(t)
          let r = await t()
          return (0, oG.getRealRegion)(r)
        },
        useFipsEndpoint: async () => {
          let r = typeof t == 'string' ? t : await t()
          return (0, Ale.isFipsRegion)(r)
            ? !0
            : typeof n != 'function'
              ? Promise.resolve(!!n)
              : n()
        },
      }
    }
  Bf.resolveRegionConfig = Ole
})
var cG = l((jf) => {
  'use strict'
  Object.defineProperty(jf, '__esModule', { value: !0 })
  var aG = (x(), w(I))
  aG.__exportStar(rG(), jf)
  aG.__exportStar(iG(), jf)
})
var uG = l((dG) => {
  'use strict'
  Object.defineProperty(dG, '__esModule', { value: !0 })
})
var mG = l((lG) => {
  'use strict'
  Object.defineProperty(lG, '__esModule', { value: !0 })
})
var pG = l((Gf) => {
  'use strict'
  Object.defineProperty(Gf, '__esModule', { value: !0 })
  Gf.getHostnameFromVariants = void 0
  var Nle = (e = [], { useFipsEndpoint: t, useDualstackEndpoint: n }) => {
    var r
    return (r = e.find(
      ({ tags: s }) =>
        t === s.includes('fips') && n === s.includes('dualstack'),
    )) === null || r === void 0
      ? void 0
      : r.hostname
  }
  Gf.getHostnameFromVariants = Nle
})
var _G = l(($f) => {
  'use strict'
  Object.defineProperty($f, '__esModule', { value: !0 })
  $f.getResolvedHostname = void 0
  var qle = (e, { regionHostname: t, partitionHostname: n }) =>
    t || (n ? n.replace('{region}', e) : void 0)
  $f.getResolvedHostname = qle
})
var fG = l((zf) => {
  'use strict'
  Object.defineProperty(zf, '__esModule', { value: !0 })
  zf.getResolvedPartition = void 0
  var kle = (e, { partitionHash: t }) => {
    var n
    return (n = Object.keys(t || {}).find((r) => t[r].regions.includes(e))) !==
      null && n !== void 0
      ? n
      : 'aws'
  }
  zf.getResolvedPartition = kle
})
var hG = l((Hf) => {
  'use strict'
  Object.defineProperty(Hf, '__esModule', { value: !0 })
  Hf.getResolvedSigningRegion = void 0
  var Mle = (e, { signingRegion: t, regionRegex: n, useFipsEndpoint: r }) => {
    if (t) return t
    if (r) {
      let s = n
          .replace('\\\\', '\\')
          .replace(/^\^/g, '\\.')
          .replace(/\$$/g, '\\.'),
        o = e.match(s)
      if (o) return o[0].slice(1, -1)
    }
  }
  Hf.getResolvedSigningRegion = Mle
})
var yG = l((Vf) => {
  'use strict'
  Object.defineProperty(Vf, '__esModule', { value: !0 })
  Vf.getRegionInfo = void 0
  var gG = pG(),
    Lle = _G(),
    Ule = fG(),
    Fle = hG(),
    Ble = (
      e,
      {
        useFipsEndpoint: t = !1,
        useDualstackEndpoint: n = !1,
        signingService: r,
        regionHash: s,
        partitionHash: o,
      },
    ) => {
      var i, a, c, u, d, p
      let _ = (0, Ule.getResolvedPartition)(e, { partitionHash: o }),
        f =
          e in s
            ? e
            : (a =
                  (i = o[_]) === null || i === void 0 ? void 0 : i.endpoint) !==
                  null && a !== void 0
              ? a
              : e,
        h = { useFipsEndpoint: t, useDualstackEndpoint: n },
        y = (0, gG.getHostnameFromVariants)(
          (c = s[f]) === null || c === void 0 ? void 0 : c.variants,
          h,
        ),
        E = (0, gG.getHostnameFromVariants)(
          (u = o[_]) === null || u === void 0 ? void 0 : u.variants,
          h,
        ),
        C = (0, Lle.getResolvedHostname)(f, {
          regionHostname: y,
          partitionHostname: E,
        })
      if (C === void 0)
        throw new Error(
          `Endpoint resolution failed for: ${{
            resolvedRegion: f,
            useFipsEndpoint: t,
            useDualstackEndpoint: n,
          }}`,
        )
      let A = (0, Fle.getResolvedSigningRegion)(C, {
        signingRegion:
          (d = s[f]) === null || d === void 0 ? void 0 : d.signingRegion,
        regionRegex: o[_].regionRegex,
        useFipsEndpoint: t,
      })
      return {
        partition: _,
        signingService: r,
        hostname: C,
        ...(A && { signingRegion: A }),
        ...(((p = s[f]) === null || p === void 0
          ? void 0
          : p.signingService) && { signingService: s[f].signingService }),
      }
    }
  Vf.getRegionInfo = Ble
})
var EG = l((Wu) => {
  'use strict'
  Object.defineProperty(Wu, '__esModule', { value: !0 })
  var $T = (x(), w(I))
  $T.__exportStar(uG(), Wu)
  $T.__exportStar(mG(), Wu)
  $T.__exportStar(yG(), Wu)
})
var Bn = l((Ku) => {
  'use strict'
  Object.defineProperty(Ku, '__esModule', { value: !0 })
  var zT = (x(), w(I))
  zT.__exportStar(nG(), Ku)
  zT.__exportStar(cG(), Ku)
  zT.__exportStar(EG(), Ku)
})
var Xu = l((br) => {
  'use strict'
  Object.defineProperty(br, '__esModule', { value: !0 })
  br.getContentLengthPlugin =
    br.contentLengthMiddlewareOptions =
    br.contentLengthMiddleware =
      void 0
  var jle = Oe(),
    SG = 'content-length'
  function bG(e) {
    return (t) => async (n) => {
      let r = n.request
      if (jle.HttpRequest.isInstance(r)) {
        let { body: s, headers: o } = r
        if (
          s &&
          Object.keys(o)
            .map((i) => i.toLowerCase())
            .indexOf(SG) === -1
        )
          try {
            let i = e(s)
            r.headers = { ...r.headers, [SG]: String(i) }
          } catch {}
      }
      return t({ ...n, request: r })
    }
  }
  br.contentLengthMiddleware = bG
  br.contentLengthMiddlewareOptions = {
    step: 'build',
    tags: ['SET_CONTENT_LENGTH', 'CONTENT_LENGTH'],
    name: 'contentLengthMiddleware',
    override: !0,
  }
  var Gle = (e) => ({
    applyToStack: (t) => {
      t.add(bG(e.bodyLengthChecker), br.contentLengthMiddlewareOptions)
    },
  })
  br.getContentLengthPlugin = Gle
})
var vG = l((ft) => {
  'use strict'
  Object.defineProperty(ft, '__esModule', { value: !0 })
  ft.isArnBucketName =
    ft.isDnsCompatibleBucketName =
    ft.S3_HOSTNAME_PATTERN =
    ft.DOT_PATTERN =
    ft.resolveParamsForS3 =
      void 0
  var $le = async (e) => {
    let t = e?.Bucket || ''
    if (
      (typeof e.Bucket == 'string' &&
        (e.Bucket = t
          .replace(/#/g, encodeURIComponent('#'))
          .replace(/\?/g, encodeURIComponent('?'))),
      (0, ft.isArnBucketName)(t))
    ) {
      if (e.ForcePathStyle === !0)
        throw new Error('Path-style addressing cannot be used with ARN buckets')
    } else
      (!(0, ft.isDnsCompatibleBucketName)(t) ||
        (t.indexOf('.') !== -1 && !String(e.Endpoint).startsWith('http:')) ||
        t.toLowerCase() !== t ||
        t.length < 3) &&
        (e.ForcePathStyle = !0)
    return (
      e.DisableMultiRegionAccessPoints &&
        ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
      e
    )
  }
  ft.resolveParamsForS3 = $le
  var zle = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
    Hle = /(\d+\.){3}\d+/,
    Vle = /\.\./
  ft.DOT_PATTERN = /\./
  ft.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./
  var Yle = (e) => zle.test(e) && !Hle.test(e) && !Vle.test(e)
  ft.isDnsCompatibleBucketName = Yle
  var Wle = (e) => {
    let [t, n, r, s, o, i] = e.split(':'),
      a = t === 'arn' && e.split(':').length >= 6,
      c = [t, n, r, o, i].filter(Boolean).length === 5
    if (a && !c) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`)
    return t === 'arn' && !!n && !!r && !!o && !!i
  }
  ft.isArnBucketName = Wle
})
var CG = l((HT) => {
  'use strict'
  Object.defineProperty(HT, '__esModule', { value: !0 })
  var Kle = (x(), w(I))
  Kle.__exportStar(vG(), HT)
})
var TG = l((Yf) => {
  'use strict'
  Object.defineProperty(Yf, '__esModule', { value: !0 })
  Yf.createConfigValueProvider = void 0
  var Xle = (e, t, n) => {
    let r = async () => {
      var s
      let o = (s = n[e]) !== null && s !== void 0 ? s : n[t]
      return typeof o == 'function' ? o() : o
    }
    return e === 'endpoint' || t === 'endpoint'
      ? async () => {
          let s = await r()
          if (s && typeof s == 'object') {
            if ('url' in s) return s.url.href
            if ('hostname' in s) {
              let { protocol: o, hostname: i, port: a, path: c } = s
              return `${o}//${i}${a ? ':' + a : ''}${c}`
            }
          }
          return s
        }
      : r
  }
  Yf.createConfigValueProvider = Xle
})
var wG = l((Wf) => {
  'use strict'
  Object.defineProperty(Wf, '__esModule', { value: !0 })
  Wf.fromEnv = void 0
  var Jle = ye(),
    Qle = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new Jle.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  Wf.fromEnv = Qle
})
var Ju = l((Kf) => {
  'use strict'
  Object.defineProperty(Kf, '__esModule', { value: !0 })
  Kf.getHomeDir = void 0
  var Zle = require('os'),
    eme = require('path'),
    VT = {},
    tme = () =>
      process && process.geteuid ? `${process.geteuid()}` : 'DEFAULT',
    nme = () => {
      let {
        HOME: e,
        USERPROFILE: t,
        HOMEPATH: n,
        HOMEDRIVE: r = `C:${eme.sep}`,
      } = process.env
      if (e) return e
      if (t) return t
      if (n) return `${r}${n}`
      let s = tme()
      return VT[s] || (VT[s] = (0, Zle.homedir)()), VT[s]
    }
  Kf.getHomeDir = nme
})
var IG = l((jn) => {
  'use strict'
  Object.defineProperty(jn, '__esModule', { value: !0 })
  jn.getProfileName = jn.DEFAULT_PROFILE = jn.ENV_PROFILE = void 0
  jn.ENV_PROFILE = 'AWS_PROFILE'
  jn.DEFAULT_PROFILE = 'default'
  var rme = (e) =>
    e.profile || process.env[jn.ENV_PROFILE] || jn.DEFAULT_PROFILE
  jn.getProfileName = rme
})
var YT = l((Xf) => {
  'use strict'
  Object.defineProperty(Xf, '__esModule', { value: !0 })
  Xf.getSSOTokenFilepath = void 0
  var sme = require('crypto'),
    ome = require('path'),
    ime = Ju(),
    ame = (e) => {
      let n = (0, sme.createHash)('sha1').update(e).digest('hex')
      return (0, ome.join)(
        (0, ime.getHomeDir)(),
        '.aws',
        'sso',
        'cache',
        `${n}.json`,
      )
    }
  Xf.getSSOTokenFilepath = ame
})
var xG = l((Jf) => {
  'use strict'
  Object.defineProperty(Jf, '__esModule', { value: !0 })
  Jf.getSSOTokenFromFile = void 0
  var cme = require('fs'),
    dme = YT(),
    { readFile: ume } = cme.promises,
    lme = async (e) => {
      let t = (0, dme.getSSOTokenFilepath)(e),
        n = await ume(t, 'utf8')
      return JSON.parse(n)
    }
  Jf.getSSOTokenFromFile = lme
})
var DG = l((Qf) => {
  'use strict'
  Object.defineProperty(Qf, '__esModule', { value: !0 })
  Qf.getConfigData = void 0
  var PG = D(),
    RG = na(),
    mme = (e) =>
      Object.entries(e)
        .filter(([t]) => {
          let n = t.split(RG.CONFIG_PREFIX_SEPARATOR)
          return !!(
            n.length === 2 && Object.values(PG.IniSectionType).includes(n[0])
          )
        })
        .reduce(
          (t, [n, r]) => {
            let s = n.startsWith(PG.IniSectionType.PROFILE)
              ? n.split(RG.CONFIG_PREFIX_SEPARATOR)[1]
              : n
            return (t[s] = r), t
          },
          { ...(e.default && { default: e.default }) },
        )
  Qf.getConfigData = mme
})
var WT = l((qo) => {
  'use strict'
  Object.defineProperty(qo, '__esModule', { value: !0 })
  qo.getConfigFilepath = qo.ENV_CONFIG_PATH = void 0
  var pme = require('path'),
    _me = Ju()
  qo.ENV_CONFIG_PATH = 'AWS_CONFIG_FILE'
  var fme = () =>
    process.env[qo.ENV_CONFIG_PATH] ||
    (0, pme.join)((0, _me.getHomeDir)(), '.aws', 'config')
  qo.getConfigFilepath = fme
})
var AG = l((ko) => {
  'use strict'
  Object.defineProperty(ko, '__esModule', { value: !0 })
  ko.getCredentialsFilepath = ko.ENV_CREDENTIALS_PATH = void 0
  var hme = require('path'),
    gme = Ju()
  ko.ENV_CREDENTIALS_PATH = 'AWS_SHARED_CREDENTIALS_FILE'
  var yme = () =>
    process.env[ko.ENV_CREDENTIALS_PATH] ||
    (0, hme.join)((0, gme.getHomeDir)(), '.aws', 'credentials')
  ko.getCredentialsFilepath = yme
})
var KT = l((Zf) => {
  'use strict'
  Object.defineProperty(Zf, '__esModule', { value: !0 })
  Zf.parseIni = void 0
  var Eme = D(),
    OG = na(),
    Sme = /^([\w-]+)\s(["'])?([\w-@\+]+)\2$/,
    bme = ['__proto__', 'profile __proto__'],
    vme = (e) => {
      let t = {},
        n,
        r
      for (let s of e.split(/\r?\n/)) {
        let o = s.split(/(^|\s)[;#]/)[0].trim()
        if (o[0] === '[' && o[o.length - 1] === ']') {
          ;(n = void 0), (r = void 0)
          let a = o.substring(1, o.length - 1),
            c = Sme.exec(a)
          if (c) {
            let [, u, , d] = c
            Object.values(Eme.IniSectionType).includes(u) &&
              (n = [u, d].join(OG.CONFIG_PREFIX_SEPARATOR))
          } else n = a
          if (bme.includes(a))
            throw new Error(`Found invalid profile name "${a}"`)
        } else if (n) {
          let a = o.indexOf('=')
          if (![0, -1].includes(a)) {
            let [c, u] = [o.substring(0, a).trim(), o.substring(a + 1).trim()]
            if (u === '') r = c
            else {
              r && s.trimStart() === s && (r = void 0), (t[n] = t[n] || {})
              let d = r ? [r, c].join(OG.CONFIG_PREFIX_SEPARATOR) : c
              t[n][d] = u
            }
          }
        }
      }
      return t
    }
  Zf.parseIni = vme
})
var JT = l((eh) => {
  'use strict'
  Object.defineProperty(eh, '__esModule', { value: !0 })
  eh.slurpFile = void 0
  var Cme = require('fs'),
    { readFile: Tme } = Cme.promises,
    XT = {},
    wme = (e, t) => (
      (!XT[e] || t?.ignoreCache) && (XT[e] = Tme(e, 'utf8')), XT[e]
    )
  eh.slurpFile = wme
})
var na = l((ra) => {
  'use strict'
  Object.defineProperty(ra, '__esModule', { value: !0 })
  ra.loadSharedConfigFiles = ra.CONFIG_PREFIX_SEPARATOR = void 0
  var Ime = DG(),
    xme = WT(),
    Pme = AG(),
    NG = KT(),
    qG = JT(),
    kG = () => ({})
  ra.CONFIG_PREFIX_SEPARATOR = '.'
  var Rme = async (e = {}) => {
    let {
        filepath: t = (0, Pme.getCredentialsFilepath)(),
        configFilepath: n = (0, xme.getConfigFilepath)(),
      } = e,
      r = await Promise.all([
        (0, qG.slurpFile)(n, { ignoreCache: e.ignoreCache })
          .then(NG.parseIni)
          .then(Ime.getConfigData)
          .catch(kG),
        (0, qG.slurpFile)(t, { ignoreCache: e.ignoreCache })
          .then(NG.parseIni)
          .catch(kG),
      ])
    return { configFile: r[0], credentialsFile: r[1] }
  }
  ra.loadSharedConfigFiles = Rme
})
var LG = l((th) => {
  'use strict'
  Object.defineProperty(th, '__esModule', { value: !0 })
  th.getSsoSessionData = void 0
  var Dme = D(),
    MG = na(),
    Ame = (e) =>
      Object.entries(e)
        .filter(([t]) =>
          t.startsWith(
            Dme.IniSectionType.SSO_SESSION + MG.CONFIG_PREFIX_SEPARATOR,
          ),
        )
        .reduce(
          (t, [n, r]) => ({
            ...t,
            [n.split(MG.CONFIG_PREFIX_SEPARATOR)[1]]: r,
          }),
          {},
        )
  th.getSsoSessionData = Ame
})
var UG = l((nh) => {
  'use strict'
  Object.defineProperty(nh, '__esModule', { value: !0 })
  nh.loadSsoSessionData = void 0
  var Ome = WT(),
    Nme = LG(),
    qme = KT(),
    kme = JT(),
    Mme = () => ({}),
    Lme = async (e = {}) => {
      var t
      return (0, kme.slurpFile)(
        (t = e.configFilepath) !== null && t !== void 0
          ? t
          : (0, Ome.getConfigFilepath)(),
      )
        .then(qme.parseIni)
        .then(Nme.getSsoSessionData)
        .catch(Mme)
    }
  nh.loadSsoSessionData = Lme
})
var FG = l((rh) => {
  'use strict'
  Object.defineProperty(rh, '__esModule', { value: !0 })
  rh.mergeConfigFiles = void 0
  var Ume = (...e) => {
    let t = {}
    for (let n of e)
      for (let [r, s] of Object.entries(n))
        t[r] !== void 0 ? Object.assign(t[r], s) : (t[r] = s)
    return t
  }
  rh.mergeConfigFiles = Ume
})
var BG = l((sh) => {
  'use strict'
  Object.defineProperty(sh, '__esModule', { value: !0 })
  sh.parseKnownFiles = void 0
  var Fme = na(),
    Bme = FG(),
    jme = async (e) => {
      let t = await (0, Fme.loadSharedConfigFiles)(e)
      return (0, Bme.mergeConfigFiles)(t.configFile, t.credentialsFile)
    }
  sh.parseKnownFiles = jme
})
var GG = l((jG) => {
  'use strict'
  Object.defineProperty(jG, '__esModule', { value: !0 })
})
var mn = l((Gn) => {
  'use strict'
  Object.defineProperty(Gn, '__esModule', { value: !0 })
  var us = (x(), w(I))
  us.__exportStar(Ju(), Gn)
  us.__exportStar(IG(), Gn)
  us.__exportStar(YT(), Gn)
  us.__exportStar(xG(), Gn)
  us.__exportStar(na(), Gn)
  us.__exportStar(UG(), Gn)
  us.__exportStar(BG(), Gn)
  us.__exportStar(GG(), Gn)
})
var zG = l((oh) => {
  'use strict'
  Object.defineProperty(oh, '__esModule', { value: !0 })
  oh.fromSharedConfigFiles = void 0
  var Gme = ye(),
    $G = mn(),
    $me =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, $G.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          $G.loadSharedConfigFiles)(n),
          i = o[r] || {},
          a = s[r] || {},
          c = t === 'config' ? { ...i, ...a } : { ...a, ...i }
        try {
          let d = e(c, t === 'config' ? s : o)
          if (d === void 0) throw new Error()
          return d
        } catch (u) {
          throw new Gme.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  oh.fromSharedConfigFiles = $me
})
var HG = l((ih) => {
  'use strict'
  Object.defineProperty(ih, '__esModule', { value: !0 })
  ih.fromStatic = void 0
  var zme = ye(),
    Hme = (e) => typeof e == 'function',
    Vme = (e) => (Hme(e) ? async () => await e() : (0, zme.fromStatic)(e))
  ih.fromStatic = Vme
})
var YG = l((ah) => {
  'use strict'
  Object.defineProperty(ah, '__esModule', { value: !0 })
  ah.loadConfig = void 0
  var VG = ye(),
    Yme = wG(),
    Wme = zG(),
    Kme = HG(),
    Xme = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, VG.memoize)(
        (0, VG.chain)(
          (0, Yme.fromEnv)(e),
          (0, Wme.fromSharedConfigFiles)(t, r),
          (0, Kme.fromStatic)(n),
        ),
      )
  ah.loadConfig = Xme
})
var vr = l((QT) => {
  'use strict'
  Object.defineProperty(QT, '__esModule', { value: !0 })
  var Jme = (x(), w(I))
  Jme.__exportStar(YG(), QT)
})
var JG = l((ch) => {
  'use strict'
  Object.defineProperty(ch, '__esModule', { value: !0 })
  ch.getEndpointUrlConfig = void 0
  var WG = mn(),
    KG = 'AWS_ENDPOINT_URL',
    XG = 'endpoint_url',
    Qme = (e) => ({
      environmentVariableSelector: (t) => {
        let n = e.split(' ').map((o) => o.toUpperCase()),
          r = t[[KG, ...n].join('_')]
        if (r) return r
        let s = t[KG]
        if (s) return s
      },
      configFileSelector: (t, n) => {
        if (n && t.services) {
          let s = n[['services', t.services].join(WG.CONFIG_PREFIX_SEPARATOR)]
          if (s) {
            let o = e.split(' ').map((a) => a.toLowerCase()),
              i = s[[o.join('_'), XG].join(WG.CONFIG_PREFIX_SEPARATOR)]
            if (i) return i
          }
        }
        let r = t[XG]
        if (r) return r
      },
      default: void 0,
    })
  ch.getEndpointUrlConfig = Qme
})
var QG = l((dh) => {
  'use strict'
  Object.defineProperty(dh, '__esModule', { value: !0 })
  dh.getEndpointFromConfig = void 0
  var Zme = vr(),
    epe = JG(),
    tpe = async (e) => (0, Zme.loadConfig)((0, epe.getEndpointUrlConfig)(e))()
  dh.getEndpointFromConfig = tpe
})
var ZG = l((uh) => {
  'use strict'
  Object.defineProperty(uh, '__esModule', { value: !0 })
  uh.parseQueryString = void 0
  function npe(e) {
    let t = {}
    if (((e = e.replace(/^\?/, '')), e))
      for (let n of e.split('&')) {
        let [r, s = null] = n.split('=')
        ;(r = decodeURIComponent(r)),
          s && (s = decodeURIComponent(s)),
          r in t
            ? Array.isArray(t[r])
              ? t[r].push(s)
              : (t[r] = [t[r], s])
            : (t[r] = s)
      }
    return t
  }
  uh.parseQueryString = npe
})
var Mo = l((Qu) => {
  'use strict'
  Object.defineProperty(Qu, '__esModule', { value: !0 })
  Qu.parseUrl = void 0
  var rpe = ZG(),
    spe = (e) => {
      if (typeof e == 'string') return (0, Qu.parseUrl)(new URL(e))
      let { hostname: t, pathname: n, port: r, protocol: s, search: o } = e,
        i
      return (
        o && (i = (0, rpe.parseQueryString)(o)),
        {
          hostname: t,
          port: r ? parseInt(r) : void 0,
          protocol: s,
          path: n,
          query: i,
        }
      )
    }
  Qu.parseUrl = spe
})
var mh = l((lh) => {
  'use strict'
  Object.defineProperty(lh, '__esModule', { value: !0 })
  lh.toEndpointV1 = void 0
  var e$ = Mo(),
    ope = (e) =>
      typeof e == 'object'
        ? 'url' in e
          ? (0, e$.parseUrl)(e.url)
          : e
        : (0, e$.parseUrl)(e)
  lh.toEndpointV1 = ope
})
var ZT = l((Lo) => {
  'use strict'
  Object.defineProperty(Lo, '__esModule', { value: !0 })
  Lo.resolveParams = Lo.getEndpointFromInstructions = void 0
  var ipe = CG(),
    ape = TG(),
    cpe = QG(),
    dpe = mh(),
    upe = async (e, t, n, r) => {
      if (!n.endpoint) {
        let i = await (0, cpe.getEndpointFromConfig)(n.serviceId || '')
        i && (n.endpoint = () => Promise.resolve((0, dpe.toEndpointV1)(i)))
      }
      let s = await (0, Lo.resolveParams)(e, t, n)
      if (typeof n.endpointProvider != 'function')
        throw new Error('config.endpointProvider is not set.')
      return n.endpointProvider(s, r)
    }
  Lo.getEndpointFromInstructions = upe
  var lpe = async (e, t, n) => {
    var r
    let s = {},
      o =
        ((r = t?.getEndpointParameterInstructions) === null || r === void 0
          ? void 0
          : r.call(t)) || {}
    for (let [i, a] of Object.entries(o))
      switch (a.type) {
        case 'staticContextParams':
          s[i] = a.value
          break
        case 'contextParams':
          s[i] = e[a.name]
          break
        case 'clientContextParams':
        case 'builtInParams':
          s[i] = await (0, ape.createConfigValueProvider)(a.name, i, n)()
          break
        default:
          throw new Error(
            'Unrecognized endpoint parameter instruction: ' + JSON.stringify(a),
          )
      }
    return (
      Object.keys(o).length === 0 && Object.assign(s, n),
      String(n.serviceId).toLowerCase() === 's3' &&
        (await (0, ipe.resolveParamsForS3)(s)),
      s
    )
  }
  Lo.resolveParams = lpe
})
var n$ = l((ph) => {
  'use strict'
  Object.defineProperty(ph, '__esModule', { value: !0 })
  var t$ = (x(), w(I))
  t$.__exportStar(ZT(), ph)
  t$.__exportStar(mh(), ph)
})
var ew = l((_h) => {
  'use strict'
  Object.defineProperty(_h, '__esModule', { value: !0 })
  _h.endpointMiddleware = void 0
  var mpe = ZT(),
    ppe =
      ({ config: e, instructions: t }) =>
      (n, r) =>
      async (s) => {
        var o, i
        let a = await (0, mpe.getEndpointFromInstructions)(
          s.input,
          {
            getEndpointParameterInstructions() {
              return t
            },
          },
          { ...e },
          r,
        )
        ;(r.endpointV2 = a),
          (r.authSchemes =
            (o = a.properties) === null || o === void 0
              ? void 0
              : o.authSchemes)
        let c = (i = r.authSchemes) === null || i === void 0 ? void 0 : i[0]
        return (
          c &&
            ((r.signing_region = c.signingRegion),
            (r.signing_service = c.signingName)),
          n({ ...s })
        )
      }
  _h.endpointMiddleware = ppe
})
var tw = l((fh) => {
  'use strict'
  Object.defineProperty(fh, '__esModule', { value: !0 })
  fh.deserializerMiddleware = void 0
  var _pe = (e, t) => (n, r) => async (s) => {
    let { response: o } = await n(s)
    try {
      let i = await t(o, e)
      return { response: o, output: i }
    } catch (i) {
      if (
        (Object.defineProperty(i, '$response', { value: o }),
        !('$metadata' in i))
      ) {
        let a =
          'Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.'
        i.message +=
          `
  ` + a
      }
      throw i
    }
  }
  fh.deserializerMiddleware = _pe
})
var nw = l((hh) => {
  'use strict'
  Object.defineProperty(hh, '__esModule', { value: !0 })
  hh.serializerMiddleware = void 0
  var fpe = (e, t) => (n, r) => async (s) => {
    var o
    let i =
      !((o = r.endpointV2) === null || o === void 0) && o.url && e.urlParser
        ? async () => e.urlParser(r.endpointV2.url)
        : e.endpoint
    if (!i) throw new Error('No valid endpoint provider available.')
    let a = await t(s.input, { ...e, endpoint: i })
    return n({ ...s, request: a })
  }
  hh.serializerMiddleware = fpe
})
var r$ = l(($n) => {
  'use strict'
  Object.defineProperty($n, '__esModule', { value: !0 })
  $n.getSerdePlugin =
    $n.serializerMiddlewareOption =
    $n.deserializerMiddlewareOption =
      void 0
  var hpe = tw(),
    gpe = nw()
  $n.deserializerMiddlewareOption = {
    name: 'deserializerMiddleware',
    step: 'deserialize',
    tags: ['DESERIALIZER'],
    override: !0,
  }
  $n.serializerMiddlewareOption = {
    name: 'serializerMiddleware',
    step: 'serialize',
    tags: ['SERIALIZER'],
    override: !0,
  }
  function ype(e, t, n) {
    return {
      applyToStack: (r) => {
        r.add(
          (0, hpe.deserializerMiddleware)(e, n),
          $n.deserializerMiddlewareOption,
        ),
          r.add(
            (0, gpe.serializerMiddleware)(e, t),
            $n.serializerMiddlewareOption,
          )
      },
    }
  }
  $n.getSerdePlugin = ype
})
var k = l((Zu) => {
  'use strict'
  Object.defineProperty(Zu, '__esModule', { value: !0 })
  var rw = (x(), w(I))
  rw.__exportStar(tw(), Zu)
  rw.__exportStar(r$(), Zu)
  rw.__exportStar(nw(), Zu)
})
var s$ = l((Uo) => {
  'use strict'
  Object.defineProperty(Uo, '__esModule', { value: !0 })
  Uo.getEndpointPlugin = Uo.endpointMiddlewareOptions = void 0
  var Epe = k(),
    Spe = ew()
  Uo.endpointMiddlewareOptions = {
    step: 'serialize',
    tags: ['ENDPOINT_PARAMETERS', 'ENDPOINT_V2', 'ENDPOINT'],
    name: 'endpointV2Middleware',
    override: !0,
    relation: 'before',
    toMiddleware: Epe.serializerMiddlewareOption.name,
  }
  var bpe = (e, t) => ({
    applyToStack: (n) => {
      n.addRelativeTo(
        (0, Spe.endpointMiddleware)({ config: e, instructions: t }),
        Uo.endpointMiddlewareOptions,
      )
    },
  })
  Uo.getEndpointPlugin = bpe
})
var o$ = l((gh) => {
  'use strict'
  Object.defineProperty(gh, '__esModule', { value: !0 })
  gh.resolveEndpointConfig = void 0
  var sw = xo(),
    vpe = mh(),
    Cpe = (e) => {
      var t, n, r
      let s = (t = e.tls) !== null && t !== void 0 ? t : !0,
        { endpoint: o } = e,
        i =
          o != null
            ? async () =>
                (0, vpe.toEndpointV1)(await (0, sw.normalizeProvider)(o)())
            : void 0
      return {
        ...e,
        endpoint: i,
        tls: s,
        isCustomEndpoint: !!o,
        useDualstackEndpoint: (0, sw.normalizeProvider)(
          (n = e.useDualstackEndpoint) !== null && n !== void 0 ? n : !1,
        ),
        useFipsEndpoint: (0, sw.normalizeProvider)(
          (r = e.useFipsEndpoint) !== null && r !== void 0 ? r : !1,
        ),
      }
    }
  gh.resolveEndpointConfig = Cpe
})
var a$ = l((i$) => {
  'use strict'
  Object.defineProperty(i$, '__esModule', { value: !0 })
})
var q = l((Fo) => {
  'use strict'
  Object.defineProperty(Fo, '__esModule', { value: !0 })
  var el = (x(), w(I))
  el.__exportStar(n$(), Fo)
  el.__exportStar(ew(), Fo)
  el.__exportStar(s$(), Fo)
  el.__exportStar(o$(), Fo)
  el.__exportStar(a$(), Fo)
})
var yh = l((Cr) => {
  'use strict'
  Object.defineProperty(Cr, '__esModule', { value: !0 })
  Cr.DEFAULT_RETRY_MODE = Cr.DEFAULT_MAX_ATTEMPTS = Cr.RETRY_MODES = void 0
  var c$
  ;(function (e) {
    ;(e.STANDARD = 'standard'), (e.ADAPTIVE = 'adaptive')
  })((c$ = Cr.RETRY_MODES || (Cr.RETRY_MODES = {})))
  Cr.DEFAULT_MAX_ATTEMPTS = 3
  Cr.DEFAULT_RETRY_MODE = c$.STANDARD
})
var d$ = l((Jt) => {
  'use strict'
  Object.defineProperty(Jt, '__esModule', { value: !0 })
  Jt.NODEJS_TIMEOUT_ERROR_CODES =
    Jt.TRANSIENT_ERROR_STATUS_CODES =
    Jt.TRANSIENT_ERROR_CODES =
    Jt.THROTTLING_ERROR_CODES =
    Jt.CLOCK_SKEW_ERROR_CODES =
      void 0
  Jt.CLOCK_SKEW_ERROR_CODES = [
    'AuthFailure',
    'InvalidSignatureException',
    'RequestExpired',
    'RequestInTheFuture',
    'RequestTimeTooSkewed',
    'SignatureDoesNotMatch',
  ]
  Jt.THROTTLING_ERROR_CODES = [
    'BandwidthLimitExceeded',
    'EC2ThrottledException',
    'LimitExceededException',
    'PriorRequestNotComplete',
    'ProvisionedThroughputExceededException',
    'RequestLimitExceeded',
    'RequestThrottled',
    'RequestThrottledException',
    'SlowDown',
    'ThrottledException',
    'Throttling',
    'ThrottlingException',
    'TooManyRequestsException',
    'TransactionInProgressException',
  ]
  Jt.TRANSIENT_ERROR_CODES = [
    'TimeoutError',
    'RequestTimeout',
    'RequestTimeoutException',
  ]
  Jt.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504]
  Jt.NODEJS_TIMEOUT_ERROR_CODES = [
    'ECONNRESET',
    'ECONNREFUSED',
    'EPIPE',
    'ETIMEDOUT',
  ]
})
var nl = l((Pt) => {
  'use strict'
  Object.defineProperty(Pt, '__esModule', { value: !0 })
  Pt.isServerError =
    Pt.isTransientError =
    Pt.isThrottlingError =
    Pt.isClockSkewError =
    Pt.isRetryableByTrait =
      void 0
  var tl = d$(),
    Tpe = (e) => e.$retryable !== void 0
  Pt.isRetryableByTrait = Tpe
  var wpe = (e) => tl.CLOCK_SKEW_ERROR_CODES.includes(e.name)
  Pt.isClockSkewError = wpe
  var Ipe = (e) => {
    var t, n
    return (
      ((t = e.$metadata) === null || t === void 0
        ? void 0
        : t.httpStatusCode) === 429 ||
      tl.THROTTLING_ERROR_CODES.includes(e.name) ||
      ((n = e.$retryable) === null || n === void 0 ? void 0 : n.throttling) ==
        !0
    )
  }
  Pt.isThrottlingError = Ipe
  var xpe = (e) => {
    var t
    return (
      tl.TRANSIENT_ERROR_CODES.includes(e.name) ||
      tl.NODEJS_TIMEOUT_ERROR_CODES.includes(e?.code || '') ||
      tl.TRANSIENT_ERROR_STATUS_CODES.includes(
        ((t = e.$metadata) === null || t === void 0
          ? void 0
          : t.httpStatusCode) || 0,
      )
    )
  }
  Pt.isTransientError = xpe
  var Ppe = (e) => {
    var t
    if (
      ((t = e.$metadata) === null || t === void 0
        ? void 0
        : t.httpStatusCode) !== void 0
    ) {
      let n = e.$metadata.httpStatusCode
      return 500 <= n && n <= 599 && !(0, Pt.isTransientError)(e)
    }
    return !1
  }
  Pt.isServerError = Ppe
})
var iw = l((Eh) => {
  'use strict'
  Object.defineProperty(Eh, '__esModule', { value: !0 })
  Eh.DefaultRateLimiter = void 0
  var Rpe = nl(),
    ow = class {
      constructor(t) {
        var n, r, s, o, i
        ;(this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = (n = t?.beta) !== null && n !== void 0 ? n : 0.7),
          (this.minCapacity =
            (r = t?.minCapacity) !== null && r !== void 0 ? r : 1),
          (this.minFillRate =
            (s = t?.minFillRate) !== null && s !== void 0 ? s : 0.5),
          (this.scaleConstant =
            (o = t?.scaleConstant) !== null && o !== void 0 ? o : 0.4),
          (this.smooth = (i = t?.smooth) !== null && i !== void 0 ? i : 0.8)
        let a = this.getCurrentTimeInSeconds()
        ;(this.lastThrottleTime = a),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity)
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3
      }
      async getSendToken() {
        return this.acquireTokenBucket(1)
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let n = ((t - this.currentCapacity) / this.fillRate) * 1e3
            await new Promise((r) => setTimeout(r, n))
          }
          this.currentCapacity = this.currentCapacity - t
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds()
        if (!this.lastTimestamp) {
          this.lastTimestamp = t
          return
        }
        let n = (t - this.lastTimestamp) * this.fillRate
        ;(this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + n,
        )),
          (this.lastTimestamp = t)
      }
      updateClientSendingRate(t) {
        let n
        if ((this.updateMeasuredRate(), (0, Rpe.isThrottlingError)(t))) {
          let s = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate
          ;(this.lastMaxRate = s),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (n = this.cubicThrottle(s)),
            this.enableTokenBucket()
        } else
          this.calculateTimeWindow(),
            (n = this.cubicSuccess(this.getCurrentTimeInSeconds()))
        let r = Math.min(n, 2 * this.measuredTxRate)
        this.updateTokenBucketRate(r)
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3,
          ),
        )
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta)
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate,
        )
      }
      enableTokenBucket() {
        this.enabled = !0
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity,
          ))
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          n = Math.floor(t * 2) / 2
        if ((this.requestCount++, n > this.lastTxRateBucket)) {
          let r = this.requestCount / (n - this.lastTxRateBucket)
          ;(this.measuredTxRate = this.getPrecise(
            r * this.smooth + this.measuredTxRate * (1 - this.smooth),
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = n)
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8))
      }
    }
  Eh.DefaultRateLimiter = ow
})
var sa = l((qe) => {
  'use strict'
  Object.defineProperty(qe, '__esModule', { value: !0 })
  qe.REQUEST_HEADER =
    qe.INVOCATION_ID_HEADER =
    qe.NO_RETRY_INCREMENT =
    qe.TIMEOUT_RETRY_COST =
    qe.RETRY_COST =
    qe.INITIAL_RETRY_TOKENS =
    qe.THROTTLING_RETRY_DELAY_BASE =
    qe.MAXIMUM_RETRY_DELAY =
    qe.DEFAULT_RETRY_DELAY_BASE =
      void 0
  qe.DEFAULT_RETRY_DELAY_BASE = 100
  qe.MAXIMUM_RETRY_DELAY = 20 * 1e3
  qe.THROTTLING_RETRY_DELAY_BASE = 500
  qe.INITIAL_RETRY_TOKENS = 500
  qe.RETRY_COST = 5
  qe.TIMEOUT_RETRY_COST = 10
  qe.NO_RETRY_INCREMENT = 1
  qe.INVOCATION_ID_HEADER = 'amz-sdk-invocation-id'
  qe.REQUEST_HEADER = 'amz-sdk-request'
})
var l$ = l((Sh) => {
  'use strict'
  Object.defineProperty(Sh, '__esModule', { value: !0 })
  Sh.getDefaultRetryBackoffStrategy = void 0
  var u$ = sa(),
    Dpe = () => {
      let e = u$.DEFAULT_RETRY_DELAY_BASE
      return {
        computeNextBackoffDelay: (r) =>
          Math.floor(
            Math.min(u$.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** r * e),
          ),
        setDelayBase: (r) => {
          e = r
        },
      }
    }
  Sh.getDefaultRetryBackoffStrategy = Dpe
})
var m$ = l((bh) => {
  'use strict'
  Object.defineProperty(bh, '__esModule', { value: !0 })
  bh.createDefaultRetryToken = void 0
  var Ape = sa(),
    Ope = ({ retryDelay: e, retryCount: t, retryCost: n }) => ({
      getRetryCount: () => t,
      getRetryDelay: () => Math.min(Ape.MAXIMUM_RETRY_DELAY, e),
      getRetryCost: () => n,
    })
  bh.createDefaultRetryToken = Ope
})
var Ch = l((vh) => {
  'use strict'
  Object.defineProperty(vh, '__esModule', { value: !0 })
  vh.StandardRetryStrategy = void 0
  var aw = yh(),
    ls = sa(),
    Npe = l$(),
    p$ = m$(),
    cw = class {
      constructor(t) {
        ;(this.maxAttempts = t),
          (this.mode = aw.RETRY_MODES.STANDARD),
          (this.capacity = ls.INITIAL_RETRY_TOKENS),
          (this.retryBackoffStrategy = (0,
          Npe.getDefaultRetryBackoffStrategy)()),
          (this.maxAttemptsProvider =
            typeof t == 'function' ? t : async () => t)
      }
      async acquireInitialRetryToken(t) {
        return (0, p$.createDefaultRetryToken)({
          retryDelay: ls.DEFAULT_RETRY_DELAY_BASE,
          retryCount: 0,
        })
      }
      async refreshRetryTokenForRetry(t, n) {
        let r = await this.getMaxAttempts()
        if (this.shouldRetry(t, n, r)) {
          let s = n.errorType
          this.retryBackoffStrategy.setDelayBase(
            s === 'THROTTLING'
              ? ls.THROTTLING_RETRY_DELAY_BASE
              : ls.DEFAULT_RETRY_DELAY_BASE,
          )
          let o = this.retryBackoffStrategy.computeNextBackoffDelay(
              t.getRetryCount(),
            ),
            i = n.retryAfterHint
              ? Math.max(n.retryAfterHint.getTime() - Date.now() || 0, o)
              : o,
            a = this.getCapacityCost(s)
          return (
            (this.capacity -= a),
            (0, p$.createDefaultRetryToken)({
              retryDelay: i,
              retryCount: t.getRetryCount() + 1,
              retryCost: a,
            })
          )
        }
        throw new Error('No retry token available')
      }
      recordSuccess(t) {
        var n
        this.capacity = Math.max(
          ls.INITIAL_RETRY_TOKENS,
          this.capacity +
            ((n = t.getRetryCost()) !== null && n !== void 0
              ? n
              : ls.NO_RETRY_INCREMENT),
        )
      }
      getCapacity() {
        return this.capacity
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider()
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${aw.DEFAULT_MAX_ATTEMPTS}`,
            ),
            aw.DEFAULT_MAX_ATTEMPTS
          )
        }
      }
      shouldRetry(t, n, r) {
        return (
          t.getRetryCount() + 1 < r &&
          this.capacity >= this.getCapacityCost(n.errorType) &&
          this.isRetryableError(n.errorType)
        )
      }
      getCapacityCost(t) {
        return t === 'TRANSIENT' ? ls.TIMEOUT_RETRY_COST : ls.RETRY_COST
      }
      isRetryableError(t) {
        return t === 'THROTTLING' || t === 'TRANSIENT'
      }
    }
  vh.StandardRetryStrategy = cw
})
var _$ = l((Th) => {
  'use strict'
  Object.defineProperty(Th, '__esModule', { value: !0 })
  Th.AdaptiveRetryStrategy = void 0
  var qpe = yh(),
    kpe = iw(),
    Mpe = Ch(),
    dw = class {
      constructor(t, n) {
        ;(this.maxAttemptsProvider = t), (this.mode = qpe.RETRY_MODES.ADAPTIVE)
        let { rateLimiter: r } = n ?? {}
        ;(this.rateLimiter = r ?? new kpe.DefaultRateLimiter()),
          (this.standardRetryStrategy = new Mpe.StandardRetryStrategy(t))
      }
      async acquireInitialRetryToken(t) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(t)
        )
      }
      async refreshRetryTokenForRetry(t, n) {
        return (
          this.rateLimiter.updateClientSendingRate(n),
          this.standardRetryStrategy.refreshRetryTokenForRetry(t, n)
        )
      }
      recordSuccess(t) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(t)
      }
    }
  Th.AdaptiveRetryStrategy = dw
})
var f$ = l((wh) => {
  'use strict'
  Object.defineProperty(wh, '__esModule', { value: !0 })
  wh.ConfiguredRetryStrategy = void 0
  var Lpe = sa(),
    Upe = Ch(),
    uw = class extends Upe.StandardRetryStrategy {
      constructor(t, n = Lpe.DEFAULT_RETRY_DELAY_BASE) {
        super(typeof t == 'function' ? t : async () => t),
          typeof n == 'number'
            ? (this.computeNextBackoffDelay = () => n)
            : (this.computeNextBackoffDelay = n)
      }
      async refreshRetryTokenForRetry(t, n) {
        let r = await super.refreshRetryTokenForRetry(t, n)
        return (
          (r.getRetryDelay = () =>
            this.computeNextBackoffDelay(r.getRetryCount())),
          r
        )
      }
    }
  wh.ConfiguredRetryStrategy = uw
})
var g$ = l((h$) => {
  'use strict'
  Object.defineProperty(h$, '__esModule', { value: !0 })
})
var Qt = l((Tr) => {
  'use strict'
  Object.defineProperty(Tr, '__esModule', { value: !0 })
  var Bo = (x(), w(I))
  Bo.__exportStar(_$(), Tr)
  Bo.__exportStar(f$(), Tr)
  Bo.__exportStar(iw(), Tr)
  Bo.__exportStar(Ch(), Tr)
  Bo.__exportStar(yh(), Tr)
  Bo.__exportStar(sa(), Tr)
  Bo.__exportStar(g$(), Tr)
})
function rl() {
  return (
    Ih > xh.length - 16 && (y$.default.randomFillSync(xh), (Ih = 0)),
    xh.slice(Ih, (Ih += 16))
  )
}
var y$,
  xh,
  Ih,
  lw = ue(() => {
    ;(y$ = sn(require('crypto'))), (xh = new Uint8Array(256)), (Ih = xh.length)
  })
var E$,
  S$ = ue(() => {
    E$ =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  })
function Fpe(e) {
  return typeof e == 'string' && E$.test(e)
}
var ms,
  sl = ue(() => {
    S$()
    ms = Fpe
  })
function Bpe(e, t = 0) {
  let n = (
    Je[e[t + 0]] +
    Je[e[t + 1]] +
    Je[e[t + 2]] +
    Je[e[t + 3]] +
    '-' +
    Je[e[t + 4]] +
    Je[e[t + 5]] +
    '-' +
    Je[e[t + 6]] +
    Je[e[t + 7]] +
    '-' +
    Je[e[t + 8]] +
    Je[e[t + 9]] +
    '-' +
    Je[e[t + 10]] +
    Je[e[t + 11]] +
    Je[e[t + 12]] +
    Je[e[t + 13]] +
    Je[e[t + 14]] +
    Je[e[t + 15]]
  ).toLowerCase()
  if (!ms(n)) throw TypeError('Stringified UUID is invalid')
  return n
}
var Je,
  ps,
  ol = ue(() => {
    sl()
    Je = []
    for (let e = 0; e < 256; ++e) Je.push((e + 256).toString(16).substr(1))
    ps = Bpe
  })
function jpe(e, t, n) {
  let r = (t && n) || 0,
    s = t || new Array(16)
  e = e || {}
  let o = e.node || b$,
    i = e.clockseq !== void 0 ? e.clockseq : mw
  if (o == null || i == null) {
    let _ = e.random || (e.rng || rl)()
    o == null && (o = b$ = [_[0] | 1, _[1], _[2], _[3], _[4], _[5]]),
      i == null && (i = mw = ((_[6] << 8) | _[7]) & 16383)
  }
  let a = e.msecs !== void 0 ? e.msecs : Date.now(),
    c = e.nsecs !== void 0 ? e.nsecs : _w + 1,
    u = a - pw + (c - _w) / 1e4
  if (
    (u < 0 && e.clockseq === void 0 && (i = (i + 1) & 16383),
    (u < 0 || a > pw) && e.nsecs === void 0 && (c = 0),
    c >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
  ;(pw = a), (_w = c), (mw = i), (a += 122192928e5)
  let d = ((a & 268435455) * 1e4 + c) % 4294967296
  ;(s[r++] = (d >>> 24) & 255),
    (s[r++] = (d >>> 16) & 255),
    (s[r++] = (d >>> 8) & 255),
    (s[r++] = d & 255)
  let p = ((a / 4294967296) * 1e4) & 268435455
  ;(s[r++] = (p >>> 8) & 255),
    (s[r++] = p & 255),
    (s[r++] = ((p >>> 24) & 15) | 16),
    (s[r++] = (p >>> 16) & 255),
    (s[r++] = (i >>> 8) | 128),
    (s[r++] = i & 255)
  for (let _ = 0; _ < 6; ++_) s[r + _] = o[_]
  return t || ps(s)
}
var b$,
  mw,
  pw,
  _w,
  v$,
  C$ = ue(() => {
    lw()
    ol()
    ;(pw = 0), (_w = 0)
    v$ = jpe
  })
function Gpe(e) {
  if (!ms(e)) throw TypeError('Invalid UUID')
  let t,
    n = new Uint8Array(16)
  return (
    (n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (n[1] = (t >>> 16) & 255),
    (n[2] = (t >>> 8) & 255),
    (n[3] = t & 255),
    (n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (n[5] = t & 255),
    (n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (n[7] = t & 255),
    (n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (n[9] = t & 255),
    (n[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (n[11] = (t / 4294967296) & 255),
    (n[12] = (t >>> 24) & 255),
    (n[13] = (t >>> 16) & 255),
    (n[14] = (t >>> 8) & 255),
    (n[15] = t & 255),
    n
  )
}
var Ph,
  fw = ue(() => {
    sl()
    Ph = Gpe
  })
function $pe(e) {
  e = unescape(encodeURIComponent(e))
  let t = []
  for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n))
  return t
}
function Rh(e, t, n) {
  function r(s, o, i, a) {
    if (
      (typeof s == 'string' && (s = $pe(s)),
      typeof o == 'string' && (o = Ph(o)),
      o.length !== 16)
    )
      throw TypeError(
        'Namespace must be array-like (16 iterable integer values, 0-255)',
      )
    let c = new Uint8Array(16 + s.length)
    if (
      (c.set(o),
      c.set(s, o.length),
      (c = n(c)),
      (c[6] = (c[6] & 15) | t),
      (c[8] = (c[8] & 63) | 128),
      i)
    ) {
      a = a || 0
      for (let u = 0; u < 16; ++u) i[a + u] = c[u]
      return i
    }
    return ps(c)
  }
  try {
    r.name = e
  } catch {}
  return (r.DNS = zpe), (r.URL = Hpe), r
}
var zpe,
  Hpe,
  hw = ue(() => {
    ol()
    fw()
    ;(zpe = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'),
      (Hpe = '6ba7b811-9dad-11d1-80b4-00c04fd430c8')
  })
function Vpe(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    T$.default.createHash('md5').update(e).digest()
  )
}
var T$,
  w$,
  I$ = ue(() => {
    T$ = sn(require('crypto'))
    w$ = Vpe
  })
var Ype,
  x$,
  P$ = ue(() => {
    hw()
    I$()
    ;(Ype = Rh('v3', 48, w$)), (x$ = Ype)
  })
function Wpe(e, t, n) {
  e = e || {}
  let r = e.random || (e.rng || rl)()
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    n = n || 0
    for (let s = 0; s < 16; ++s) t[n + s] = r[s]
    return t
  }
  return ps(r)
}
var R$,
  D$ = ue(() => {
    lw()
    ol()
    R$ = Wpe
  })
function Kpe(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    A$.default.createHash('sha1').update(e).digest()
  )
}
var A$,
  O$,
  N$ = ue(() => {
    A$ = sn(require('crypto'))
    O$ = Kpe
  })
var Xpe,
  q$,
  k$ = ue(() => {
    hw()
    N$()
    ;(Xpe = Rh('v5', 80, O$)), (q$ = Xpe)
  })
var M$,
  L$ = ue(() => {
    M$ = '00000000-0000-0000-0000-000000000000'
  })
function Jpe(e) {
  if (!ms(e)) throw TypeError('Invalid UUID')
  return parseInt(e.substr(14, 1), 16)
}
var U$,
  F$ = ue(() => {
    sl()
    U$ = Jpe
  })
var gw = {}
fd(gw, {
  NIL: () => M$,
  parse: () => Ph,
  stringify: () => ps,
  v1: () => v$,
  v3: () => x$,
  v4: () => R$,
  v5: () => q$,
  validate: () => ms,
  version: () => U$,
})
var yw = ue(() => {
  C$()
  P$()
  D$()
  k$()
  L$()
  F$()
  sl()
  ol()
  fw()
})
var B$ = l((Dh) => {
  'use strict'
  Object.defineProperty(Dh, '__esModule', { value: !0 })
  Dh.getDefaultRetryQuota = void 0
  var Ew = Qt(),
    Qpe = (e, t) => {
      var n, r, s
      let o = e,
        i =
          (n = t?.noRetryIncrement) !== null && n !== void 0
            ? n
            : Ew.NO_RETRY_INCREMENT,
        a = (r = t?.retryCost) !== null && r !== void 0 ? r : Ew.RETRY_COST,
        c =
          (s = t?.timeoutRetryCost) !== null && s !== void 0
            ? s
            : Ew.TIMEOUT_RETRY_COST,
        u = e,
        d = (h) => (h.name === 'TimeoutError' ? c : a),
        p = (h) => d(h) <= u
      return Object.freeze({
        hasRetryTokens: p,
        retrieveRetryTokens: (h) => {
          if (!p(h)) throw new Error('No retry token available')
          let y = d(h)
          return (u -= y), y
        },
        releaseRetryTokens: (h) => {
          ;(u += h ?? i), (u = Math.min(u, o))
        },
      })
    }
  Dh.getDefaultRetryQuota = Qpe
})
var Sw = l((Ah) => {
  'use strict'
  Object.defineProperty(Ah, '__esModule', { value: !0 })
  Ah.defaultDelayDecider = void 0
  var Zpe = Qt(),
    e_e = (e, t) =>
      Math.floor(Math.min(Zpe.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** t * e))
  Ah.defaultDelayDecider = e_e
})
var bw = l((Nh) => {
  'use strict'
  Object.defineProperty(Nh, '__esModule', { value: !0 })
  Nh.defaultRetryDecider = void 0
  var Oh = nl(),
    t_e = (e) =>
      e
        ? (0, Oh.isRetryableByTrait)(e) ||
          (0, Oh.isClockSkewError)(e) ||
          (0, Oh.isThrottlingError)(e) ||
          (0, Oh.isTransientError)(e)
        : !1
  Nh.defaultRetryDecider = t_e
})
var vw = l((qh) => {
  'use strict'
  Object.defineProperty(qh, '__esModule', { value: !0 })
  qh.asSdkError = void 0
  var n_e = (e) =>
    e instanceof Error
      ? e
      : e instanceof Object
        ? Object.assign(new Error(), e)
        : typeof e == 'string'
          ? new Error(e)
          : new Error(`AWS SDK error wrapper for ${e}`)
  qh.asSdkError = n_e
})
var ww = l((kh) => {
  'use strict'
  Object.defineProperty(kh, '__esModule', { value: !0 })
  kh.StandardRetryStrategy = void 0
  var Cw = Oe(),
    r_e = nl(),
    jo = Qt(),
    s_e = (yw(), w(gw)),
    o_e = B$(),
    i_e = Sw(),
    a_e = bw(),
    c_e = vw(),
    Tw = class {
      constructor(t, n) {
        var r, s, o
        ;(this.maxAttemptsProvider = t),
          (this.mode = jo.RETRY_MODES.STANDARD),
          (this.retryDecider =
            (r = n?.retryDecider) !== null && r !== void 0
              ? r
              : a_e.defaultRetryDecider),
          (this.delayDecider =
            (s = n?.delayDecider) !== null && s !== void 0
              ? s
              : i_e.defaultDelayDecider),
          (this.retryQuota =
            (o = n?.retryQuota) !== null && o !== void 0
              ? o
              : (0, o_e.getDefaultRetryQuota)(jo.INITIAL_RETRY_TOKENS))
      }
      shouldRetry(t, n, r) {
        return (
          n < r && this.retryDecider(t) && this.retryQuota.hasRetryTokens(t)
        )
      }
      async getMaxAttempts() {
        let t
        try {
          t = await this.maxAttemptsProvider()
        } catch {
          t = jo.DEFAULT_MAX_ATTEMPTS
        }
        return t
      }
      async retry(t, n, r) {
        let s,
          o = 0,
          i = 0,
          a = await this.getMaxAttempts(),
          { request: c } = n
        for (
          Cw.HttpRequest.isInstance(c) &&
          (c.headers[jo.INVOCATION_ID_HEADER] = (0, s_e.v4)());
          ;

        )
          try {
            Cw.HttpRequest.isInstance(c) &&
              (c.headers[jo.REQUEST_HEADER] = `attempt=${o + 1}; max=${a}`),
              r?.beforeRequest && (await r.beforeRequest())
            let { response: u, output: d } = await t(n)
            return (
              r?.afterRequest && r.afterRequest(u),
              this.retryQuota.releaseRetryTokens(s),
              (d.$metadata.attempts = o + 1),
              (d.$metadata.totalRetryDelay = i),
              { response: u, output: d }
            )
          } catch (u) {
            let d = (0, c_e.asSdkError)(u)
            if ((o++, this.shouldRetry(d, o, a))) {
              s = this.retryQuota.retrieveRetryTokens(d)
              let p = this.delayDecider(
                  (0, r_e.isThrottlingError)(d)
                    ? jo.THROTTLING_RETRY_DELAY_BASE
                    : jo.DEFAULT_RETRY_DELAY_BASE,
                  o,
                ),
                _ = d_e(d.$response),
                f = Math.max(_ || 0, p)
              ;(i += f), await new Promise((h) => setTimeout(h, f))
              continue
            }
            throw (
              (d.$metadata || (d.$metadata = {}),
              (d.$metadata.attempts = o),
              (d.$metadata.totalRetryDelay = i),
              d)
            )
          }
      }
    }
  kh.StandardRetryStrategy = Tw
  var d_e = (e) => {
    if (!Cw.HttpResponse.isInstance(e)) return
    let t = Object.keys(e.headers).find(
      (o) => o.toLowerCase() === 'retry-after',
    )
    if (!t) return
    let n = e.headers[t],
      r = Number(n)
    return Number.isNaN(r) ? new Date(n).getTime() - Date.now() : r * 1e3
  }
})
var G$ = l((Mh) => {
  'use strict'
  Object.defineProperty(Mh, '__esModule', { value: !0 })
  Mh.AdaptiveRetryStrategy = void 0
  var j$ = Qt(),
    u_e = ww(),
    Iw = class extends u_e.StandardRetryStrategy {
      constructor(t, n) {
        let { rateLimiter: r, ...s } = n ?? {}
        super(t, s),
          (this.rateLimiter = r ?? new j$.DefaultRateLimiter()),
          (this.mode = j$.RETRY_MODES.ADAPTIVE)
      }
      async retry(t, n) {
        return super.retry(t, n, {
          beforeRequest: async () => this.rateLimiter.getSendToken(),
          afterRequest: (r) => {
            this.rateLimiter.updateClientSendingRate(r)
          },
        })
      }
    }
  Mh.AdaptiveRetryStrategy = Iw
})
var z$ = l((Re) => {
  'use strict'
  Object.defineProperty(Re, '__esModule', { value: !0 })
  Re.NODE_RETRY_MODE_CONFIG_OPTIONS =
    Re.CONFIG_RETRY_MODE =
    Re.ENV_RETRY_MODE =
    Re.resolveRetryConfig =
    Re.NODE_MAX_ATTEMPT_CONFIG_OPTIONS =
    Re.CONFIG_MAX_ATTEMPTS =
    Re.ENV_MAX_ATTEMPTS =
      void 0
  var $$ = xo(),
    oa = Qt()
  Re.ENV_MAX_ATTEMPTS = 'AWS_MAX_ATTEMPTS'
  Re.CONFIG_MAX_ATTEMPTS = 'max_attempts'
  Re.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => {
      let t = e[Re.ENV_MAX_ATTEMPTS]
      if (!t) return
      let n = parseInt(t)
      if (Number.isNaN(n))
        throw new Error(
          `Environment variable ${Re.ENV_MAX_ATTEMPTS} mast be a number, got "${t}"`,
        )
      return n
    },
    configFileSelector: (e) => {
      let t = e[Re.CONFIG_MAX_ATTEMPTS]
      if (!t) return
      let n = parseInt(t)
      if (Number.isNaN(n))
        throw new Error(
          `Shared config file entry ${Re.CONFIG_MAX_ATTEMPTS} mast be a number, got "${t}"`,
        )
      return n
    },
    default: oa.DEFAULT_MAX_ATTEMPTS,
  }
  var l_e = (e) => {
    var t
    let { retryStrategy: n } = e,
      r = (0, $$.normalizeProvider)(
        (t = e.maxAttempts) !== null && t !== void 0
          ? t
          : oa.DEFAULT_MAX_ATTEMPTS,
      )
    return {
      ...e,
      maxAttempts: r,
      retryStrategy: async () =>
        n ||
        ((await (0, $$.normalizeProvider)(e.retryMode)()) ===
        oa.RETRY_MODES.ADAPTIVE
          ? new oa.AdaptiveRetryStrategy(r)
          : new oa.StandardRetryStrategy(r)),
    }
  }
  Re.resolveRetryConfig = l_e
  Re.ENV_RETRY_MODE = 'AWS_RETRY_MODE'
  Re.CONFIG_RETRY_MODE = 'retry_mode'
  Re.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Re.ENV_RETRY_MODE],
    configFileSelector: (e) => e[Re.CONFIG_RETRY_MODE],
    default: oa.DEFAULT_RETRY_MODE,
  }
})
var V$ = l((zn) => {
  'use strict'
  Object.defineProperty(zn, '__esModule', { value: !0 })
  zn.getOmitRetryHeadersPlugin =
    zn.omitRetryHeadersMiddlewareOptions =
    zn.omitRetryHeadersMiddleware =
      void 0
  var m_e = Oe(),
    H$ = Qt(),
    p_e = () => (e) => async (t) => {
      let { request: n } = t
      return (
        m_e.HttpRequest.isInstance(n) &&
          (delete n.headers[H$.INVOCATION_ID_HEADER],
          delete n.headers[H$.REQUEST_HEADER]),
        e(t)
      )
    }
  zn.omitRetryHeadersMiddleware = p_e
  zn.omitRetryHeadersMiddlewareOptions = {
    name: 'omitRetryHeadersMiddleware',
    tags: ['RETRY', 'HEADERS', 'OMIT_RETRY_HEADERS'],
    relation: 'before',
    toMiddleware: 'awsAuthMiddleware',
    override: !0,
  }
  var __e = (e) => ({
    applyToStack: (t) => {
      t.addRelativeTo(
        (0, zn.omitRetryHeadersMiddleware)(),
        zn.omitRetryHeadersMiddlewareOptions,
      )
    },
  })
  zn.getOmitRetryHeadersPlugin = __e
})
var W$ = l((Rt) => {
  'use strict'
  Object.defineProperty(Rt, '__esModule', { value: !0 })
  Rt.getRetryAfterHint =
    Rt.getRetryPlugin =
    Rt.retryMiddlewareOptions =
    Rt.retryMiddleware =
      void 0
  var Pw = Oe(),
    xw = nl(),
    Y$ = Qt(),
    f_e = (yw(), w(gw)),
    h_e = vw(),
    g_e = (e) => (t, n) => async (r) => {
      let s = await e.retryStrategy(),
        o = await e.maxAttempts()
      if (y_e(s)) {
        s = s
        let i = await s.acquireInitialRetryToken(n.partition_id),
          a = new Error(),
          c = 0,
          u = 0,
          { request: d } = r
        for (
          Pw.HttpRequest.isInstance(d) &&
          (d.headers[Y$.INVOCATION_ID_HEADER] = (0, f_e.v4)());
          ;

        )
          try {
            Pw.HttpRequest.isInstance(d) &&
              (d.headers[Y$.REQUEST_HEADER] = `attempt=${c + 1}; max=${o}`)
            let { response: p, output: _ } = await t(r)
            return (
              s.recordSuccess(i),
              (_.$metadata.attempts = c + 1),
              (_.$metadata.totalRetryDelay = u),
              { response: p, output: _ }
            )
          } catch (p) {
            let _ = E_e(p)
            a = (0, h_e.asSdkError)(p)
            try {
              i = await s.refreshRetryTokenForRetry(i, _)
            } catch {
              throw (
                (a.$metadata || (a.$metadata = {}),
                (a.$metadata.attempts = c + 1),
                (a.$metadata.totalRetryDelay = u),
                a)
              )
            }
            c = i.getRetryCount()
            let f = i.getRetryDelay()
            ;(u += f), await new Promise((h) => setTimeout(h, f))
          }
      } else
        return (
          (s = s),
          s?.mode &&
            (n.userAgent = [
              ...(n.userAgent || []),
              ['cfg/retry-mode', s.mode],
            ]),
          s.retry(t, r)
        )
    }
  Rt.retryMiddleware = g_e
  var y_e = (e) =>
      typeof e.acquireInitialRetryToken < 'u' &&
      typeof e.refreshRetryTokenForRetry < 'u' &&
      typeof e.recordSuccess < 'u',
    E_e = (e) => {
      let t = { errorType: S_e(e) },
        n = (0, Rt.getRetryAfterHint)(e.$response)
      return n && (t.retryAfterHint = n), t
    },
    S_e = (e) =>
      (0, xw.isThrottlingError)(e)
        ? 'THROTTLING'
        : (0, xw.isTransientError)(e)
          ? 'TRANSIENT'
          : (0, xw.isServerError)(e)
            ? 'SERVER_ERROR'
            : 'CLIENT_ERROR'
  Rt.retryMiddlewareOptions = {
    name: 'retryMiddleware',
    tags: ['RETRY'],
    step: 'finalizeRequest',
    priority: 'high',
    override: !0,
  }
  var b_e = (e) => ({
    applyToStack: (t) => {
      t.add((0, Rt.retryMiddleware)(e), Rt.retryMiddlewareOptions)
    },
  })
  Rt.getRetryPlugin = b_e
  var v_e = (e) => {
    if (!Pw.HttpResponse.isInstance(e)) return
    let t = Object.keys(e.headers).find(
      (o) => o.toLowerCase() === 'retry-after',
    )
    if (!t) return
    let n = e.headers[t],
      r = Number(n)
    return Number.isNaN(r) ? new Date(n) : new Date(r * 1e3)
  }
  Rt.getRetryAfterHint = v_e
})
var Ir = l((wr) => {
  'use strict'
  Object.defineProperty(wr, '__esModule', { value: !0 })
  var Go = (x(), w(I))
  Go.__exportStar(G$(), wr)
  Go.__exportStar(ww(), wr)
  Go.__exportStar(z$(), wr)
  Go.__exportStar(Sw(), wr)
  Go.__exportStar(V$(), wr)
  Go.__exportStar(bw(), wr)
  Go.__exportStar(W$(), wr)
})
var K$ = l((Lh) => {
  'use strict'
  Object.defineProperty(Lh, '__esModule', { value: !0 })
  Lh.NoOpLogger = void 0
  var Rw = class {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  }
  Lh.NoOpLogger = Rw
})
var Q$ = l((ia) => {
  'use strict'
  Object.defineProperty(ia, '__esModule', { value: !0 })
  ia.constructStack = void 0
  var $o = (e, t) => {
      let n = []
      if ((e && n.push(e), t)) for (let r of t) n.push(r)
      return n
    },
    _s = (e, t) =>
      `${e || 'anonymous'}${
        t && t.length > 0 ? ` (a.k.a. ${t.join(',')})` : ''
      }`,
    C_e = () => {
      let e = [],
        t = [],
        n = !1,
        r = new Set(),
        s = (p) =>
          p.sort(
            (_, f) =>
              X$[f.step] - X$[_.step] ||
              J$[f.priority || 'normal'] - J$[_.priority || 'normal'],
          ),
        o = (p) => {
          let _ = !1,
            f = (h) => {
              let y = $o(h.name, h.aliases)
              if (y.includes(p)) {
                _ = !0
                for (let E of y) r.delete(E)
                return !1
              }
              return !0
            }
          return (e = e.filter(f)), (t = t.filter(f)), _
        },
        i = (p) => {
          let _ = !1,
            f = (h) => {
              if (h.middleware === p) {
                _ = !0
                for (let y of $o(h.name, h.aliases)) r.delete(y)
                return !1
              }
              return !0
            }
          return (e = e.filter(f)), (t = t.filter(f)), _
        },
        a = (p) => {
          var _
          return (
            e.forEach((f) => {
              p.add(f.middleware, { ...f })
            }),
            t.forEach((f) => {
              p.addRelativeTo(f.middleware, { ...f })
            }),
            (_ = p.identifyOnResolve) === null ||
              _ === void 0 ||
              _.call(p, d.identifyOnResolve()),
            p
          )
        },
        c = (p) => {
          let _ = []
          return (
            p.before.forEach((f) => {
              f.before.length === 0 && f.after.length === 0
                ? _.push(f)
                : _.push(...c(f))
            }),
            _.push(p),
            p.after.reverse().forEach((f) => {
              f.before.length === 0 && f.after.length === 0
                ? _.push(f)
                : _.push(...c(f))
            }),
            _
          )
        },
        u = (p = !1) => {
          let _ = [],
            f = [],
            h = {}
          return (
            e.forEach((E) => {
              let C = { ...E, before: [], after: [] }
              for (let A of $o(C.name, C.aliases)) h[A] = C
              _.push(C)
            }),
            t.forEach((E) => {
              let C = { ...E, before: [], after: [] }
              for (let A of $o(C.name, C.aliases)) h[A] = C
              f.push(C)
            }),
            f.forEach((E) => {
              if (E.toMiddleware) {
                let C = h[E.toMiddleware]
                if (C === void 0) {
                  if (p) return
                  throw new Error(
                    `${E.toMiddleware} is not found when adding ${_s(
                      E.name,
                      E.aliases,
                    )} middleware ${E.relation} ${E.toMiddleware}`,
                  )
                }
                E.relation === 'after' && C.after.push(E),
                  E.relation === 'before' && C.before.push(E)
              }
            }),
            s(_)
              .map(c)
              .reduce((E, C) => (E.push(...C), E), [])
          )
        },
        d = {
          add: (p, _ = {}) => {
            let { name: f, override: h, aliases: y } = _,
              E = {
                step: 'initialize',
                priority: 'normal',
                middleware: p,
                ..._,
              },
              C = $o(f, y)
            if (C.length > 0) {
              if (C.some((A) => r.has(A))) {
                if (!h)
                  throw new Error(`Duplicate middleware name '${_s(f, y)}'`)
                for (let A of C) {
                  let se = e.findIndex((be) => {
                    var ee
                    return (
                      be.name === A ||
                      ((ee = be.aliases) === null || ee === void 0
                        ? void 0
                        : ee.some((Ae) => Ae === A))
                    )
                  })
                  if (se === -1) continue
                  let Q = e[se]
                  if (Q.step !== E.step || E.priority !== Q.priority)
                    throw new Error(
                      `"${_s(Q.name, Q.aliases)}" middleware with ${
                        Q.priority
                      } priority in ${
                        Q.step
                      } step cannot be overridden by "${_s(
                        f,
                        y,
                      )}" middleware with ${E.priority} priority in ${
                        E.step
                      } step.`,
                    )
                  e.splice(se, 1)
                }
              }
              for (let A of C) r.add(A)
            }
            e.push(E)
          },
          addRelativeTo: (p, _) => {
            let { name: f, override: h, aliases: y } = _,
              E = { middleware: p, ..._ },
              C = $o(f, y)
            if (C.length > 0) {
              if (C.some((A) => r.has(A))) {
                if (!h)
                  throw new Error(`Duplicate middleware name '${_s(f, y)}'`)
                for (let A of C) {
                  let se = t.findIndex((be) => {
                    var ee
                    return (
                      be.name === A ||
                      ((ee = be.aliases) === null || ee === void 0
                        ? void 0
                        : ee.some((Ae) => Ae === A))
                    )
                  })
                  if (se === -1) continue
                  let Q = t[se]
                  if (
                    Q.toMiddleware !== E.toMiddleware ||
                    Q.relation !== E.relation
                  )
                    throw new Error(
                      `"${_s(Q.name, Q.aliases)}" middleware ${Q.relation} "${
                        Q.toMiddleware
                      }" middleware cannot be overridden by "${_s(
                        f,
                        y,
                      )}" middleware ${E.relation} "${
                        E.toMiddleware
                      }" middleware.`,
                    )
                  t.splice(se, 1)
                }
              }
              for (let A of C) r.add(A)
            }
            t.push(E)
          },
          clone: () => a((0, ia.constructStack)()),
          use: (p) => {
            p.applyToStack(d)
          },
          remove: (p) => (typeof p == 'string' ? o(p) : i(p)),
          removeByTag: (p) => {
            let _ = !1,
              f = (h) => {
                let { tags: y, name: E, aliases: C } = h
                if (y && y.includes(p)) {
                  let A = $o(E, C)
                  for (let se of A) r.delete(se)
                  return (_ = !0), !1
                }
                return !0
              }
            return (e = e.filter(f)), (t = t.filter(f)), _
          },
          concat: (p) => {
            var _, f
            let h = a((0, ia.constructStack)())
            return (
              h.use(p),
              h.identifyOnResolve(
                n ||
                  h.identifyOnResolve() ||
                  ((f =
                    (_ = p.identifyOnResolve) === null || _ === void 0
                      ? void 0
                      : _.call(p)) !== null && f !== void 0
                    ? f
                    : !1),
              ),
              h
            )
          },
          applyToStack: a,
          identify: () =>
            u(!0).map((p) => {
              var _
              let f =
                (_ = p.step) !== null && _ !== void 0
                  ? _
                  : p.relation + ' ' + p.toMiddleware
              return _s(p.name, p.aliases) + ' - ' + f
            }),
          identifyOnResolve(p) {
            return typeof p == 'boolean' && (n = p), n
          },
          resolve: (p, _) => {
            for (let f of u()
              .map((h) => h.middleware)
              .reverse())
              p = f(p, _)
            return n && console.log(d.identify()), p
          },
        }
      return d
    }
  ia.constructStack = C_e
  var X$ = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1,
    },
    J$ = { high: 3, normal: 2, low: 1 }
})
var Aw = l((Dw) => {
  'use strict'
  Object.defineProperty(Dw, '__esModule', { value: !0 })
  var T_e = (x(), w(I))
  T_e.__exportStar(Q$(), Dw)
})
var Z$ = l((Uh) => {
  'use strict'
  Object.defineProperty(Uh, '__esModule', { value: !0 })
  Uh.Client = void 0
  var w_e = Aw(),
    Ow = class {
      constructor(t) {
        ;(this.middlewareStack = (0, w_e.constructStack)()), (this.config = t)
      }
      send(t, n, r) {
        let s = typeof n != 'function' ? n : void 0,
          o = typeof n == 'function' ? n : r,
          i = t.resolveMiddleware(this.middlewareStack, this.config, s)
        if (o)
          i(t)
            .then(
              (a) => o(null, a.output),
              (a) => o(a),
            )
            .catch(() => {})
        else return i(t).then((a) => a.output)
      }
      destroy() {
        this.config.requestHandler.destroy &&
          this.config.requestHandler.destroy()
      }
    }
  Uh.Client = Ow
})
var ez = l((Fh) => {
  'use strict'
  Object.defineProperty(Fh, '__esModule', { value: !0 })
  Fh.fromBase64 = void 0
  var I_e = Po(),
    x_e = /^[A-Za-z0-9+/]*={0,2}$/,
    P_e = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError('Incorrect padding on base64 string.')
      if (!x_e.exec(e)) throw new TypeError('Invalid base64 string.')
      let t = (0, I_e.fromString)(e, 'base64')
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    }
  Fh.fromBase64 = P_e
})
var tz = l((Bh) => {
  'use strict'
  Object.defineProperty(Bh, '__esModule', { value: !0 })
  Bh.toBase64 = void 0
  var R_e = Po(),
    D_e = (e) =>
      (0, R_e.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength).toString(
        'base64',
      )
  Bh.toBase64 = D_e
})
var aa = l((jh) => {
  'use strict'
  Object.defineProperty(jh, '__esModule', { value: !0 })
  var nz = (x(), w(I))
  nz.__exportStar(ez(), jh)
  nz.__exportStar(tz(), jh)
})
var iz = l((ca) => {
  'use strict'
  Object.defineProperty(ca, '__esModule', { value: !0 })
  ca.transformFromString = ca.transformToString = void 0
  var sz = aa(),
    oz = Ln(),
    rz = Nw()
  function A_e(e, t = 'utf-8') {
    return t === 'base64' ? (0, sz.toBase64)(e) : (0, oz.toUtf8)(e)
  }
  ca.transformToString = A_e
  function O_e(e, t) {
    return t === 'base64'
      ? rz.Uint8ArrayBlobAdapter.mutate((0, sz.fromBase64)(e))
      : rz.Uint8ArrayBlobAdapter.mutate((0, oz.fromUtf8)(e))
  }
  ca.transformFromString = O_e
})
var Nw = l((Gh) => {
  'use strict'
  Object.defineProperty(Gh, '__esModule', { value: !0 })
  Gh.Uint8ArrayBlobAdapter = void 0
  var az = iz(),
    qw = class e extends Uint8Array {
      static fromString(t, n = 'utf-8') {
        switch (typeof t) {
          case 'string':
            return (0, az.transformFromString)(t, n)
          default:
            throw new Error(
              `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
            )
        }
      }
      static mutate(t) {
        return Object.setPrototypeOf(t, e.prototype), t
      }
      transformToString(t = 'utf-8') {
        return (0, az.transformToString)(this, t)
      }
    }
  Gh.Uint8ArrayBlobAdapter = qw
})
var cz = l(($h) => {
  'use strict'
  Object.defineProperty($h, '__esModule', { value: !0 })
  $h.getAwsChunkedEncodingStream = void 0
  var N_e = require('stream'),
    q_e = (e, t) => {
      let {
          base64Encoder: n,
          bodyLengthChecker: r,
          checksumAlgorithmFn: s,
          checksumLocationName: o,
          streamHasher: i,
        } = t,
        a = n !== void 0 && s !== void 0 && o !== void 0 && i !== void 0,
        c = a ? i(s, e) : void 0,
        u = new N_e.Readable({ read: () => {} })
      return (
        e.on('data', (d) => {
          let p = r(d) || 0
          u.push(`${p.toString(16)}\r
`),
            u.push(d),
            u.push(`\r
`)
        }),
        e.on('end', async () => {
          if (
            (u.push(`0\r
`),
            a)
          ) {
            let d = n(await c)
            u.push(`${o}:${d}\r
`),
              u.push(`\r
`)
          }
          u.push(null)
        }),
        u
      )
    }
  $h.getAwsChunkedEncodingStream = q_e
})
var Mw = l((zh) => {
  'use strict'
  Object.defineProperty(zh, '__esModule', { value: !0 })
  zh.buildQueryString = void 0
  var kw = fT()
  function k_e(e) {
    let t = []
    for (let n of Object.keys(e).sort()) {
      let r = e[n]
      if (((n = (0, kw.escapeUri)(n)), Array.isArray(r)))
        for (let s = 0, o = r.length; s < o; s++)
          t.push(`${n}=${(0, kw.escapeUri)(r[s])}`)
      else {
        let s = n
        ;(r || typeof r == 'string') && (s += `=${(0, kw.escapeUri)(r)}`),
          t.push(s)
      }
    }
    return t.join('&')
  }
  zh.buildQueryString = k_e
})
var dz = l((Hh) => {
  'use strict'
  Object.defineProperty(Hh, '__esModule', { value: !0 })
  Hh.NODEJS_TIMEOUT_ERROR_CODES = void 0
  Hh.NODEJS_TIMEOUT_ERROR_CODES = ['ECONNRESET', 'EPIPE', 'ETIMEDOUT']
})
var Lw = l((Vh) => {
  'use strict'
  Object.defineProperty(Vh, '__esModule', { value: !0 })
  Vh.getTransformedHeaders = void 0
  var M_e = (e) => {
    let t = {}
    for (let n of Object.keys(e)) {
      let r = e[n]
      t[n] = Array.isArray(r) ? r.join(',') : r
    }
    return t
  }
  Vh.getTransformedHeaders = M_e
})
var uz = l((Yh) => {
  'use strict'
  Object.defineProperty(Yh, '__esModule', { value: !0 })
  Yh.setConnectionTimeout = void 0
  var L_e = (e, t, n = 0) => {
    if (!n) return
    let r = setTimeout(() => {
      e.destroy(),
        t(
          Object.assign(
            new Error(
              `Socket timed out without establishing a connection within ${n} ms`,
            ),
            { name: 'TimeoutError' },
          ),
        )
    }, n)
    e.on('socket', (s) => {
      s.connecting
        ? s.on('connect', () => {
            clearTimeout(r)
          })
        : clearTimeout(r)
    })
  }
  Yh.setConnectionTimeout = L_e
})
var lz = l((Wh) => {
  'use strict'
  Object.defineProperty(Wh, '__esModule', { value: !0 })
  Wh.setSocketKeepAlive = void 0
  var U_e = (e, { keepAlive: t, keepAliveMsecs: n }) => {
    t === !0 &&
      e.on('socket', (r) => {
        r.setKeepAlive(t, n || 0)
      })
  }
  Wh.setSocketKeepAlive = U_e
})
var mz = l((Kh) => {
  'use strict'
  Object.defineProperty(Kh, '__esModule', { value: !0 })
  Kh.setSocketTimeout = void 0
  var F_e = (e, t, n = 0) => {
    e.setTimeout(n, () => {
      e.destroy(),
        t(
          Object.assign(new Error(`Connection timed out after ${n} ms`), {
            name: 'TimeoutError',
          }),
        )
    })
  }
  Kh.setSocketTimeout = F_e
})
var Uw = l((Xh) => {
  'use strict'
  Object.defineProperty(Xh, '__esModule', { value: !0 })
  Xh.writeRequestBody = void 0
  var B_e = require('stream'),
    pz = 1e3
  async function j_e(e, t, n = pz) {
    var r
    let s = (r = t.headers) !== null && r !== void 0 ? r : {},
      o = s.Expect || s.expect,
      i = -1,
      a = !1
    o === '100-continue' &&
      (await Promise.race([
        new Promise((c) => {
          i = Number(setTimeout(c, Math.max(pz, n)))
        }),
        new Promise((c) => {
          e.on('continue', () => {
            clearTimeout(i), c()
          }),
            e.on('error', () => {
              ;(a = !0), clearTimeout(i), c()
            })
        }),
      ])),
      a || G_e(e, t.body)
  }
  Xh.writeRequestBody = j_e
  function G_e(e, t) {
    t instanceof B_e.Readable ? t.pipe(e) : t ? e.end(Buffer.from(t)) : e.end()
  }
})
var hz = l((da) => {
  'use strict'
  Object.defineProperty(da, '__esModule', { value: !0 })
  da.NodeHttpHandler = da.DEFAULT_REQUEST_TIMEOUT = void 0
  var $_e = Oe(),
    z_e = Mw(),
    _z = require('http'),
    fz = require('https'),
    H_e = dz(),
    V_e = Lw(),
    Y_e = uz(),
    W_e = lz(),
    K_e = mz(),
    X_e = Uw()
  da.DEFAULT_REQUEST_TIMEOUT = 0
  var Fw = class {
    constructor(t) {
      ;(this.metadata = { handlerProtocol: 'http/1.1' }),
        (this.configProvider = new Promise((n, r) => {
          typeof t == 'function'
            ? t()
                .then((s) => {
                  n(this.resolveDefaultConfig(s))
                })
                .catch(r)
            : n(this.resolveDefaultConfig(t))
        }))
    }
    resolveDefaultConfig(t) {
      let {
          requestTimeout: n,
          connectionTimeout: r,
          socketTimeout: s,
          httpAgent: o,
          httpsAgent: i,
        } = t || {},
        a = !0,
        c = 50
      return {
        connectionTimeout: r,
        requestTimeout: n ?? s,
        httpAgent: o || new _z.Agent({ keepAlive: a, maxSockets: c }),
        httpsAgent: i || new fz.Agent({ keepAlive: a, maxSockets: c }),
      }
    }
    destroy() {
      var t, n, r, s
      ;(n =
        (t = this.config) === null || t === void 0 ? void 0 : t.httpAgent) ===
        null ||
        n === void 0 ||
        n.destroy(),
        (s =
          (r = this.config) === null || r === void 0
            ? void 0
            : r.httpsAgent) === null ||
          s === void 0 ||
          s.destroy()
    }
    async handle(t, { abortSignal: n } = {}) {
      return (
        this.config || (this.config = await this.configProvider),
        new Promise((r, s) => {
          var o, i
          let a,
            c = async (A) => {
              await a, r(A)
            },
            u = async (A) => {
              await a, s(A)
            }
          if (!this.config)
            throw new Error('Node HTTP request handler config is not resolved')
          if (n?.aborted) {
            let A = new Error('Request aborted')
            ;(A.name = 'AbortError'), u(A)
            return
          }
          let d = t.protocol === 'https:',
            p = (0, z_e.buildQueryString)(t.query || {}),
            _
          if (t.username != null || t.password != null) {
            let A = (o = t.username) !== null && o !== void 0 ? o : '',
              se = (i = t.password) !== null && i !== void 0 ? i : ''
            _ = `${A}:${se}`
          }
          let f = t.path
          p && (f += `?${p}`), t.fragment && (f += `#${t.fragment}`)
          let h = {
              headers: t.headers,
              host: t.hostname,
              method: t.method,
              path: f,
              port: t.port,
              agent: d ? this.config.httpsAgent : this.config.httpAgent,
              auth: _,
            },
            E = (d ? fz.request : _z.request)(h, (A) => {
              let se = new $_e.HttpResponse({
                statusCode: A.statusCode || -1,
                reason: A.statusMessage,
                headers: (0, V_e.getTransformedHeaders)(A.headers),
                body: A,
              })
              c({ response: se })
            })
          E.on('error', (A) => {
            H_e.NODEJS_TIMEOUT_ERROR_CODES.includes(A.code)
              ? u(Object.assign(A, { name: 'TimeoutError' }))
              : u(A)
          }),
            (0, Y_e.setConnectionTimeout)(E, u, this.config.connectionTimeout),
            (0, K_e.setSocketTimeout)(E, u, this.config.requestTimeout),
            n &&
              (n.onabort = () => {
                E.abort()
                let A = new Error('Request aborted')
                ;(A.name = 'AbortError'), u(A)
              })
          let C = h.agent
          typeof C == 'object' &&
            'keepAlive' in C &&
            (0, W_e.setSocketKeepAlive)(E, {
              keepAlive: C.keepAlive,
              keepAliveMsecs: C.keepAliveMsecs,
            }),
            (a = (0, X_e.writeRequestBody)(
              E,
              t,
              this.config.requestTimeout,
            ).catch(s))
        })
      )
    }
    updateHttpClientConfig(t, n) {
      ;(this.config = void 0),
        (this.configProvider = this.configProvider.then((r) => ({
          ...r,
          [t]: n,
        })))
    }
    httpHandlerConfigs() {
      var t
      return (t = this.config) !== null && t !== void 0 ? t : {}
    }
  }
  da.NodeHttpHandler = Fw
})
var gz = l((Jh) => {
  'use strict'
  Object.defineProperty(Jh, '__esModule', { value: !0 })
  Jh.NodeHttp2ConnectionPool = void 0
  var Bw = class {
    constructor(t) {
      ;(this.sessions = []), (this.sessions = t ?? [])
    }
    poll() {
      if (this.sessions.length > 0) return this.sessions.shift()
    }
    offerLast(t) {
      this.sessions.push(t)
    }
    contains(t) {
      return this.sessions.includes(t)
    }
    remove(t) {
      this.sessions = this.sessions.filter((n) => n !== t)
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]()
    }
    destroy(t) {
      for (let n of this.sessions) n === t && (n.destroyed || n.destroy())
    }
  }
  Jh.NodeHttp2ConnectionPool = Bw
})
var yz = l((Qh) => {
  'use strict'
  Object.defineProperty(Qh, '__esModule', { value: !0 })
  Qh.NodeHttp2ConnectionManager = void 0
  var J_e = (x(), w(I)),
    Q_e = J_e.__importDefault(require('http2')),
    Z_e = gz(),
    jw = class {
      constructor(t) {
        if (
          ((this.sessionCache = new Map()),
          (this.config = t),
          this.config.maxConcurrency && this.config.maxConcurrency <= 0)
        )
          throw new RangeError('maxConcurrency must be greater than zero.')
      }
      lease(t, n) {
        let r = this.getUrlString(t),
          s = this.sessionCache.get(r)
        if (s) {
          let c = s.poll()
          if (c && !this.config.disableConcurrency) return c
        }
        let o = Q_e.default.connect(r)
        this.config.maxConcurrency &&
          o.settings(
            { maxConcurrentStreams: this.config.maxConcurrency },
            (c) => {
              if (c)
                throw new Error(
                  'Fail to set maxConcurrentStreams to ' +
                    this.config.maxConcurrency +
                    'when creating new session for ' +
                    t.destination.toString(),
                )
            },
          ),
          o.unref()
        let i = () => {
          o.destroy(), this.deleteSession(r, o)
        }
        o.on('goaway', i),
          o.on('error', i),
          o.on('frameError', i),
          o.on('close', () => this.deleteSession(r, o)),
          n.requestTimeout && o.setTimeout(n.requestTimeout, i)
        let a = this.sessionCache.get(r) || new Z_e.NodeHttp2ConnectionPool()
        return a.offerLast(o), this.sessionCache.set(r, a), o
      }
      deleteSession(t, n) {
        let r = this.sessionCache.get(t)
        r && r.contains(n) && (r.remove(n), this.sessionCache.set(t, r))
      }
      release(t, n) {
        var r
        let s = this.getUrlString(t)
        ;(r = this.sessionCache.get(s)) === null ||
          r === void 0 ||
          r.offerLast(n)
      }
      destroy() {
        for (let [t, n] of this.sessionCache) {
          for (let r of n) r.destroyed || r.destroy(), n.remove(r)
          this.sessionCache.delete(t)
        }
      }
      setMaxConcurrentStreams(t) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0)
          throw new RangeError(
            'maxConcurrentStreams must be greater than zero.',
          )
        this.config.maxConcurrency = t
      }
      setDisableConcurrentStreams(t) {
        this.config.disableConcurrency = t
      }
      getUrlString(t) {
        return t.destination.toString()
      }
    }
  Qh.NodeHttp2ConnectionManager = jw
})
var Sz = l((Zh) => {
  'use strict'
  Object.defineProperty(Zh, '__esModule', { value: !0 })
  Zh.NodeHttp2Handler = void 0
  var efe = Oe(),
    tfe = Mw(),
    Ez = require('http2'),
    nfe = Lw(),
    rfe = yz(),
    sfe = Uw(),
    Gw = class {
      constructor(t) {
        ;(this.metadata = { handlerProtocol: 'h2' }),
          (this.connectionManager = new rfe.NodeHttp2ConnectionManager({})),
          (this.configProvider = new Promise((n, r) => {
            typeof t == 'function'
              ? t()
                  .then((s) => {
                    n(s || {})
                  })
                  .catch(r)
              : n(t || {})
          }))
      }
      destroy() {
        this.connectionManager.destroy()
      }
      async handle(t, { abortSignal: n } = {}) {
        this.config ||
          ((this.config = await this.configProvider),
          this.connectionManager.setDisableConcurrentStreams(
            this.config.disableConcurrentStreams || !1,
          ),
          this.config.maxConcurrentStreams &&
            this.connectionManager.setMaxConcurrentStreams(
              this.config.maxConcurrentStreams,
            ))
        let { requestTimeout: r, disableConcurrentStreams: s } = this.config
        return new Promise((o, i) => {
          var a, c, u
          let d = !1,
            p,
            _ = async (Te) => {
              await p, o(Te)
            },
            f = async (Te) => {
              await p, i(Te)
            }
          if (n?.aborted) {
            d = !0
            let Te = new Error('Request aborted')
            ;(Te.name = 'AbortError'), f(Te)
            return
          }
          let { hostname: h, method: y, port: E, protocol: C, query: A } = t,
            se = ''
          if (t.username != null || t.password != null) {
            let Te = (a = t.username) !== null && a !== void 0 ? a : '',
              _d = (c = t.password) !== null && c !== void 0 ? c : ''
            se = `${Te}:${_d}@`
          }
          let Q = `${C}//${se}${h}${E ? `:${E}` : ''}`,
            be = { destination: new URL(Q) },
            ee = this.connectionManager.lease(be, {
              requestTimeout:
                (u = this.config) === null || u === void 0
                  ? void 0
                  : u.sessionTimeout,
              disableConcurrentStreams: s || !1,
            }),
            Ae = (Te) => {
              s && this.destroySession(ee), (d = !0), f(Te)
            },
            Et = (0, tfe.buildQueryString)(A || {}),
            Xs = t.path
          Et && (Xs += `?${Et}`), t.fragment && (Xs += `#${t.fragment}`)
          let St = ee.request({
            ...t.headers,
            [Ez.constants.HTTP2_HEADER_PATH]: Xs,
            [Ez.constants.HTTP2_HEADER_METHOD]: y,
          })
          ee.ref(),
            St.on('response', (Te) => {
              let _d = new efe.HttpResponse({
                statusCode: Te[':status'] || -1,
                headers: (0, nfe.getTransformedHeaders)(Te),
                body: St,
              })
              ;(d = !0),
                _({ response: _d }),
                s && (ee.close(), this.connectionManager.deleteSession(Q, ee))
            }),
            r &&
              St.setTimeout(r, () => {
                St.close()
                let Te = new Error(
                  `Stream timed out because of no activity for ${r} ms`,
                )
                ;(Te.name = 'TimeoutError'), Ae(Te)
              }),
            n &&
              (n.onabort = () => {
                St.close()
                let Te = new Error('Request aborted')
                ;(Te.name = 'AbortError'), Ae(Te)
              }),
            St.on('frameError', (Te, _d, g5) => {
              Ae(
                new Error(
                  `Frame type id ${Te} in stream id ${g5} has failed with code ${_d}.`,
                ),
              )
            }),
            St.on('error', Ae),
            St.on('aborted', () => {
              Ae(
                new Error(
                  `HTTP/2 stream is abnormally aborted in mid-communication with result code ${St.rstCode}.`,
                ),
              )
            }),
            St.on('close', () => {
              ee.unref(),
                s && ee.destroy(),
                d ||
                  Ae(
                    new Error(
                      'Unexpected error: http2 request did not get a response',
                    ),
                  )
            }),
            (p = (0, sfe.writeRequestBody)(St, t, r))
        })
      }
      updateHttpClientConfig(t, n) {
        ;(this.config = void 0),
          (this.configProvider = this.configProvider.then((r) => ({
            ...r,
            [t]: n,
          })))
      }
      httpHandlerConfigs() {
        var t
        return (t = this.config) !== null && t !== void 0 ? t : {}
      }
      destroySession(t) {
        t.destroyed || t.destroy()
      }
    }
  Zh.NodeHttp2Handler = Gw
})
var bz = l((eg) => {
  'use strict'
  Object.defineProperty(eg, '__esModule', { value: !0 })
  eg.Collector = void 0
  var ofe = require('stream'),
    $w = class extends ofe.Writable {
      constructor() {
        super(...arguments), (this.bufferedBytes = [])
      }
      _write(t, n, r) {
        this.bufferedBytes.push(t), r()
      }
    }
  eg.Collector = $w
})
var vz = l((tg) => {
  'use strict'
  Object.defineProperty(tg, '__esModule', { value: !0 })
  tg.streamCollector = void 0
  var ife = bz(),
    afe = (e) =>
      new Promise((t, n) => {
        let r = new ife.Collector()
        e.pipe(r),
          e.on('error', (s) => {
            r.end(), n(s)
          }),
          r.on('error', n),
          r.on('finish', function () {
            let s = new Uint8Array(Buffer.concat(this.bufferedBytes))
            t(s)
          })
      })
  tg.streamCollector = afe
})
var ua = l((il) => {
  'use strict'
  Object.defineProperty(il, '__esModule', { value: !0 })
  var zw = (x(), w(I))
  zw.__exportStar(hz(), il)
  zw.__exportStar(Sz(), il)
  zw.__exportStar(vz(), il)
})
var Tz = l((ng) => {
  'use strict'
  Object.defineProperty(ng, '__esModule', { value: !0 })
  ng.sdkStreamMixin = void 0
  var cfe = ua(),
    dfe = Po(),
    Hw = require('stream'),
    ufe = require('util'),
    Cz = 'The stream has already been transformed.',
    lfe = (e) => {
      var t, n
      if (!(e instanceof Hw.Readable)) {
        let o =
          ((n =
            (t = e?.__proto__) === null || t === void 0
              ? void 0
              : t.constructor) === null || n === void 0
            ? void 0
            : n.name) || e
        throw new Error(
          `Unexpected stream implementation, expect Stream.Readable instance, got ${o}`,
        )
      }
      let r = !1,
        s = async () => {
          if (r) throw new Error(Cz)
          return (r = !0), await (0, cfe.streamCollector)(e)
        }
      return Object.assign(e, {
        transformToByteArray: s,
        transformToString: async (o) => {
          let i = await s()
          return o === void 0 || Buffer.isEncoding(o)
            ? (0, dfe.fromArrayBuffer)(
                i.buffer,
                i.byteOffset,
                i.byteLength,
              ).toString(o)
            : new ufe.TextDecoder(o).decode(i)
        },
        transformToWebStream: () => {
          if (r) throw new Error(Cz)
          if (e.readableFlowing !== null)
            throw new Error('The stream has been consumed by other callbacks.')
          if (typeof Hw.Readable.toWeb != 'function')
            throw new Error(
              'Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.',
            )
          return (r = !0), Hw.Readable.toWeb(e)
        },
      })
    }
  ng.sdkStreamMixin = lfe
})
var wz = l((al) => {
  'use strict'
  Object.defineProperty(al, '__esModule', { value: !0 })
  var Vw = (x(), w(I))
  Vw.__exportStar(Nw(), al)
  Vw.__exportStar(cz(), al)
  Vw.__exportStar(Tz(), al)
})
var Iz = l((rg) => {
  'use strict'
  Object.defineProperty(rg, '__esModule', { value: !0 })
  rg.collectBody = void 0
  var Yw = wz(),
    mfe = async (e = new Uint8Array(), t) => {
      if (e instanceof Uint8Array) return Yw.Uint8ArrayBlobAdapter.mutate(e)
      if (!e) return Yw.Uint8ArrayBlobAdapter.mutate(new Uint8Array())
      let n = t.streamCollector(e)
      return Yw.Uint8ArrayBlobAdapter.mutate(await n)
    }
  rg.collectBody = mfe
})
var xz = l((sg) => {
  'use strict'
  Object.defineProperty(sg, '__esModule', { value: !0 })
  sg.Command = void 0
  var pfe = Aw(),
    Ww = class {
      constructor() {
        this.middlewareStack = (0, pfe.constructStack)()
      }
    }
  sg.Command = Ww
})
var Pz = l((og) => {
  'use strict'
  Object.defineProperty(og, '__esModule', { value: !0 })
  og.SENSITIVE_STRING = void 0
  og.SENSITIVE_STRING = '***SensitiveInformation***'
})
var Rz = l((ig) => {
  'use strict'
  Object.defineProperty(ig, '__esModule', { value: !0 })
  ig.createAggregatedClient = void 0
  var _fe = (e, t) => {
    for (let n of Object.keys(e)) {
      let r = e[n],
        s = async function (i, a, c) {
          let u = new r(i)
          if (typeof a == 'function') this.send(u, a)
          else if (typeof c == 'function') {
            if (typeof a != 'object')
              throw new Error(`Expected http options but got ${typeof a}`)
            this.send(u, a || {}, c)
          } else return this.send(u, a)
        },
        o = (n[0].toLowerCase() + n.slice(1)).replace(/Command$/, '')
      t.prototype[o] = s
    }
  }
  ig.createAggregatedClient = _fe
})
var Xw = l((R) => {
  'use strict'
  Object.defineProperty(R, '__esModule', { value: !0 })
  R.logger =
    R.strictParseByte =
    R.strictParseShort =
    R.strictParseInt32 =
    R.strictParseInt =
    R.strictParseLong =
    R.limitedParseFloat32 =
    R.limitedParseFloat =
    R.handleFloat =
    R.limitedParseDouble =
    R.strictParseFloat32 =
    R.strictParseFloat =
    R.strictParseDouble =
    R.expectUnion =
    R.expectString =
    R.expectObject =
    R.expectNonNull =
    R.expectByte =
    R.expectShort =
    R.expectInt32 =
    R.expectInt =
    R.expectLong =
    R.expectFloat32 =
    R.expectNumber =
    R.expectBoolean =
    R.parseBoolean =
      void 0
  var ffe = (e) => {
    switch (e) {
      case 'true':
        return !0
      case 'false':
        return !1
      default:
        throw new Error(`Unable to parse boolean value "${e}"`)
    }
  }
  R.parseBoolean = ffe
  var hfe = (e) => {
    if (e != null) {
      if (typeof e == 'number') {
        if (
          ((e === 0 || e === 1) &&
            R.logger.warn(ag(`Expected boolean, got ${typeof e}: ${e}`)),
          e === 0)
        )
          return !1
        if (e === 1) return !0
      }
      if (typeof e == 'string') {
        let t = e.toLowerCase()
        if (
          ((t === 'false' || t === 'true') &&
            R.logger.warn(ag(`Expected boolean, got ${typeof e}: ${e}`)),
          t === 'false')
        )
          return !1
        if (t === 'true') return !0
      }
      if (typeof e == 'boolean') return e
      throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`)
    }
  }
  R.expectBoolean = hfe
  var gfe = (e) => {
    if (e != null) {
      if (typeof e == 'string') {
        let t = parseFloat(e)
        if (!Number.isNaN(t))
          return (
            String(t) !== String(e) &&
              R.logger.warn(ag(`Expected number but observed string: ${e}`)),
            t
          )
      }
      if (typeof e == 'number') return e
      throw new TypeError(`Expected number, got ${typeof e}: ${e}`)
    }
  }
  R.expectNumber = gfe
  var yfe = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
    Efe = (e) => {
      let t = (0, R.expectNumber)(e)
      if (
        t !== void 0 &&
        !Number.isNaN(t) &&
        t !== 1 / 0 &&
        t !== -1 / 0 &&
        Math.abs(t) > yfe
      )
        throw new TypeError(`Expected 32-bit float, got ${e}`)
      return t
    }
  R.expectFloat32 = Efe
  var Sfe = (e) => {
    if (e != null) {
      if (Number.isInteger(e) && !Number.isNaN(e)) return e
      throw new TypeError(`Expected integer, got ${typeof e}: ${e}`)
    }
  }
  R.expectLong = Sfe
  R.expectInt = R.expectLong
  var bfe = (e) => Kw(e, 32)
  R.expectInt32 = bfe
  var vfe = (e) => Kw(e, 16)
  R.expectShort = vfe
  var Cfe = (e) => Kw(e, 8)
  R.expectByte = Cfe
  var Kw = (e, t) => {
      let n = (0, R.expectLong)(e)
      if (n !== void 0 && Tfe(n, t) !== n)
        throw new TypeError(`Expected ${t}-bit integer, got ${e}`)
      return n
    },
    Tfe = (e, t) => {
      switch (t) {
        case 32:
          return Int32Array.of(e)[0]
        case 16:
          return Int16Array.of(e)[0]
        case 8:
          return Int8Array.of(e)[0]
      }
    },
    wfe = (e, t) => {
      if (e == null)
        throw t
          ? new TypeError(`Expected a non-null value for ${t}`)
          : new TypeError('Expected a non-null value')
      return e
    }
  R.expectNonNull = wfe
  var Ife = (e) => {
    if (e == null) return
    if (typeof e == 'object' && !Array.isArray(e)) return e
    let t = Array.isArray(e) ? 'array' : typeof e
    throw new TypeError(`Expected object, got ${t}: ${e}`)
  }
  R.expectObject = Ife
  var xfe = (e) => {
    if (e != null) {
      if (typeof e == 'string') return e
      if (['boolean', 'number', 'bigint'].includes(typeof e))
        return (
          R.logger.warn(ag(`Expected string, got ${typeof e}: ${e}`)), String(e)
        )
      throw new TypeError(`Expected string, got ${typeof e}: ${e}`)
    }
  }
  R.expectString = xfe
  var Pfe = (e) => {
    if (e == null) return
    let t = (0, R.expectObject)(e),
      n = Object.entries(t)
        .filter(([, r]) => r != null)
        .map(([r]) => r)
    if (n.length === 0)
      throw new TypeError(
        'Unions must have exactly one non-null member. None were found.',
      )
    if (n.length > 1)
      throw new TypeError(
        `Unions must have exactly one non-null member. Keys ${n} were not null.`,
      )
    return t
  }
  R.expectUnion = Pfe
  var Rfe = (e) =>
    typeof e == 'string' ? (0, R.expectNumber)(la(e)) : (0, R.expectNumber)(e)
  R.strictParseDouble = Rfe
  R.strictParseFloat = R.strictParseDouble
  var Dfe = (e) =>
    typeof e == 'string' ? (0, R.expectFloat32)(la(e)) : (0, R.expectFloat32)(e)
  R.strictParseFloat32 = Dfe
  var Afe = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    la = (e) => {
      let t = e.match(Afe)
      if (t === null || t[0].length !== e.length)
        throw new TypeError('Expected real number, got implicit NaN')
      return parseFloat(e)
    },
    Ofe = (e) => (typeof e == 'string' ? Dz(e) : (0, R.expectNumber)(e))
  R.limitedParseDouble = Ofe
  R.handleFloat = R.limitedParseDouble
  R.limitedParseFloat = R.limitedParseDouble
  var Nfe = (e) => (typeof e == 'string' ? Dz(e) : (0, R.expectFloat32)(e))
  R.limitedParseFloat32 = Nfe
  var Dz = (e) => {
      switch (e) {
        case 'NaN':
          return NaN
        case 'Infinity':
          return 1 / 0
        case '-Infinity':
          return -1 / 0
        default:
          throw new Error(`Unable to parse float value: ${e}`)
      }
    },
    qfe = (e) =>
      typeof e == 'string' ? (0, R.expectLong)(la(e)) : (0, R.expectLong)(e)
  R.strictParseLong = qfe
  R.strictParseInt = R.strictParseLong
  var kfe = (e) =>
    typeof e == 'string' ? (0, R.expectInt32)(la(e)) : (0, R.expectInt32)(e)
  R.strictParseInt32 = kfe
  var Mfe = (e) =>
    typeof e == 'string' ? (0, R.expectShort)(la(e)) : (0, R.expectShort)(e)
  R.strictParseShort = Mfe
  var Lfe = (e) =>
    typeof e == 'string' ? (0, R.expectByte)(la(e)) : (0, R.expectByte)(e)
  R.strictParseByte = Lfe
  var ag = (e) =>
    String(new TypeError(e).stack || e)
      .split(
        `
`,
      )
      .slice(0, 5)
      .filter((t) => !t.includes('stackTraceWarning')).join(`
`)
  R.logger = { warn: console.warn }
})
var Az = l((Zt) => {
  'use strict'
  Object.defineProperty(Zt, '__esModule', { value: !0 })
  Zt.parseEpochTimestamp =
    Zt.parseRfc7231DateTime =
    Zt.parseRfc3339DateTimeWithOffset =
    Zt.parseRfc3339DateTime =
    Zt.dateToUtcString =
      void 0
  var fs = Xw(),
    Ufe = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    Qw = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ]
  function Ffe(e) {
    let t = e.getUTCFullYear(),
      n = e.getUTCMonth(),
      r = e.getUTCDay(),
      s = e.getUTCDate(),
      o = e.getUTCHours(),
      i = e.getUTCMinutes(),
      a = e.getUTCSeconds(),
      c = s < 10 ? `0${s}` : `${s}`,
      u = o < 10 ? `0${o}` : `${o}`,
      d = i < 10 ? `0${i}` : `${i}`,
      p = a < 10 ? `0${a}` : `${a}`
    return `${Ufe[r]}, ${c} ${Qw[n]} ${t} ${u}:${d}:${p} GMT`
  }
  Zt.dateToUtcString = Ffe
  var Bfe = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
    ),
    jfe = (e) => {
      if (e == null) return
      if (typeof e != 'string')
        throw new TypeError('RFC-3339 date-times must be expressed as strings')
      let t = Bfe.exec(e)
      if (!t) throw new TypeError('Invalid RFC-3339 date-time value')
      let [n, r, s, o, i, a, c, u] = t,
        d = (0, fs.strictParseShort)(ma(r)),
        p = Hn(s, 'month', 1, 12),
        _ = Hn(o, 'day', 1, 31)
      return cl(d, p, _, {
        hours: i,
        minutes: a,
        seconds: c,
        fractionalMilliseconds: u,
      })
    }
  Zt.parseRfc3339DateTime = jfe
  var Gfe = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
    ),
    $fe = (e) => {
      if (e == null) return
      if (typeof e != 'string')
        throw new TypeError('RFC-3339 date-times must be expressed as strings')
      let t = Gfe.exec(e)
      if (!t) throw new TypeError('Invalid RFC-3339 date-time value')
      let [n, r, s, o, i, a, c, u, d] = t,
        p = (0, fs.strictParseShort)(ma(r)),
        _ = Hn(s, 'month', 1, 12),
        f = Hn(o, 'day', 1, 31),
        h = cl(p, _, f, {
          hours: i,
          minutes: a,
          seconds: c,
          fractionalMilliseconds: u,
        })
      return d.toUpperCase() != 'Z' && h.setTime(h.getTime() - nhe(d)), h
    }
  Zt.parseRfc3339DateTimeWithOffset = $fe
  var zfe = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    Hfe = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    Vfe = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
    ),
    Yfe = (e) => {
      if (e == null) return
      if (typeof e != 'string')
        throw new TypeError('RFC-7231 date-times must be expressed as strings')
      let t = zfe.exec(e)
      if (t) {
        let [n, r, s, o, i, a, c, u] = t
        return cl((0, fs.strictParseShort)(ma(o)), Jw(s), Hn(r, 'day', 1, 31), {
          hours: i,
          minutes: a,
          seconds: c,
          fractionalMilliseconds: u,
        })
      }
      if (((t = Hfe.exec(e)), t)) {
        let [n, r, s, o, i, a, c, u] = t
        return Jfe(
          cl(Kfe(o), Jw(s), Hn(r, 'day', 1, 31), {
            hours: i,
            minutes: a,
            seconds: c,
            fractionalMilliseconds: u,
          }),
        )
      }
      if (((t = Vfe.exec(e)), t)) {
        let [n, r, s, o, i, a, c, u] = t
        return cl(
          (0, fs.strictParseShort)(ma(u)),
          Jw(r),
          Hn(s.trimLeft(), 'day', 1, 31),
          { hours: o, minutes: i, seconds: a, fractionalMilliseconds: c },
        )
      }
      throw new TypeError('Invalid RFC-7231 date-time value')
    }
  Zt.parseRfc7231DateTime = Yfe
  var Wfe = (e) => {
    if (e == null) return
    let t
    if (typeof e == 'number') t = e
    else if (typeof e == 'string') t = (0, fs.strictParseDouble)(e)
    else
      throw new TypeError(
        'Epoch timestamps must be expressed as floating point numbers or their string representation',
      )
    if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
      throw new TypeError(
        'Epoch timestamps must be valid, non-Infinite, non-NaN numerics',
      )
    return new Date(Math.round(t * 1e3))
  }
  Zt.parseEpochTimestamp = Wfe
  var cl = (e, t, n, r) => {
      let s = t - 1
      return (
        Zfe(e, s, n),
        new Date(
          Date.UTC(
            e,
            s,
            n,
            Hn(r.hours, 'hour', 0, 23),
            Hn(r.minutes, 'minute', 0, 59),
            Hn(r.seconds, 'seconds', 0, 60),
            the(r.fractionalMilliseconds),
          ),
        )
      )
    },
    Kfe = (e) => {
      let t = new Date().getUTCFullYear(),
        n = Math.floor(t / 100) * 100 + (0, fs.strictParseShort)(ma(e))
      return n < t ? n + 100 : n
    },
    Xfe = 50 * 365 * 24 * 60 * 60 * 1e3,
    Jfe = (e) =>
      e.getTime() - new Date().getTime() > Xfe
        ? new Date(
            Date.UTC(
              e.getUTCFullYear() - 100,
              e.getUTCMonth(),
              e.getUTCDate(),
              e.getUTCHours(),
              e.getUTCMinutes(),
              e.getUTCSeconds(),
              e.getUTCMilliseconds(),
            ),
          )
        : e,
    Jw = (e) => {
      let t = Qw.indexOf(e)
      if (t < 0) throw new TypeError(`Invalid month: ${e}`)
      return t + 1
    },
    Qfe = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    Zfe = (e, t, n) => {
      let r = Qfe[t]
      if ((t === 1 && ehe(e) && (r = 29), n > r))
        throw new TypeError(`Invalid day for ${Qw[t]} in ${e}: ${n}`)
    },
    ehe = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
    Hn = (e, t, n, r) => {
      let s = (0, fs.strictParseByte)(ma(e))
      if (s < n || s > r)
        throw new TypeError(`${t} must be between ${n} and ${r}, inclusive`)
      return s
    },
    the = (e) => (e == null ? 0 : (0, fs.strictParseFloat32)('0.' + e) * 1e3),
    nhe = (e) => {
      let t = e[0],
        n = 1
      if (t == '+') n = 1
      else if (t == '-') n = -1
      else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`)
      let r = Number(e.substring(1, 3)),
        s = Number(e.substring(4, 6))
      return n * (r * 60 + s) * 60 * 1e3
    },
    ma = (e) => {
      let t = 0
      for (; t < e.length - 1 && e.charAt(t) === '0'; ) t++
      return t === 0 ? e : e.slice(t)
    }
})
var eI = l((pa) => {
  'use strict'
  Object.defineProperty(pa, '__esModule', { value: !0 })
  pa.decorateServiceException = pa.ServiceException = void 0
  var Zw = class e extends Error {
    constructor(t) {
      super(t.message),
        Object.setPrototypeOf(this, e.prototype),
        (this.name = t.name),
        (this.$fault = t.$fault),
        (this.$metadata = t.$metadata)
    }
  }
  pa.ServiceException = Zw
  var rhe = (e, t = {}) => {
    Object.entries(t)
      .filter(([, r]) => r !== void 0)
      .forEach(([r, s]) => {
        ;(e[r] == null || e[r] === '') && (e[r] = s)
      })
    let n = e.message || e.Message || 'UnknownError'
    return (e.message = n), delete e.Message, e
  }
  pa.decorateServiceException = rhe
})
var Oz = l((zo) => {
  'use strict'
  Object.defineProperty(zo, '__esModule', { value: !0 })
  zo.withBaseException = zo.throwDefaultError = void 0
  var she = eI(),
    ohe = ({ output: e, parsedBody: t, exceptionCtor: n, errorCode: r }) => {
      let s = ahe(e),
        o = s.httpStatusCode ? s.httpStatusCode + '' : void 0,
        i = new n({
          name: t?.code || t?.Code || r || o || 'UnknownError',
          $fault: 'client',
          $metadata: s,
        })
      throw (0, she.decorateServiceException)(i, t)
    }
  zo.throwDefaultError = ohe
  var ihe =
    (e) =>
    ({ output: t, parsedBody: n, errorCode: r }) => {
      ;(0, zo.throwDefaultError)({
        output: t,
        parsedBody: n,
        exceptionCtor: e,
        errorCode: r,
      })
    }
  zo.withBaseException = ihe
  var ahe = (e) => {
    var t, n
    return {
      httpStatusCode: e.statusCode,
      requestId:
        (n =
          (t = e.headers['x-amzn-requestid']) !== null && t !== void 0
            ? t
            : e.headers['x-amzn-request-id']) !== null && n !== void 0
          ? n
          : e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }
  }
})
var Nz = l((cg) => {
  'use strict'
  Object.defineProperty(cg, '__esModule', { value: !0 })
  cg.loadConfigsForDefaultMode = void 0
  var che = (e) => {
    switch (e) {
      case 'standard':
        return { retryMode: 'standard', connectionTimeout: 3100 }
      case 'in-region':
        return { retryMode: 'standard', connectionTimeout: 1100 }
      case 'cross-region':
        return { retryMode: 'standard', connectionTimeout: 3100 }
      case 'mobile':
        return { retryMode: 'standard', connectionTimeout: 3e4 }
      default:
        return {}
    }
  }
  cg.loadConfigsForDefaultMode = che
})
var kz = l((dg) => {
  'use strict'
  Object.defineProperty(dg, '__esModule', { value: !0 })
  dg.emitWarningIfUnsupportedVersion = void 0
  var qz = !1,
    dhe = (e) => {
      e && !qz && parseInt(e.substring(1, e.indexOf('.'))) < 14 && (qz = !0)
    }
  dg.emitWarningIfUnsupportedVersion = dhe
})
var Mz = l((hs) => {
  'use strict'
  Object.defineProperty(hs, '__esModule', { value: !0 })
  hs.resolveChecksumRuntimeConfig =
    hs.getChecksumConfiguration =
    hs.AlgorithmId =
      void 0
  var tI = D()
  Object.defineProperty(hs, 'AlgorithmId', {
    enumerable: !0,
    get: function () {
      return tI.AlgorithmId
    },
  })
  var uhe = (e) => {
    let t = []
    for (let n in tI.AlgorithmId) {
      let r = tI.AlgorithmId[n]
      e[r] !== void 0 &&
        t.push({ algorithmId: () => r, checksumConstructor: () => e[r] })
    }
    return {
      _checksumAlgorithms: t,
      addChecksumAlgorithm(n) {
        this._checksumAlgorithms.push(n)
      },
      checksumAlgorithms() {
        return this._checksumAlgorithms
      },
    }
  }
  hs.getChecksumConfiguration = uhe
  var lhe = (e) => {
    let t = {}
    return (
      e.checksumAlgorithms().forEach((n) => {
        t[n.algorithmId()] = n.checksumConstructor()
      }),
      t
    )
  }
  hs.resolveChecksumRuntimeConfig = lhe
})
var Lz = l((_a) => {
  'use strict'
  Object.defineProperty(_a, '__esModule', { value: !0 })
  _a.resolveRetryRuntimeConfig = _a.getRetryConfiguration = void 0
  var mhe = (e) => {
    let t = e.retryStrategy
    return {
      setRetryStrategy(n) {
        t = n
      },
      retryStrategy() {
        return t
      },
    }
  }
  _a.getRetryConfiguration = mhe
  var phe = (e) => {
    let t = {}
    return (t.retryStrategy = e.retryStrategy()), t
  }
  _a.resolveRetryRuntimeConfig = phe
})
var Bz = l((xr) => {
  'use strict'
  Object.defineProperty(xr, '__esModule', { value: !0 })
  xr.resolveDefaultRuntimeConfig =
    xr.getDefaultClientConfiguration =
    xr.getDefaultExtensionConfiguration =
      void 0
  var Uz = Mz(),
    Fz = Lz(),
    _he = (e) => ({
      ...(0, Uz.getChecksumConfiguration)(e),
      ...(0, Fz.getRetryConfiguration)(e),
    })
  xr.getDefaultExtensionConfiguration = _he
  xr.getDefaultClientConfiguration = xr.getDefaultExtensionConfiguration
  var fhe = (e) => ({
    ...(0, Uz.resolveChecksumRuntimeConfig)(e),
    ...(0, Fz.resolveRetryRuntimeConfig)(e),
  })
  xr.resolveDefaultRuntimeConfig = fhe
})
var jz = l((nI) => {
  'use strict'
  Object.defineProperty(nI, '__esModule', { value: !0 })
  var hhe = (x(), w(I))
  hhe.__exportStar(Bz(), nI)
})
var rI = l((ug) => {
  'use strict'
  Object.defineProperty(ug, '__esModule', { value: !0 })
  ug.extendedEncodeURIComponent = void 0
  function ghe(e) {
    return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
      return '%' + t.charCodeAt(0).toString(16).toUpperCase()
    })
  }
  ug.extendedEncodeURIComponent = ghe
})
var Gz = l((lg) => {
  'use strict'
  Object.defineProperty(lg, '__esModule', { value: !0 })
  lg.getArrayIfSingleItem = void 0
  var yhe = (e) => (Array.isArray(e) ? e : [e])
  lg.getArrayIfSingleItem = yhe
})
var $z = l((dl) => {
  'use strict'
  Object.defineProperty(dl, '__esModule', { value: !0 })
  dl.getValueFromTextNode = void 0
  var Ehe = (e) => {
    let t = '#text'
    for (let n in e)
      e.hasOwnProperty(n) && e[n][t] !== void 0
        ? (e[n] = e[n][t])
        : typeof e[n] == 'object' &&
          e[n] !== null &&
          (e[n] = (0, dl.getValueFromTextNode)(e[n]))
    return e
  }
  dl.getValueFromTextNode = Ehe
})
var zz = l((Vn) => {
  'use strict'
  Object.defineProperty(Vn, '__esModule', { value: !0 })
  Vn.LazyJsonString = Vn.StringWrapper = void 0
  var She = function () {
    let e = Object.getPrototypeOf(this).constructor,
      t = Function.bind.apply(String, [null, ...arguments]),
      n = new t()
    return Object.setPrototypeOf(n, e.prototype), n
  }
  Vn.StringWrapper = She
  Vn.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
      value: Vn.StringWrapper,
      enumerable: !1,
      writable: !0,
      configurable: !0,
    },
  })
  Object.setPrototypeOf(Vn.StringWrapper, String)
  var sI = class e extends Vn.StringWrapper {
    deserializeJSON() {
      return JSON.parse(super.toString())
    }
    toJSON() {
      return super.toString()
    }
    static fromObject(t) {
      return t instanceof e
        ? t
        : t instanceof String || typeof t == 'string'
          ? new e(t)
          : new e(JSON.stringify(t))
    }
  }
  Vn.LazyJsonString = sI
})
var Yz = l((gs) => {
  'use strict'
  Object.defineProperty(gs, '__esModule', { value: !0 })
  gs.take = gs.convertMap = gs.map = void 0
  function Hz(e, t, n) {
    let r, s, o
    if (typeof t > 'u' && typeof n > 'u') (r = {}), (o = e)
    else {
      if (((r = e), typeof t == 'function'))
        return (s = t), (o = n), Che(r, s, o)
      o = t
    }
    for (let i of Object.keys(o)) {
      if (!Array.isArray(o[i])) {
        r[i] = o[i]
        continue
      }
      Vz(r, null, o, i)
    }
    return r
  }
  gs.map = Hz
  var bhe = (e) => {
    let t = {}
    for (let [n, r] of Object.entries(e || {})) t[n] = [, r]
    return t
  }
  gs.convertMap = bhe
  var vhe = (e, t) => {
    let n = {}
    for (let r in t) Vz(n, e, t, r)
    return n
  }
  gs.take = vhe
  var Che = (e, t, n) =>
      Hz(
        e,
        Object.entries(n).reduce(
          (r, [s, o]) => (
            Array.isArray(o)
              ? (r[s] = o)
              : typeof o == 'function'
                ? (r[s] = [t, o()])
                : (r[s] = [t, o]),
            r
          ),
          {},
        ),
      ),
    Vz = (e, t, n, r) => {
      if (t !== null) {
        let i = n[r]
        typeof i == 'function' && (i = [, i])
        let [a = The, c = whe, u = r] = i
        ;((typeof a == 'function' && a(t[u])) ||
          (typeof a != 'function' && a)) &&
          (e[r] = c(t[u]))
        return
      }
      let [s, o] = n[r]
      if (typeof o == 'function') {
        let i,
          a = s === void 0 && (i = o()) != null,
          c =
            (typeof s == 'function' && !!s(void 0)) ||
            (typeof s != 'function' && !!s)
        a ? (e[r] = i) : c && (e[r] = o())
      } else {
        let i = s === void 0 && o != null,
          a =
            (typeof s == 'function' && !!s(o)) ||
            (typeof s != 'function' && !!s)
        ;(i || a) && (e[r] = o)
      }
    },
    The = (e) => e != null,
    whe = (e) => e
})
var Kz = l((mg) => {
  'use strict'
  Object.defineProperty(mg, '__esModule', { value: !0 })
  mg.resolvedPath = void 0
  var Wz = rI(),
    Ihe = (e, t, n, r, s, o) => {
      if (t != null && t[n] !== void 0) {
        let i = r()
        if (i.length <= 0)
          throw new Error(
            'Empty value provided for input HTTP label: ' + n + '.',
          )
        e = e.replace(
          s,
          o
            ? i
                .split('/')
                .map((a) => (0, Wz.extendedEncodeURIComponent)(a))
                .join('/')
            : (0, Wz.extendedEncodeURIComponent)(i),
        )
      } else
        throw new Error('No value provided for input HTTP label: ' + n + '.')
      return e
    }
  mg.resolvedPath = Ihe
})
var Xz = l((pg) => {
  'use strict'
  Object.defineProperty(pg, '__esModule', { value: !0 })
  pg.serializeFloat = void 0
  var xhe = (e) => {
    if (e !== e) return 'NaN'
    switch (e) {
      case 1 / 0:
        return 'Infinity'
      case -1 / 0:
        return '-Infinity'
      default:
        return e
    }
  }
  pg.serializeFloat = xhe
})
var Jz = l((ul) => {
  'use strict'
  Object.defineProperty(ul, '__esModule', { value: !0 })
  ul._json = void 0
  var Phe = (e) => {
    if (e == null) return {}
    if (Array.isArray(e)) return e.filter((t) => t != null)
    if (typeof e == 'object') {
      let t = {}
      for (let n of Object.keys(e)) e[n] != null && (t[n] = (0, ul._json)(e[n]))
      return t
    }
    return e
  }
  ul._json = Phe
})
var Qz = l((_g) => {
  'use strict'
  Object.defineProperty(_g, '__esModule', { value: !0 })
  _g.splitEvery = void 0
  function Rhe(e, t, n) {
    if (n <= 0 || !Number.isInteger(n))
      throw new Error(
        'Invalid number of delimiters (' + n + ') for splitEvery.',
      )
    let r = e.split(t)
    if (n === 1) return r
    let s = [],
      o = ''
    for (let i = 0; i < r.length; i++)
      o === '' ? (o = r[i]) : (o += t + r[i]),
        (i + 1) % n === 0 && (s.push(o), (o = ''))
    return o !== '' && s.push(o), s
  }
  _g.splitEvery = Rhe
})
var v = l((ve) => {
  'use strict'
  Object.defineProperty(ve, '__esModule', { value: !0 })
  var De = (x(), w(I))
  De.__exportStar(K$(), ve)
  De.__exportStar(Z$(), ve)
  De.__exportStar(Iz(), ve)
  De.__exportStar(xz(), ve)
  De.__exportStar(Pz(), ve)
  De.__exportStar(Rz(), ve)
  De.__exportStar(Az(), ve)
  De.__exportStar(Oz(), ve)
  De.__exportStar(Nz(), ve)
  De.__exportStar(kz(), ve)
  De.__exportStar(jz(), ve)
  De.__exportStar(eI(), ve)
  De.__exportStar(rI(), ve)
  De.__exportStar(Gz(), ve)
  De.__exportStar($z(), ve)
  De.__exportStar(zz(), ve)
  De.__exportStar(Yz(), ve)
  De.__exportStar(Xw(), ve)
  De.__exportStar(Kz(), ve)
  De.__exportStar(Xz(), ve)
  De.__exportStar(Jz(), ve)
  De.__exportStar(Qz(), ve)
})
var Zz = l((fg) => {
  'use strict'
  Object.defineProperty(fg, '__esModule', { value: !0 })
  fg.awsExpectUnion = void 0
  var Dhe = v(),
    Ahe = (e) => {
      if (e != null)
        return (
          typeof e == 'object' && '__type' in e && delete e.__type,
          (0, Dhe.expectUnion)(e)
        )
    }
  fg.awsExpectUnion = Ahe
})
var eH = l((oI) => {
  'use strict'
  Object.defineProperty(oI, '__esModule', { value: !0 })
  var Ohe = (x(), w(I))
  Ohe.__exportStar(Zz(), oI)
})
var tH = l((iI) => {
  'use strict'
  Object.defineProperty(iI, '__esModule', { value: !0 })
  var Nhe = (x(), w(I))
  Nhe.__exportStar(eH(), iI)
})
function ll() {
  return (
    hg > gg.length - 16 && (nH.default.randomFillSync(gg), (hg = 0)),
    gg.slice(hg, (hg += 16))
  )
}
var nH,
  gg,
  hg,
  aI = ue(() => {
    ;(nH = sn(require('crypto'))), (gg = new Uint8Array(256)), (hg = gg.length)
  })
var rH,
  sH = ue(() => {
    rH =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  })
function qhe(e) {
  return typeof e == 'string' && rH.test(e)
}
var ys,
  ml = ue(() => {
    sH()
    ys = qhe
  })
function khe(e, t = 0) {
  let n = (
    Qe[e[t + 0]] +
    Qe[e[t + 1]] +
    Qe[e[t + 2]] +
    Qe[e[t + 3]] +
    '-' +
    Qe[e[t + 4]] +
    Qe[e[t + 5]] +
    '-' +
    Qe[e[t + 6]] +
    Qe[e[t + 7]] +
    '-' +
    Qe[e[t + 8]] +
    Qe[e[t + 9]] +
    '-' +
    Qe[e[t + 10]] +
    Qe[e[t + 11]] +
    Qe[e[t + 12]] +
    Qe[e[t + 13]] +
    Qe[e[t + 14]] +
    Qe[e[t + 15]]
  ).toLowerCase()
  if (!ys(n)) throw TypeError('Stringified UUID is invalid')
  return n
}
var Qe,
  Es,
  pl = ue(() => {
    ml()
    Qe = []
    for (let e = 0; e < 256; ++e) Qe.push((e + 256).toString(16).substr(1))
    Es = khe
  })
function Mhe(e, t, n) {
  let r = (t && n) || 0,
    s = t || new Array(16)
  e = e || {}
  let o = e.node || oH,
    i = e.clockseq !== void 0 ? e.clockseq : cI
  if (o == null || i == null) {
    let _ = e.random || (e.rng || ll)()
    o == null && (o = oH = [_[0] | 1, _[1], _[2], _[3], _[4], _[5]]),
      i == null && (i = cI = ((_[6] << 8) | _[7]) & 16383)
  }
  let a = e.msecs !== void 0 ? e.msecs : Date.now(),
    c = e.nsecs !== void 0 ? e.nsecs : uI + 1,
    u = a - dI + (c - uI) / 1e4
  if (
    (u < 0 && e.clockseq === void 0 && (i = (i + 1) & 16383),
    (u < 0 || a > dI) && e.nsecs === void 0 && (c = 0),
    c >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
  ;(dI = a), (uI = c), (cI = i), (a += 122192928e5)
  let d = ((a & 268435455) * 1e4 + c) % 4294967296
  ;(s[r++] = (d >>> 24) & 255),
    (s[r++] = (d >>> 16) & 255),
    (s[r++] = (d >>> 8) & 255),
    (s[r++] = d & 255)
  let p = ((a / 4294967296) * 1e4) & 268435455
  ;(s[r++] = (p >>> 8) & 255),
    (s[r++] = p & 255),
    (s[r++] = ((p >>> 24) & 15) | 16),
    (s[r++] = (p >>> 16) & 255),
    (s[r++] = (i >>> 8) | 128),
    (s[r++] = i & 255)
  for (let _ = 0; _ < 6; ++_) s[r + _] = o[_]
  return t || Es(s)
}
var oH,
  cI,
  dI,
  uI,
  iH,
  aH = ue(() => {
    aI()
    pl()
    ;(dI = 0), (uI = 0)
    iH = Mhe
  })
function Lhe(e) {
  if (!ys(e)) throw TypeError('Invalid UUID')
  let t,
    n = new Uint8Array(16)
  return (
    (n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (n[1] = (t >>> 16) & 255),
    (n[2] = (t >>> 8) & 255),
    (n[3] = t & 255),
    (n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (n[5] = t & 255),
    (n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (n[7] = t & 255),
    (n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (n[9] = t & 255),
    (n[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (n[11] = (t / 4294967296) & 255),
    (n[12] = (t >>> 24) & 255),
    (n[13] = (t >>> 16) & 255),
    (n[14] = (t >>> 8) & 255),
    (n[15] = t & 255),
    n
  )
}
var yg,
  lI = ue(() => {
    ml()
    yg = Lhe
  })
function Uhe(e) {
  e = unescape(encodeURIComponent(e))
  let t = []
  for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n))
  return t
}
function Eg(e, t, n) {
  function r(s, o, i, a) {
    if (
      (typeof s == 'string' && (s = Uhe(s)),
      typeof o == 'string' && (o = yg(o)),
      o.length !== 16)
    )
      throw TypeError(
        'Namespace must be array-like (16 iterable integer values, 0-255)',
      )
    let c = new Uint8Array(16 + s.length)
    if (
      (c.set(o),
      c.set(s, o.length),
      (c = n(c)),
      (c[6] = (c[6] & 15) | t),
      (c[8] = (c[8] & 63) | 128),
      i)
    ) {
      a = a || 0
      for (let u = 0; u < 16; ++u) i[a + u] = c[u]
      return i
    }
    return Es(c)
  }
  try {
    r.name = e
  } catch {}
  return (r.DNS = Fhe), (r.URL = Bhe), r
}
var Fhe,
  Bhe,
  mI = ue(() => {
    pl()
    lI()
    ;(Fhe = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'),
      (Bhe = '6ba7b811-9dad-11d1-80b4-00c04fd430c8')
  })
function jhe(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    cH.default.createHash('md5').update(e).digest()
  )
}
var cH,
  dH,
  uH = ue(() => {
    cH = sn(require('crypto'))
    dH = jhe
  })
var Ghe,
  lH,
  mH = ue(() => {
    mI()
    uH()
    ;(Ghe = Eg('v3', 48, dH)), (lH = Ghe)
  })
function $he(e, t, n) {
  e = e || {}
  let r = e.random || (e.rng || ll)()
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    n = n || 0
    for (let s = 0; s < 16; ++s) t[n + s] = r[s]
    return t
  }
  return Es(r)
}
var pH,
  _H = ue(() => {
    aI()
    pl()
    pH = $he
  })
function zhe(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    fH.default.createHash('sha1').update(e).digest()
  )
}
var fH,
  hH,
  gH = ue(() => {
    fH = sn(require('crypto'))
    hH = zhe
  })
var Hhe,
  yH,
  EH = ue(() => {
    mI()
    gH()
    ;(Hhe = Eg('v5', 80, hH)), (yH = Hhe)
  })
var SH,
  bH = ue(() => {
    SH = '00000000-0000-0000-0000-000000000000'
  })
function Vhe(e) {
  if (!ys(e)) throw TypeError('Invalid UUID')
  return parseInt(e.substr(14, 1), 16)
}
var vH,
  CH = ue(() => {
    ml()
    vH = Vhe
  })
var TH = {}
fd(TH, {
  NIL: () => SH,
  parse: () => yg,
  stringify: () => Es,
  v1: () => iH,
  v3: () => lH,
  v4: () => pH,
  v5: () => yH,
  validate: () => ys,
  version: () => vH,
})
var wH = ue(() => {
  aH()
  mH()
  _H()
  EH()
  bH()
  CH()
  ml()
  pl()
  lI()
})
var Sg = l((fa) => {
  'use strict'
  Object.defineProperty(fa, '__esModule', { value: !0 })
  fa.DynamoDBServiceException = fa.__ServiceException = void 0
  var IH = v()
  Object.defineProperty(fa, '__ServiceException', {
    enumerable: !0,
    get: function () {
      return IH.ServiceException
    },
  })
  var pI = class e extends IH.ServiceException {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e.prototype)
    }
  }
  fa.DynamoDBServiceException = pI
})
var VI = l((b) => {
  'use strict'
  Object.defineProperty(b, '__esModule', { value: !0 })
  b.GlobalTableNotFoundException =
    b.ExportNotFoundException =
    b.S3SseAlgorithm =
    b.ExportViewType =
    b.ExportType =
    b.ExportStatus =
    b.ExportFormat =
    b.TransactionConflictException =
    b.ReturnValue =
    b.ResourceInUseException =
    b.TableStatus =
    b.IndexStatus =
    b.GlobalTableAlreadyExistsException =
    b.TableClass =
    b.ReplicaStatus =
    b.GlobalTableStatus =
    b.TableNotFoundException =
    b.TableInUseException =
    b.LimitExceededException =
    b.ContributorInsightsStatus =
    b.ContributorInsightsAction =
    b.ContinuousBackupsUnavailableException =
    b.PointInTimeRecoveryStatus =
    b.ContinuousBackupsStatus =
    b.ConditionalOperator =
    b.ComparisonOperator =
    b.ItemCollectionSizeLimitExceededException =
    b.ReturnItemCollectionMetrics =
    b.ResourceNotFoundException =
    b.ProvisionedThroughputExceededException =
    b.InvalidEndpointException =
    b.RequestLimitExceeded =
    b.InternalServerError =
    b.BatchStatementErrorCodeEnum =
    b.ReturnValuesOnConditionCheckFailure =
    b.ReturnConsumedCapacity =
    b.BackupTypeFilter =
    b.BackupNotFoundException =
    b.BackupInUseException =
    b.TimeToLiveStatus =
    b.StreamViewType =
    b.SSEStatus =
    b.SSEType =
    b.ProjectionType =
    b.KeyType =
    b.BillingMode =
    b.BackupType =
    b.BackupStatus =
    b.ScalarAttributeType =
    b.AttributeAction =
      void 0
  b.TransactionCanceledException =
    b.ConditionalCheckFailedException =
    b.AttributeValue =
    b.IndexNotFoundException =
    b.ReplicaNotFoundException =
    b.ReplicaAlreadyExistsException =
    b.InvalidRestoreTimeException =
    b.TableAlreadyExistsException =
    b.Select =
    b.ImportConflictException =
    b.PointInTimeRecoveryUnavailableException =
    b.InvalidExportTimeException =
    b.ExportConflictException =
    b.TransactionInProgressException =
    b.IdempotentParameterMismatchException =
    b.DuplicateItemException =
    b.DestinationStatus =
    b.ImportNotFoundException =
    b.InputFormat =
    b.InputCompressionType =
    b.ImportStatus =
      void 0
  var me = Sg()
  b.AttributeAction = { ADD: 'ADD', DELETE: 'DELETE', PUT: 'PUT' }
  b.ScalarAttributeType = { B: 'B', N: 'N', S: 'S' }
  b.BackupStatus = {
    AVAILABLE: 'AVAILABLE',
    CREATING: 'CREATING',
    DELETED: 'DELETED',
  }
  b.BackupType = { AWS_BACKUP: 'AWS_BACKUP', SYSTEM: 'SYSTEM', USER: 'USER' }
  b.BillingMode = {
    PAY_PER_REQUEST: 'PAY_PER_REQUEST',
    PROVISIONED: 'PROVISIONED',
  }
  b.KeyType = { HASH: 'HASH', RANGE: 'RANGE' }
  b.ProjectionType = { ALL: 'ALL', INCLUDE: 'INCLUDE', KEYS_ONLY: 'KEYS_ONLY' }
  b.SSEType = { AES256: 'AES256', KMS: 'KMS' }
  b.SSEStatus = {
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLED: 'ENABLED',
    ENABLING: 'ENABLING',
    UPDATING: 'UPDATING',
  }
  b.StreamViewType = {
    KEYS_ONLY: 'KEYS_ONLY',
    NEW_AND_OLD_IMAGES: 'NEW_AND_OLD_IMAGES',
    NEW_IMAGE: 'NEW_IMAGE',
    OLD_IMAGE: 'OLD_IMAGE',
  }
  b.TimeToLiveStatus = {
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLED: 'ENABLED',
    ENABLING: 'ENABLING',
  }
  var _I = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'BackupInUseException', $fault: 'client', ...t }),
        (this.name = 'BackupInUseException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.BackupInUseException = _I
  var fI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'BackupNotFoundException', $fault: 'client', ...t }),
        (this.name = 'BackupNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.BackupNotFoundException = fI
  b.BackupTypeFilter = {
    ALL: 'ALL',
    AWS_BACKUP: 'AWS_BACKUP',
    SYSTEM: 'SYSTEM',
    USER: 'USER',
  }
  b.ReturnConsumedCapacity = {
    INDEXES: 'INDEXES',
    NONE: 'NONE',
    TOTAL: 'TOTAL',
  }
  b.ReturnValuesOnConditionCheckFailure = { ALL_OLD: 'ALL_OLD', NONE: 'NONE' }
  b.BatchStatementErrorCodeEnum = {
    AccessDenied: 'AccessDenied',
    ConditionalCheckFailed: 'ConditionalCheckFailed',
    DuplicateItem: 'DuplicateItem',
    InternalServerError: 'InternalServerError',
    ItemCollectionSizeLimitExceeded: 'ItemCollectionSizeLimitExceeded',
    ProvisionedThroughputExceeded: 'ProvisionedThroughputExceeded',
    RequestLimitExceeded: 'RequestLimitExceeded',
    ResourceNotFound: 'ResourceNotFound',
    ThrottlingError: 'ThrottlingError',
    TransactionConflict: 'TransactionConflict',
    ValidationError: 'ValidationError',
  }
  var hI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InternalServerError', $fault: 'server', ...t }),
        (this.name = 'InternalServerError'),
        (this.$fault = 'server'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.InternalServerError = hI
  var gI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'RequestLimitExceeded', $fault: 'client', ...t }),
        (this.name = 'RequestLimitExceeded'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.RequestLimitExceeded = gI
  var yI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InvalidEndpointException', $fault: 'client', ...t }),
        (this.name = 'InvalidEndpointException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message)
    }
  }
  b.InvalidEndpointException = yI
  var EI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ProvisionedThroughputExceededException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ProvisionedThroughputExceededException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ProvisionedThroughputExceededException = EI
  var SI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ResourceNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ResourceNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ResourceNotFoundException = SI
  b.ReturnItemCollectionMetrics = { NONE: 'NONE', SIZE: 'SIZE' }
  var bI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ItemCollectionSizeLimitExceededException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ItemCollectionSizeLimitExceededException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ItemCollectionSizeLimitExceededException = bI
  b.ComparisonOperator = {
    BEGINS_WITH: 'BEGINS_WITH',
    BETWEEN: 'BETWEEN',
    CONTAINS: 'CONTAINS',
    EQ: 'EQ',
    GE: 'GE',
    GT: 'GT',
    IN: 'IN',
    LE: 'LE',
    LT: 'LT',
    NE: 'NE',
    NOT_CONTAINS: 'NOT_CONTAINS',
    NOT_NULL: 'NOT_NULL',
    NULL: 'NULL',
  }
  b.ConditionalOperator = { AND: 'AND', OR: 'OR' }
  b.ContinuousBackupsStatus = { DISABLED: 'DISABLED', ENABLED: 'ENABLED' }
  b.PointInTimeRecoveryStatus = { DISABLED: 'DISABLED', ENABLED: 'ENABLED' }
  var vI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ContinuousBackupsUnavailableException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ContinuousBackupsUnavailableException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ContinuousBackupsUnavailableException = vI
  b.ContributorInsightsAction = { DISABLE: 'DISABLE', ENABLE: 'ENABLE' }
  b.ContributorInsightsStatus = {
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLED: 'ENABLED',
    ENABLING: 'ENABLING',
    FAILED: 'FAILED',
  }
  var CI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'LimitExceededException', $fault: 'client', ...t }),
        (this.name = 'LimitExceededException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.LimitExceededException = CI
  var TI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TableInUseException', $fault: 'client', ...t }),
        (this.name = 'TableInUseException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.TableInUseException = TI
  var wI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TableNotFoundException', $fault: 'client', ...t }),
        (this.name = 'TableNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.TableNotFoundException = wI
  b.GlobalTableStatus = {
    ACTIVE: 'ACTIVE',
    CREATING: 'CREATING',
    DELETING: 'DELETING',
    UPDATING: 'UPDATING',
  }
  b.ReplicaStatus = {
    ACTIVE: 'ACTIVE',
    CREATING: 'CREATING',
    CREATION_FAILED: 'CREATION_FAILED',
    DELETING: 'DELETING',
    INACCESSIBLE_ENCRYPTION_CREDENTIALS: 'INACCESSIBLE_ENCRYPTION_CREDENTIALS',
    REGION_DISABLED: 'REGION_DISABLED',
    UPDATING: 'UPDATING',
  }
  b.TableClass = {
    STANDARD: 'STANDARD',
    STANDARD_INFREQUENT_ACCESS: 'STANDARD_INFREQUENT_ACCESS',
  }
  var II = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'GlobalTableAlreadyExistsException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'GlobalTableAlreadyExistsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.GlobalTableAlreadyExistsException = II
  b.IndexStatus = {
    ACTIVE: 'ACTIVE',
    CREATING: 'CREATING',
    DELETING: 'DELETING',
    UPDATING: 'UPDATING',
  }
  b.TableStatus = {
    ACTIVE: 'ACTIVE',
    ARCHIVED: 'ARCHIVED',
    ARCHIVING: 'ARCHIVING',
    CREATING: 'CREATING',
    DELETING: 'DELETING',
    INACCESSIBLE_ENCRYPTION_CREDENTIALS: 'INACCESSIBLE_ENCRYPTION_CREDENTIALS',
    UPDATING: 'UPDATING',
  }
  var xI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ResourceInUseException', $fault: 'client', ...t }),
        (this.name = 'ResourceInUseException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ResourceInUseException = xI
  b.ReturnValue = {
    ALL_NEW: 'ALL_NEW',
    ALL_OLD: 'ALL_OLD',
    NONE: 'NONE',
    UPDATED_NEW: 'UPDATED_NEW',
    UPDATED_OLD: 'UPDATED_OLD',
  }
  var PI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TransactionConflictException', $fault: 'client', ...t }),
        (this.name = 'TransactionConflictException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.TransactionConflictException = PI
  b.ExportFormat = { DYNAMODB_JSON: 'DYNAMODB_JSON', ION: 'ION' }
  b.ExportStatus = {
    COMPLETED: 'COMPLETED',
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
  }
  b.ExportType = {
    FULL_EXPORT: 'FULL_EXPORT',
    INCREMENTAL_EXPORT: 'INCREMENTAL_EXPORT',
  }
  b.ExportViewType = {
    NEW_AND_OLD_IMAGES: 'NEW_AND_OLD_IMAGES',
    NEW_IMAGE: 'NEW_IMAGE',
  }
  b.S3SseAlgorithm = { AES256: 'AES256', KMS: 'KMS' }
  var RI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ExportNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ExportNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ExportNotFoundException = RI
  var DI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'GlobalTableNotFoundException', $fault: 'client', ...t }),
        (this.name = 'GlobalTableNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.GlobalTableNotFoundException = DI
  b.ImportStatus = {
    CANCELLED: 'CANCELLED',
    CANCELLING: 'CANCELLING',
    COMPLETED: 'COMPLETED',
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
  }
  b.InputCompressionType = { GZIP: 'GZIP', NONE: 'NONE', ZSTD: 'ZSTD' }
  b.InputFormat = { CSV: 'CSV', DYNAMODB_JSON: 'DYNAMODB_JSON', ION: 'ION' }
  var AI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ImportNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ImportNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ImportNotFoundException = AI
  b.DestinationStatus = {
    ACTIVE: 'ACTIVE',
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLE_FAILED: 'ENABLE_FAILED',
    ENABLING: 'ENABLING',
  }
  var OI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'DuplicateItemException', $fault: 'client', ...t }),
        (this.name = 'DuplicateItemException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.DuplicateItemException = OI
  var NI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'IdempotentParameterMismatchException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'IdempotentParameterMismatchException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message)
    }
  }
  b.IdempotentParameterMismatchException = NI
  var qI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TransactionInProgressException', $fault: 'client', ...t }),
        (this.name = 'TransactionInProgressException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message)
    }
  }
  b.TransactionInProgressException = qI
  var kI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ExportConflictException', $fault: 'client', ...t }),
        (this.name = 'ExportConflictException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ExportConflictException = kI
  var MI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InvalidExportTimeException', $fault: 'client', ...t }),
        (this.name = 'InvalidExportTimeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.InvalidExportTimeException = MI
  var LI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'PointInTimeRecoveryUnavailableException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'PointInTimeRecoveryUnavailableException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.PointInTimeRecoveryUnavailableException = LI
  var UI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ImportConflictException', $fault: 'client', ...t }),
        (this.name = 'ImportConflictException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ImportConflictException = UI
  b.Select = {
    ALL_ATTRIBUTES: 'ALL_ATTRIBUTES',
    ALL_PROJECTED_ATTRIBUTES: 'ALL_PROJECTED_ATTRIBUTES',
    COUNT: 'COUNT',
    SPECIFIC_ATTRIBUTES: 'SPECIFIC_ATTRIBUTES',
  }
  var FI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TableAlreadyExistsException', $fault: 'client', ...t }),
        (this.name = 'TableAlreadyExistsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.TableAlreadyExistsException = FI
  var BI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InvalidRestoreTimeException', $fault: 'client', ...t }),
        (this.name = 'InvalidRestoreTimeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.InvalidRestoreTimeException = BI
  var jI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ReplicaAlreadyExistsException', $fault: 'client', ...t }),
        (this.name = 'ReplicaAlreadyExistsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ReplicaAlreadyExistsException = jI
  var GI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ReplicaNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ReplicaNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.ReplicaNotFoundException = GI
  var $I = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'IndexNotFoundException', $fault: 'client', ...t }),
        (this.name = 'IndexNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  b.IndexNotFoundException = $I
  var Yhe
  ;(function (e) {
    e.visit = (t, n) =>
      t.S !== void 0
        ? n.S(t.S)
        : t.N !== void 0
          ? n.N(t.N)
          : t.B !== void 0
            ? n.B(t.B)
            : t.SS !== void 0
              ? n.SS(t.SS)
              : t.NS !== void 0
                ? n.NS(t.NS)
                : t.BS !== void 0
                  ? n.BS(t.BS)
                  : t.M !== void 0
                    ? n.M(t.M)
                    : t.L !== void 0
                      ? n.L(t.L)
                      : t.NULL !== void 0
                        ? n.NULL(t.NULL)
                        : t.BOOL !== void 0
                          ? n.BOOL(t.BOOL)
                          : n._(t.$unknown[0], t.$unknown[1])
  })((Yhe = b.AttributeValue || (b.AttributeValue = {})))
  var zI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ConditionalCheckFailedException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ConditionalCheckFailedException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Item = t.Item)
    }
  }
  b.ConditionalCheckFailedException = zI
  var HI = class e extends me.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TransactionCanceledException', $fault: 'client', ...t }),
        (this.name = 'TransactionCanceledException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message),
        (this.CancellationReasons = t.CancellationReasons)
    }
  }
  b.TransactionCanceledException = HI
})
var F = l((g) => {
  'use strict'
  Object.defineProperty(g, '__esModule', { value: !0 })
  g.se_UpdateItemCommand =
    g.se_UpdateGlobalTableSettingsCommand =
    g.se_UpdateGlobalTableCommand =
    g.se_UpdateContributorInsightsCommand =
    g.se_UpdateContinuousBackupsCommand =
    g.se_UntagResourceCommand =
    g.se_TransactWriteItemsCommand =
    g.se_TransactGetItemsCommand =
    g.se_TagResourceCommand =
    g.se_ScanCommand =
    g.se_RestoreTableToPointInTimeCommand =
    g.se_RestoreTableFromBackupCommand =
    g.se_QueryCommand =
    g.se_PutItemCommand =
    g.se_ListTagsOfResourceCommand =
    g.se_ListTablesCommand =
    g.se_ListImportsCommand =
    g.se_ListGlobalTablesCommand =
    g.se_ListExportsCommand =
    g.se_ListContributorInsightsCommand =
    g.se_ListBackupsCommand =
    g.se_ImportTableCommand =
    g.se_GetItemCommand =
    g.se_ExportTableToPointInTimeCommand =
    g.se_ExecuteTransactionCommand =
    g.se_ExecuteStatementCommand =
    g.se_EnableKinesisStreamingDestinationCommand =
    g.se_DisableKinesisStreamingDestinationCommand =
    g.se_DescribeTimeToLiveCommand =
    g.se_DescribeTableReplicaAutoScalingCommand =
    g.se_DescribeTableCommand =
    g.se_DescribeLimitsCommand =
    g.se_DescribeKinesisStreamingDestinationCommand =
    g.se_DescribeImportCommand =
    g.se_DescribeGlobalTableSettingsCommand =
    g.se_DescribeGlobalTableCommand =
    g.se_DescribeExportCommand =
    g.se_DescribeEndpointsCommand =
    g.se_DescribeContributorInsightsCommand =
    g.se_DescribeContinuousBackupsCommand =
    g.se_DescribeBackupCommand =
    g.se_DeleteTableCommand =
    g.se_DeleteItemCommand =
    g.se_DeleteBackupCommand =
    g.se_CreateTableCommand =
    g.se_CreateGlobalTableCommand =
    g.se_CreateBackupCommand =
    g.se_BatchWriteItemCommand =
    g.se_BatchGetItemCommand =
    g.se_BatchExecuteStatementCommand =
      void 0
  g.de_UpdateContributorInsightsCommand =
    g.de_UpdateContinuousBackupsCommand =
    g.de_UntagResourceCommand =
    g.de_TransactWriteItemsCommand =
    g.de_TransactGetItemsCommand =
    g.de_TagResourceCommand =
    g.de_ScanCommand =
    g.de_RestoreTableToPointInTimeCommand =
    g.de_RestoreTableFromBackupCommand =
    g.de_QueryCommand =
    g.de_PutItemCommand =
    g.de_ListTagsOfResourceCommand =
    g.de_ListTablesCommand =
    g.de_ListImportsCommand =
    g.de_ListGlobalTablesCommand =
    g.de_ListExportsCommand =
    g.de_ListContributorInsightsCommand =
    g.de_ListBackupsCommand =
    g.de_ImportTableCommand =
    g.de_GetItemCommand =
    g.de_ExportTableToPointInTimeCommand =
    g.de_ExecuteTransactionCommand =
    g.de_ExecuteStatementCommand =
    g.de_EnableKinesisStreamingDestinationCommand =
    g.de_DisableKinesisStreamingDestinationCommand =
    g.de_DescribeTimeToLiveCommand =
    g.de_DescribeTableReplicaAutoScalingCommand =
    g.de_DescribeTableCommand =
    g.de_DescribeLimitsCommand =
    g.de_DescribeKinesisStreamingDestinationCommand =
    g.de_DescribeImportCommand =
    g.de_DescribeGlobalTableSettingsCommand =
    g.de_DescribeGlobalTableCommand =
    g.de_DescribeExportCommand =
    g.de_DescribeEndpointsCommand =
    g.de_DescribeContributorInsightsCommand =
    g.de_DescribeContinuousBackupsCommand =
    g.de_DescribeBackupCommand =
    g.de_DeleteTableCommand =
    g.de_DeleteItemCommand =
    g.de_DeleteBackupCommand =
    g.de_CreateTableCommand =
    g.de_CreateGlobalTableCommand =
    g.de_CreateBackupCommand =
    g.de_BatchWriteItemCommand =
    g.de_BatchGetItemCommand =
    g.de_BatchExecuteStatementCommand =
    g.se_UpdateTimeToLiveCommand =
    g.se_UpdateTableReplicaAutoScalingCommand =
    g.se_UpdateTableCommand =
      void 0
  g.de_UpdateTimeToLiveCommand =
    g.de_UpdateTableReplicaAutoScalingCommand =
    g.de_UpdateTableCommand =
    g.de_UpdateItemCommand =
    g.de_UpdateGlobalTableSettingsCommand =
    g.de_UpdateGlobalTableCommand =
      void 0
  var ha = tH(),
    Whe = Oe(),
    m = v(),
    bg = (wH(), w(TH)),
    Khe = Sg(),
    de = VI(),
    Xhe = async (e, t) => {
      let n = G('BatchExecuteStatement'),
        r
      return (r = JSON.stringify(aSe(e, t))), j(t, n, '/', void 0, r)
    }
  g.se_BatchExecuteStatementCommand = Xhe
  var Jhe = async (e, t) => {
    let n = G('BatchGetItem'),
      r
    return (r = JSON.stringify(cSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_BatchGetItemCommand = Jhe
  var Qhe = async (e, t) => {
    let n = G('BatchWriteItem'),
      r
    return (r = JSON.stringify(lSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_BatchWriteItemCommand = Qhe
  var Zhe = async (e, t) => {
    let n = G('CreateBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_CreateBackupCommand = Zhe
  var ege = async (e, t) => {
    let n = G('CreateGlobalTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_CreateGlobalTableCommand = ege
  var tge = async (e, t) => {
    let n = G('CreateTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_CreateTableCommand = tge
  var nge = async (e, t) => {
    let n = G('DeleteBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DeleteBackupCommand = nge
  var rge = async (e, t) => {
    let n = G('DeleteItem'),
      r
    return (r = JSON.stringify(hSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_DeleteItemCommand = rge
  var sge = async (e, t) => {
    let n = G('DeleteTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DeleteTableCommand = sge
  var oge = async (e, t) => {
    let n = G('DescribeBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeBackupCommand = oge
  var ige = async (e, t) => {
    let n = G('DescribeContinuousBackups'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeContinuousBackupsCommand = ige
  var age = async (e, t) => {
    let n = G('DescribeContributorInsights'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeContributorInsightsCommand = age
  var cge = async (e, t) => {
    let n = G('DescribeEndpoints'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeEndpointsCommand = cge
  var dge = async (e, t) => {
    let n = G('DescribeExport'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeExportCommand = dge
  var uge = async (e, t) => {
    let n = G('DescribeGlobalTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeGlobalTableCommand = uge
  var lge = async (e, t) => {
    let n = G('DescribeGlobalTableSettings'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeGlobalTableSettingsCommand = lge
  var mge = async (e, t) => {
    let n = G('DescribeImport'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeImportCommand = mge
  var pge = async (e, t) => {
    let n = G('DescribeKinesisStreamingDestination'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeKinesisStreamingDestinationCommand = pge
  var _ge = async (e, t) => {
    let n = G('DescribeLimits'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeLimitsCommand = _ge
  var fge = async (e, t) => {
    let n = G('DescribeTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeTableCommand = fge
  var hge = async (e, t) => {
    let n = G('DescribeTableReplicaAutoScaling'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeTableReplicaAutoScalingCommand = hge
  var gge = async (e, t) => {
    let n = G('DescribeTimeToLive'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DescribeTimeToLiveCommand = gge
  var yge = async (e, t) => {
    let n = G('DisableKinesisStreamingDestination'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_DisableKinesisStreamingDestinationCommand = yge
  var Ege = async (e, t) => {
    let n = G('EnableKinesisStreamingDestination'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_EnableKinesisStreamingDestinationCommand = Ege
  var Sge = async (e, t) => {
    let n = G('ExecuteStatement'),
      r
    return (r = JSON.stringify(ySe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_ExecuteStatementCommand = Sge
  var bge = async (e, t) => {
    let n = G('ExecuteTransaction'),
      r
    return (r = JSON.stringify(ESe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_ExecuteTransactionCommand = bge
  var vge = async (e, t) => {
    let n = G('ExportTableToPointInTime'),
      r
    return (r = JSON.stringify(bSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_ExportTableToPointInTimeCommand = vge
  var Cge = async (e, t) => {
    let n = G('GetItem'),
      r
    return (r = JSON.stringify(CSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_GetItemCommand = Cge
  var Tge = async (e, t) => {
    let n = G('ImportTable'),
      r
    return (r = JSON.stringify(PSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_ImportTableCommand = Tge
  var wge = async (e, t) => {
    let n = G('ListBackups'),
      r
    return (r = JSON.stringify(qSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_ListBackupsCommand = wge
  var Ige = async (e, t) => {
    let n = G('ListContributorInsights'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_ListContributorInsightsCommand = Ige
  var xge = async (e, t) => {
    let n = G('ListExports'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_ListExportsCommand = xge
  var Pge = async (e, t) => {
    let n = G('ListGlobalTables'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_ListGlobalTablesCommand = Pge
  var Rge = async (e, t) => {
    let n = G('ListImports'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_ListImportsCommand = Rge
  var Dge = async (e, t) => {
    let n = G('ListTables'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_ListTablesCommand = Dge
  var Age = async (e, t) => {
    let n = G('ListTagsOfResource'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_ListTagsOfResourceCommand = Age
  var Oge = async (e, t) => {
    let n = G('PutItem'),
      r
    return (r = JSON.stringify(BSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_PutItemCommand = Oge
  var Nge = async (e, t) => {
    let n = G('Query'),
      r
    return (r = JSON.stringify(GSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_QueryCommand = Nge
  var qge = async (e, t) => {
    let n = G('RestoreTableFromBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_RestoreTableFromBackupCommand = qge
  var kge = async (e, t) => {
    let n = G('RestoreTableToPointInTime'),
      r
    return (r = JSON.stringify(JSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_RestoreTableToPointInTimeCommand = kge
  var Mge = async (e, t) => {
    let n = G('Scan'),
      r
    return (r = JSON.stringify(QSe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_ScanCommand = Mge
  var Lge = async (e, t) => {
    let n = G('TagResource'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_TagResourceCommand = Lge
  var Uge = async (e, t) => {
    let n = G('TransactGetItems'),
      r
    return (r = JSON.stringify(tbe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_TransactGetItemsCommand = Uge
  var Fge = async (e, t) => {
    let n = G('TransactWriteItems'),
      r
    return (r = JSON.stringify(sbe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_TransactWriteItemsCommand = Fge
  var Bge = async (e, t) => {
    let n = G('UntagResource'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_UntagResourceCommand = Bge
  var jge = async (e, t) => {
    let n = G('UpdateContinuousBackups'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateContinuousBackupsCommand = jge
  var Gge = async (e, t) => {
    let n = G('UpdateContributorInsights'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateContributorInsightsCommand = Gge
  var $ge = async (e, t) => {
    let n = G('UpdateGlobalTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateGlobalTableCommand = $ge
  var zge = async (e, t) => {
    let n = G('UpdateGlobalTableSettings'),
      r
    return (r = JSON.stringify(ibe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateGlobalTableSettingsCommand = zge
  var Hge = async (e, t) => {
    let n = G('UpdateItem'),
      r
    return (r = JSON.stringify(abe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateItemCommand = Hge
  var Vge = async (e, t) => {
    let n = G('UpdateTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateTableCommand = Vge
  var Yge = async (e, t) => {
    let n = G('UpdateTableReplicaAutoScaling'),
      r
    return (r = JSON.stringify(cbe(e, t))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateTableReplicaAutoScalingCommand = Yge
  var Wge = async (e, t) => {
    let n = G('UpdateTimeToLive'),
      r
    return (r = JSON.stringify((0, m._json)(e))), j(t, n, '/', void 0, r)
  }
  g.se_UpdateTimeToLiveCommand = Wge
  var Kge = async (e, t) => {
    if (e.statusCode >= 300) return Xge(e, t)
    let n = await Y(e.body, t),
      r = {}
    return (r = gbe(n, t)), { $metadata: P(e), ...r }
  }
  g.de_BatchExecuteStatementCommand = Kge
  var Xge = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Jge = async (e, t) => {
      if (e.statusCode >= 300) return Qge(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = ybe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_BatchGetItemCommand = Jge
  var Qge = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Zge = async (e, t) => {
      if (e.statusCode >= 300) return eye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Cbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_BatchWriteItemCommand = Zge
  var eye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await _l(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    tye = async (e, t) => {
      if (e.statusCode >= 300) return nye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Rbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_CreateBackupCommand = tye
  var nye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'BackupInUseException':
        case 'com.amazonaws.dynamodb#BackupInUseException':
          throw await YI(n, t)
        case 'ContinuousBackupsUnavailableException':
        case 'com.amazonaws.dynamodb#ContinuousBackupsUnavailableException':
          throw await PH(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'TableInUseException':
        case 'com.amazonaws.dynamodb#TableInUseException':
          throw await KI(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    rye = async (e, t) => {
      if (e.statusCode >= 300) return sye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Dbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_CreateGlobalTableCommand = rye
  var sye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'GlobalTableAlreadyExistsException':
        case 'com.amazonaws.dynamodb#GlobalTableAlreadyExistsException':
          throw await XEe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    oye = async (e, t) => {
      if (e.statusCode >= 300) return iye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Abe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_CreateTableCommand = oye
  var iye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    aye = async (e, t) => {
      if (e.statusCode >= 300) return cye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Obe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DeleteBackupCommand = aye
  var cye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'BackupInUseException':
        case 'com.amazonaws.dynamodb#BackupInUseException':
          throw await YI(n, t)
        case 'BackupNotFoundException':
        case 'com.amazonaws.dynamodb#BackupNotFoundException':
          throw await WI(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    dye = async (e, t) => {
      if (e.statusCode >= 300) return uye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Nbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DeleteItemCommand = dye
  var uye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await vg(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await _l(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await Tg(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    lye = async (e, t) => {
      if (e.statusCode >= 300) return mye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = kbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DeleteTableCommand = lye
  var mye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    pye = async (e, t) => {
      if (e.statusCode >= 300) return _ye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Mbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeBackupCommand = pye
  var _ye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'BackupNotFoundException':
        case 'com.amazonaws.dynamodb#BackupNotFoundException':
          throw await WI(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    fye = async (e, t) => {
      if (e.statusCode >= 300) return hye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Lbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeContinuousBackupsCommand = fye
  var hye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    gye = async (e, t) => {
      if (e.statusCode >= 300) return yye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Ube(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeContributorInsightsCommand = gye
  var yye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Eye = async (e, t) => {
      if (e.statusCode >= 300) return Sye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_DescribeEndpointsCommand = Eye
  var Sye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body),
        s = n.body
      return B({ output: e, parsedBody: s, errorCode: r })
    },
    bye = async (e, t) => {
      if (e.statusCode >= 300) return vye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Fbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeExportCommand = bye
  var vye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ExportNotFoundException':
        case 'com.amazonaws.dynamodb#ExportNotFoundException':
          throw await KEe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Cye = async (e, t) => {
      if (e.statusCode >= 300) return Tye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Bbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeGlobalTableCommand = Cye
  var Tye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await Cg(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    wye = async (e, t) => {
      if (e.statusCode >= 300) return Iye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = jbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeGlobalTableSettingsCommand = wye
  var Iye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await Cg(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    xye = async (e, t) => {
      if (e.statusCode >= 300) return Pye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Gbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeImportCommand = xye
  var Pye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ImportNotFoundException':
        case 'com.amazonaws.dynamodb#ImportNotFoundException':
          throw await QEe(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Rye = async (e, t) => {
      if (e.statusCode >= 300) return Dye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_DescribeKinesisStreamingDestinationCommand = Rye
  var Dye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Aye = async (e, t) => {
      if (e.statusCode >= 300) return Oye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_DescribeLimitsCommand = Aye
  var Oye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Nye = async (e, t) => {
      if (e.statusCode >= 300) return qye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = $be(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeTableCommand = Nye
  var qye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    kye = async (e, t) => {
      if (e.statusCode >= 300) return Mye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = zbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_DescribeTableReplicaAutoScalingCommand = kye
  var Mye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Lye = async (e, t) => {
      if (e.statusCode >= 300) return Uye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_DescribeTimeToLiveCommand = Lye
  var Uye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Fye = async (e, t) => {
      if (e.statusCode >= 300) return Bye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_DisableKinesisStreamingDestinationCommand = Fye
  var Bye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    jye = async (e, t) => {
      if (e.statusCode >= 300) return Gye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_EnableKinesisStreamingDestinationCommand = jye
  var Gye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    $ye = async (e, t) => {
      if (e.statusCode >= 300) return zye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Hbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ExecuteStatementCommand = $ye
  var zye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await vg(n, t)
        case 'DuplicateItemException':
        case 'com.amazonaws.dynamodb#DuplicateItemException':
          throw await YEe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await _l(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await Tg(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Hye = async (e, t) => {
      if (e.statusCode >= 300) return Vye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Vbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ExecuteTransactionCommand = Hye
  var Vye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'IdempotentParameterMismatchException':
        case 'com.amazonaws.dynamodb#IdempotentParameterMismatchException':
          throw await RH(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionCanceledException':
        case 'com.amazonaws.dynamodb#TransactionCanceledException':
          throw await XI(n, t)
        case 'TransactionInProgressException':
        case 'com.amazonaws.dynamodb#TransactionInProgressException':
          throw await NH(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Yye = async (e, t) => {
      if (e.statusCode >= 300) return Wye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Ybe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ExportTableToPointInTimeCommand = Yye
  var Wye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ExportConflictException':
        case 'com.amazonaws.dynamodb#ExportConflictException':
          throw await WEe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidExportTimeException':
        case 'com.amazonaws.dynamodb#InvalidExportTimeException':
          throw await eSe(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'PointInTimeRecoveryUnavailableException':
        case 'com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException':
          throw await DH(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Kye = async (e, t) => {
      if (e.statusCode >= 300) return Xye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Wbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_GetItemCommand = Kye
  var Xye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Jye = async (e, t) => {
      if (e.statusCode >= 300) return Qye(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Zbe(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ImportTableCommand = Jye
  var Qye = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ImportConflictException':
        case 'com.amazonaws.dynamodb#ImportConflictException':
          throw await JEe(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Zye = async (e, t) => {
      if (e.statusCode >= 300) return eEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = cve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ListBackupsCommand = Zye
  var eEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    tEe = async (e, t) => {
      if (e.statusCode >= 300) return nEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_ListContributorInsightsCommand = tEe
  var nEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    rEe = async (e, t) => {
      if (e.statusCode >= 300) return sEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_ListExportsCommand = rEe
  var sEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    oEe = async (e, t) => {
      if (e.statusCode >= 300) return iEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_ListGlobalTablesCommand = oEe
  var iEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    aEe = async (e, t) => {
      if (e.statusCode >= 300) return cEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = dve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ListImportsCommand = aEe
  var cEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    dEe = async (e, t) => {
      if (e.statusCode >= 300) return uEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_ListTablesCommand = dEe
  var uEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    lEe = async (e, t) => {
      if (e.statusCode >= 300) return mEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_ListTagsOfResourceCommand = lEe
  var mEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    pEe = async (e, t) => {
      if (e.statusCode >= 300) return _Ee(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = _ve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_PutItemCommand = pEe
  var _Ee = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await vg(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await _l(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await Tg(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    fEe = async (e, t) => {
      if (e.statusCode >= 300) return hEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = hve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_QueryCommand = fEe
  var hEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    gEe = async (e, t) => {
      if (e.statusCode >= 300) return yEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Ive(n, t)), { $metadata: P(e), ...r }
    }
  g.de_RestoreTableFromBackupCommand = gEe
  var yEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'BackupInUseException':
        case 'com.amazonaws.dynamodb#BackupInUseException':
          throw await YI(n, t)
        case 'BackupNotFoundException':
        case 'com.amazonaws.dynamodb#BackupNotFoundException':
          throw await WI(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'TableAlreadyExistsException':
        case 'com.amazonaws.dynamodb#TableAlreadyExistsException':
          throw await OH(n, t)
        case 'TableInUseException':
        case 'com.amazonaws.dynamodb#TableInUseException':
          throw await KI(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    EEe = async (e, t) => {
      if (e.statusCode >= 300) return SEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = xve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_RestoreTableToPointInTimeCommand = EEe
  var SEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'InvalidRestoreTimeException':
        case 'com.amazonaws.dynamodb#InvalidRestoreTimeException':
          throw await tSe(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'PointInTimeRecoveryUnavailableException':
        case 'com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException':
          throw await DH(n, t)
        case 'TableAlreadyExistsException':
        case 'com.amazonaws.dynamodb#TableAlreadyExistsException':
          throw await OH(n, t)
        case 'TableInUseException':
        case 'com.amazonaws.dynamodb#TableInUseException':
          throw await KI(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    bEe = async (e, t) => {
      if (e.statusCode >= 300) return vEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Pve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_ScanCommand = bEe
  var vEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    CEe = async (e, t) =>
      e.statusCode >= 300
        ? TEe(e, t)
        : (await (0, m.collectBody)(e.body, t), { $metadata: P(e) })
  g.de_TagResourceCommand = CEe
  var TEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    wEe = async (e, t) => {
      if (e.statusCode >= 300) return IEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Ave(n, t)), { $metadata: P(e), ...r }
    }
  g.de_TransactGetItemsCommand = wEe
  var IEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionCanceledException':
        case 'com.amazonaws.dynamodb#TransactionCanceledException':
          throw await XI(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    xEe = async (e, t) => {
      if (e.statusCode >= 300) return PEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Nve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_TransactWriteItemsCommand = xEe
  var PEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'IdempotentParameterMismatchException':
        case 'com.amazonaws.dynamodb#IdempotentParameterMismatchException':
          throw await RH(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionCanceledException':
        case 'com.amazonaws.dynamodb#TransactionCanceledException':
          throw await XI(n, t)
        case 'TransactionInProgressException':
        case 'com.amazonaws.dynamodb#TransactionInProgressException':
          throw await NH(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    REe = async (e, t) =>
      e.statusCode >= 300
        ? DEe(e, t)
        : (await (0, m.collectBody)(e.body, t), { $metadata: P(e) })
  g.de_UntagResourceCommand = REe
  var DEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    AEe = async (e, t) => {
      if (e.statusCode >= 300) return OEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = qve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_UpdateContinuousBackupsCommand = AEe
  var OEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ContinuousBackupsUnavailableException':
        case 'com.amazonaws.dynamodb#ContinuousBackupsUnavailableException':
          throw await PH(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    NEe = async (e, t) => {
      if (e.statusCode >= 300) return qEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_UpdateContributorInsightsCommand = NEe
  var qEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    kEe = async (e, t) => {
      if (e.statusCode >= 300) return MEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = kve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_UpdateGlobalTableCommand = kEe
  var MEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await Cg(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ReplicaAlreadyExistsException':
        case 'com.amazonaws.dynamodb#ReplicaAlreadyExistsException':
          throw await nSe(n, t)
        case 'ReplicaNotFoundException':
        case 'com.amazonaws.dynamodb#ReplicaNotFoundException':
          throw await AH(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ho(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    LEe = async (e, t) => {
      if (e.statusCode >= 300) return UEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Mve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_UpdateGlobalTableSettingsCommand = LEe
  var UEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await Cg(n, t)
        case 'IndexNotFoundException':
        case 'com.amazonaws.dynamodb#IndexNotFoundException':
          throw await ZEe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ReplicaNotFoundException':
        case 'com.amazonaws.dynamodb#ReplicaNotFoundException':
          throw await AH(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    FEe = async (e, t) => {
      if (e.statusCode >= 300) return BEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Lve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_UpdateItemCommand = FEe
  var BEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await vg(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await _l(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await en(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Dt(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await Tg(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    jEe = async (e, t) => {
      if (e.statusCode >= 300) return GEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Uve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_UpdateTableCommand = jEe
  var GEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    $Ee = async (e, t) => {
      if (e.statusCode >= 300) return zEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = Fve(n, t)), { $metadata: P(e), ...r }
    }
  g.de_UpdateTableReplicaAutoScalingCommand = $Ee
  var zEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    HEe = async (e, t) => {
      if (e.statusCode >= 300) return VEe(e, t)
      let n = await Y(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: P(e), ...r }
    }
  g.de_UpdateTimeToLiveCommand = HEe
  var VEe = async (e, t) => {
      let n = { ...e, body: await $(e.body, t) },
        r = z(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await K(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await re(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await ke(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await pn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await he(n, t)
        default:
          let s = n.body
          return B({ output: e, parsedBody: s, errorCode: r })
      }
    },
    YI = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.BackupInUseException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    WI = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.BackupNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    vg = async (e, t) => {
      let n = e.body,
        r = Pbe(n, t),
        s = new de.ConditionalCheckFailedException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    PH = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ContinuousBackupsUnavailableException({
          $metadata: P(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    YEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.DuplicateItemException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    WEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ExportConflictException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    KEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ExportNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    XEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.GlobalTableAlreadyExistsException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Cg = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.GlobalTableNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    RH = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.IdempotentParameterMismatchException({
          $metadata: P(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    JEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ImportConflictException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    QEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ImportNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    ZEe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.IndexNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    K = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.InternalServerError({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    re = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.InvalidEndpointException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    eSe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.InvalidExportTimeException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    tSe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.InvalidRestoreTimeException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    _l = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ItemCollectionSizeLimitExceededException({
          $metadata: P(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    ke = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.LimitExceededException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    DH = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.PointInTimeRecoveryUnavailableException({
          $metadata: P(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    en = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ProvisionedThroughputExceededException({
          $metadata: P(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    nSe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ReplicaAlreadyExistsException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    AH = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ReplicaNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Dt = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.RequestLimitExceeded({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    pn = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ResourceInUseException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    he = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.ResourceNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    OH = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.TableAlreadyExistsException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    KI = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.TableInUseException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ho = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.TableNotFoundException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    XI = async (e, t) => {
      let n = e.body,
        r = Ove(n, t),
        s = new de.TransactionCanceledException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Tg = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.TransactionConflictException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    NH = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new de.TransactionInProgressException({ $metadata: P(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    rSe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = sSe(s, t)), n),
        {},
      ),
    Pr = (e, t) =>
      de.AttributeValue.visit(e, {
        B: (n) => ({ B: t.base64Encoder(n) }),
        BOOL: (n) => ({ BOOL: n }),
        BS: (n) => ({ BS: pSe(n, t) }),
        L: (n) => ({ L: NSe(n, t) }),
        M: (n) => ({ M: kSe(n, t) }),
        N: (n) => ({ N: n }),
        NS: (n) => ({ NS: (0, m._json)(n) }),
        NULL: (n) => ({ NULL: n }),
        S: (n) => ({ S: n }),
        SS: (n) => ({ SS: (0, m._json)(n) }),
        _: (n, r) => ({ name: r }),
      }),
    qH = (e, t) => e.filter((n) => n != null).map((n) => Pr(n, t)),
    sSe = (e, t) => (0, m.take)(e, { Action: [], Value: (n) => Pr(n, t) }),
    oSe = (e, t) =>
      (0, m.take)(e, {
        PolicyName: [],
        TargetTrackingScalingPolicyConfiguration: (n) => iSe(n, t),
      }),
    bs = (e, t) =>
      (0, m.take)(e, {
        AutoScalingDisabled: [],
        AutoScalingRoleArn: [],
        MaximumUnits: [],
        MinimumUnits: [],
        ScalingPolicyUpdate: (n) => oSe(n, t),
      }),
    iSe = (e, t) =>
      (0, m.take)(e, {
        DisableScaleIn: [],
        ScaleInCooldown: [],
        ScaleOutCooldown: [],
        TargetValue: m.serializeFloat,
      }),
    aSe = (e, t) =>
      (0, m.take)(e, {
        ReturnConsumedCapacity: [],
        Statements: (n) => USe(n, t),
      }),
    cSe = (e, t) =>
      (0, m.take)(e, {
        RequestItems: (n) => dSe(n, t),
        ReturnConsumedCapacity: [],
      }),
    dSe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = OSe(s, t)), n),
        {},
      ),
    uSe = (e, t) =>
      (0, m.take)(e, {
        ConsistentRead: [],
        Parameters: (n) => QI(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
      }),
    lSe = (e, t) =>
      (0, m.take)(e, {
        RequestItems: (n) => mSe(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
      }),
    mSe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = ube(s, t)), n),
        {},
      ),
    pSe = (e, t) => e.filter((n) => n != null).map((n) => t.base64Encoder(n)),
    kH = (e, t) =>
      (0, m.take)(e, {
        AttributeValueList: (n) => qH(n, t),
        ComparisonOperator: [],
      }),
    _Se = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Key: (n) => _n(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    fSe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Key: (n) => _n(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    hSe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (n) => JI(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Key: (n) => _n(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    gSe = (e, t) => (0, m.take)(e, { Key: (n) => _n(n, t) }),
    ySe = (e, t) =>
      (0, m.take)(e, {
        ConsistentRead: [],
        Limit: [],
        NextToken: [],
        Parameters: (n) => QI(n, t),
        ReturnConsumedCapacity: [],
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
      }),
    ESe = (e, t) =>
      (0, m.take)(e, {
        ClientRequestToken: [!0, (n) => n ?? (0, bg.v4)()],
        ReturnConsumedCapacity: [],
        TransactStatements: (n) => LSe(n, t),
      }),
    JI = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = SSe(s, t)), n),
        {},
      ),
    SSe = (e, t) =>
      (0, m.take)(e, {
        AttributeValueList: (n) => qH(n, t),
        ComparisonOperator: [],
        Exists: [],
        Value: (n) => Pr(n, t),
      }),
    bSe = (e, t) =>
      (0, m.take)(e, {
        ClientToken: [!0, (n) => n ?? (0, bg.v4)()],
        ExportFormat: [],
        ExportTime: (n) => Math.round(n.getTime() / 1e3),
        ExportType: [],
        IncrementalExportSpecification: (n) => RSe(n, t),
        S3Bucket: [],
        S3BucketOwner: [],
        S3Prefix: [],
        S3SseAlgorithm: [],
        S3SseKmsKeyId: [],
        TableArn: [],
      }),
    Rr = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Pr(s, t)), n),
        {},
      ),
    MH = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = kH(s, t)), n),
        {},
      ),
    vSe = (e, t) =>
      (0, m.take)(e, {
        ExpressionAttributeNames: m._json,
        Key: (n) => _n(n, t),
        ProjectionExpression: [],
        TableName: [],
      }),
    CSe = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConsistentRead: [],
        ExpressionAttributeNames: m._json,
        Key: (n) => _n(n, t),
        ProjectionExpression: [],
        ReturnConsumedCapacity: [],
        TableName: [],
      }),
    TSe = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedWriteCapacityAutoScalingUpdate: (n) => bs(n, t),
      }),
    wSe = (e, t) => e.filter((n) => n != null).map((n) => TSe(n, t)),
    ISe = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedWriteCapacityAutoScalingSettingsUpdate: (n) => bs(n, t),
        ProvisionedWriteCapacityUnits: [],
      }),
    xSe = (e, t) => e.filter((n) => n != null).map((n) => ISe(n, t)),
    PSe = (e, t) =>
      (0, m.take)(e, {
        ClientToken: [!0, (n) => n ?? (0, bg.v4)()],
        InputCompressionType: [],
        InputFormat: [],
        InputFormatOptions: m._json,
        S3BucketSource: m._json,
        TableCreationParameters: m._json,
      }),
    RSe = (e, t) =>
      (0, m.take)(e, {
        ExportFromTime: (n) => Math.round(n.getTime() / 1e3),
        ExportToTime: (n) => Math.round(n.getTime() / 1e3),
        ExportViewType: [],
      }),
    _n = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Pr(s, t)), n),
        {},
      ),
    DSe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = kH(s, t)), n),
        {},
      ),
    ASe = (e, t) => e.filter((n) => n != null).map((n) => _n(n, t)),
    OSe = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConsistentRead: [],
        ExpressionAttributeNames: m._json,
        Keys: (n) => ASe(n, t),
        ProjectionExpression: [],
      }),
    NSe = (e, t) => e.filter((n) => n != null).map((n) => Pr(n, t)),
    qSe = (e, t) =>
      (0, m.take)(e, {
        BackupType: [],
        ExclusiveStartBackupArn: [],
        Limit: [],
        TableName: [],
        TimeRangeLowerBound: (n) => Math.round(n.getTime() / 1e3),
        TimeRangeUpperBound: (n) => Math.round(n.getTime() / 1e3),
      }),
    kSe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Pr(s, t)), n),
        {},
      ),
    MSe = (e, t) =>
      (0, m.take)(e, {
        Parameters: (n) => QI(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
      }),
    LSe = (e, t) => e.filter((n) => n != null).map((n) => MSe(n, t)),
    USe = (e, t) => e.filter((n) => n != null).map((n) => uSe(n, t)),
    QI = (e, t) => e.filter((n) => n != null).map((n) => Pr(n, t)),
    FSe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Item: (n) => ZI(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    BSe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (n) => JI(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Item: (n) => ZI(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    ZI = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Pr(s, t)), n),
        {},
      ),
    jSe = (e, t) => (0, m.take)(e, { Item: (n) => ZI(n, t) }),
    GSe = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConditionalOperator: [],
        ConsistentRead: [],
        ExclusiveStartKey: (n) => _n(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        FilterExpression: [],
        IndexName: [],
        KeyConditionExpression: [],
        KeyConditions: (n) => DSe(n, t),
        Limit: [],
        ProjectionExpression: [],
        QueryFilter: (n) => MH(n, t),
        ReturnConsumedCapacity: [],
        ScanIndexForward: [],
        Select: [],
        TableName: [],
      }),
    $Se = (e, t) =>
      (0, m.take)(e, {
        RegionName: [],
        ReplicaGlobalSecondaryIndexUpdates: (n) => VSe(n, t),
        ReplicaProvisionedReadCapacityAutoScalingUpdate: (n) => bs(n, t),
      }),
    zSe = (e, t) => e.filter((n) => n != null).map((n) => $Se(n, t)),
    HSe = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedReadCapacityAutoScalingUpdate: (n) => bs(n, t),
      }),
    VSe = (e, t) => e.filter((n) => n != null).map((n) => HSe(n, t)),
    YSe = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedReadCapacityAutoScalingSettingsUpdate: (n) => bs(n, t),
        ProvisionedReadCapacityUnits: [],
      }),
    WSe = (e, t) => e.filter((n) => n != null).map((n) => YSe(n, t)),
    KSe = (e, t) =>
      (0, m.take)(e, {
        RegionName: [],
        ReplicaGlobalSecondaryIndexSettingsUpdate: (n) => WSe(n, t),
        ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: (n) =>
          bs(n, t),
        ReplicaProvisionedReadCapacityUnits: [],
        ReplicaTableClass: [],
      }),
    XSe = (e, t) => e.filter((n) => n != null).map((n) => KSe(n, t)),
    JSe = (e, t) =>
      (0, m.take)(e, {
        BillingModeOverride: [],
        GlobalSecondaryIndexOverride: m._json,
        LocalSecondaryIndexOverride: m._json,
        ProvisionedThroughputOverride: m._json,
        RestoreDateTime: (n) => Math.round(n.getTime() / 1e3),
        SSESpecificationOverride: m._json,
        SourceTableArn: [],
        SourceTableName: [],
        TargetTableName: [],
        UseLatestRestorableTime: [],
      }),
    QSe = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConditionalOperator: [],
        ConsistentRead: [],
        ExclusiveStartKey: (n) => _n(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        FilterExpression: [],
        IndexName: [],
        Limit: [],
        ProjectionExpression: [],
        ReturnConsumedCapacity: [],
        ScanFilter: (n) => MH(n, t),
        Segment: [],
        Select: [],
        TableName: [],
        TotalSegments: [],
      }),
    ZSe = (e, t) => (0, m.take)(e, { Get: (n) => vSe(n, t) }),
    ebe = (e, t) => e.filter((n) => n != null).map((n) => ZSe(n, t)),
    tbe = (e, t) =>
      (0, m.take)(e, {
        ReturnConsumedCapacity: [],
        TransactItems: (n) => ebe(n, t),
      }),
    nbe = (e, t) =>
      (0, m.take)(e, {
        ConditionCheck: (n) => _Se(n, t),
        Delete: (n) => fSe(n, t),
        Put: (n) => FSe(n, t),
        Update: (n) => obe(n, t),
      }),
    rbe = (e, t) => e.filter((n) => n != null).map((n) => nbe(n, t)),
    sbe = (e, t) =>
      (0, m.take)(e, {
        ClientRequestToken: [!0, (n) => n ?? (0, bg.v4)()],
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        TransactItems: (n) => rbe(n, t),
      }),
    obe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Key: (n) => _n(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
        UpdateExpression: [],
      }),
    ibe = (e, t) =>
      (0, m.take)(e, {
        GlobalTableBillingMode: [],
        GlobalTableGlobalSecondaryIndexSettingsUpdate: (n) => xSe(n, t),
        GlobalTableName: [],
        GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: (n) =>
          bs(n, t),
        GlobalTableProvisionedWriteCapacityUnits: [],
        ReplicaSettingsUpdate: (n) => XSe(n, t),
      }),
    abe = (e, t) =>
      (0, m.take)(e, {
        AttributeUpdates: (n) => rSe(n, t),
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (n) => JI(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => Rr(n, t),
        Key: (n) => _n(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
        UpdateExpression: [],
      }),
    cbe = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexUpdates: (n) => wSe(n, t),
        ProvisionedWriteCapacityAutoScalingUpdate: (n) => bs(n, t),
        ReplicaUpdates: (n) => zSe(n, t),
        TableName: [],
      }),
    dbe = (e, t) =>
      (0, m.take)(e, {
        DeleteRequest: (n) => gSe(n, t),
        PutRequest: (n) => jSe(n, t),
      }),
    ube = (e, t) => e.filter((n) => n != null).map((n) => dbe(n, t)),
    lbe = (e, t) =>
      (0, m.take)(e, {
        ArchivalBackupArn: m.expectString,
        ArchivalDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ArchivalReason: m.expectString,
      }),
    Yn = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (
          s === null || (n[r] = ga((0, ha.awsExpectUnion)(s), t)), n
        ),
        {},
      ),
    ga = (e, t) =>
      e.B != null
        ? { B: t.base64Decoder(e.B) }
        : (0, m.expectBoolean)(e.BOOL) !== void 0
          ? { BOOL: (0, m.expectBoolean)(e.BOOL) }
          : e.BS != null
            ? { BS: wbe(e.BS, t) }
            : e.L != null
              ? { L: ave(e.L, t) }
              : e.M != null
                ? { M: uve(e.M, t) }
                : (0, m.expectString)(e.N) !== void 0
                  ? { N: (0, m.expectString)(e.N) }
                  : e.NS != null
                    ? { NS: (0, m._json)(e.NS) }
                    : (0, m.expectBoolean)(e.NULL) !== void 0
                      ? { NULL: (0, m.expectBoolean)(e.NULL) }
                      : (0, m.expectString)(e.S) !== void 0
                        ? { S: (0, m.expectString)(e.S) }
                        : e.SS != null
                          ? { SS: (0, m._json)(e.SS) }
                          : { $unknown: Object.entries(e)[0] },
    mbe = (e, t) =>
      (0, m.take)(e, {
        PolicyName: m.expectString,
        TargetTrackingScalingPolicyConfiguration: (n) => _be(n, t),
      }),
    pbe = (e, t) => (e || []).filter((r) => r != null).map((r) => mbe(r, t)),
    Ss = (e, t) =>
      (0, m.take)(e, {
        AutoScalingDisabled: m.expectBoolean,
        AutoScalingRoleArn: m.expectString,
        MaximumUnits: m.expectLong,
        MinimumUnits: m.expectLong,
        ScalingPolicies: (n) => pbe(n, t),
      }),
    _be = (e, t) =>
      (0, m.take)(e, {
        DisableScaleIn: m.expectBoolean,
        ScaleInCooldown: m.expectInt32,
        ScaleOutCooldown: m.expectInt32,
        TargetValue: m.limitedParseDouble,
      }),
    LH = (e, t) =>
      (0, m.take)(e, {
        BackupDetails: (n) => UH(n, t),
        SourceTableDetails: (n) => Rve(n, t),
        SourceTableFeatureDetails: (n) => Dve(n, t),
      }),
    UH = (e, t) =>
      (0, m.take)(e, {
        BackupArn: m.expectString,
        BackupCreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupExpiryDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupName: m.expectString,
        BackupSizeBytes: m.expectLong,
        BackupStatus: m.expectString,
        BackupType: m.expectString,
      }),
    fbe = (e, t) => (e || []).filter((r) => r != null).map((r) => hbe(r, t)),
    hbe = (e, t) =>
      (0, m.take)(e, {
        BackupArn: m.expectString,
        BackupCreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupExpiryDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupName: m.expectString,
        BackupSizeBytes: m.expectLong,
        BackupStatus: m.expectString,
        BackupType: m.expectString,
        TableArn: m.expectString,
        TableId: m.expectString,
        TableName: m.expectString,
      }),
    gbe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => ya(n, t),
        Responses: (n) => lve(n, t),
      }),
    ybe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => ya(n, t),
        Responses: (n) => Sbe(n, t),
        UnprocessedKeys: (n) => Ebe(n, t),
      }),
    Ebe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = ive(s, t)), n),
        {},
      ),
    Sbe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Ig(s, t)), n),
        {},
      ),
    bbe = (e, t) =>
      (0, m.take)(e, {
        Code: m.expectString,
        Item: (n) => Yn(n, t),
        Message: m.expectString,
      }),
    vbe = (e, t) =>
      (0, m.take)(e, {
        Error: (n) => bbe(n, t),
        Item: (n) => Yn(n, t),
        TableName: m.expectString,
      }),
    Cbe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => ya(n, t),
        ItemCollectionMetrics: (n) => zH(n, t),
        UnprocessedItems: (n) => Tbe(n, t),
      }),
    Tbe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = jve(s, t)), n),
        {},
      ),
    FH = (e, t) =>
      (0, m.take)(e, {
        BillingMode: m.expectString,
        LastUpdateToPayPerRequestDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
      }),
    wbe = (e, t) =>
      (e || []).filter((r) => r != null).map((r) => t.base64Decoder(r)),
    Ibe = (e, t) =>
      (0, m.take)(e, {
        Code: m.expectString,
        Item: (n) => Yn(n, t),
        Message: m.expectString,
      }),
    xbe = (e, t) => (e || []).filter((r) => r != null).map((r) => Ibe(r, t)),
    BH = (e, t) =>
      (0, m.take)(e, {
        CapacityUnits: m.limitedParseDouble,
        ReadCapacityUnits: m.limitedParseDouble,
        WriteCapacityUnits: m.limitedParseDouble,
      }),
    Pbe = (e, t) =>
      (0, m.take)(e, { Item: (n) => Yn(n, t), message: m.expectString }),
    vs = (e, t) =>
      (0, m.take)(e, {
        CapacityUnits: m.limitedParseDouble,
        GlobalSecondaryIndexes: (n) => xH(n, t),
        LocalSecondaryIndexes: (n) => xH(n, t),
        ReadCapacityUnits: m.limitedParseDouble,
        Table: (n) => BH(n, t),
        TableName: m.expectString,
        WriteCapacityUnits: m.limitedParseDouble,
      }),
    ya = (e, t) => (e || []).filter((r) => r != null).map((r) => vs(r, t)),
    jH = (e, t) =>
      (0, m.take)(e, {
        ContinuousBackupsStatus: m.expectString,
        PointInTimeRecoveryDescription: (n) => mve(n, t),
      }),
    Rbe = (e, t) => (0, m.take)(e, { BackupDetails: (n) => UH(n, t) }),
    Dbe = (e, t) => (0, m.take)(e, { GlobalTableDescription: (n) => ex(n, t) }),
    Abe = (e, t) => (0, m.take)(e, { TableDescription: (n) => Ea(n, t) }),
    Obe = (e, t) => (0, m.take)(e, { BackupDescription: (n) => LH(n, t) }),
    Nbe = (e, t) =>
      (0, m.take)(e, {
        Attributes: (n) => Yn(n, t),
        ConsumedCapacity: (n) => vs(n, t),
        ItemCollectionMetrics: (n) => wg(n, t),
      }),
    qbe = (e, t) => (0, m.take)(e, { Key: (n) => fl(n, t) }),
    kbe = (e, t) => (0, m.take)(e, { TableDescription: (n) => Ea(n, t) }),
    Mbe = (e, t) => (0, m.take)(e, { BackupDescription: (n) => LH(n, t) }),
    Lbe = (e, t) =>
      (0, m.take)(e, { ContinuousBackupsDescription: (n) => jH(n, t) }),
    Ube = (e, t) =>
      (0, m.take)(e, {
        ContributorInsightsRuleList: m._json,
        ContributorInsightsStatus: m.expectString,
        FailureException: m._json,
        IndexName: m.expectString,
        LastUpdateDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableName: m.expectString,
      }),
    Fbe = (e, t) => (0, m.take)(e, { ExportDescription: (n) => GH(n, t) }),
    Bbe = (e, t) => (0, m.take)(e, { GlobalTableDescription: (n) => ex(n, t) }),
    jbe = (e, t) =>
      (0, m.take)(e, {
        GlobalTableName: m.expectString,
        ReplicaSettings: (n) => WH(n, t),
      }),
    Gbe = (e, t) => (0, m.take)(e, { ImportTableDescription: (n) => $H(n, t) }),
    $be = (e, t) => (0, m.take)(e, { Table: (n) => Ea(n, t) }),
    zbe = (e, t) =>
      (0, m.take)(e, { TableAutoScalingDescription: (n) => XH(n, t) }),
    Hbe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => vs(n, t),
        Items: (n) => Ig(n, t),
        LastEvaluatedKey: (n) => fl(n, t),
        NextToken: m.expectString,
      }),
    Vbe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => ya(n, t),
        Responses: (n) => HH(n, t),
      }),
    GH = (e, t) =>
      (0, m.take)(e, {
        BilledSizeBytes: m.expectLong,
        ClientToken: m.expectString,
        EndTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ExportArn: m.expectString,
        ExportFormat: m.expectString,
        ExportManifest: m.expectString,
        ExportStatus: m.expectString,
        ExportTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ExportType: m.expectString,
        FailureCode: m.expectString,
        FailureMessage: m.expectString,
        IncrementalExportSpecification: (n) => eve(n, t),
        ItemCount: m.expectLong,
        S3Bucket: m.expectString,
        S3BucketOwner: m.expectString,
        S3Prefix: m.expectString,
        S3SseAlgorithm: m.expectString,
        S3SseKmsKeyId: m.expectString,
        StartTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableArn: m.expectString,
        TableId: m.expectString,
      }),
    Ybe = (e, t) => (0, m.take)(e, { ExportDescription: (n) => GH(n, t) }),
    Wbe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => vs(n, t),
        Item: (n) => Yn(n, t),
      }),
    Kbe = (e, t) =>
      (0, m.take)(e, {
        Backfilling: m.expectBoolean,
        IndexArn: m.expectString,
        IndexName: m.expectString,
        IndexSizeBytes: m.expectLong,
        IndexStatus: m.expectString,
        ItemCount: m.expectLong,
        KeySchema: m._json,
        Projection: m._json,
        ProvisionedThroughput: (n) => VH(n, t),
      }),
    Xbe = (e, t) => (e || []).filter((r) => r != null).map((r) => Kbe(r, t)),
    ex = (e, t) =>
      (0, m.take)(e, {
        CreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        GlobalTableArn: m.expectString,
        GlobalTableName: m.expectString,
        GlobalTableStatus: m.expectString,
        ReplicationGroup: (n) => YH(n, t),
      }),
    Jbe = (e, t) =>
      (0, m.take)(e, {
        CloudWatchLogGroupArn: m.expectString,
        EndTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ImportArn: m.expectString,
        ImportStatus: m.expectString,
        InputFormat: m.expectString,
        S3BucketSource: m._json,
        StartTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableArn: m.expectString,
      }),
    Qbe = (e, t) => (e || []).filter((r) => r != null).map((r) => Jbe(r, t)),
    $H = (e, t) =>
      (0, m.take)(e, {
        ClientToken: m.expectString,
        CloudWatchLogGroupArn: m.expectString,
        EndTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ErrorCount: m.expectLong,
        FailureCode: m.expectString,
        FailureMessage: m.expectString,
        ImportArn: m.expectString,
        ImportStatus: m.expectString,
        ImportedItemCount: m.expectLong,
        InputCompressionType: m.expectString,
        InputFormat: m.expectString,
        InputFormatOptions: m._json,
        ProcessedItemCount: m.expectLong,
        ProcessedSizeBytes: m.expectLong,
        S3BucketSource: m._json,
        StartTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableArn: m.expectString,
        TableCreationParameters: m._json,
        TableId: m.expectString,
      }),
    Zbe = (e, t) => (0, m.take)(e, { ImportTableDescription: (n) => $H(n, t) }),
    eve = (e, t) =>
      (0, m.take)(e, {
        ExportFromTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ExportToTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ExportViewType: m.expectString,
      }),
    tve = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (
          s === null || (n[r] = ga((0, ha.awsExpectUnion)(s), t)), n
        ),
        {},
      ),
    wg = (e, t) =>
      (0, m.take)(e, {
        ItemCollectionKey: (n) => tve(n, t),
        SizeEstimateRangeGB: (n) => rve(n, t),
      }),
    nve = (e, t) => (e || []).filter((r) => r != null).map((r) => wg(r, t)),
    zH = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = nve(s, t)), n),
        {},
      ),
    rve = (e, t) =>
      (e || [])
        .filter((r) => r != null)
        .map((r) => (0, m.limitedParseDouble)(r)),
    Ig = (e, t) => (e || []).filter((r) => r != null).map((r) => Yn(r, t)),
    sve = (e, t) => (0, m.take)(e, { Item: (n) => Yn(n, t) }),
    HH = (e, t) => (e || []).filter((r) => r != null).map((r) => sve(r, t)),
    fl = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (
          s === null || (n[r] = ga((0, ha.awsExpectUnion)(s), t)), n
        ),
        {},
      ),
    ove = (e, t) => (e || []).filter((r) => r != null).map((r) => fl(r, t)),
    ive = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConsistentRead: m.expectBoolean,
        ExpressionAttributeNames: m._json,
        Keys: (n) => ove(n, t),
        ProjectionExpression: m.expectString,
      }),
    ave = (e, t) =>
      (e || [])
        .filter((r) => r != null)
        .map((r) => ga((0, ha.awsExpectUnion)(r), t)),
    cve = (e, t) =>
      (0, m.take)(e, {
        BackupSummaries: (n) => fbe(n, t),
        LastEvaluatedBackupArn: m.expectString,
      }),
    dve = (e, t) =>
      (0, m.take)(e, {
        ImportSummaryList: (n) => Qbe(n, t),
        NextToken: m.expectString,
      }),
    uve = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (
          s === null || (n[r] = ga((0, ha.awsExpectUnion)(s), t)), n
        ),
        {},
      ),
    lve = (e, t) => (e || []).filter((r) => r != null).map((r) => vbe(r, t)),
    mve = (e, t) =>
      (0, m.take)(e, {
        EarliestRestorableDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        LatestRestorableDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        PointInTimeRecoveryStatus: m.expectString,
      }),
    VH = (e, t) =>
      (0, m.take)(e, {
        LastDecreaseDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        LastIncreaseDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        NumberOfDecreasesToday: m.expectLong,
        ReadCapacityUnits: m.expectLong,
        WriteCapacityUnits: m.expectLong,
      }),
    pve = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (
          s === null || (n[r] = ga((0, ha.awsExpectUnion)(s), t)), n
        ),
        {},
      ),
    _ve = (e, t) =>
      (0, m.take)(e, {
        Attributes: (n) => Yn(n, t),
        ConsumedCapacity: (n) => vs(n, t),
        ItemCollectionMetrics: (n) => wg(n, t),
      }),
    fve = (e, t) => (0, m.take)(e, { Item: (n) => pve(n, t) }),
    hve = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => vs(n, t),
        Count: m.expectInt32,
        Items: (n) => Ig(n, t),
        LastEvaluatedKey: (n) => fl(n, t),
        ScannedCount: m.expectInt32,
      }),
    gve = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexes: (n) => bve(n, t),
        RegionName: m.expectString,
        ReplicaProvisionedReadCapacityAutoScalingSettings: (n) => Ss(n, t),
        ReplicaProvisionedWriteCapacityAutoScalingSettings: (n) => Ss(n, t),
        ReplicaStatus: m.expectString,
      }),
    yve = (e, t) => (e || []).filter((r) => r != null).map((r) => gve(r, t)),
    Eve = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexes: m._json,
        KMSMasterKeyId: m.expectString,
        ProvisionedThroughputOverride: m._json,
        RegionName: m.expectString,
        ReplicaInaccessibleDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ReplicaStatus: m.expectString,
        ReplicaStatusDescription: m.expectString,
        ReplicaStatusPercentProgress: m.expectString,
        ReplicaTableClassSummary: (n) => tx(n, t),
      }),
    YH = (e, t) => (e || []).filter((r) => r != null).map((r) => Eve(r, t)),
    Sve = (e, t) =>
      (0, m.take)(e, {
        IndexName: m.expectString,
        IndexStatus: m.expectString,
        ProvisionedReadCapacityAutoScalingSettings: (n) => Ss(n, t),
        ProvisionedWriteCapacityAutoScalingSettings: (n) => Ss(n, t),
      }),
    bve = (e, t) => (e || []).filter((r) => r != null).map((r) => Sve(r, t)),
    vve = (e, t) =>
      (0, m.take)(e, {
        IndexName: m.expectString,
        IndexStatus: m.expectString,
        ProvisionedReadCapacityAutoScalingSettings: (n) => Ss(n, t),
        ProvisionedReadCapacityUnits: m.expectLong,
        ProvisionedWriteCapacityAutoScalingSettings: (n) => Ss(n, t),
        ProvisionedWriteCapacityUnits: m.expectLong,
      }),
    Cve = (e, t) => (e || []).filter((r) => r != null).map((r) => vve(r, t)),
    Tve = (e, t) =>
      (0, m.take)(e, {
        RegionName: m.expectString,
        ReplicaBillingModeSummary: (n) => FH(n, t),
        ReplicaGlobalSecondaryIndexSettings: (n) => Cve(n, t),
        ReplicaProvisionedReadCapacityAutoScalingSettings: (n) => Ss(n, t),
        ReplicaProvisionedReadCapacityUnits: m.expectLong,
        ReplicaProvisionedWriteCapacityAutoScalingSettings: (n) => Ss(n, t),
        ReplicaProvisionedWriteCapacityUnits: m.expectLong,
        ReplicaStatus: m.expectString,
        ReplicaTableClassSummary: (n) => tx(n, t),
      }),
    WH = (e, t) => (e || []).filter((r) => r != null).map((r) => Tve(r, t)),
    wve = (e, t) =>
      (0, m.take)(e, {
        RestoreDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        RestoreInProgress: m.expectBoolean,
        SourceBackupArn: m.expectString,
        SourceTableArn: m.expectString,
      }),
    Ive = (e, t) => (0, m.take)(e, { TableDescription: (n) => Ea(n, t) }),
    xve = (e, t) => (0, m.take)(e, { TableDescription: (n) => Ea(n, t) }),
    Pve = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => vs(n, t),
        Count: m.expectInt32,
        Items: (n) => Ig(n, t),
        LastEvaluatedKey: (n) => fl(n, t),
        ScannedCount: m.expectInt32,
      }),
    xH = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = BH(s, t)), n),
        {},
      ),
    Rve = (e, t) =>
      (0, m.take)(e, {
        BillingMode: m.expectString,
        ItemCount: m.expectLong,
        KeySchema: m._json,
        ProvisionedThroughput: m._json,
        TableArn: m.expectString,
        TableCreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableId: m.expectString,
        TableName: m.expectString,
        TableSizeBytes: m.expectLong,
      }),
    Dve = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexes: m._json,
        LocalSecondaryIndexes: m._json,
        SSEDescription: (n) => KH(n, t),
        StreamDescription: m._json,
        TimeToLiveDescription: m._json,
      }),
    KH = (e, t) =>
      (0, m.take)(e, {
        InaccessibleEncryptionDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        KMSMasterKeyArn: m.expectString,
        SSEType: m.expectString,
        Status: m.expectString,
      }),
    XH = (e, t) =>
      (0, m.take)(e, {
        Replicas: (n) => yve(n, t),
        TableName: m.expectString,
        TableStatus: m.expectString,
      }),
    tx = (e, t) =>
      (0, m.take)(e, {
        LastUpdateDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableClass: m.expectString,
      }),
    Ea = (e, t) =>
      (0, m.take)(e, {
        ArchivalSummary: (n) => lbe(n, t),
        AttributeDefinitions: m._json,
        BillingModeSummary: (n) => FH(n, t),
        CreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        DeletionProtectionEnabled: m.expectBoolean,
        GlobalSecondaryIndexes: (n) => Xbe(n, t),
        GlobalTableVersion: m.expectString,
        ItemCount: m.expectLong,
        KeySchema: m._json,
        LatestStreamArn: m.expectString,
        LatestStreamLabel: m.expectString,
        LocalSecondaryIndexes: m._json,
        ProvisionedThroughput: (n) => VH(n, t),
        Replicas: (n) => YH(n, t),
        RestoreSummary: (n) => wve(n, t),
        SSEDescription: (n) => KH(n, t),
        StreamSpecification: m._json,
        TableArn: m.expectString,
        TableClassSummary: (n) => tx(n, t),
        TableId: m.expectString,
        TableName: m.expectString,
        TableSizeBytes: m.expectLong,
        TableStatus: m.expectString,
      }),
    Ave = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => ya(n, t),
        Responses: (n) => HH(n, t),
      }),
    Ove = (e, t) =>
      (0, m.take)(e, {
        CancellationReasons: (n) => xbe(n, t),
        Message: m.expectString,
      }),
    Nve = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => ya(n, t),
        ItemCollectionMetrics: (n) => zH(n, t),
      }),
    qve = (e, t) =>
      (0, m.take)(e, { ContinuousBackupsDescription: (n) => jH(n, t) }),
    kve = (e, t) => (0, m.take)(e, { GlobalTableDescription: (n) => ex(n, t) }),
    Mve = (e, t) =>
      (0, m.take)(e, {
        GlobalTableName: m.expectString,
        ReplicaSettings: (n) => WH(n, t),
      }),
    Lve = (e, t) =>
      (0, m.take)(e, {
        Attributes: (n) => Yn(n, t),
        ConsumedCapacity: (n) => vs(n, t),
        ItemCollectionMetrics: (n) => wg(n, t),
      }),
    Uve = (e, t) => (0, m.take)(e, { TableDescription: (n) => Ea(n, t) }),
    Fve = (e, t) =>
      (0, m.take)(e, { TableAutoScalingDescription: (n) => XH(n, t) }),
    Bve = (e, t) =>
      (0, m.take)(e, {
        DeleteRequest: (n) => qbe(n, t),
        PutRequest: (n) => fve(n, t),
      }),
    jve = (e, t) => (e || []).filter((r) => r != null).map((r) => Bve(r, t)),
    P = (e) => ({
      httpStatusCode: e.statusCode,
      requestId:
        e.headers['x-amzn-requestid'] ??
        e.headers['x-amzn-request-id'] ??
        e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }),
    Gve = (e, t) => (0, m.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    B = (0, m.withBaseException)(Khe.DynamoDBServiceException),
    j = async (e, t, n, r, s) => {
      let {
          hostname: o,
          protocol: i = 'https',
          port: a,
          path: c,
        } = await e.endpoint(),
        u = {
          protocol: i,
          hostname: o,
          port: a,
          method: 'POST',
          path: c.endsWith('/') ? c.slice(0, -1) + n : c + n,
          headers: t,
        }
      return (
        r !== void 0 && (u.hostname = r),
        s !== void 0 && (u.body = s),
        new Whe.HttpRequest(u)
      )
    }
  function G(e) {
    return {
      'content-type': 'application/x-amz-json-1.0',
      'x-amz-target': `DynamoDB_20120810.${e}`,
    }
  }
  var Y = (e, t) => Gve(e, t).then((n) => (n.length ? JSON.parse(n) : {})),
    $ = async (e, t) => {
      let n = await Y(e, t)
      return (n.message = n.message ?? n.Message), n
    },
    z = (e, t) => {
      let n = (o, i) =>
          Object.keys(o).find((a) => a.toLowerCase() === i.toLowerCase()),
        r = (o) => {
          let i = o
          return (
            typeof i == 'number' && (i = i.toString()),
            i.indexOf(',') >= 0 && (i = i.split(',')[0]),
            i.indexOf(':') >= 0 && (i = i.split(':')[0]),
            i.indexOf('#') >= 0 && (i = i.split('#')[1]),
            i
          )
        },
        s = n(e.headers, 'x-amzn-errortype')
      if (s !== void 0) return r(e.headers[s])
      if (t.code !== void 0) return r(t.code)
      if (t.__type !== void 0) return r(t.__type)
    }
})
var xg = l((Sa) => {
  'use strict'
  Object.defineProperty(Sa, '__esModule', { value: !0 })
  Sa.DescribeEndpointsCommand = Sa.$Command = void 0
  var $ve = q(),
    zve = k(),
    QH = v()
  Object.defineProperty(Sa, '$Command', {
    enumerable: !0,
    get: function () {
      return QH.Command
    },
  })
  var Hve = D(),
    JH = F(),
    nx = class e extends QH.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, zve.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, $ve.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeEndpointsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Hve.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeEndpoints',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, JH.se_DescribeEndpointsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, JH.de_DescribeEndpointsCommand)(t, n)
      }
    }
  Sa.DescribeEndpointsCommand = nx
})
var ZH = l((Pg) => {
  'use strict'
  Object.defineProperty(Pg, '__esModule', { value: !0 })
  Pg.resolveClientEndpointParameters = void 0
  var Vve = (e) => ({
    ...e,
    useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
    useFipsEndpoint: e.useFipsEndpoint ?? !1,
    defaultSigningName: 'dynamodb',
  })
  Pg.resolveClientEndpointParameters = Vve
})
var e2 = l((lVe, Yve) => {
  Yve.exports = {
    name: '@aws-sdk/client-dynamodb',
    description:
      'AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native',
    version: '3.433.0',
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      'build:cjs': 'tsc -p tsconfig.cjs.json',
      'build:docs': 'typedoc',
      'build:es': 'tsc -p tsconfig.es.json',
      'build:include:deps':
        'lerna run --scope $npm_package_name --include-dependencies build',
      'build:types': 'tsc -p tsconfig.types.json',
      'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
      clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
      'extract:docs': 'api-extractor run --local',
      'generate:client':
        'node ../../scripts/generate-clients/single-service --solo dynamodb',
    },
    main: './dist-cjs/index.js',
    types: './dist-types/index.d.ts',
    module: './dist-es/index.js',
    sideEffects: !1,
    dependencies: {
      '@aws-crypto/sha256-browser': '3.0.0',
      '@aws-crypto/sha256-js': '3.0.0',
      '@aws-sdk/client-sts': '3.433.0',
      '@aws-sdk/core': '3.433.0',
      '@aws-sdk/credential-provider-node': '3.433.0',
      '@aws-sdk/middleware-endpoint-discovery': '3.433.0',
      '@aws-sdk/middleware-host-header': '3.433.0',
      '@aws-sdk/middleware-logger': '3.433.0',
      '@aws-sdk/middleware-recursion-detection': '3.433.0',
      '@aws-sdk/middleware-signing': '3.433.0',
      '@aws-sdk/middleware-user-agent': '3.433.0',
      '@aws-sdk/region-config-resolver': '3.433.0',
      '@aws-sdk/types': '3.433.0',
      '@aws-sdk/util-endpoints': '3.433.0',
      '@aws-sdk/util-user-agent-browser': '3.433.0',
      '@aws-sdk/util-user-agent-node': '3.433.0',
      '@smithy/config-resolver': '^2.0.16',
      '@smithy/fetch-http-handler': '^2.2.4',
      '@smithy/hash-node': '^2.0.12',
      '@smithy/invalid-dependency': '^2.0.12',
      '@smithy/middleware-content-length': '^2.0.14',
      '@smithy/middleware-endpoint': '^2.1.3',
      '@smithy/middleware-retry': '^2.0.18',
      '@smithy/middleware-serde': '^2.0.12',
      '@smithy/middleware-stack': '^2.0.6',
      '@smithy/node-config-provider': '^2.1.3',
      '@smithy/node-http-handler': '^2.1.8',
      '@smithy/protocol-http': '^3.0.8',
      '@smithy/smithy-client': '^2.1.12',
      '@smithy/types': '^2.4.0',
      '@smithy/url-parser': '^2.0.12',
      '@smithy/util-base64': '^2.0.0',
      '@smithy/util-body-length-browser': '^2.0.0',
      '@smithy/util-body-length-node': '^2.1.0',
      '@smithy/util-defaults-mode-browser': '^2.0.16',
      '@smithy/util-defaults-mode-node': '^2.0.21',
      '@smithy/util-retry': '^2.0.5',
      '@smithy/util-utf8': '^2.0.0',
      '@smithy/util-waiter': '^2.0.12',
      tslib: '^2.5.0',
      uuid: '^8.3.2',
    },
    devDependencies: {
      '@smithy/service-client-documentation-generator': '^2.0.0',
      '@tsconfig/node14': '1.0.3',
      '@types/node': '^14.14.31',
      '@types/uuid': '^8.3.0',
      concurrently: '7.0.0',
      'downlevel-dts': '0.10.1',
      rimraf: '3.0.2',
      typedoc: '0.23.23',
      typescript: '~4.9.5',
    },
    engines: { node: '>=14.0.0' },
    typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
    files: ['dist-*/**'],
    author: {
      name: 'AWS SDK for JavaScript Team',
      url: 'https://aws.amazon.com/javascript/',
    },
    license: 'Apache-2.0',
    browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
    'react-native': {
      './dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
    },
    homepage:
      'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb',
    repository: {
      type: 'git',
      url: 'https://github.com/aws/aws-sdk-js-v3.git',
      directory: 'clients/client-dynamodb',
    },
  }
})
var t2 = l((Rg) => {
  'use strict'
  Object.defineProperty(Rg, '__esModule', { value: !0 })
  Rg.resolveStsAuthConfig = void 0
  var Wve = Sr(),
    Kve = (e, { stsClientCtor: t }) =>
      (0, Wve.resolveAwsAuthConfig)({ ...e, stsClientCtor: t })
  Rg.resolveStsAuthConfig = Kve
})
var n2 = l((Dg) => {
  'use strict'
  Object.defineProperty(Dg, '__esModule', { value: !0 })
  Dg.resolveClientEndpointParameters = void 0
  var Xve = (e) => ({
    ...e,
    useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
    useFipsEndpoint: e.useFipsEndpoint ?? !1,
    useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
    defaultSigningName: 'sts',
  })
  Dg.resolveClientEndpointParameters = Xve
})
var r2 = l((_Ve, Jve) => {
  Jve.exports = {
    name: '@aws-sdk/client-sts',
    description:
      'AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native',
    version: '3.433.0',
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      'build:cjs': 'tsc -p tsconfig.cjs.json',
      'build:docs': 'typedoc',
      'build:es': 'tsc -p tsconfig.es.json',
      'build:include:deps':
        'lerna run --scope $npm_package_name --include-dependencies build',
      'build:types': 'tsc -p tsconfig.types.json',
      'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
      clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
      'extract:docs': 'api-extractor run --local',
      'generate:client':
        'node ../../scripts/generate-clients/single-service --solo sts',
      test: 'yarn test:unit',
      'test:unit': 'jest',
    },
    main: './dist-cjs/index.js',
    types: './dist-types/index.d.ts',
    module: './dist-es/index.js',
    sideEffects: !1,
    dependencies: {
      '@aws-crypto/sha256-browser': '3.0.0',
      '@aws-crypto/sha256-js': '3.0.0',
      '@aws-sdk/credential-provider-node': '3.433.0',
      '@aws-sdk/middleware-host-header': '3.433.0',
      '@aws-sdk/middleware-logger': '3.433.0',
      '@aws-sdk/middleware-recursion-detection': '3.433.0',
      '@aws-sdk/middleware-sdk-sts': '3.433.0',
      '@aws-sdk/middleware-signing': '3.433.0',
      '@aws-sdk/middleware-user-agent': '3.433.0',
      '@aws-sdk/region-config-resolver': '3.433.0',
      '@aws-sdk/types': '3.433.0',
      '@aws-sdk/util-endpoints': '3.433.0',
      '@aws-sdk/util-user-agent-browser': '3.433.0',
      '@aws-sdk/util-user-agent-node': '3.433.0',
      '@smithy/config-resolver': '^2.0.16',
      '@smithy/fetch-http-handler': '^2.2.4',
      '@smithy/hash-node': '^2.0.12',
      '@smithy/invalid-dependency': '^2.0.12',
      '@smithy/middleware-content-length': '^2.0.14',
      '@smithy/middleware-endpoint': '^2.1.3',
      '@smithy/middleware-retry': '^2.0.18',
      '@smithy/middleware-serde': '^2.0.12',
      '@smithy/middleware-stack': '^2.0.6',
      '@smithy/node-config-provider': '^2.1.3',
      '@smithy/node-http-handler': '^2.1.8',
      '@smithy/protocol-http': '^3.0.8',
      '@smithy/smithy-client': '^2.1.12',
      '@smithy/types': '^2.4.0',
      '@smithy/url-parser': '^2.0.12',
      '@smithy/util-base64': '^2.0.0',
      '@smithy/util-body-length-browser': '^2.0.0',
      '@smithy/util-body-length-node': '^2.1.0',
      '@smithy/util-defaults-mode-browser': '^2.0.16',
      '@smithy/util-defaults-mode-node': '^2.0.21',
      '@smithy/util-retry': '^2.0.5',
      '@smithy/util-utf8': '^2.0.0',
      'fast-xml-parser': '4.2.5',
      tslib: '^2.5.0',
    },
    devDependencies: {
      '@smithy/service-client-documentation-generator': '^2.0.0',
      '@tsconfig/node14': '1.0.3',
      '@types/node': '^14.14.31',
      concurrently: '7.0.0',
      'downlevel-dts': '0.10.1',
      rimraf: '3.0.2',
      typedoc: '0.23.23',
      typescript: '~4.9.5',
    },
    engines: { node: '>=14.0.0' },
    typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
    files: ['dist-*/**'],
    author: {
      name: 'AWS SDK for JavaScript Team',
      url: 'https://aws.amazon.com/javascript/',
    },
    license: 'Apache-2.0',
    browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
    'react-native': {
      './dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
    },
    homepage:
      'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts',
    repository: {
      type: 'git',
      url: 'https://github.com/aws/aws-sdk-js-v3.git',
      directory: 'clients/client-sts',
    },
  }
})
var Ag = l((ba) => {
  'use strict'
  Object.defineProperty(ba, '__esModule', { value: !0 })
  ba.STSServiceException = ba.__ServiceException = void 0
  var s2 = v()
  Object.defineProperty(ba, '__ServiceException', {
    enumerable: !0,
    get: function () {
      return s2.ServiceException
    },
  })
  var rx = class e extends s2.ServiceException {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e.prototype)
    }
  }
  ba.STSServiceException = rx
})
var Ts = l((ne) => {
  'use strict'
  Object.defineProperty(ne, '__esModule', { value: !0 })
  ne.GetSessionTokenResponseFilterSensitiveLog =
    ne.GetFederationTokenResponseFilterSensitiveLog =
    ne.AssumeRoleWithWebIdentityResponseFilterSensitiveLog =
    ne.AssumeRoleWithWebIdentityRequestFilterSensitiveLog =
    ne.AssumeRoleWithSAMLResponseFilterSensitiveLog =
    ne.AssumeRoleWithSAMLRequestFilterSensitiveLog =
    ne.AssumeRoleResponseFilterSensitiveLog =
    ne.CredentialsFilterSensitiveLog =
    ne.InvalidAuthorizationMessageException =
    ne.IDPCommunicationErrorException =
    ne.InvalidIdentityTokenException =
    ne.IDPRejectedClaimException =
    ne.RegionDisabledException =
    ne.PackedPolicyTooLargeException =
    ne.MalformedPolicyDocumentException =
    ne.ExpiredTokenException =
      void 0
  var mx = v(),
    Cs = Ag(),
    sx = class e extends Cs.STSServiceException {
      constructor(t) {
        super({ name: 'ExpiredTokenException', $fault: 'client', ...t }),
          (this.name = 'ExpiredTokenException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  ne.ExpiredTokenException = sx
  var ox = class e extends Cs.STSServiceException {
    constructor(t) {
      super({
        name: 'MalformedPolicyDocumentException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'MalformedPolicyDocumentException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.MalformedPolicyDocumentException = ox
  var ix = class e extends Cs.STSServiceException {
    constructor(t) {
      super({ name: 'PackedPolicyTooLargeException', $fault: 'client', ...t }),
        (this.name = 'PackedPolicyTooLargeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.PackedPolicyTooLargeException = ix
  var ax = class e extends Cs.STSServiceException {
    constructor(t) {
      super({ name: 'RegionDisabledException', $fault: 'client', ...t }),
        (this.name = 'RegionDisabledException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.RegionDisabledException = ax
  var cx = class e extends Cs.STSServiceException {
    constructor(t) {
      super({ name: 'IDPRejectedClaimException', $fault: 'client', ...t }),
        (this.name = 'IDPRejectedClaimException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.IDPRejectedClaimException = cx
  var dx = class e extends Cs.STSServiceException {
    constructor(t) {
      super({ name: 'InvalidIdentityTokenException', $fault: 'client', ...t }),
        (this.name = 'InvalidIdentityTokenException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.InvalidIdentityTokenException = dx
  var ux = class e extends Cs.STSServiceException {
    constructor(t) {
      super({ name: 'IDPCommunicationErrorException', $fault: 'client', ...t }),
        (this.name = 'IDPCommunicationErrorException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.IDPCommunicationErrorException = ux
  var lx = class e extends Cs.STSServiceException {
    constructor(t) {
      super({
        name: 'InvalidAuthorizationMessageException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'InvalidAuthorizationMessageException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ne.InvalidAuthorizationMessageException = lx
  var Qve = (e) => ({
    ...e,
    ...(e.SecretAccessKey && { SecretAccessKey: mx.SENSITIVE_STRING }),
  })
  ne.CredentialsFilterSensitiveLog = Qve
  var Zve = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ne.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ne.AssumeRoleResponseFilterSensitiveLog = Zve
  var eCe = (e) => ({
    ...e,
    ...(e.SAMLAssertion && { SAMLAssertion: mx.SENSITIVE_STRING }),
  })
  ne.AssumeRoleWithSAMLRequestFilterSensitiveLog = eCe
  var tCe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ne.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ne.AssumeRoleWithSAMLResponseFilterSensitiveLog = tCe
  var nCe = (e) => ({
    ...e,
    ...(e.WebIdentityToken && { WebIdentityToken: mx.SENSITIVE_STRING }),
  })
  ne.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = nCe
  var rCe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ne.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ne.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = rCe
  var sCe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ne.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ne.GetFederationTokenResponseFilterSensitiveLog = sCe
  var oCe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ne.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ne.GetSessionTokenResponseFilterSensitiveLog = oCe
})
var Og = l((Dr) => {
  'use strict'
  var o2 =
      ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
    iCe = o2 + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
    i2 = '[' + o2 + '][' + iCe + ']*',
    aCe = new RegExp('^' + i2 + '$'),
    cCe = function (e, t) {
      let n = [],
        r = t.exec(e)
      for (; r; ) {
        let s = []
        s.startIndex = t.lastIndex - r[0].length
        let o = r.length
        for (let i = 0; i < o; i++) s.push(r[i])
        n.push(s), (r = t.exec(e))
      }
      return n
    },
    dCe = function (e) {
      let t = aCe.exec(e)
      return !(t === null || typeof t > 'u')
    }
  Dr.isExist = function (e) {
    return typeof e < 'u'
  }
  Dr.isEmptyObject = function (e) {
    return Object.keys(e).length === 0
  }
  Dr.merge = function (e, t, n) {
    if (t) {
      let r = Object.keys(t),
        s = r.length
      for (let o = 0; o < s; o++)
        n === 'strict' ? (e[r[o]] = [t[r[o]]]) : (e[r[o]] = t[r[o]])
    }
  }
  Dr.getValue = function (e) {
    return Dr.isExist(e) ? e : ''
  }
  Dr.isName = dCe
  Dr.getAllMatches = cCe
  Dr.nameRegexp = i2
})
var _x = l((l2) => {
  'use strict'
  var px = Og(),
    uCe = { allowBooleanAttributes: !1, unpairedTags: [] }
  l2.validate = function (e, t) {
    t = Object.assign({}, uCe, t)
    let n = [],
      r = !1,
      s = !1
    e[0] === '\uFEFF' && (e = e.substr(1))
    for (let o = 0; o < e.length; o++)
      if (e[o] === '<' && e[o + 1] === '?') {
        if (((o += 2), (o = c2(e, o)), o.err)) return o
      } else if (e[o] === '<') {
        let i = o
        if ((o++, e[o] === '!')) {
          o = d2(e, o)
          continue
        } else {
          let a = !1
          e[o] === '/' && ((a = !0), o++)
          let c = ''
          for (
            ;
            o < e.length &&
            e[o] !== '>' &&
            e[o] !== ' ' &&
            e[o] !== '	' &&
            e[o] !==
              `
` &&
            e[o] !== '\r';
            o++
          )
            c += e[o]
          if (
            ((c = c.trim()),
            c[c.length - 1] === '/' &&
              ((c = c.substring(0, c.length - 1)), o--),
            !yCe(c))
          ) {
            let p
            return (
              c.trim().length === 0
                ? (p = "Invalid space after '<'.")
                : (p = "Tag '" + c + "' is an invalid name."),
              Me('InvalidTag', p, ht(e, o))
            )
          }
          let u = pCe(e, o)
          if (u === !1)
            return Me(
              'InvalidAttr',
              "Attributes for '" + c + "' have open quote.",
              ht(e, o),
            )
          let d = u.value
          if (((o = u.index), d[d.length - 1] === '/')) {
            let p = o - d.length
            d = d.substring(0, d.length - 1)
            let _ = u2(d, t)
            if (_ === !0) r = !0
            else return Me(_.err.code, _.err.msg, ht(e, p + _.err.line))
          } else if (a)
            if (u.tagClosed) {
              if (d.trim().length > 0)
                return Me(
                  'InvalidTag',
                  "Closing tag '" +
                    c +
                    "' can't have attributes or invalid starting.",
                  ht(e, i),
                )
              {
                let p = n.pop()
                if (c !== p.tagName) {
                  let _ = ht(e, p.tagStartPos)
                  return Me(
                    'InvalidTag',
                    "Expected closing tag '" +
                      p.tagName +
                      "' (opened in line " +
                      _.line +
                      ', col ' +
                      _.col +
                      ") instead of closing tag '" +
                      c +
                      "'.",
                    ht(e, i),
                  )
                }
                n.length == 0 && (s = !0)
              }
            } else
              return Me(
                'InvalidTag',
                "Closing tag '" + c + "' doesn't have proper closing.",
                ht(e, o),
              )
          else {
            let p = u2(d, t)
            if (p !== !0)
              return Me(p.err.code, p.err.msg, ht(e, o - d.length + p.err.line))
            if (s === !0)
              return Me(
                'InvalidXml',
                'Multiple possible root nodes found.',
                ht(e, o),
              )
            t.unpairedTags.indexOf(c) !== -1 ||
              n.push({ tagName: c, tagStartPos: i }),
              (r = !0)
          }
          for (o++; o < e.length; o++)
            if (e[o] === '<')
              if (e[o + 1] === '!') {
                o++, (o = d2(e, o))
                continue
              } else if (e[o + 1] === '?') {
                if (((o = c2(e, ++o)), o.err)) return o
              } else break
            else if (e[o] === '&') {
              let p = hCe(e, o)
              if (p == -1)
                return Me('InvalidChar', "char '&' is not expected.", ht(e, o))
              o = p
            } else if (s === !0 && !a2(e[o]))
              return Me('InvalidXml', 'Extra text at the end', ht(e, o))
          e[o] === '<' && o--
        }
      } else {
        if (a2(e[o])) continue
        return Me(
          'InvalidChar',
          "char '" + e[o] + "' is not expected.",
          ht(e, o),
        )
      }
    if (r) {
      if (n.length == 1)
        return Me(
          'InvalidTag',
          "Unclosed tag '" + n[0].tagName + "'.",
          ht(e, n[0].tagStartPos),
        )
      if (n.length > 0)
        return Me(
          'InvalidXml',
          "Invalid '" +
            JSON.stringify(
              n.map((o) => o.tagName),
              null,
              4,
            ).replace(/\r?\n/g, '') +
            "' found.",
          { line: 1, col: 1 },
        )
    } else return Me('InvalidXml', 'Start tag expected.', 1)
    return !0
  }
  function a2(e) {
    return (
      e === ' ' ||
      e === '	' ||
      e ===
        `
` ||
      e === '\r'
    )
  }
  function c2(e, t) {
    let n = t
    for (; t < e.length; t++)
      if (e[t] == '?' || e[t] == ' ') {
        let r = e.substr(n, t - n)
        if (t > 5 && r === 'xml')
          return Me(
            'InvalidXml',
            'XML declaration allowed only at the start of the document.',
            ht(e, t),
          )
        if (e[t] == '?' && e[t + 1] == '>') {
          t++
          break
        } else continue
      }
    return t
  }
  function d2(e, t) {
    if (e.length > t + 5 && e[t + 1] === '-' && e[t + 2] === '-') {
      for (t += 3; t < e.length; t++)
        if (e[t] === '-' && e[t + 1] === '-' && e[t + 2] === '>') {
          t += 2
          break
        }
    } else if (
      e.length > t + 8 &&
      e[t + 1] === 'D' &&
      e[t + 2] === 'O' &&
      e[t + 3] === 'C' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'Y' &&
      e[t + 6] === 'P' &&
      e[t + 7] === 'E'
    ) {
      let n = 1
      for (t += 8; t < e.length; t++)
        if (e[t] === '<') n++
        else if (e[t] === '>' && (n--, n === 0)) break
    } else if (
      e.length > t + 9 &&
      e[t + 1] === '[' &&
      e[t + 2] === 'C' &&
      e[t + 3] === 'D' &&
      e[t + 4] === 'A' &&
      e[t + 5] === 'T' &&
      e[t + 6] === 'A' &&
      e[t + 7] === '['
    ) {
      for (t += 8; t < e.length; t++)
        if (e[t] === ']' && e[t + 1] === ']' && e[t + 2] === '>') {
          t += 2
          break
        }
    }
    return t
  }
  var lCe = '"',
    mCe = "'"
  function pCe(e, t) {
    let n = '',
      r = '',
      s = !1
    for (; t < e.length; t++) {
      if (e[t] === lCe || e[t] === mCe)
        r === '' ? (r = e[t]) : r !== e[t] || (r = '')
      else if (e[t] === '>' && r === '') {
        s = !0
        break
      }
      n += e[t]
    }
    return r !== '' ? !1 : { value: n, index: t, tagClosed: s }
  }
  var _Ce = new RegExp(
    `(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
    'g',
  )
  function u2(e, t) {
    let n = px.getAllMatches(e, _Ce),
      r = {}
    for (let s = 0; s < n.length; s++) {
      if (n[s][1].length === 0)
        return Me(
          'InvalidAttr',
          "Attribute '" + n[s][2] + "' has no space in starting.",
          hl(n[s]),
        )
      if (n[s][3] !== void 0 && n[s][4] === void 0)
        return Me(
          'InvalidAttr',
          "Attribute '" + n[s][2] + "' is without value.",
          hl(n[s]),
        )
      if (n[s][3] === void 0 && !t.allowBooleanAttributes)
        return Me(
          'InvalidAttr',
          "boolean attribute '" + n[s][2] + "' is not allowed.",
          hl(n[s]),
        )
      let o = n[s][2]
      if (!gCe(o))
        return Me(
          'InvalidAttr',
          "Attribute '" + o + "' is an invalid name.",
          hl(n[s]),
        )
      if (!r.hasOwnProperty(o)) r[o] = 1
      else
        return Me('InvalidAttr', "Attribute '" + o + "' is repeated.", hl(n[s]))
    }
    return !0
  }
  function fCe(e, t) {
    let n = /\d/
    for (e[t] === 'x' && (t++, (n = /[\da-fA-F]/)); t < e.length; t++) {
      if (e[t] === ';') return t
      if (!e[t].match(n)) break
    }
    return -1
  }
  function hCe(e, t) {
    if ((t++, e[t] === ';')) return -1
    if (e[t] === '#') return t++, fCe(e, t)
    let n = 0
    for (; t < e.length; t++, n++)
      if (!(e[t].match(/\w/) && n < 20)) {
        if (e[t] === ';') break
        return -1
      }
    return t
  }
  function Me(e, t, n) {
    return { err: { code: e, msg: t, line: n.line || n, col: n.col } }
  }
  function gCe(e) {
    return px.isName(e)
  }
  function yCe(e) {
    return px.isName(e)
  }
  function ht(e, t) {
    let n = e.substring(0, t).split(/\r?\n/)
    return { line: n.length, col: n[n.length - 1].length + 1 }
  }
  function hl(e) {
    return e.startIndex + e[1].length
  }
})
var p2 = l((fx) => {
  var m2 = {
      preserveOrder: !1,
      attributeNamePrefix: '@_',
      attributesGroupName: !1,
      textNodeName: '#text',
      ignoreAttributes: !0,
      removeNSPrefix: !1,
      allowBooleanAttributes: !1,
      parseTagValue: !0,
      parseAttributeValue: !1,
      trimValues: !0,
      cdataPropName: !1,
      numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
      tagValueProcessor: function (e, t) {
        return t
      },
      attributeValueProcessor: function (e, t) {
        return t
      },
      stopNodes: [],
      alwaysCreateTextNode: !1,
      isArray: () => !1,
      commentPropName: !1,
      unpairedTags: [],
      processEntities: !0,
      htmlEntities: !1,
      ignoreDeclaration: !1,
      ignorePiTags: !1,
      transformTagName: !1,
      transformAttributeName: !1,
      updateTag: function (e, t, n) {
        return e
      },
    },
    ECe = function (e) {
      return Object.assign({}, m2, e)
    }
  fx.buildOptions = ECe
  fx.defaultOptions = m2
})
var f2 = l((SVe, _2) => {
  'use strict'
  var hx = class {
    constructor(t) {
      ;(this.tagname = t), (this.child = []), (this[':@'] = {})
    }
    add(t, n) {
      t === '__proto__' && (t = '#__proto__'), this.child.push({ [t]: n })
    }
    addChild(t) {
      t.tagname === '__proto__' && (t.tagname = '#__proto__'),
        t[':@'] && Object.keys(t[':@']).length > 0
          ? this.child.push({ [t.tagname]: t.child, ':@': t[':@'] })
          : this.child.push({ [t.tagname]: t.child })
    }
  }
  _2.exports = hx
})
var g2 = l((bVe, h2) => {
  var SCe = Og()
  function bCe(e, t) {
    let n = {}
    if (
      e[t + 3] === 'O' &&
      e[t + 4] === 'C' &&
      e[t + 5] === 'T' &&
      e[t + 6] === 'Y' &&
      e[t + 7] === 'P' &&
      e[t + 8] === 'E'
    ) {
      t = t + 9
      let r = 1,
        s = !1,
        o = !1,
        i = ''
      for (; t < e.length; t++)
        if (e[t] === '<' && !o) {
          if (s && TCe(e, t))
            (t += 7),
              ([entityName, val, t] = vCe(e, t + 1)),
              val.indexOf('&') === -1 &&
                (n[PCe(entityName)] = {
                  regx: RegExp(`&${entityName};`, 'g'),
                  val,
                })
          else if (s && wCe(e, t)) t += 8
          else if (s && ICe(e, t)) t += 8
          else if (s && xCe(e, t)) t += 9
          else if (CCe) o = !0
          else throw new Error('Invalid DOCTYPE')
          r++, (i = '')
        } else if (e[t] === '>') {
          if (
            (o ? e[t - 1] === '-' && e[t - 2] === '-' && ((o = !1), r--) : r--,
            r === 0)
          )
            break
        } else e[t] === '[' ? (s = !0) : (i += e[t])
      if (r !== 0) throw new Error('Unclosed DOCTYPE')
    } else throw new Error('Invalid Tag instead of DOCTYPE')
    return { entities: n, i: t }
  }
  function vCe(e, t) {
    let n = ''
    for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++) n += e[t]
    if (((n = n.trim()), n.indexOf(' ') !== -1))
      throw new Error('External entites are not supported')
    let r = e[t++],
      s = ''
    for (; t < e.length && e[t] !== r; t++) s += e[t]
    return [n, s, t]
  }
  function CCe(e, t) {
    return e[t + 1] === '!' && e[t + 2] === '-' && e[t + 3] === '-'
  }
  function TCe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'E' &&
      e[t + 3] === 'N' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'I' &&
      e[t + 6] === 'T' &&
      e[t + 7] === 'Y'
    )
  }
  function wCe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'E' &&
      e[t + 3] === 'L' &&
      e[t + 4] === 'E' &&
      e[t + 5] === 'M' &&
      e[t + 6] === 'E' &&
      e[t + 7] === 'N' &&
      e[t + 8] === 'T'
    )
  }
  function ICe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'A' &&
      e[t + 3] === 'T' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'L' &&
      e[t + 6] === 'I' &&
      e[t + 7] === 'S' &&
      e[t + 8] === 'T'
    )
  }
  function xCe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'N' &&
      e[t + 3] === 'O' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'A' &&
      e[t + 6] === 'T' &&
      e[t + 7] === 'I' &&
      e[t + 8] === 'O' &&
      e[t + 9] === 'N'
    )
  }
  function PCe(e) {
    if (SCe.isName(e)) return e
    throw new Error(`Invalid entity name ${e}`)
  }
  h2.exports = bCe
})
var E2 = l((vVe, y2) => {
  var RCe = /^[-+]?0x[a-fA-F0-9]+$/,
    DCe =
      /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/
  !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt)
  !Number.parseFloat &&
    window.parseFloat &&
    (Number.parseFloat = window.parseFloat)
  var ACe = { hex: !0, leadingZeros: !0, decimalPoint: '.', eNotation: !0 }
  function OCe(e, t = {}) {
    if (((t = Object.assign({}, ACe, t)), !e || typeof e != 'string')) return e
    let n = e.trim()
    if (t.skipLike !== void 0 && t.skipLike.test(n)) return e
    if (t.hex && RCe.test(n)) return Number.parseInt(n, 16)
    {
      let r = DCe.exec(n)
      if (r) {
        let s = r[1],
          o = r[2],
          i = NCe(r[3]),
          a = r[4] || r[6]
        if (!t.leadingZeros && o.length > 0 && s && n[2] !== '.') return e
        if (!t.leadingZeros && o.length > 0 && !s && n[1] !== '.') return e
        {
          let c = Number(n),
            u = '' + c
          return u.search(/[eE]/) !== -1 || a
            ? t.eNotation
              ? c
              : e
            : n.indexOf('.') !== -1
              ? (u === '0' && i === '') || u === i || (s && u === '-' + i)
                ? c
                : e
              : o
                ? i === u || s + i === u
                  ? c
                  : e
                : n === u || n === s + u
                  ? c
                  : e
        }
      } else return e
    }
  }
  function NCe(e) {
    return (
      e &&
        e.indexOf('.') !== -1 &&
        ((e = e.replace(/0+$/, '')),
        e === '.'
          ? (e = '0')
          : e[0] === '.'
            ? (e = '0' + e)
            : e[e.length - 1] === '.' && (e = e.substr(0, e.length - 1))),
      e
    )
  }
  y2.exports = OCe
})
var b2 = l((TVe, S2) => {
  'use strict'
  var Sx = Og(),
    gl = f2(),
    qCe = g2(),
    kCe = E2(),
    CVe =
      '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'.replace(
        /NAME/g,
        Sx.nameRegexp,
      ),
    gx = class {
      constructor(t) {
        ;(this.options = t),
          (this.currentNode = null),
          (this.tagsNodeStack = []),
          (this.docTypeEntities = {}),
          (this.lastEntities = {
            apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
            gt: { regex: /&(gt|#62|#x3E);/g, val: '>' },
            lt: { regex: /&(lt|#60|#x3C);/g, val: '<' },
            quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
          }),
          (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: '&' }),
          (this.htmlEntities = {
            space: { regex: /&(nbsp|#160);/g, val: ' ' },
            cent: { regex: /&(cent|#162);/g, val: '\xA2' },
            pound: { regex: /&(pound|#163);/g, val: '\xA3' },
            yen: { regex: /&(yen|#165);/g, val: '\xA5' },
            euro: { regex: /&(euro|#8364);/g, val: '\u20AC' },
            copyright: { regex: /&(copy|#169);/g, val: '\xA9' },
            reg: { regex: /&(reg|#174);/g, val: '\xAE' },
            inr: { regex: /&(inr|#8377);/g, val: '\u20B9' },
          }),
          (this.addExternalEntities = MCe),
          (this.parseXml = jCe),
          (this.parseTextData = LCe),
          (this.resolveNameSpace = UCe),
          (this.buildAttributesMap = BCe),
          (this.isItStopNode = HCe),
          (this.replaceEntitiesValue = $Ce),
          (this.readStopNodeData = YCe),
          (this.saveTextToParentTag = zCe),
          (this.addChild = GCe)
      }
    }
  function MCe(e) {
    let t = Object.keys(e)
    for (let n = 0; n < t.length; n++) {
      let r = t[n]
      this.lastEntities[r] = {
        regex: new RegExp('&' + r + ';', 'g'),
        val: e[r],
      }
    }
  }
  function LCe(e, t, n, r, s, o, i) {
    if (
      e !== void 0 &&
      (this.options.trimValues && !r && (e = e.trim()), e.length > 0)
    ) {
      i || (e = this.replaceEntitiesValue(e))
      let a = this.options.tagValueProcessor(t, e, n, s, o)
      return a == null
        ? e
        : typeof a != typeof e || a !== e
          ? a
          : this.options.trimValues
            ? Ex(e, this.options.parseTagValue, this.options.numberParseOptions)
            : e.trim() === e
              ? Ex(
                  e,
                  this.options.parseTagValue,
                  this.options.numberParseOptions,
                )
              : e
    }
  }
  function UCe(e) {
    if (this.options.removeNSPrefix) {
      let t = e.split(':'),
        n = e.charAt(0) === '/' ? '/' : ''
      if (t[0] === 'xmlns') return ''
      t.length === 2 && (e = n + t[1])
    }
    return e
  }
  var FCe = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, 'gm')
  function BCe(e, t, n) {
    if (!this.options.ignoreAttributes && typeof e == 'string') {
      let r = Sx.getAllMatches(e, FCe),
        s = r.length,
        o = {}
      for (let i = 0; i < s; i++) {
        let a = this.resolveNameSpace(r[i][1]),
          c = r[i][4],
          u = this.options.attributeNamePrefix + a
        if (a.length)
          if (
            (this.options.transformAttributeName &&
              (u = this.options.transformAttributeName(u)),
            u === '__proto__' && (u = '#__proto__'),
            c !== void 0)
          ) {
            this.options.trimValues && (c = c.trim()),
              (c = this.replaceEntitiesValue(c))
            let d = this.options.attributeValueProcessor(a, c, t)
            d == null
              ? (o[u] = c)
              : typeof d != typeof c || d !== c
                ? (o[u] = d)
                : (o[u] = Ex(
                    c,
                    this.options.parseAttributeValue,
                    this.options.numberParseOptions,
                  ))
          } else this.options.allowBooleanAttributes && (o[u] = !0)
      }
      if (!Object.keys(o).length) return
      if (this.options.attributesGroupName) {
        let i = {}
        return (i[this.options.attributesGroupName] = o), i
      }
      return o
    }
  }
  var jCe = function (e) {
    e = e.replace(
      /\r\n?/g,
      `
`,
    )
    let t = new gl('!xml'),
      n = t,
      r = '',
      s = ''
    for (let o = 0; o < e.length; o++)
      if (e[o] === '<')
        if (e[o + 1] === '/') {
          let a = Vo(e, '>', o, 'Closing Tag is not closed.'),
            c = e.substring(o + 2, a).trim()
          if (this.options.removeNSPrefix) {
            let p = c.indexOf(':')
            p !== -1 && (c = c.substr(p + 1))
          }
          this.options.transformTagName &&
            (c = this.options.transformTagName(c)),
            n && (r = this.saveTextToParentTag(r, n, s))
          let u = s.substring(s.lastIndexOf('.') + 1)
          if (c && this.options.unpairedTags.indexOf(c) !== -1)
            throw new Error(
              `Unpaired tag can not be used as closing tag: </${c}>`,
            )
          let d = 0
          u && this.options.unpairedTags.indexOf(u) !== -1
            ? ((d = s.lastIndexOf('.', s.lastIndexOf('.') - 1)),
              this.tagsNodeStack.pop())
            : (d = s.lastIndexOf('.')),
            (s = s.substring(0, d)),
            (n = this.tagsNodeStack.pop()),
            (r = ''),
            (o = a)
        } else if (e[o + 1] === '?') {
          let a = yx(e, o, !1, '?>')
          if (!a) throw new Error('Pi Tag is not closed.')
          if (
            ((r = this.saveTextToParentTag(r, n, s)),
            !(
              (this.options.ignoreDeclaration && a.tagName === '?xml') ||
              this.options.ignorePiTags
            ))
          ) {
            let c = new gl(a.tagName)
            c.add(this.options.textNodeName, ''),
              a.tagName !== a.tagExp &&
                a.attrExpPresent &&
                (c[':@'] = this.buildAttributesMap(a.tagExp, s, a.tagName)),
              this.addChild(n, c, s)
          }
          o = a.closeIndex + 1
        } else if (e.substr(o + 1, 3) === '!--') {
          let a = Vo(e, '-->', o + 4, 'Comment is not closed.')
          if (this.options.commentPropName) {
            let c = e.substring(o + 4, a - 2)
            ;(r = this.saveTextToParentTag(r, n, s)),
              n.add(this.options.commentPropName, [
                { [this.options.textNodeName]: c },
              ])
          }
          o = a
        } else if (e.substr(o + 1, 2) === '!D') {
          let a = qCe(e, o)
          ;(this.docTypeEntities = a.entities), (o = a.i)
        } else if (e.substr(o + 1, 2) === '![') {
          let a = Vo(e, ']]>', o, 'CDATA is not closed.') - 2,
            c = e.substring(o + 9, a)
          if (
            ((r = this.saveTextToParentTag(r, n, s)),
            this.options.cdataPropName)
          )
            n.add(this.options.cdataPropName, [
              { [this.options.textNodeName]: c },
            ])
          else {
            let u = this.parseTextData(c, n.tagname, s, !0, !1, !0)
            u == null && (u = ''), n.add(this.options.textNodeName, u)
          }
          o = a + 2
        } else {
          let a = yx(e, o, this.options.removeNSPrefix),
            c = a.tagName,
            u = a.tagExp,
            d = a.attrExpPresent,
            p = a.closeIndex
          this.options.transformTagName &&
            (c = this.options.transformTagName(c)),
            n &&
              r &&
              n.tagname !== '!xml' &&
              (r = this.saveTextToParentTag(r, n, s, !1))
          let _ = n
          if (
            (_ &&
              this.options.unpairedTags.indexOf(_.tagname) !== -1 &&
              ((n = this.tagsNodeStack.pop()),
              (s = s.substring(0, s.lastIndexOf('.')))),
            c !== t.tagname && (s += s ? '.' + c : c),
            this.isItStopNode(this.options.stopNodes, s, c))
          ) {
            let f = ''
            if (u.length > 0 && u.lastIndexOf('/') === u.length - 1)
              o = a.closeIndex
            else if (this.options.unpairedTags.indexOf(c) !== -1)
              o = a.closeIndex
            else {
              let y = this.readStopNodeData(e, c, p + 1)
              if (!y) throw new Error(`Unexpected end of ${c}`)
              ;(o = y.i), (f = y.tagContent)
            }
            let h = new gl(c)
            c !== u && d && (h[':@'] = this.buildAttributesMap(u, s, c)),
              f && (f = this.parseTextData(f, c, s, !0, d, !0, !0)),
              (s = s.substr(0, s.lastIndexOf('.'))),
              h.add(this.options.textNodeName, f),
              this.addChild(n, h, s)
          } else {
            if (u.length > 0 && u.lastIndexOf('/') === u.length - 1) {
              c[c.length - 1] === '/'
                ? ((c = c.substr(0, c.length - 1)), (u = c))
                : (u = u.substr(0, u.length - 1)),
                this.options.transformTagName &&
                  (c = this.options.transformTagName(c))
              let f = new gl(c)
              c !== u && d && (f[':@'] = this.buildAttributesMap(u, s, c)),
                this.addChild(n, f, s),
                (s = s.substr(0, s.lastIndexOf('.')))
            } else {
              let f = new gl(c)
              this.tagsNodeStack.push(n),
                c !== u && d && (f[':@'] = this.buildAttributesMap(u, s, c)),
                this.addChild(n, f, s),
                (n = f)
            }
            ;(r = ''), (o = p)
          }
        }
      else r += e[o]
    return t.child
  }
  function GCe(e, t, n) {
    let r = this.options.updateTag(t.tagname, n, t[':@'])
    r === !1 || (typeof r == 'string' && (t.tagname = r), e.addChild(t))
  }
  var $Ce = function (e) {
    if (this.options.processEntities) {
      for (let t in this.docTypeEntities) {
        let n = this.docTypeEntities[t]
        e = e.replace(n.regx, n.val)
      }
      for (let t in this.lastEntities) {
        let n = this.lastEntities[t]
        e = e.replace(n.regex, n.val)
      }
      if (this.options.htmlEntities)
        for (let t in this.htmlEntities) {
          let n = this.htmlEntities[t]
          e = e.replace(n.regex, n.val)
        }
      e = e.replace(this.ampEntity.regex, this.ampEntity.val)
    }
    return e
  }
  function zCe(e, t, n, r) {
    return (
      e &&
        (r === void 0 && (r = Object.keys(t.child).length === 0),
        (e = this.parseTextData(
          e,
          t.tagname,
          n,
          !1,
          t[':@'] ? Object.keys(t[':@']).length !== 0 : !1,
          r,
        )),
        e !== void 0 && e !== '' && t.add(this.options.textNodeName, e),
        (e = '')),
      e
    )
  }
  function HCe(e, t, n) {
    let r = '*.' + n
    for (let s in e) {
      let o = e[s]
      if (r === o || t === o) return !0
    }
    return !1
  }
  function VCe(e, t, n = '>') {
    let r,
      s = ''
    for (let o = t; o < e.length; o++) {
      let i = e[o]
      if (r) i === r && (r = '')
      else if (i === '"' || i === "'") r = i
      else if (i === n[0])
        if (n[1]) {
          if (e[o + 1] === n[1]) return { data: s, index: o }
        } else return { data: s, index: o }
      else i === '	' && (i = ' ')
      s += i
    }
  }
  function Vo(e, t, n, r) {
    let s = e.indexOf(t, n)
    if (s === -1) throw new Error(r)
    return s + t.length - 1
  }
  function yx(e, t, n, r = '>') {
    let s = VCe(e, t + 1, r)
    if (!s) return
    let o = s.data,
      i = s.index,
      a = o.search(/\s/),
      c = o,
      u = !0
    if (
      (a !== -1 &&
        ((c = o.substr(0, a).replace(/\s\s*$/, '')), (o = o.substr(a + 1))),
      n)
    ) {
      let d = c.indexOf(':')
      d !== -1 && ((c = c.substr(d + 1)), (u = c !== s.data.substr(d + 1)))
    }
    return { tagName: c, tagExp: o, closeIndex: i, attrExpPresent: u }
  }
  function YCe(e, t, n) {
    let r = n,
      s = 1
    for (; n < e.length; n++)
      if (e[n] === '<')
        if (e[n + 1] === '/') {
          let o = Vo(e, '>', n, `${t} is not closed`)
          if (e.substring(n + 2, o).trim() === t && (s--, s === 0))
            return { tagContent: e.substring(r, n), i: o }
          n = o
        } else if (e[n + 1] === '?')
          n = Vo(e, '?>', n + 1, 'StopNode is not closed.')
        else if (e.substr(n + 1, 3) === '!--')
          n = Vo(e, '-->', n + 3, 'StopNode is not closed.')
        else if (e.substr(n + 1, 2) === '![')
          n = Vo(e, ']]>', n, 'StopNode is not closed.') - 2
        else {
          let o = yx(e, n, '>')
          o &&
            ((o && o.tagName) === t &&
              o.tagExp[o.tagExp.length - 1] !== '/' &&
              s++,
            (n = o.closeIndex))
        }
  }
  function Ex(e, t, n) {
    if (t && typeof e == 'string') {
      let r = e.trim()
      return r === 'true' ? !0 : r === 'false' ? !1 : kCe(e, n)
    } else return Sx.isExist(e) ? e : ''
  }
  S2.exports = gx
})
var T2 = l((C2) => {
  'use strict'
  function WCe(e, t) {
    return v2(e, t)
  }
  function v2(e, t, n) {
    let r,
      s = {}
    for (let o = 0; o < e.length; o++) {
      let i = e[o],
        a = KCe(i),
        c = ''
      if ((n === void 0 ? (c = a) : (c = n + '.' + a), a === t.textNodeName))
        r === void 0 ? (r = i[a]) : (r += '' + i[a])
      else {
        if (a === void 0) continue
        if (i[a]) {
          let u = v2(i[a], t, c),
            d = JCe(u, t)
          i[':@']
            ? XCe(u, i[':@'], c, t)
            : Object.keys(u).length === 1 &&
                u[t.textNodeName] !== void 0 &&
                !t.alwaysCreateTextNode
              ? (u = u[t.textNodeName])
              : Object.keys(u).length === 0 &&
                (t.alwaysCreateTextNode ? (u[t.textNodeName] = '') : (u = '')),
            s[a] !== void 0 && s.hasOwnProperty(a)
              ? (Array.isArray(s[a]) || (s[a] = [s[a]]), s[a].push(u))
              : t.isArray(a, c, d)
                ? (s[a] = [u])
                : (s[a] = u)
        }
      }
    }
    return (
      typeof r == 'string'
        ? r.length > 0 && (s[t.textNodeName] = r)
        : r !== void 0 && (s[t.textNodeName] = r),
      s
    )
  }
  function KCe(e) {
    let t = Object.keys(e)
    for (let n = 0; n < t.length; n++) {
      let r = t[n]
      if (r !== ':@') return r
    }
  }
  function XCe(e, t, n, r) {
    if (t) {
      let s = Object.keys(t),
        o = s.length
      for (let i = 0; i < o; i++) {
        let a = s[i]
        r.isArray(a, n + '.' + a, !0, !0) ? (e[a] = [t[a]]) : (e[a] = t[a])
      }
    }
  }
  function JCe(e, t) {
    let { textNodeName: n } = t,
      r = Object.keys(e).length
    return !!(
      r === 0 ||
      (r === 1 && (e[n] || typeof e[n] == 'boolean' || e[n] === 0))
    )
  }
  C2.prettify = WCe
})
var I2 = l((IVe, w2) => {
  var { buildOptions: QCe } = p2(),
    ZCe = b2(),
    { prettify: e0e } = T2(),
    t0e = _x(),
    bx = class {
      constructor(t) {
        ;(this.externalEntities = {}), (this.options = QCe(t))
      }
      parse(t, n) {
        if (typeof t != 'string')
          if (t.toString) t = t.toString()
          else
            throw new Error('XML data is accepted in String or Bytes[] form.')
        if (n) {
          n === !0 && (n = {})
          let o = t0e.validate(t, n)
          if (o !== !0) throw Error(`${o.err.msg}:${o.err.line}:${o.err.col}`)
        }
        let r = new ZCe(this.options)
        r.addExternalEntities(this.externalEntities)
        let s = r.parseXml(t)
        return this.options.preserveOrder || s === void 0
          ? s
          : e0e(s, this.options)
      }
      addEntity(t, n) {
        if (n.indexOf('&') !== -1)
          throw new Error("Entity value can't have '&'")
        if (t.indexOf('&') !== -1 || t.indexOf(';') !== -1)
          throw new Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'",
          )
        if (n === '&')
          throw new Error("An entity with value '&' is not permitted")
        this.externalEntities[t] = n
      }
    }
  w2.exports = bx
})
var A2 = l((xVe, D2) => {
  var n0e = `
`
  function r0e(e, t) {
    let n = ''
    return t.format && t.indentBy.length > 0 && (n = n0e), P2(e, t, '', n)
  }
  function P2(e, t, n, r) {
    let s = '',
      o = !1
    for (let i = 0; i < e.length; i++) {
      let a = e[i],
        c = s0e(a),
        u = ''
      if (
        (n.length === 0 ? (u = c) : (u = `${n}.${c}`), c === t.textNodeName)
      ) {
        let h = a[c]
        o0e(u, t) || ((h = t.tagValueProcessor(c, h)), (h = R2(h, t))),
          o && (s += r),
          (s += h),
          (o = !1)
        continue
      } else if (c === t.cdataPropName) {
        o && (s += r), (s += `<![CDATA[${a[c][0][t.textNodeName]}]]>`), (o = !1)
        continue
      } else if (c === t.commentPropName) {
        ;(s += r + `<!--${a[c][0][t.textNodeName]}-->`), (o = !0)
        continue
      } else if (c[0] === '?') {
        let h = x2(a[':@'], t),
          y = c === '?xml' ? '' : r,
          E = a[c][0][t.textNodeName]
        ;(E = E.length !== 0 ? ' ' + E : ''),
          (s += y + `<${c}${E}${h}?>`),
          (o = !0)
        continue
      }
      let d = r
      d !== '' && (d += t.indentBy)
      let p = x2(a[':@'], t),
        _ = r + `<${c}${p}`,
        f = P2(a[c], t, u, d)
      t.unpairedTags.indexOf(c) !== -1
        ? t.suppressUnpairedNode
          ? (s += _ + '>')
          : (s += _ + '/>')
        : (!f || f.length === 0) && t.suppressEmptyNode
          ? (s += _ + '/>')
          : f && f.endsWith('>')
            ? (s += _ + `>${f}${r}</${c}>`)
            : ((s += _ + '>'),
              f && r !== '' && (f.includes('/>') || f.includes('</'))
                ? (s += r + t.indentBy + f + r)
                : (s += f),
              (s += `</${c}>`)),
        (o = !0)
    }
    return s
  }
  function s0e(e) {
    let t = Object.keys(e)
    for (let n = 0; n < t.length; n++) {
      let r = t[n]
      if (r !== ':@') return r
    }
  }
  function x2(e, t) {
    let n = ''
    if (e && !t.ignoreAttributes)
      for (let r in e) {
        let s = t.attributeValueProcessor(r, e[r])
        ;(s = R2(s, t)),
          s === !0 && t.suppressBooleanAttributes
            ? (n += ` ${r.substr(t.attributeNamePrefix.length)}`)
            : (n += ` ${r.substr(t.attributeNamePrefix.length)}="${s}"`)
      }
    return n
  }
  function o0e(e, t) {
    e = e.substr(0, e.length - t.textNodeName.length - 1)
    let n = e.substr(e.lastIndexOf('.') + 1)
    for (let r in t.stopNodes)
      if (t.stopNodes[r] === e || t.stopNodes[r] === '*.' + n) return !0
    return !1
  }
  function R2(e, t) {
    if (e && e.length > 0 && t.processEntities)
      for (let n = 0; n < t.entities.length; n++) {
        let r = t.entities[n]
        e = e.replace(r.regex, r.val)
      }
    return e
  }
  D2.exports = r0e
})
var N2 = l((PVe, O2) => {
  'use strict'
  var i0e = A2(),
    a0e = {
      attributeNamePrefix: '@_',
      attributesGroupName: !1,
      textNodeName: '#text',
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: '  ',
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function (e, t) {
        return t
      },
      attributeValueProcessor: function (e, t) {
        return t
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [
        { regex: new RegExp('&', 'g'), val: '&amp;' },
        { regex: new RegExp('>', 'g'), val: '&gt;' },
        { regex: new RegExp('<', 'g'), val: '&lt;' },
        { regex: new RegExp("'", 'g'), val: '&apos;' },
        { regex: new RegExp('"', 'g'), val: '&quot;' },
      ],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1,
    }
  function ws(e) {
    ;(this.options = Object.assign({}, a0e, e)),
      this.options.ignoreAttributes || this.options.attributesGroupName
        ? (this.isAttribute = function () {
            return !1
          })
        : ((this.attrPrefixLen = this.options.attributeNamePrefix.length),
          (this.isAttribute = u0e)),
      (this.processTextOrObjNode = c0e),
      this.options.format
        ? ((this.indentate = d0e),
          (this.tagEndChar = `>
`),
          (this.newLine = `
`))
        : ((this.indentate = function () {
            return ''
          }),
          (this.tagEndChar = '>'),
          (this.newLine = ''))
  }
  ws.prototype.build = function (e) {
    return this.options.preserveOrder
      ? i0e(e, this.options)
      : (Array.isArray(e) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1 &&
          (e = { [this.options.arrayNodeName]: e }),
        this.j2x(e, 0).val)
  }
  ws.prototype.j2x = function (e, t) {
    let n = '',
      r = ''
    for (let s in e)
      if (!(typeof e[s] > 'u'))
        if (e[s] === null)
          s[0] === '?'
            ? (r += this.indentate(t) + '<' + s + '?' + this.tagEndChar)
            : (r += this.indentate(t) + '<' + s + '/' + this.tagEndChar)
        else if (e[s] instanceof Date)
          r += this.buildTextValNode(e[s], s, '', t)
        else if (typeof e[s] != 'object') {
          let o = this.isAttribute(s)
          if (o) n += this.buildAttrPairStr(o, '' + e[s])
          else if (s === this.options.textNodeName) {
            let i = this.options.tagValueProcessor(s, '' + e[s])
            r += this.replaceEntitiesValue(i)
          } else r += this.buildTextValNode(e[s], s, '', t)
        } else if (Array.isArray(e[s])) {
          let o = e[s].length,
            i = ''
          for (let a = 0; a < o; a++) {
            let c = e[s][a]
            typeof c > 'u' ||
              (c === null
                ? s[0] === '?'
                  ? (r += this.indentate(t) + '<' + s + '?' + this.tagEndChar)
                  : (r += this.indentate(t) + '<' + s + '/' + this.tagEndChar)
                : typeof c == 'object'
                  ? this.options.oneListGroup
                    ? (i += this.j2x(c, t + 1).val)
                    : (i += this.processTextOrObjNode(c, s, t))
                  : (i += this.buildTextValNode(c, s, '', t)))
          }
          this.options.oneListGroup && (i = this.buildObjectNode(i, s, '', t)),
            (r += i)
        } else if (
          this.options.attributesGroupName &&
          s === this.options.attributesGroupName
        ) {
          let o = Object.keys(e[s]),
            i = o.length
          for (let a = 0; a < i; a++)
            n += this.buildAttrPairStr(o[a], '' + e[s][o[a]])
        } else r += this.processTextOrObjNode(e[s], s, t)
    return { attrStr: n, val: r }
  }
  ws.prototype.buildAttrPairStr = function (e, t) {
    return (
      (t = this.options.attributeValueProcessor(e, '' + t)),
      (t = this.replaceEntitiesValue(t)),
      this.options.suppressBooleanAttributes && t === 'true'
        ? ' ' + e
        : ' ' + e + '="' + t + '"'
    )
  }
  function c0e(e, t, n) {
    let r = this.j2x(e, n + 1)
    return e[this.options.textNodeName] !== void 0 &&
      Object.keys(e).length === 1
      ? this.buildTextValNode(e[this.options.textNodeName], t, r.attrStr, n)
      : this.buildObjectNode(r.val, t, r.attrStr, n)
  }
  ws.prototype.buildObjectNode = function (e, t, n, r) {
    if (e === '')
      return t[0] === '?'
        ? this.indentate(r) + '<' + t + n + '?' + this.tagEndChar
        : this.indentate(r) + '<' + t + n + this.closeTag(t) + this.tagEndChar
    {
      let s = '</' + t + this.tagEndChar,
        o = ''
      return (
        t[0] === '?' && ((o = '?'), (s = '')),
        n && e.indexOf('<') === -1
          ? this.indentate(r) + '<' + t + n + o + '>' + e + s
          : this.options.commentPropName !== !1 &&
              t === this.options.commentPropName &&
              o.length === 0
            ? this.indentate(r) + `<!--${e}-->` + this.newLine
            : this.indentate(r) +
              '<' +
              t +
              n +
              o +
              this.tagEndChar +
              e +
              this.indentate(r) +
              s
      )
    }
  }
  ws.prototype.closeTag = function (e) {
    let t = ''
    return (
      this.options.unpairedTags.indexOf(e) !== -1
        ? this.options.suppressUnpairedNode || (t = '/')
        : this.options.suppressEmptyNode
          ? (t = '/')
          : (t = `></${e}`),
      t
    )
  }
  ws.prototype.buildTextValNode = function (e, t, n, r) {
    if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
      return this.indentate(r) + `<![CDATA[${e}]]>` + this.newLine
    if (
      this.options.commentPropName !== !1 &&
      t === this.options.commentPropName
    )
      return this.indentate(r) + `<!--${e}-->` + this.newLine
    if (t[0] === '?')
      return this.indentate(r) + '<' + t + n + '?' + this.tagEndChar
    {
      let s = this.options.tagValueProcessor(t, e)
      return (
        (s = this.replaceEntitiesValue(s)),
        s === ''
          ? this.indentate(r) + '<' + t + n + this.closeTag(t) + this.tagEndChar
          : this.indentate(r) +
            '<' +
            t +
            n +
            '>' +
            s +
            '</' +
            t +
            this.tagEndChar
      )
    }
  }
  ws.prototype.replaceEntitiesValue = function (e) {
    if (e && e.length > 0 && this.options.processEntities)
      for (let t = 0; t < this.options.entities.length; t++) {
        let n = this.options.entities[t]
        e = e.replace(n.regex, n.val)
      }
    return e
  }
  function d0e(e) {
    return this.options.indentBy.repeat(e)
  }
  function u0e(e) {
    return e.startsWith(this.options.attributeNamePrefix)
      ? e.substr(this.attrPrefixLen)
      : !1
  }
  O2.exports = ws
})
var k2 = l((RVe, q2) => {
  'use strict'
  var l0e = _x(),
    m0e = I2(),
    p0e = N2()
  q2.exports = { XMLParser: m0e, XMLValidator: l0e, XMLBuilder: p0e }
})
var Or = l((ce) => {
  'use strict'
  Object.defineProperty(ce, '__esModule', { value: !0 })
  ce.de_GetSessionTokenCommand =
    ce.de_GetFederationTokenCommand =
    ce.de_GetCallerIdentityCommand =
    ce.de_GetAccessKeyInfoCommand =
    ce.de_DecodeAuthorizationMessageCommand =
    ce.de_AssumeRoleWithWebIdentityCommand =
    ce.de_AssumeRoleWithSAMLCommand =
    ce.de_AssumeRoleCommand =
    ce.se_GetSessionTokenCommand =
    ce.se_GetFederationTokenCommand =
    ce.se_GetCallerIdentityCommand =
    ce.se_GetAccessKeyInfoCommand =
    ce.se_DecodeAuthorizationMessageCommand =
    ce.se_AssumeRoleWithWebIdentityCommand =
    ce.se_AssumeRoleWithSAMLCommand =
    ce.se_AssumeRoleCommand =
      void 0
  var _0e = Oe(),
    W = v(),
    f0e = k2(),
    Is = Ts(),
    h0e = Ag(),
    g0e = async (e, t) => {
      let n = Rs,
        r
      return (
        (r = As({ ...$0e(e, t), Action: 'AssumeRole', Version: '2011-06-15' })),
        Ps(t, n, '/', void 0, r)
      )
    }
  ce.se_AssumeRoleCommand = g0e
  var y0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...z0e(e, t),
        Action: 'AssumeRoleWithSAML',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_AssumeRoleWithSAMLCommand = y0e
  var E0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...H0e(e, t),
        Action: 'AssumeRoleWithWebIdentity',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_AssumeRoleWithWebIdentityCommand = E0e
  var S0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...V0e(e, t),
        Action: 'DecodeAuthorizationMessage',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_DecodeAuthorizationMessageCommand = S0e
  var b0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...Y0e(e, t),
        Action: 'GetAccessKeyInfo',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_GetAccessKeyInfoCommand = b0e
  var v0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...W0e(e, t),
        Action: 'GetCallerIdentity',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_GetCallerIdentityCommand = v0e
  var C0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...K0e(e, t),
        Action: 'GetFederationToken',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_GetFederationTokenCommand = C0e
  var T0e = async (e, t) => {
    let n = Rs,
      r
    return (
      (r = As({
        ...X0e(e, t),
        Action: 'GetSessionToken',
        Version: '2011-06-15',
      })),
      Ps(t, n, '/', void 0, r)
    )
  }
  ce.se_GetSessionTokenCommand = T0e
  var w0e = async (e, t) => {
    if (e.statusCode >= 300) return I0e(e, t)
    let n = await Ar(e.body, t),
      r = {}
    return (r = nTe(n.AssumeRoleResult, t)), { $metadata: st(e), ...r }
  }
  ce.de_AssumeRoleCommand = w0e
  var I0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body)
      switch (r) {
        case 'ExpiredTokenException':
        case 'com.amazonaws.sts#ExpiredTokenException':
          throw await vx(n, t)
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Ng(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await qg(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await yl(n, t)
        default:
          let s = n.body
          return xs({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    x0e = async (e, t) => {
      if (e.statusCode >= 300) return P0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (
        (r = rTe(n.AssumeRoleWithSAMLResult, t)), { $metadata: st(e), ...r }
      )
    }
  ce.de_AssumeRoleWithSAMLCommand = x0e
  var P0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body)
      switch (r) {
        case 'ExpiredTokenException':
        case 'com.amazonaws.sts#ExpiredTokenException':
          throw await vx(n, t)
        case 'IDPRejectedClaim':
        case 'com.amazonaws.sts#IDPRejectedClaimException':
          throw await M2(n, t)
        case 'InvalidIdentityToken':
        case 'com.amazonaws.sts#InvalidIdentityTokenException':
          throw await L2(n, t)
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Ng(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await qg(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await yl(n, t)
        default:
          let s = n.body
          return xs({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    R0e = async (e, t) => {
      if (e.statusCode >= 300) return D0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (
        (r = sTe(n.AssumeRoleWithWebIdentityResult, t)),
        { $metadata: st(e), ...r }
      )
    }
  ce.de_AssumeRoleWithWebIdentityCommand = R0e
  var D0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body)
      switch (r) {
        case 'ExpiredTokenException':
        case 'com.amazonaws.sts#ExpiredTokenException':
          throw await vx(n, t)
        case 'IDPCommunicationError':
        case 'com.amazonaws.sts#IDPCommunicationErrorException':
          throw await j0e(n, t)
        case 'IDPRejectedClaim':
        case 'com.amazonaws.sts#IDPRejectedClaimException':
          throw await M2(n, t)
        case 'InvalidIdentityToken':
        case 'com.amazonaws.sts#InvalidIdentityTokenException':
          throw await L2(n, t)
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Ng(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await qg(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await yl(n, t)
        default:
          let s = n.body
          return xs({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    A0e = async (e, t) => {
      if (e.statusCode >= 300) return O0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (
        (r = oTe(n.DecodeAuthorizationMessageResult, t)),
        { $metadata: st(e), ...r }
      )
    }
  ce.de_DecodeAuthorizationMessageCommand = A0e
  var O0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body)
      switch (r) {
        case 'InvalidAuthorizationMessageException':
        case 'com.amazonaws.sts#InvalidAuthorizationMessageException':
          throw await G0e(n, t)
        default:
          let s = n.body
          return xs({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    N0e = async (e, t) => {
      if (e.statusCode >= 300) return q0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (r = cTe(n.GetAccessKeyInfoResult, t)), { $metadata: st(e), ...r }
    }
  ce.de_GetAccessKeyInfoCommand = N0e
  var q0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body),
        s = n.body
      return xs({ output: e, parsedBody: s.Error, errorCode: r })
    },
    k0e = async (e, t) => {
      if (e.statusCode >= 300) return M0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (r = dTe(n.GetCallerIdentityResult, t)), { $metadata: st(e), ...r }
    }
  ce.de_GetCallerIdentityCommand = k0e
  var M0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body),
        s = n.body
      return xs({ output: e, parsedBody: s.Error, errorCode: r })
    },
    L0e = async (e, t) => {
      if (e.statusCode >= 300) return U0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (
        (r = uTe(n.GetFederationTokenResult, t)), { $metadata: st(e), ...r }
      )
    }
  ce.de_GetFederationTokenCommand = L0e
  var U0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body)
      switch (r) {
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Ng(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await qg(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await yl(n, t)
        default:
          let s = n.body
          return xs({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    F0e = async (e, t) => {
      if (e.statusCode >= 300) return B0e(e, t)
      let n = await Ar(e.body, t),
        r = {}
      return (r = lTe(n.GetSessionTokenResult, t)), { $metadata: st(e), ...r }
    }
  ce.de_GetSessionTokenCommand = F0e
  var B0e = async (e, t) => {
      let n = { ...e, body: await Ds(e.body, t) },
        r = Os(e, n.body)
      switch (r) {
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await yl(n, t)
        default:
          let s = n.body
          return xs({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    vx = async (e, t) => {
      let n = e.body,
        r = iTe(n.Error, t),
        s = new Is.ExpiredTokenException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    j0e = async (e, t) => {
      let n = e.body,
        r = mTe(n.Error, t),
        s = new Is.IDPCommunicationErrorException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    M2 = async (e, t) => {
      let n = e.body,
        r = pTe(n.Error, t),
        s = new Is.IDPRejectedClaimException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    G0e = async (e, t) => {
      let n = e.body,
        r = _Te(n.Error, t),
        s = new Is.InvalidAuthorizationMessageException({
          $metadata: st(e),
          ...r,
        })
      return (0, W.decorateServiceException)(s, n)
    },
    L2 = async (e, t) => {
      let n = e.body,
        r = fTe(n.Error, t),
        s = new Is.InvalidIdentityTokenException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    Ng = async (e, t) => {
      let n = e.body,
        r = hTe(n.Error, t),
        s = new Is.MalformedPolicyDocumentException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    qg = async (e, t) => {
      let n = e.body,
        r = gTe(n.Error, t),
        s = new Is.PackedPolicyTooLargeException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    yl = async (e, t) => {
      let n = e.body,
        r = yTe(n.Error, t),
        s = new Is.RegionDisabledException({ $metadata: st(e), ...r })
      return (0, W.decorateServiceException)(s, n)
    },
    $0e = (e, t) => {
      let n = {}
      if (
        (e.RoleArn != null && (n.RoleArn = e.RoleArn),
        e.RoleSessionName != null && (n.RoleSessionName = e.RoleSessionName),
        e.PolicyArns != null)
      ) {
        let r = kg(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      if (
        (e.Policy != null && (n.Policy = e.Policy),
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        e.Tags != null)
      ) {
        let r = U2(e.Tags, t)
        e.Tags?.length === 0 && (n.Tags = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `Tags.${s}`
            n[i] = o
          })
      }
      if (e.TransitiveTagKeys != null) {
        let r = tTe(e.TransitiveTagKeys, t)
        e.TransitiveTagKeys?.length === 0 && (n.TransitiveTagKeys = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `TransitiveTagKeys.${s}`
            n[i] = o
          })
      }
      if (
        (e.ExternalId != null && (n.ExternalId = e.ExternalId),
        e.SerialNumber != null && (n.SerialNumber = e.SerialNumber),
        e.TokenCode != null && (n.TokenCode = e.TokenCode),
        e.SourceIdentity != null && (n.SourceIdentity = e.SourceIdentity),
        e.ProvidedContexts != null)
      ) {
        let r = Z0e(e.ProvidedContexts, t)
        e.ProvidedContexts?.length === 0 && (n.ProvidedContexts = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `ProvidedContexts.${s}`
            n[i] = o
          })
      }
      return n
    },
    z0e = (e, t) => {
      let n = {}
      if (
        (e.RoleArn != null && (n.RoleArn = e.RoleArn),
        e.PrincipalArn != null && (n.PrincipalArn = e.PrincipalArn),
        e.SAMLAssertion != null && (n.SAMLAssertion = e.SAMLAssertion),
        e.PolicyArns != null)
      ) {
        let r = kg(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      return (
        e.Policy != null && (n.Policy = e.Policy),
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        n
      )
    },
    H0e = (e, t) => {
      let n = {}
      if (
        (e.RoleArn != null && (n.RoleArn = e.RoleArn),
        e.RoleSessionName != null && (n.RoleSessionName = e.RoleSessionName),
        e.WebIdentityToken != null && (n.WebIdentityToken = e.WebIdentityToken),
        e.ProviderId != null && (n.ProviderId = e.ProviderId),
        e.PolicyArns != null)
      ) {
        let r = kg(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      return (
        e.Policy != null && (n.Policy = e.Policy),
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        n
      )
    },
    V0e = (e, t) => {
      let n = {}
      return (
        e.EncodedMessage != null && (n.EncodedMessage = e.EncodedMessage), n
      )
    },
    Y0e = (e, t) => {
      let n = {}
      return e.AccessKeyId != null && (n.AccessKeyId = e.AccessKeyId), n
    },
    W0e = (e, t) => ({}),
    K0e = (e, t) => {
      let n = {}
      if (
        (e.Name != null && (n.Name = e.Name),
        e.Policy != null && (n.Policy = e.Policy),
        e.PolicyArns != null)
      ) {
        let r = kg(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      if (
        (e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        e.Tags != null)
      ) {
        let r = U2(e.Tags, t)
        e.Tags?.length === 0 && (n.Tags = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `Tags.${s}`
            n[i] = o
          })
      }
      return n
    },
    X0e = (e, t) => {
      let n = {}
      return (
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        e.SerialNumber != null && (n.SerialNumber = e.SerialNumber),
        e.TokenCode != null && (n.TokenCode = e.TokenCode),
        n
      )
    },
    kg = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) {
        if (s === null) continue
        let o = J0e(s, t)
        Object.entries(o).forEach(([i, a]) => {
          n[`member.${r}.${i}`] = a
        }),
          r++
      }
      return n
    },
    J0e = (e, t) => {
      let n = {}
      return e.arn != null && (n.arn = e.arn), n
    },
    Q0e = (e, t) => {
      let n = {}
      return (
        e.ProviderArn != null && (n.ProviderArn = e.ProviderArn),
        e.ContextAssertion != null && (n.ContextAssertion = e.ContextAssertion),
        n
      )
    },
    Z0e = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) {
        if (s === null) continue
        let o = Q0e(s, t)
        Object.entries(o).forEach(([i, a]) => {
          n[`member.${r}.${i}`] = a
        }),
          r++
      }
      return n
    },
    eTe = (e, t) => {
      let n = {}
      return (
        e.Key != null && (n.Key = e.Key),
        e.Value != null && (n.Value = e.Value),
        n
      )
    },
    tTe = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) s !== null && ((n[`member.${r}`] = s), r++)
      return n
    },
    U2 = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) {
        if (s === null) continue
        let o = eTe(s, t)
        Object.entries(o).forEach(([i, a]) => {
          n[`member.${r}.${i}`] = a
        }),
          r++
      }
      return n
    },
    Cx = (e, t) => {
      let n = {}
      return (
        e.AssumedRoleId !== void 0 &&
          (n.AssumedRoleId = (0, W.expectString)(e.AssumedRoleId)),
        e.Arn !== void 0 && (n.Arn = (0, W.expectString)(e.Arn)),
        n
      )
    },
    nTe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = El(e.Credentials, t)),
        e.AssumedRoleUser !== void 0 &&
          (n.AssumedRoleUser = Cx(e.AssumedRoleUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, W.strictParseInt32)(e.PackedPolicySize)),
        e.SourceIdentity !== void 0 &&
          (n.SourceIdentity = (0, W.expectString)(e.SourceIdentity)),
        n
      )
    },
    rTe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = El(e.Credentials, t)),
        e.AssumedRoleUser !== void 0 &&
          (n.AssumedRoleUser = Cx(e.AssumedRoleUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, W.strictParseInt32)(e.PackedPolicySize)),
        e.Subject !== void 0 && (n.Subject = (0, W.expectString)(e.Subject)),
        e.SubjectType !== void 0 &&
          (n.SubjectType = (0, W.expectString)(e.SubjectType)),
        e.Issuer !== void 0 && (n.Issuer = (0, W.expectString)(e.Issuer)),
        e.Audience !== void 0 && (n.Audience = (0, W.expectString)(e.Audience)),
        e.NameQualifier !== void 0 &&
          (n.NameQualifier = (0, W.expectString)(e.NameQualifier)),
        e.SourceIdentity !== void 0 &&
          (n.SourceIdentity = (0, W.expectString)(e.SourceIdentity)),
        n
      )
    },
    sTe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = El(e.Credentials, t)),
        e.SubjectFromWebIdentityToken !== void 0 &&
          (n.SubjectFromWebIdentityToken = (0, W.expectString)(
            e.SubjectFromWebIdentityToken,
          )),
        e.AssumedRoleUser !== void 0 &&
          (n.AssumedRoleUser = Cx(e.AssumedRoleUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, W.strictParseInt32)(e.PackedPolicySize)),
        e.Provider !== void 0 && (n.Provider = (0, W.expectString)(e.Provider)),
        e.Audience !== void 0 && (n.Audience = (0, W.expectString)(e.Audience)),
        e.SourceIdentity !== void 0 &&
          (n.SourceIdentity = (0, W.expectString)(e.SourceIdentity)),
        n
      )
    },
    El = (e, t) => {
      let n = {}
      return (
        e.AccessKeyId !== void 0 &&
          (n.AccessKeyId = (0, W.expectString)(e.AccessKeyId)),
        e.SecretAccessKey !== void 0 &&
          (n.SecretAccessKey = (0, W.expectString)(e.SecretAccessKey)),
        e.SessionToken !== void 0 &&
          (n.SessionToken = (0, W.expectString)(e.SessionToken)),
        e.Expiration !== void 0 &&
          (n.Expiration = (0, W.expectNonNull)(
            (0, W.parseRfc3339DateTimeWithOffset)(e.Expiration),
          )),
        n
      )
    },
    oTe = (e, t) => {
      let n = {}
      return (
        e.DecodedMessage !== void 0 &&
          (n.DecodedMessage = (0, W.expectString)(e.DecodedMessage)),
        n
      )
    },
    iTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    aTe = (e, t) => {
      let n = {}
      return (
        e.FederatedUserId !== void 0 &&
          (n.FederatedUserId = (0, W.expectString)(e.FederatedUserId)),
        e.Arn !== void 0 && (n.Arn = (0, W.expectString)(e.Arn)),
        n
      )
    },
    cTe = (e, t) => {
      let n = {}
      return (
        e.Account !== void 0 && (n.Account = (0, W.expectString)(e.Account)), n
      )
    },
    dTe = (e, t) => {
      let n = {}
      return (
        e.UserId !== void 0 && (n.UserId = (0, W.expectString)(e.UserId)),
        e.Account !== void 0 && (n.Account = (0, W.expectString)(e.Account)),
        e.Arn !== void 0 && (n.Arn = (0, W.expectString)(e.Arn)),
        n
      )
    },
    uTe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = El(e.Credentials, t)),
        e.FederatedUser !== void 0 &&
          (n.FederatedUser = aTe(e.FederatedUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, W.strictParseInt32)(e.PackedPolicySize)),
        n
      )
    },
    lTe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = El(e.Credentials, t)), n
      )
    },
    mTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    pTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    _Te = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    fTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    hTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    gTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    yTe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, W.expectString)(e.message)), n
      )
    },
    st = (e) => ({
      httpStatusCode: e.statusCode,
      requestId:
        e.headers['x-amzn-requestid'] ??
        e.headers['x-amzn-request-id'] ??
        e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }),
    ETe = (e, t) => (0, W.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    xs = (0, W.withBaseException)(h0e.STSServiceException),
    Ps = async (e, t, n, r, s) => {
      let {
          hostname: o,
          protocol: i = 'https',
          port: a,
          path: c,
        } = await e.endpoint(),
        u = {
          protocol: i,
          hostname: o,
          port: a,
          method: 'POST',
          path: c.endsWith('/') ? c.slice(0, -1) + n : c + n,
          headers: t,
        }
      return (
        r !== void 0 && (u.hostname = r),
        s !== void 0 && (u.body = s),
        new _0e.HttpRequest(u)
      )
    },
    Rs = { 'content-type': 'application/x-www-form-urlencoded' },
    Ar = (e, t) =>
      ETe(e, t).then((n) => {
        if (n.length) {
          let r = new f0e.XMLParser({
            attributeNamePrefix: '',
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (c, u) =>
              u.trim() === '' &&
              u.includes(`
`)
                ? ''
                : void 0,
          })
          r.addEntity('#xD', '\r'),
            r.addEntity(
              '#10',
              `
`,
            )
          let s = r.parse(n),
            o = '#text',
            i = Object.keys(s)[0],
            a = s[i]
          return (
            a[o] && ((a[i] = a[o]), delete a[o]), (0, W.getValueFromTextNode)(a)
          )
        }
        return {}
      }),
    Ds = async (e, t) => {
      let n = await Ar(e, t)
      return (
        n.Error && (n.Error.message = n.Error.message ?? n.Error.Message), n
      )
    },
    As = (e) =>
      Object.entries(e)
        .map(
          ([t, n]) =>
            (0, W.extendedEncodeURIComponent)(t) +
            '=' +
            (0, W.extendedEncodeURIComponent)(n),
        )
        .join('&'),
    Os = (e, t) => {
      if (t.Error?.Code !== void 0) return t.Error.Code
      if (e.statusCode == 404) return 'NotFound'
    }
})
var Mg = l((va) => {
  'use strict'
  Object.defineProperty(va, '__esModule', { value: !0 })
  va.AssumeRoleCommand = va.$Command = void 0
  var STe = Sr(),
    bTe = q(),
    vTe = k(),
    B2 = v()
  Object.defineProperty(va, '$Command', {
    enumerable: !0,
    get: function () {
      return B2.Command
    },
  })
  var CTe = D(),
    TTe = Ts(),
    F2 = Or(),
    Tx = class e extends B2.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, vTe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, bTe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, STe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'AssumeRoleCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: TTe.AssumeRoleResponseFilterSensitiveLog,
            [CTe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'AssumeRole',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, F2.se_AssumeRoleCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, F2.de_AssumeRoleCommand)(t, n)
      }
    }
  va.AssumeRoleCommand = Tx
})
var Lg = l((Ca) => {
  'use strict'
  Object.defineProperty(Ca, '__esModule', { value: !0 })
  Ca.AssumeRoleWithWebIdentityCommand = Ca.$Command = void 0
  var wTe = q(),
    ITe = k(),
    $2 = v()
  Object.defineProperty(Ca, '$Command', {
    enumerable: !0,
    get: function () {
      return $2.Command
    },
  })
  var xTe = D(),
    j2 = Ts(),
    G2 = Or(),
    wx = class e extends $2.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ITe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, wTe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'AssumeRoleWithWebIdentityCommand',
            inputFilterSensitiveLog:
              j2.AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
            outputFilterSensitiveLog:
              j2.AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
            [xTe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'AssumeRoleWithWebIdentity',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, G2.se_AssumeRoleWithWebIdentityCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, G2.de_AssumeRoleWithWebIdentityCommand)(t, n)
      }
    }
  Ca.AssumeRoleWithWebIdentityCommand = wx
})
var Ix = l((Wn) => {
  'use strict'
  Object.defineProperty(Wn, '__esModule', { value: !0 })
  Wn.decorateDefaultCredentialProvider =
    Wn.getDefaultRoleAssumerWithWebIdentity =
    Wn.getDefaultRoleAssumer =
      void 0
  var PTe = Mg(),
    RTe = Lg(),
    z2 = 'us-east-1',
    H2 = (e) =>
      typeof e != 'function'
        ? e === void 0
          ? z2
          : e
        : async () => {
            try {
              return await e()
            } catch {
              return z2
            }
          },
    DTe = (e, t) => {
      let n, r
      return async (s, o) => {
        if (((r = s), !n)) {
          let { logger: a, region: c, requestHandler: u } = e
          n = new t({
            logger: a,
            credentialDefaultProvider: () => async () => r,
            region: H2(c || e.region),
            ...(u ? { requestHandler: u } : {}),
          })
        }
        let { Credentials: i } = await n.send(new PTe.AssumeRoleCommand(o))
        if (!i || !i.AccessKeyId || !i.SecretAccessKey)
          throw new Error(
            `Invalid response from STS.assumeRole call with role ${o.RoleArn}`,
          )
        return {
          accessKeyId: i.AccessKeyId,
          secretAccessKey: i.SecretAccessKey,
          sessionToken: i.SessionToken,
          expiration: i.Expiration,
        }
      }
    }
  Wn.getDefaultRoleAssumer = DTe
  var ATe = (e, t) => {
    let n
    return async (r) => {
      if (!n) {
        let { logger: o, region: i, requestHandler: a } = e
        n = new t({
          logger: o,
          region: H2(i || e.region),
          ...(a ? { requestHandler: a } : {}),
        })
      }
      let { Credentials: s } = await n.send(
        new RTe.AssumeRoleWithWebIdentityCommand(r),
      )
      if (!s || !s.AccessKeyId || !s.SecretAccessKey)
        throw new Error(
          `Invalid response from STS.assumeRoleWithWebIdentity call with role ${r.RoleArn}`,
        )
      return {
        accessKeyId: s.AccessKeyId,
        secretAccessKey: s.SecretAccessKey,
        sessionToken: s.SessionToken,
        expiration: s.Expiration,
      }
    }
  }
  Wn.getDefaultRoleAssumerWithWebIdentity = ATe
  var OTe = (e) => (t) =>
    e({
      roleAssumer: (0, Wn.getDefaultRoleAssumer)(t, t.stsClientCtor),
      roleAssumerWithWebIdentity: (0, Wn.getDefaultRoleAssumerWithWebIdentity)(
        t,
        t.stsClientCtor,
      ),
      ...t,
    })
  Wn.decorateDefaultCredentialProvider = OTe
})
var V2 = l((ot) => {
  'use strict'
  Object.defineProperty(ot, '__esModule', { value: !0 })
  ot.fromEnv =
    ot.ENV_EXPIRATION =
    ot.ENV_SESSION =
    ot.ENV_SECRET =
    ot.ENV_KEY =
      void 0
  var NTe = ye()
  ot.ENV_KEY = 'AWS_ACCESS_KEY_ID'
  ot.ENV_SECRET = 'AWS_SECRET_ACCESS_KEY'
  ot.ENV_SESSION = 'AWS_SESSION_TOKEN'
  ot.ENV_EXPIRATION = 'AWS_CREDENTIAL_EXPIRATION'
  var qTe = () => async () => {
    let e = process.env[ot.ENV_KEY],
      t = process.env[ot.ENV_SECRET],
      n = process.env[ot.ENV_SESSION],
      r = process.env[ot.ENV_EXPIRATION]
    if (e && t)
      return {
        accessKeyId: e,
        secretAccessKey: t,
        ...(n && { sessionToken: n }),
        ...(r && { expiration: new Date(r) }),
      }
    throw new NTe.CredentialsProviderError(
      'Unable to find environment variable credentials.',
    )
  }
  ot.fromEnv = qTe
})
var Px = l((xx) => {
  'use strict'
  Object.defineProperty(xx, '__esModule', { value: !0 })
  var kTe = (x(), w(I))
  kTe.__exportStar(V2(), xx)
})
var Fg = l((Ug) => {
  'use strict'
  Object.defineProperty(Ug, '__esModule', { value: !0 })
  Ug.httpRequest = void 0
  var Rx = ye(),
    MTe = require('buffer'),
    LTe = require('http')
  function UTe(e) {
    return new Promise((t, n) => {
      var r
      let s = (0, LTe.request)({
        method: 'GET',
        ...e,
        hostname:
          (r = e.hostname) === null || r === void 0
            ? void 0
            : r.replace(/^\[(.+)\]$/, '$1'),
      })
      s.on('error', (o) => {
        n(
          Object.assign(
            new Rx.ProviderError(
              'Unable to connect to instance metadata service',
            ),
            o,
          ),
        ),
          s.destroy()
      }),
        s.on('timeout', () => {
          n(
            new Rx.ProviderError('TimeoutError from instance metadata service'),
          ),
            s.destroy()
        }),
        s.on('response', (o) => {
          let { statusCode: i = 400 } = o
          ;(i < 200 || 300 <= i) &&
            (n(
              Object.assign(
                new Rx.ProviderError(
                  'Error response received from instance metadata service',
                ),
                { statusCode: i },
              ),
            ),
            s.destroy())
          let a = []
          o.on('data', (c) => {
            a.push(c)
          }),
            o.on('end', () => {
              t(MTe.Buffer.concat(a)), s.destroy()
            })
        }),
        s.end()
    })
  }
  Ug.httpRequest = UTe
})
var Dx = l((Ta) => {
  'use strict'
  Object.defineProperty(Ta, '__esModule', { value: !0 })
  Ta.fromImdsCredentials = Ta.isImdsCredentials = void 0
  var FTe = (e) =>
    !!e &&
    typeof e == 'object' &&
    typeof e.AccessKeyId == 'string' &&
    typeof e.SecretAccessKey == 'string' &&
    typeof e.Token == 'string' &&
    typeof e.Expiration == 'string'
  Ta.isImdsCredentials = FTe
  var BTe = (e) => ({
    accessKeyId: e.AccessKeyId,
    secretAccessKey: e.SecretAccessKey,
    sessionToken: e.Token,
    expiration: new Date(e.Expiration),
  })
  Ta.fromImdsCredentials = BTe
})
var Bg = l((Kn) => {
  'use strict'
  Object.defineProperty(Kn, '__esModule', { value: !0 })
  Kn.providerConfigFromInit =
    Kn.DEFAULT_MAX_RETRIES =
    Kn.DEFAULT_TIMEOUT =
      void 0
  Kn.DEFAULT_TIMEOUT = 1e3
  Kn.DEFAULT_MAX_RETRIES = 0
  var jTe = ({
    maxRetries: e = Kn.DEFAULT_MAX_RETRIES,
    timeout: t = Kn.DEFAULT_TIMEOUT,
  }) => ({ maxRetries: e, timeout: t })
  Kn.providerConfigFromInit = jTe
})
var Ax = l((jg) => {
  'use strict'
  Object.defineProperty(jg, '__esModule', { value: !0 })
  jg.retry = void 0
  var GTe = (e, t) => {
    let n = e()
    for (let r = 0; r < t; r++) n = n.catch(e)
    return n
  }
  jg.retry = GTe
})
var W2 = l(($e) => {
  'use strict'
  Object.defineProperty($e, '__esModule', { value: !0 })
  $e.fromContainerMetadata =
    $e.ENV_CMDS_AUTH_TOKEN =
    $e.ENV_CMDS_RELATIVE_URI =
    $e.ENV_CMDS_FULL_URI =
      void 0
  var Gg = ye(),
    $Te = require('url'),
    zTe = Fg(),
    Y2 = Dx(),
    HTe = Bg(),
    VTe = Ax()
  $e.ENV_CMDS_FULL_URI = 'AWS_CONTAINER_CREDENTIALS_FULL_URI'
  $e.ENV_CMDS_RELATIVE_URI = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI'
  $e.ENV_CMDS_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN'
  var YTe = (e = {}) => {
    let { timeout: t, maxRetries: n } = (0, HTe.providerConfigFromInit)(e)
    return () =>
      (0, VTe.retry)(async () => {
        let r = await QTe(),
          s = JSON.parse(await WTe(t, r))
        if (!(0, Y2.isImdsCredentials)(s))
          throw new Gg.CredentialsProviderError(
            'Invalid response received from instance metadata service.',
          )
        return (0, Y2.fromImdsCredentials)(s)
      }, n)
  }
  $e.fromContainerMetadata = YTe
  var WTe = async (e, t) => (
      process.env[$e.ENV_CMDS_AUTH_TOKEN] &&
        (t.headers = {
          ...t.headers,
          Authorization: process.env[$e.ENV_CMDS_AUTH_TOKEN],
        }),
      (await (0, zTe.httpRequest)({ ...t, timeout: e })).toString()
    ),
    KTe = '169.254.170.2',
    XTe = { localhost: !0, '127.0.0.1': !0 },
    JTe = { 'http:': !0, 'https:': !0 },
    QTe = async () => {
      if (process.env[$e.ENV_CMDS_RELATIVE_URI])
        return { hostname: KTe, path: process.env[$e.ENV_CMDS_RELATIVE_URI] }
      if (process.env[$e.ENV_CMDS_FULL_URI]) {
        let e = (0, $Te.parse)(process.env[$e.ENV_CMDS_FULL_URI])
        if (!e.hostname || !(e.hostname in XTe))
          throw new Gg.CredentialsProviderError(
            `${e.hostname} is not a valid container metadata service hostname`,
            !1,
          )
        if (!e.protocol || !(e.protocol in JTe))
          throw new Gg.CredentialsProviderError(
            `${e.protocol} is not a valid container metadata service protocol`,
            !1,
          )
        return { ...e, port: e.port ? parseInt(e.port, 10) : void 0 }
      }
      throw new Gg.CredentialsProviderError(
        `The container metadata credential provider cannot be used unless the ${$e.ENV_CMDS_RELATIVE_URI} or ${$e.ENV_CMDS_FULL_URI} environment variable is set`,
        !1,
      )
    }
})
var K2 = l((Sl) => {
  'use strict'
  Object.defineProperty(Sl, '__esModule', { value: !0 })
  Sl.Endpoint = void 0
  var ZTe
  ;(function (e) {
    ;(e.IPv4 = 'http://169.254.169.254'), (e.IPv6 = 'http://[fd00:ec2::254]')
  })((ZTe = Sl.Endpoint || (Sl.Endpoint = {})))
})
var X2 = l((Xn) => {
  'use strict'
  Object.defineProperty(Xn, '__esModule', { value: !0 })
  Xn.ENDPOINT_CONFIG_OPTIONS =
    Xn.CONFIG_ENDPOINT_NAME =
    Xn.ENV_ENDPOINT_NAME =
      void 0
  Xn.ENV_ENDPOINT_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT'
  Xn.CONFIG_ENDPOINT_NAME = 'ec2_metadata_service_endpoint'
  Xn.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Xn.ENV_ENDPOINT_NAME],
    configFileSelector: (e) => e[Xn.CONFIG_ENDPOINT_NAME],
    default: void 0,
  }
})
var Ox = l((bl) => {
  'use strict'
  Object.defineProperty(bl, '__esModule', { value: !0 })
  bl.EndpointMode = void 0
  var ewe
  ;(function (e) {
    ;(e.IPv4 = 'IPv4'), (e.IPv6 = 'IPv6')
  })((ewe = bl.EndpointMode || (bl.EndpointMode = {})))
})
var J2 = l((Jn) => {
  'use strict'
  Object.defineProperty(Jn, '__esModule', { value: !0 })
  Jn.ENDPOINT_MODE_CONFIG_OPTIONS =
    Jn.CONFIG_ENDPOINT_MODE_NAME =
    Jn.ENV_ENDPOINT_MODE_NAME =
      void 0
  var twe = Ox()
  Jn.ENV_ENDPOINT_MODE_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE'
  Jn.CONFIG_ENDPOINT_MODE_NAME = 'ec2_metadata_service_endpoint_mode'
  Jn.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Jn.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (e) => e[Jn.CONFIG_ENDPOINT_MODE_NAME],
    default: twe.EndpointMode.IPv4,
  }
})
var qx = l(($g) => {
  'use strict'
  Object.defineProperty($g, '__esModule', { value: !0 })
  $g.getInstanceMetadataEndpoint = void 0
  var Z2 = vr(),
    nwe = Mo(),
    Q2 = K2(),
    rwe = X2(),
    Nx = Ox(),
    swe = J2(),
    owe = async () => (0, nwe.parseUrl)((await iwe()) || (await awe()))
  $g.getInstanceMetadataEndpoint = owe
  var iwe = async () => (0, Z2.loadConfig)(rwe.ENDPOINT_CONFIG_OPTIONS)(),
    awe = async () => {
      let e = await (0, Z2.loadConfig)(swe.ENDPOINT_MODE_CONFIG_OPTIONS)()
      switch (e) {
        case Nx.EndpointMode.IPv4:
          return Q2.Endpoint.IPv4
        case Nx.EndpointMode.IPv6:
          return Q2.Endpoint.IPv6
        default:
          throw new Error(
            `Unsupported endpoint mode: ${e}. Select from ${Object.values(
              Nx.EndpointMode,
            )}`,
          )
      }
    }
})
var e3 = l((zg) => {
  'use strict'
  Object.defineProperty(zg, '__esModule', { value: !0 })
  zg.getExtendedInstanceMetadataCredentials = void 0
  var cwe = 5 * 60,
    dwe = 5 * 60,
    uwe =
      'https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html',
    lwe = (e, t) => {
      var n
      let r = cwe + Math.floor(Math.random() * dwe),
        s = new Date(Date.now() + r * 1e3)
      t.warn(
        'Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: ' +
          uwe,
      )
      let o =
        (n = e.originalExpiration) !== null && n !== void 0 ? n : e.expiration
      return { ...e, ...(o ? { originalExpiration: o } : {}), expiration: s }
    }
  zg.getExtendedInstanceMetadataCredentials = lwe
})
var n3 = l((Hg) => {
  'use strict'
  Object.defineProperty(Hg, '__esModule', { value: !0 })
  Hg.staticStabilityProvider = void 0
  var t3 = e3(),
    mwe = (e, t = {}) => {
      let n = t?.logger || console,
        r
      return async () => {
        let s
        try {
          ;(s = await e()),
            s.expiration &&
              s.expiration.getTime() < Date.now() &&
              (s = (0, t3.getExtendedInstanceMetadataCredentials)(s, n))
        } catch (o) {
          if (r)
            n.warn('Credential renew failed: ', o),
              (s = (0, t3.getExtendedInstanceMetadataCredentials)(r, n))
          else throw o
        }
        return (r = s), s
      }
    }
  Hg.staticStabilityProvider = mwe
})
var i3 = l((Vg) => {
  'use strict'
  Object.defineProperty(Vg, '__esModule', { value: !0 })
  Vg.fromInstanceMetadata = void 0
  var pwe = ye(),
    kx = Fg(),
    r3 = Dx(),
    _we = Bg(),
    s3 = Ax(),
    fwe = qx(),
    hwe = n3(),
    o3 = '/latest/meta-data/iam/security-credentials/',
    gwe = '/latest/api/token',
    ywe = (e = {}) =>
      (0, hwe.staticStabilityProvider)(Ewe(e), { logger: e.logger })
  Vg.fromInstanceMetadata = ywe
  var Ewe = (e) => {
      let t = !1,
        { timeout: n, maxRetries: r } = (0, _we.providerConfigFromInit)(e),
        s = async (o, i) => {
          let a = (
            await (0, s3.retry)(async () => {
              let c
              try {
                c = await bwe(i)
              } catch (u) {
                throw (u.statusCode === 401 && (t = !1), u)
              }
              return c
            }, o)
          ).trim()
          return (0, s3.retry)(async () => {
            let c
            try {
              c = await vwe(a, i)
            } catch (u) {
              throw (u.statusCode === 401 && (t = !1), u)
            }
            return c
          }, o)
        }
      return async () => {
        let o = await (0, fwe.getInstanceMetadataEndpoint)()
        if (t) return s(r, { ...o, timeout: n })
        {
          let i
          try {
            i = (await Swe({ ...o, timeout: n })).toString()
          } catch (a) {
            if (a?.statusCode === 400)
              throw Object.assign(a, {
                message: 'EC2 Metadata token request returned error',
              })
            return (
              (a.message === 'TimeoutError' ||
                [403, 404, 405].includes(a.statusCode)) &&
                (t = !0),
              s(r, { ...o, timeout: n })
            )
          }
          return s(r, {
            ...o,
            headers: { 'x-aws-ec2-metadata-token': i },
            timeout: n,
          })
        }
      }
    },
    Swe = async (e) =>
      (0, kx.httpRequest)({
        ...e,
        path: gwe,
        method: 'PUT',
        headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '21600' },
      }),
    bwe = async (e) =>
      (await (0, kx.httpRequest)({ ...e, path: o3 })).toString(),
    vwe = async (e, t) => {
      let n = JSON.parse(
        (await (0, kx.httpRequest)({ ...t, path: o3 + e })).toString(),
      )
      if (!(0, r3.isImdsCredentials)(n))
        throw new pwe.CredentialsProviderError(
          'Invalid response received from instance metadata service.',
        )
      return (0, r3.fromImdsCredentials)(n)
    }
})
var c3 = l((a3) => {
  'use strict'
  Object.defineProperty(a3, '__esModule', { value: !0 })
})
var Wg = l((Qn) => {
  'use strict'
  Object.defineProperty(Qn, '__esModule', { value: !0 })
  Qn.getInstanceMetadataEndpoint = Qn.httpRequest = void 0
  var Yg = (x(), w(I))
  Yg.__exportStar(W2(), Qn)
  Yg.__exportStar(i3(), Qn)
  Yg.__exportStar(Bg(), Qn)
  Yg.__exportStar(c3(), Qn)
  var Cwe = Fg()
  Object.defineProperty(Qn, 'httpRequest', {
    enumerable: !0,
    get: function () {
      return Cwe.httpRequest
    },
  })
  var Twe = qx()
  Object.defineProperty(Qn, 'getInstanceMetadataEndpoint', {
    enumerable: !0,
    get: function () {
      return Twe.getInstanceMetadataEndpoint
    },
  })
})
var u3 = l((Kg) => {
  'use strict'
  Object.defineProperty(Kg, '__esModule', { value: !0 })
  Kg.resolveCredentialSource = void 0
  var wwe = Px(),
    d3 = Wg(),
    Iwe = ye(),
    xwe = (e, t) => {
      let n = {
        EcsContainer: d3.fromContainerMetadata,
        Ec2InstanceMetadata: d3.fromInstanceMetadata,
        Environment: wwe.fromEnv,
      }
      if (e in n) return n[e]()
      throw new Iwe.CredentialsProviderError(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
      )
    }
  Kg.resolveCredentialSource = xwe
})
var l3 = l((wa) => {
  'use strict'
  Object.defineProperty(wa, '__esModule', { value: !0 })
  wa.resolveAssumeRoleCredentials = wa.isAssumeRoleProfile = void 0
  var Mx = ye(),
    Pwe = mn(),
    Rwe = u3(),
    Dwe = Lx(),
    Awe = (e) =>
      !!e &&
      typeof e == 'object' &&
      typeof e.role_arn == 'string' &&
      ['undefined', 'string'].indexOf(typeof e.role_session_name) > -1 &&
      ['undefined', 'string'].indexOf(typeof e.external_id) > -1 &&
      ['undefined', 'string'].indexOf(typeof e.mfa_serial) > -1 &&
      (Owe(e) || Nwe(e))
  wa.isAssumeRoleProfile = Awe
  var Owe = (e) =>
      typeof e.source_profile == 'string' && typeof e.credential_source > 'u',
    Nwe = (e) =>
      typeof e.credential_source == 'string' && typeof e.source_profile > 'u',
    qwe = async (e, t, n, r = {}) => {
      let s = t[e]
      if (!n.roleAssumer)
        throw new Mx.CredentialsProviderError(
          `Profile ${e} requires a role to be assumed, but no role assumption callback was provided.`,
          !1,
        )
      let { source_profile: o } = s
      if (o && o in r)
        throw new Mx.CredentialsProviderError(
          `Detected a cycle attempting to resolve credentials for profile ${(0,
          Pwe.getProfileName)(n)}. Profiles visited: ` +
            Object.keys(r).join(', '),
          !1,
        )
      let i = o
          ? (0, Dwe.resolveProfileData)(o, t, n, { ...r, [o]: !0 })
          : (0, Rwe.resolveCredentialSource)(s.credential_source, e)(),
        a = {
          RoleArn: s.role_arn,
          RoleSessionName: s.role_session_name || `aws-sdk-js-${Date.now()}`,
          ExternalId: s.external_id,
          DurationSeconds: parseInt(s.duration_seconds || '3600', 10),
        },
        { mfa_serial: c } = s
      if (c) {
        if (!n.mfaCodeProvider)
          throw new Mx.CredentialsProviderError(
            `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
            !1,
          )
        ;(a.SerialNumber = c), (a.TokenCode = await n.mfaCodeProvider(c))
      }
      let u = await i
      return n.roleAssumer(u, a)
    }
  wa.resolveAssumeRoleCredentials = qwe
})
var m3 = l((Xg) => {
  'use strict'
  Object.defineProperty(Xg, '__esModule', { value: !0 })
  Xg.getValidatedProcessCredentials = void 0
  var kwe = (e, t) => {
    if (t.Version !== 1)
      throw Error(`Profile ${e} credential_process did not return Version 1.`)
    if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
      throw Error(
        `Profile ${e} credential_process returned invalid credentials.`,
      )
    if (t.Expiration) {
      let n = new Date()
      if (new Date(t.Expiration) < n)
        throw Error(
          `Profile ${e} credential_process returned expired credentials.`,
        )
    }
    return {
      accessKeyId: t.AccessKeyId,
      secretAccessKey: t.SecretAccessKey,
      ...(t.SessionToken && { sessionToken: t.SessionToken }),
      ...(t.Expiration && { expiration: new Date(t.Expiration) }),
    }
  }
  Xg.getValidatedProcessCredentials = kwe
})
var p3 = l((Jg) => {
  'use strict'
  Object.defineProperty(Jg, '__esModule', { value: !0 })
  Jg.resolveProcessCredentials = void 0
  var Ux = ye(),
    Mwe = require('child_process'),
    Lwe = require('util'),
    Uwe = m3(),
    Fwe = async (e, t) => {
      let n = t[e]
      if (t[e]) {
        let r = n.credential_process
        if (r !== void 0) {
          let s = (0, Lwe.promisify)(Mwe.exec)
          try {
            let { stdout: o } = await s(r),
              i
            try {
              i = JSON.parse(o.trim())
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`,
              )
            }
            return (0, Uwe.getValidatedProcessCredentials)(e, i)
          } catch (o) {
            throw new Ux.CredentialsProviderError(o.message)
          }
        } else
          throw new Ux.CredentialsProviderError(
            `Profile ${e} did not contain credential_process.`,
          )
      } else
        throw new Ux.CredentialsProviderError(
          `Profile ${e} could not be found in shared credentials file.`,
        )
    }
  Jg.resolveProcessCredentials = Fwe
})
var f3 = l((Qg) => {
  'use strict'
  Object.defineProperty(Qg, '__esModule', { value: !0 })
  Qg.fromProcess = void 0
  var _3 = mn(),
    Bwe = p3(),
    jwe =
      (e = {}) =>
      async () => {
        let t = await (0, _3.parseKnownFiles)(e)
        return (0, Bwe.resolveProcessCredentials)((0, _3.getProfileName)(e), t)
      }
  Qg.fromProcess = jwe
})
var Bx = l((Fx) => {
  'use strict'
  Object.defineProperty(Fx, '__esModule', { value: !0 })
  var Gwe = (x(), w(I))
  Gwe.__exportStar(f3(), Fx)
})
var h3 = l((Ia) => {
  'use strict'
  Object.defineProperty(Ia, '__esModule', { value: !0 })
  Ia.resolveProcessCredentials = Ia.isProcessProfile = void 0
  var $we = Bx(),
    zwe = (e) =>
      !!e && typeof e == 'object' && typeof e.credential_process == 'string'
  Ia.isProcessProfile = zwe
  var Hwe = async (e, t) => (0, $we.fromProcess)({ ...e, profile: t })()
  Ia.resolveProcessCredentials = Hwe
})
var jx = l((Zg) => {
  'use strict'
  Object.defineProperty(Zg, '__esModule', { value: !0 })
  Zg.isSsoProfile = void 0
  var Vwe = (e) =>
    e &&
    (typeof e.sso_start_url == 'string' ||
      typeof e.sso_account_id == 'string' ||
      typeof e.sso_session == 'string' ||
      typeof e.sso_region == 'string' ||
      typeof e.sso_role_name == 'string')
  Zg.isSsoProfile = Vwe
})
var g3 = l((ey) => {
  'use strict'
  Object.defineProperty(ey, '__esModule', { value: !0 })
  ey.resolveClientEndpointParameters = void 0
  var Ywe = (e) => ({
    ...e,
    useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
    useFipsEndpoint: e.useFipsEndpoint ?? !1,
    defaultSigningName: 'awsssoportal',
  })
  ey.resolveClientEndpointParameters = Ywe
})
var y3 = l((iYe, Wwe) => {
  Wwe.exports = {
    name: '@aws-sdk/client-sso',
    description:
      'AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native',
    version: '3.433.0',
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      'build:cjs': 'tsc -p tsconfig.cjs.json',
      'build:docs': 'typedoc',
      'build:es': 'tsc -p tsconfig.es.json',
      'build:include:deps':
        'lerna run --scope $npm_package_name --include-dependencies build',
      'build:types': 'tsc -p tsconfig.types.json',
      'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
      clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
      'extract:docs': 'api-extractor run --local',
      'generate:client':
        'node ../../scripts/generate-clients/single-service --solo sso',
    },
    main: './dist-cjs/index.js',
    types: './dist-types/index.d.ts',
    module: './dist-es/index.js',
    sideEffects: !1,
    dependencies: {
      '@aws-crypto/sha256-browser': '3.0.0',
      '@aws-crypto/sha256-js': '3.0.0',
      '@aws-sdk/middleware-host-header': '3.433.0',
      '@aws-sdk/middleware-logger': '3.433.0',
      '@aws-sdk/middleware-recursion-detection': '3.433.0',
      '@aws-sdk/middleware-user-agent': '3.433.0',
      '@aws-sdk/region-config-resolver': '3.433.0',
      '@aws-sdk/types': '3.433.0',
      '@aws-sdk/util-endpoints': '3.433.0',
      '@aws-sdk/util-user-agent-browser': '3.433.0',
      '@aws-sdk/util-user-agent-node': '3.433.0',
      '@smithy/config-resolver': '^2.0.16',
      '@smithy/fetch-http-handler': '^2.2.4',
      '@smithy/hash-node': '^2.0.12',
      '@smithy/invalid-dependency': '^2.0.12',
      '@smithy/middleware-content-length': '^2.0.14',
      '@smithy/middleware-endpoint': '^2.1.3',
      '@smithy/middleware-retry': '^2.0.18',
      '@smithy/middleware-serde': '^2.0.12',
      '@smithy/middleware-stack': '^2.0.6',
      '@smithy/node-config-provider': '^2.1.3',
      '@smithy/node-http-handler': '^2.1.8',
      '@smithy/protocol-http': '^3.0.8',
      '@smithy/smithy-client': '^2.1.12',
      '@smithy/types': '^2.4.0',
      '@smithy/url-parser': '^2.0.12',
      '@smithy/util-base64': '^2.0.0',
      '@smithy/util-body-length-browser': '^2.0.0',
      '@smithy/util-body-length-node': '^2.1.0',
      '@smithy/util-defaults-mode-browser': '^2.0.16',
      '@smithy/util-defaults-mode-node': '^2.0.21',
      '@smithy/util-retry': '^2.0.5',
      '@smithy/util-utf8': '^2.0.0',
      tslib: '^2.5.0',
    },
    devDependencies: {
      '@smithy/service-client-documentation-generator': '^2.0.0',
      '@tsconfig/node14': '1.0.3',
      '@types/node': '^14.14.31',
      concurrently: '7.0.0',
      'downlevel-dts': '0.10.1',
      rimraf: '3.0.2',
      typedoc: '0.23.23',
      typescript: '~4.9.5',
    },
    engines: { node: '>=14.0.0' },
    typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
    files: ['dist-*/**'],
    author: {
      name: 'AWS SDK for JavaScript Team',
      url: 'https://aws.amazon.com/javascript/',
    },
    license: 'Apache-2.0',
    browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
    'react-native': {
      './dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
    },
    homepage:
      'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso',
    repository: {
      type: 'git',
      url: 'https://github.com/aws/aws-sdk-js-v3.git',
      directory: 'clients/client-sso',
    },
  }
})
var S3 = l((ty, E3) => {
  'use strict'
  Object.defineProperty(ty, '__esModule', { value: !0 })
  ty.isCrtAvailable = void 0
  var Kwe = () => {
    try {
      return typeof require == 'function' &&
        typeof E3 < 'u' &&
        require('aws-crt')
        ? ['md/crt-avail']
        : null
    } catch {
      return null
    }
  }
  ty.isCrtAvailable = Kwe
})
var vl = l((Zn) => {
  'use strict'
  Object.defineProperty(Zn, '__esModule', { value: !0 })
  Zn.defaultUserAgent = Zn.UA_APP_ID_INI_NAME = Zn.UA_APP_ID_ENV_NAME = void 0
  var Xwe = vr(),
    b3 = require('os'),
    Gx = require('process'),
    Jwe = S3()
  Zn.UA_APP_ID_ENV_NAME = 'AWS_SDK_UA_APP_ID'
  Zn.UA_APP_ID_INI_NAME = 'sdk-ua-app-id'
  var Qwe = ({ serviceId: e, clientVersion: t }) => {
    let n = [
        ['aws-sdk-js', t],
        ['ua', '2.0'],
        [`os/${(0, b3.platform)()}`, (0, b3.release)()],
        ['lang/js'],
        ['md/nodejs', `${Gx.versions.node}`],
      ],
      r = (0, Jwe.isCrtAvailable)()
    r && n.push(r),
      e && n.push([`api/${e}`, t]),
      Gx.env.AWS_EXECUTION_ENV &&
        n.push([`exec-env/${Gx.env.AWS_EXECUTION_ENV}`])
    let s = (0, Xwe.loadConfig)({
        environmentVariableSelector: (i) => i[Zn.UA_APP_ID_ENV_NAME],
        configFileSelector: (i) => i[Zn.UA_APP_ID_INI_NAME],
        default: void 0,
      })(),
      o
    return async () => {
      if (!o) {
        let i = await s
        o = i ? [...n, [`app/${i}`]] : [...n]
      }
      return o
    }
  }
  Zn.defaultUserAgent = Qwe
})
var Cl = l((ny) => {
  'use strict'
  Object.defineProperty(ny, '__esModule', { value: !0 })
  ny.Hash = void 0
  var $x = Po(),
    Zwe = Ln(),
    eIe = require('buffer'),
    v3 = require('crypto'),
    zx = class {
      constructor(t, n) {
        ;(this.algorithmIdentifier = t), (this.secret = n), this.reset()
      }
      update(t, n) {
        this.hash.update((0, Zwe.toUint8Array)(C3(t, n)))
      }
      digest() {
        return Promise.resolve(this.hash.digest())
      }
      reset() {
        this.hash = this.secret
          ? (0, v3.createHmac)(this.algorithmIdentifier, C3(this.secret))
          : (0, v3.createHash)(this.algorithmIdentifier)
      }
    }
  ny.Hash = zx
  function C3(e, t) {
    return eIe.Buffer.isBuffer(e)
      ? e
      : typeof e == 'string'
        ? (0, $x.fromString)(e, t)
        : ArrayBuffer.isView(e)
          ? (0, $x.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength)
          : (0, $x.fromArrayBuffer)(e)
  }
})
var w3 = l((ry) => {
  'use strict'
  Object.defineProperty(ry, '__esModule', { value: !0 })
  ry.calculateBodyLength = void 0
  var T3 = require('fs'),
    tIe = (e) => {
      if (!e) return 0
      if (typeof e == 'string') return Buffer.from(e).length
      if (typeof e.byteLength == 'number') return e.byteLength
      if (typeof e.size == 'number') return e.size
      if (typeof e.start == 'number' && typeof e.end == 'number')
        return e.end + 1 - e.start
      if (typeof e.path == 'string' || Buffer.isBuffer(e.path))
        return (0, T3.lstatSync)(e.path).size
      if (typeof e.fd == 'number') return (0, T3.fstatSync)(e.fd).size
      throw new Error(`Body Length computation failed for ${e}`)
    }
  ry.calculateBodyLength = tIe
})
var Tl = l((Hx) => {
  'use strict'
  Object.defineProperty(Hx, '__esModule', { value: !0 })
  var nIe = (x(), w(I))
  nIe.__exportStar(w3(), Hx)
})
var F3 = l((sy) => {
  'use strict'
  Object.defineProperty(sy, '__esModule', { value: !0 })
  sy.ruleSet = void 0
  var k3 = 'required',
    fn = 'fn',
    hn = 'argv',
    Ra = 'ref',
    I3 = 'isSet',
    Nr = 'tree',
    xa = 'error',
    Pa = 'endpoint',
    Vx = 'PartitionResult',
    Yx = 'getAttr',
    x3 = { [k3]: !1, type: 'String' },
    P3 = { [k3]: !0, default: !1, type: 'Boolean' },
    R3 = { [Ra]: 'Endpoint' },
    M3 = { [fn]: 'booleanEquals', [hn]: [{ [Ra]: 'UseFIPS' }, !0] },
    L3 = { [fn]: 'booleanEquals', [hn]: [{ [Ra]: 'UseDualStack' }, !0] },
    tn = {},
    D3 = {
      [fn]: 'booleanEquals',
      [hn]: [!0, { [fn]: Yx, [hn]: [{ [Ra]: Vx }, 'supportsFIPS'] }],
    },
    U3 = { [Ra]: Vx },
    A3 = {
      [fn]: 'booleanEquals',
      [hn]: [!0, { [fn]: Yx, [hn]: [U3, 'supportsDualStack'] }],
    },
    O3 = [M3],
    N3 = [L3],
    q3 = [{ [Ra]: 'Region' }],
    rIe = {
      version: '1.0',
      parameters: { Region: x3, UseDualStack: P3, UseFIPS: P3, Endpoint: x3 },
      rules: [
        {
          conditions: [{ [fn]: I3, [hn]: [R3] }],
          type: Nr,
          rules: [
            {
              conditions: O3,
              error:
                'Invalid Configuration: FIPS and custom endpoint are not supported',
              type: xa,
            },
            {
              conditions: N3,
              error:
                'Invalid Configuration: Dualstack and custom endpoint are not supported',
              type: xa,
            },
            { endpoint: { url: R3, properties: tn, headers: tn }, type: Pa },
          ],
        },
        {
          conditions: [{ [fn]: I3, [hn]: q3 }],
          type: Nr,
          rules: [
            {
              conditions: [{ [fn]: 'aws.partition', [hn]: q3, assign: Vx }],
              type: Nr,
              rules: [
                {
                  conditions: [M3, L3],
                  type: Nr,
                  rules: [
                    {
                      conditions: [D3, A3],
                      type: Nr,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: tn,
                            headers: tn,
                          },
                          type: Pa,
                        },
                      ],
                    },
                    {
                      error:
                        'FIPS and DualStack are enabled, but this partition does not support one or both',
                      type: xa,
                    },
                  ],
                },
                {
                  conditions: O3,
                  type: Nr,
                  rules: [
                    {
                      conditions: [D3],
                      type: Nr,
                      rules: [
                        {
                          conditions: [
                            {
                              [fn]: 'stringEquals',
                              [hn]: [
                                'aws-us-gov',
                                { [fn]: Yx, [hn]: [U3, 'name'] },
                              ],
                            },
                          ],
                          endpoint: {
                            url: 'https://portal.sso.{Region}.amazonaws.com',
                            properties: tn,
                            headers: tn,
                          },
                          type: Pa,
                        },
                        {
                          endpoint: {
                            url: 'https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}',
                            properties: tn,
                            headers: tn,
                          },
                          type: Pa,
                        },
                      ],
                    },
                    {
                      error:
                        'FIPS is enabled but this partition does not support FIPS',
                      type: xa,
                    },
                  ],
                },
                {
                  conditions: N3,
                  type: Nr,
                  rules: [
                    {
                      conditions: [A3],
                      type: Nr,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: tn,
                            headers: tn,
                          },
                          type: Pa,
                        },
                      ],
                    },
                    {
                      error:
                        'DualStack is enabled but this partition does not support DualStack',
                      type: xa,
                    },
                  ],
                },
                {
                  endpoint: {
                    url: 'https://portal.sso.{Region}.{PartitionResult#dnsSuffix}',
                    properties: tn,
                    headers: tn,
                  },
                  type: Pa,
                },
              ],
            },
          ],
        },
        { error: 'Invalid Configuration: Missing Region', type: xa },
      ],
    }
  sy.ruleSet = rIe
})
var B3 = l((oy) => {
  'use strict'
  Object.defineProperty(oy, '__esModule', { value: !0 })
  oy.defaultEndpointResolver = void 0
  var sIe = ea(),
    oIe = F3(),
    iIe = (e, t = {}) =>
      (0, sIe.resolveEndpoint)(oIe.ruleSet, {
        endpointParams: e,
        logger: t.logger,
      })
  oy.defaultEndpointResolver = iIe
})
var $3 = l((iy) => {
  'use strict'
  Object.defineProperty(iy, '__esModule', { value: !0 })
  iy.getRuntimeConfig = void 0
  var aIe = v(),
    cIe = Mo(),
    j3 = aa(),
    G3 = Ln(),
    dIe = B3(),
    uIe = (e) => ({
      apiVersion: '2019-06-10',
      base64Decoder: e?.base64Decoder ?? j3.fromBase64,
      base64Encoder: e?.base64Encoder ?? j3.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? dIe.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      logger: e?.logger ?? new aIe.NoOpLogger(),
      serviceId: e?.serviceId ?? 'SSO',
      urlParser: e?.urlParser ?? cIe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? G3.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? G3.toUtf8,
    })
  iy.getRuntimeConfig = uIe
})
var z3 = l((gt) => {
  'use strict'
  Object.defineProperty(gt, '__esModule', { value: !0 })
  gt.IMDS_REGION_PATH =
    gt.DEFAULTS_MODE_OPTIONS =
    gt.ENV_IMDS_DISABLED =
    gt.AWS_DEFAULT_REGION_ENV =
    gt.AWS_REGION_ENV =
    gt.AWS_EXECUTION_ENV =
      void 0
  gt.AWS_EXECUTION_ENV = 'AWS_EXECUTION_ENV'
  gt.AWS_REGION_ENV = 'AWS_REGION'
  gt.AWS_DEFAULT_REGION_ENV = 'AWS_DEFAULT_REGION'
  gt.ENV_IMDS_DISABLED = 'AWS_EC2_METADATA_DISABLED'
  gt.DEFAULTS_MODE_OPTIONS = [
    'in-region',
    'cross-region',
    'mobile',
    'standard',
    'legacy',
  ]
  gt.IMDS_REGION_PATH = '/latest/meta-data/placement/region'
})
var H3 = l((ay) => {
  'use strict'
  Object.defineProperty(ay, '__esModule', { value: !0 })
  ay.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0
  var lIe = 'AWS_DEFAULTS_MODE',
    mIe = 'defaults_mode'
  ay.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[lIe],
    configFileSelector: (e) => e[mIe],
    default: 'legacy',
  }
})
var W3 = l((cy) => {
  'use strict'
  Object.defineProperty(cy, '__esModule', { value: !0 })
  cy.resolveDefaultsModeConfig = void 0
  var pIe = Bn(),
    V3 = Wg(),
    Y3 = vr(),
    _Ie = ye(),
    Ns = z3(),
    fIe = H3(),
    hIe = ({
      region: e = (0, Y3.loadConfig)(pIe.NODE_REGION_CONFIG_OPTIONS),
      defaultsMode: t = (0, Y3.loadConfig)(
        fIe.NODE_DEFAULTS_MODE_CONFIG_OPTIONS,
      ),
    } = {}) =>
      (0, _Ie.memoize)(async () => {
        let n = typeof t == 'function' ? await t() : t
        switch (n?.toLowerCase()) {
          case 'auto':
            return gIe(e)
          case 'in-region':
          case 'cross-region':
          case 'mobile':
          case 'standard':
          case 'legacy':
            return Promise.resolve(n?.toLocaleLowerCase())
          case void 0:
            return Promise.resolve('legacy')
          default:
            throw new Error(
              `Invalid parameter for "defaultsMode", expect ${Ns.DEFAULTS_MODE_OPTIONS.join(
                ', ',
              )}, got ${n}`,
            )
        }
      })
  cy.resolveDefaultsModeConfig = hIe
  var gIe = async (e) => {
      if (e) {
        let t = typeof e == 'function' ? await e() : e,
          n = await yIe()
        return n ? (t === n ? 'in-region' : 'cross-region') : 'standard'
      }
      return 'standard'
    },
    yIe = async () => {
      var e
      if (
        process.env[Ns.AWS_EXECUTION_ENV] &&
        (process.env[Ns.AWS_REGION_ENV] ||
          process.env[Ns.AWS_DEFAULT_REGION_ENV])
      )
        return (e = process.env[Ns.AWS_REGION_ENV]) !== null && e !== void 0
          ? e
          : process.env[Ns.AWS_DEFAULT_REGION_ENV]
      if (!process.env[Ns.ENV_IMDS_DISABLED])
        try {
          let t = await (0, V3.getInstanceMetadataEndpoint)()
          return (
            await (0, V3.httpRequest)({ ...t, path: Ns.IMDS_REGION_PATH })
          ).toString()
        } catch {}
    }
})
var wl = l((Wx) => {
  'use strict'
  Object.defineProperty(Wx, '__esModule', { value: !0 })
  var EIe = (x(), w(I))
  EIe.__exportStar(W3(), Wx)
})
var J3 = l((uy) => {
  'use strict'
  Object.defineProperty(uy, '__esModule', { value: !0 })
  uy.getRuntimeConfig = void 0
  var SIe = (x(), w(I)),
    bIe = SIe.__importDefault(y3()),
    vIe = vl(),
    dy = Bn(),
    CIe = Cl(),
    K3 = Ir(),
    Il = vr(),
    X3 = ua(),
    TIe = Tl(),
    wIe = Qt(),
    IIe = $3(),
    xIe = v(),
    PIe = wl(),
    RIe = v(),
    DIe = (e) => {
      ;(0, RIe.emitWarningIfUnsupportedVersion)(process.version)
      let t = (0, PIe.resolveDefaultsModeConfig)(e),
        n = () => t().then(xIe.loadConfigsForDefaultMode),
        r = (0, IIe.getRuntimeConfig)(e)
      return {
        ...r,
        ...e,
        runtime: 'node',
        defaultsMode: t,
        bodyLengthChecker: e?.bodyLengthChecker ?? TIe.calculateBodyLength,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, vIe.defaultUserAgent)({
            serviceId: r.serviceId,
            clientVersion: bIe.default.version,
          }),
        maxAttempts:
          e?.maxAttempts ??
          (0, Il.loadConfig)(K3.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          e?.region ??
          (0, Il.loadConfig)(
            dy.NODE_REGION_CONFIG_OPTIONS,
            dy.NODE_REGION_CONFIG_FILE_OPTIONS,
          ),
        requestHandler: e?.requestHandler ?? new X3.NodeHttpHandler(n),
        retryMode:
          e?.retryMode ??
          (0, Il.loadConfig)({
            ...K3.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () =>
              (await n()).retryMode || wIe.DEFAULT_RETRY_MODE,
          }),
        sha256: e?.sha256 ?? CIe.Hash.bind(null, 'sha256'),
        streamCollector: e?.streamCollector ?? X3.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, Il.loadConfig)(dy.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, Il.loadConfig)(dy.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    }
  uy.getRuntimeConfig = DIe
})
var Q3 = l((Da) => {
  'use strict'
  Object.defineProperty(Da, '__esModule', { value: !0 })
  Da.resolveAwsRegionExtensionConfiguration =
    Da.getAwsRegionExtensionConfiguration = void 0
  var AIe = (e) => {
    let t = async () => {
      if (e.region === void 0)
        throw new Error('Region is missing from runtimeConfig')
      let n = e.region
      return typeof n == 'string' ? n : n()
    }
    return {
      setRegion(n) {
        t = n
      },
      region() {
        return t
      },
    }
  }
  Da.getAwsRegionExtensionConfiguration = AIe
  var OIe = (e) => ({ region: e.region() })
  Da.resolveAwsRegionExtensionConfiguration = OIe
})
var Z3 = l((nn) => {
  'use strict'
  Object.defineProperty(nn, '__esModule', { value: !0 })
  nn.NODE_REGION_CONFIG_FILE_OPTIONS =
    nn.NODE_REGION_CONFIG_OPTIONS =
    nn.REGION_INI_NAME =
    nn.REGION_ENV_NAME =
      void 0
  nn.REGION_ENV_NAME = 'AWS_REGION'
  nn.REGION_INI_NAME = 'region'
  nn.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[nn.REGION_ENV_NAME],
    configFileSelector: (e) => e[nn.REGION_INI_NAME],
    default: () => {
      throw new Error('Region is missing')
    },
  }
  nn.NODE_REGION_CONFIG_FILE_OPTIONS = { preferredFile: 'credentials' }
})
var Kx = l((ly) => {
  'use strict'
  Object.defineProperty(ly, '__esModule', { value: !0 })
  ly.isFipsRegion = void 0
  var NIe = (e) =>
    typeof e == 'string' && (e.startsWith('fips-') || e.endsWith('-fips'))
  ly.isFipsRegion = NIe
})
var eV = l((my) => {
  'use strict'
  Object.defineProperty(my, '__esModule', { value: !0 })
  my.getRealRegion = void 0
  var qIe = Kx(),
    kIe = (e) =>
      (0, qIe.isFipsRegion)(e)
        ? ['fips-aws-global', 'aws-fips'].includes(e)
          ? 'us-east-1'
          : e.replace(/fips-(dkr-|prod-)?|-fips/, '')
        : e
  my.getRealRegion = kIe
})
var nV = l((py) => {
  'use strict'
  Object.defineProperty(py, '__esModule', { value: !0 })
  py.resolveRegionConfig = void 0
  var tV = eV(),
    MIe = Kx(),
    LIe = (e) => {
      let { region: t, useFipsEndpoint: n } = e
      if (!t) throw new Error('Region is missing')
      return {
        ...e,
        region: async () => {
          if (typeof t == 'string') return (0, tV.getRealRegion)(t)
          let r = await t()
          return (0, tV.getRealRegion)(r)
        },
        useFipsEndpoint: async () => {
          let r = typeof t == 'string' ? t : await t()
          return (0, MIe.isFipsRegion)(r)
            ? !0
            : typeof n != 'function'
              ? Promise.resolve(!!n)
              : n()
        },
      }
    }
  py.resolveRegionConfig = LIe
})
var sV = l((_y) => {
  'use strict'
  Object.defineProperty(_y, '__esModule', { value: !0 })
  var rV = (x(), w(I))
  rV.__exportStar(Z3(), _y)
  rV.__exportStar(nV(), _y)
})
var xl = l((fy) => {
  'use strict'
  Object.defineProperty(fy, '__esModule', { value: !0 })
  var oV = (x(), w(I))
  oV.__exportStar(Q3(), fy)
  oV.__exportStar(sV(), fy)
})
var dV = l((hy) => {
  'use strict'
  Object.defineProperty(hy, '__esModule', { value: !0 })
  hy.resolveRuntimeExtensions = void 0
  var iV = xl(),
    aV = Oe(),
    cV = v(),
    Xx = (e) => e,
    UIe = (e, t) => {
      let n = {
        ...Xx((0, iV.getAwsRegionExtensionConfiguration)(e)),
        ...Xx((0, cV.getDefaultExtensionConfiguration)(e)),
        ...Xx((0, aV.getHttpHandlerExtensionConfiguration)(e)),
      }
      return (
        t.forEach((r) => r.configure(n)),
        {
          ...e,
          ...(0, iV.resolveAwsRegionExtensionConfiguration)(n),
          ...(0, cV.resolveDefaultRuntimeConfig)(n),
          ...(0, aV.resolveHttpHandlerRuntimeConfig)(n),
        }
      )
    }
  hy.resolveRuntimeExtensions = UIe
})
var Pl = l((Aa) => {
  'use strict'
  Object.defineProperty(Aa, '__esModule', { value: !0 })
  Aa.SSOClient = Aa.__Client = void 0
  var uV = Ou(),
    FIe = Nu(),
    BIe = qu(),
    lV = Yu(),
    jIe = Bn(),
    GIe = Xu(),
    $Ie = q(),
    mV = Ir(),
    pV = v()
  Object.defineProperty(Aa, '__Client', {
    enumerable: !0,
    get: function () {
      return pV.Client
    },
  })
  var zIe = g3(),
    HIe = J3(),
    VIe = dV(),
    Jx = class extends pV.Client {
      constructor(...[t]) {
        let n = (0, HIe.getRuntimeConfig)(t || {}),
          r = (0, zIe.resolveClientEndpointParameters)(n),
          s = (0, jIe.resolveRegionConfig)(r),
          o = (0, $Ie.resolveEndpointConfig)(s),
          i = (0, mV.resolveRetryConfig)(o),
          a = (0, uV.resolveHostHeaderConfig)(i),
          c = (0, lV.resolveUserAgentConfig)(a),
          u = (0, VIe.resolveRuntimeExtensions)(c, t?.extensions || [])
        super(u),
          (this.config = u),
          this.middlewareStack.use((0, mV.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, GIe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, uV.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, FIe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, BIe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, lV.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  Aa.SSOClient = Jx
})
var gy = l((Oa) => {
  'use strict'
  Object.defineProperty(Oa, '__esModule', { value: !0 })
  Oa.SSOServiceException = Oa.__ServiceException = void 0
  var _V = v()
  Object.defineProperty(Oa, '__ServiceException', {
    enumerable: !0,
    get: function () {
      return _V.ServiceException
    },
  })
  var Qx = class e extends _V.ServiceException {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e.prototype)
    }
  }
  Oa.SSOServiceException = Qx
})
var Yo = l((xe) => {
  'use strict'
  Object.defineProperty(xe, '__esModule', { value: !0 })
  xe.LogoutRequestFilterSensitiveLog =
    xe.ListAccountsRequestFilterSensitiveLog =
    xe.ListAccountRolesRequestFilterSensitiveLog =
    xe.GetRoleCredentialsResponseFilterSensitiveLog =
    xe.RoleCredentialsFilterSensitiveLog =
    xe.GetRoleCredentialsRequestFilterSensitiveLog =
    xe.UnauthorizedException =
    xe.TooManyRequestsException =
    xe.ResourceNotFoundException =
    xe.InvalidRequestException =
      void 0
  var Na = v(),
    yy = gy(),
    Zx = class e extends yy.SSOServiceException {
      constructor(t) {
        super({ name: 'InvalidRequestException', $fault: 'client', ...t }),
          (this.name = 'InvalidRequestException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  xe.InvalidRequestException = Zx
  var eP = class e extends yy.SSOServiceException {
    constructor(t) {
      super({ name: 'ResourceNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ResourceNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  xe.ResourceNotFoundException = eP
  var tP = class e extends yy.SSOServiceException {
    constructor(t) {
      super({ name: 'TooManyRequestsException', $fault: 'client', ...t }),
        (this.name = 'TooManyRequestsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  xe.TooManyRequestsException = tP
  var nP = class e extends yy.SSOServiceException {
    constructor(t) {
      super({ name: 'UnauthorizedException', $fault: 'client', ...t }),
        (this.name = 'UnauthorizedException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  xe.UnauthorizedException = nP
  var YIe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: Na.SENSITIVE_STRING }),
  })
  xe.GetRoleCredentialsRequestFilterSensitiveLog = YIe
  var WIe = (e) => ({
    ...e,
    ...(e.secretAccessKey && { secretAccessKey: Na.SENSITIVE_STRING }),
    ...(e.sessionToken && { sessionToken: Na.SENSITIVE_STRING }),
  })
  xe.RoleCredentialsFilterSensitiveLog = WIe
  var KIe = (e) => ({
    ...e,
    ...(e.roleCredentials && {
      roleCredentials: (0, xe.RoleCredentialsFilterSensitiveLog)(
        e.roleCredentials,
      ),
    }),
  })
  xe.GetRoleCredentialsResponseFilterSensitiveLog = KIe
  var XIe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: Na.SENSITIVE_STRING }),
  })
  xe.ListAccountRolesRequestFilterSensitiveLog = XIe
  var JIe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: Na.SENSITIVE_STRING }),
  })
  xe.ListAccountsRequestFilterSensitiveLog = JIe
  var QIe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: Na.SENSITIVE_STRING }),
  })
  xe.LogoutRequestFilterSensitiveLog = QIe
})
var Rl = l((ze) => {
  'use strict'
  Object.defineProperty(ze, '__esModule', { value: !0 })
  ze.de_LogoutCommand =
    ze.de_ListAccountsCommand =
    ze.de_ListAccountRolesCommand =
    ze.de_GetRoleCredentialsCommand =
    ze.se_LogoutCommand =
    ze.se_ListAccountsCommand =
    ze.se_ListAccountRolesCommand =
    ze.se_GetRoleCredentialsCommand =
      void 0
  var Ey = Oe(),
    J = v(),
    Sy = Yo(),
    ZIe = gy(),
    exe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = (0, J.map)({}, wy, { 'x-amz-sso_bearer_token': e.accessToken }),
        a = `${
          o?.endsWith('/') ? o.slice(0, -1) : o || ''
        }/federation/credentials`,
        c = (0, J.map)({
          role_name: [, (0, J.expectNonNull)(e.roleName, 'roleName')],
          account_id: [, (0, J.expectNonNull)(e.accountId, 'accountId')],
        }),
        u
      return new Ey.HttpRequest({
        protocol: r,
        hostname: n,
        port: s,
        method: 'GET',
        headers: i,
        path: a,
        query: c,
        body: u,
      })
    }
  ze.se_GetRoleCredentialsCommand = exe
  var txe = async (e, t) => {
    let {
        hostname: n,
        protocol: r = 'https',
        port: s,
        path: o,
      } = await t.endpoint(),
      i = (0, J.map)({}, wy, { 'x-amz-sso_bearer_token': e.accessToken }),
      a = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/assignment/roles`,
      c = (0, J.map)({
        next_token: [, e.nextToken],
        max_result: [
          () => e.maxResults !== void 0,
          () => e.maxResults.toString(),
        ],
        account_id: [, (0, J.expectNonNull)(e.accountId, 'accountId')],
      }),
      u
    return new Ey.HttpRequest({
      protocol: r,
      hostname: n,
      port: s,
      method: 'GET',
      headers: i,
      path: a,
      query: c,
      body: u,
    })
  }
  ze.se_ListAccountRolesCommand = txe
  var nxe = async (e, t) => {
    let {
        hostname: n,
        protocol: r = 'https',
        port: s,
        path: o,
      } = await t.endpoint(),
      i = (0, J.map)({}, wy, { 'x-amz-sso_bearer_token': e.accessToken }),
      a = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/assignment/accounts`,
      c = (0, J.map)({
        next_token: [, e.nextToken],
        max_result: [
          () => e.maxResults !== void 0,
          () => e.maxResults.toString(),
        ],
      }),
      u
    return new Ey.HttpRequest({
      protocol: r,
      hostname: n,
      port: s,
      method: 'GET',
      headers: i,
      path: a,
      query: c,
      body: u,
    })
  }
  ze.se_ListAccountsCommand = nxe
  var rxe = async (e, t) => {
    let {
        hostname: n,
        protocol: r = 'https',
        port: s,
        path: o,
      } = await t.endpoint(),
      i = (0, J.map)({}, wy, { 'x-amz-sso_bearer_token': e.accessToken }),
      a = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/logout`,
      c
    return new Ey.HttpRequest({
      protocol: r,
      hostname: n,
      port: s,
      method: 'POST',
      headers: i,
      path: a,
      body: c,
    })
  }
  ze.se_LogoutCommand = rxe
  var sxe = async (e, t) => {
    if (e.statusCode !== 200 && e.statusCode >= 300) return oxe(e, t)
    let n = (0, J.map)({ $metadata: qs(e) }),
      r = (0, J.expectNonNull)(
        (0, J.expectObject)(await Iy(e.body, t)),
        'body',
      ),
      s = (0, J.take)(r, { roleCredentials: J._json })
    return Object.assign(n, s), n
  }
  ze.de_GetRoleCredentialsCommand = sxe
  var oxe = async (e, t) => {
      let n = { ...e, body: await xy(e.body, t) },
        r = Py(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await vy(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.sso#ResourceNotFoundException':
          throw await rP(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Cy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Ty(n, t)
        default:
          let s = n.body
          return by({ output: e, parsedBody: s, errorCode: r })
      }
    },
    ixe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return axe(e, t)
      let n = (0, J.map)({ $metadata: qs(e) }),
        r = (0, J.expectNonNull)(
          (0, J.expectObject)(await Iy(e.body, t)),
          'body',
        ),
        s = (0, J.take)(r, { nextToken: J.expectString, roleList: J._json })
      return Object.assign(n, s), n
    }
  ze.de_ListAccountRolesCommand = ixe
  var axe = async (e, t) => {
      let n = { ...e, body: await xy(e.body, t) },
        r = Py(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await vy(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.sso#ResourceNotFoundException':
          throw await rP(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Cy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Ty(n, t)
        default:
          let s = n.body
          return by({ output: e, parsedBody: s, errorCode: r })
      }
    },
    cxe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return dxe(e, t)
      let n = (0, J.map)({ $metadata: qs(e) }),
        r = (0, J.expectNonNull)(
          (0, J.expectObject)(await Iy(e.body, t)),
          'body',
        ),
        s = (0, J.take)(r, { accountList: J._json, nextToken: J.expectString })
      return Object.assign(n, s), n
    }
  ze.de_ListAccountsCommand = cxe
  var dxe = async (e, t) => {
      let n = { ...e, body: await xy(e.body, t) },
        r = Py(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await vy(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.sso#ResourceNotFoundException':
          throw await rP(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Cy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Ty(n, t)
        default:
          let s = n.body
          return by({ output: e, parsedBody: s, errorCode: r })
      }
    },
    uxe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return lxe(e, t)
      let n = (0, J.map)({ $metadata: qs(e) })
      return await (0, J.collectBody)(e.body, t), n
    }
  ze.de_LogoutCommand = uxe
  var lxe = async (e, t) => {
      let n = { ...e, body: await xy(e.body, t) },
        r = Py(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await vy(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Cy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Ty(n, t)
        default:
          let s = n.body
          return by({ output: e, parsedBody: s, errorCode: r })
      }
    },
    by = (0, J.withBaseException)(ZIe.SSOServiceException),
    vy = async (e, t) => {
      let n = (0, J.map)({}),
        r = e.body,
        s = (0, J.take)(r, { message: J.expectString })
      Object.assign(n, s)
      let o = new Sy.InvalidRequestException({ $metadata: qs(e), ...n })
      return (0, J.decorateServiceException)(o, e.body)
    },
    rP = async (e, t) => {
      let n = (0, J.map)({}),
        r = e.body,
        s = (0, J.take)(r, { message: J.expectString })
      Object.assign(n, s)
      let o = new Sy.ResourceNotFoundException({ $metadata: qs(e), ...n })
      return (0, J.decorateServiceException)(o, e.body)
    },
    Cy = async (e, t) => {
      let n = (0, J.map)({}),
        r = e.body,
        s = (0, J.take)(r, { message: J.expectString })
      Object.assign(n, s)
      let o = new Sy.TooManyRequestsException({ $metadata: qs(e), ...n })
      return (0, J.decorateServiceException)(o, e.body)
    },
    Ty = async (e, t) => {
      let n = (0, J.map)({}),
        r = e.body,
        s = (0, J.take)(r, { message: J.expectString })
      Object.assign(n, s)
      let o = new Sy.UnauthorizedException({ $metadata: qs(e), ...n })
      return (0, J.decorateServiceException)(o, e.body)
    },
    qs = (e) => ({
      httpStatusCode: e.statusCode,
      requestId:
        e.headers['x-amzn-requestid'] ??
        e.headers['x-amzn-request-id'] ??
        e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }),
    mxe = (e, t) => (0, J.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    wy = (e) =>
      e != null &&
      e !== '' &&
      (!Object.getOwnPropertyNames(e).includes('length') || e.length != 0) &&
      (!Object.getOwnPropertyNames(e).includes('size') || e.size != 0),
    Iy = (e, t) => mxe(e, t).then((n) => (n.length ? JSON.parse(n) : {})),
    xy = async (e, t) => {
      let n = await Iy(e, t)
      return (n.message = n.message ?? n.Message), n
    },
    Py = (e, t) => {
      let n = (o, i) =>
          Object.keys(o).find((a) => a.toLowerCase() === i.toLowerCase()),
        r = (o) => {
          let i = o
          return (
            typeof i == 'number' && (i = i.toString()),
            i.indexOf(',') >= 0 && (i = i.split(',')[0]),
            i.indexOf(':') >= 0 && (i = i.split(':')[0]),
            i.indexOf('#') >= 0 && (i = i.split('#')[1]),
            i
          )
        },
        s = n(e.headers, 'x-amzn-errortype')
      if (s !== void 0) return r(e.headers[s])
      if (t.code !== void 0) return r(t.code)
      if (t.__type !== void 0) return r(t.__type)
    }
})
var oP = l((qa) => {
  'use strict'
  Object.defineProperty(qa, '__esModule', { value: !0 })
  qa.GetRoleCredentialsCommand = qa.$Command = void 0
  var pxe = q(),
    _xe = k(),
    gV = v()
  Object.defineProperty(qa, '$Command', {
    enumerable: !0,
    get: function () {
      return gV.Command
    },
  })
  var fxe = D(),
    fV = Yo(),
    hV = Rl(),
    sP = class e extends gV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, _xe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, pxe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'GetRoleCredentialsCommand',
            inputFilterSensitiveLog:
              fV.GetRoleCredentialsRequestFilterSensitiveLog,
            outputFilterSensitiveLog:
              fV.GetRoleCredentialsResponseFilterSensitiveLog,
            [fxe.SMITHY_CONTEXT_KEY]: {
              service: 'SWBPortalService',
              operation: 'GetRoleCredentials',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, hV.se_GetRoleCredentialsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, hV.de_GetRoleCredentialsCommand)(t, n)
      }
    }
  qa.GetRoleCredentialsCommand = sP
})
var Ry = l((ka) => {
  'use strict'
  Object.defineProperty(ka, '__esModule', { value: !0 })
  ka.ListAccountRolesCommand = ka.$Command = void 0
  var hxe = q(),
    gxe = k(),
    EV = v()
  Object.defineProperty(ka, '$Command', {
    enumerable: !0,
    get: function () {
      return EV.Command
    },
  })
  var yxe = D(),
    Exe = Yo(),
    yV = Rl(),
    iP = class e extends EV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, gxe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, hxe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'ListAccountRolesCommand',
            inputFilterSensitiveLog:
              Exe.ListAccountRolesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (d) => d,
            [yxe.SMITHY_CONTEXT_KEY]: {
              service: 'SWBPortalService',
              operation: 'ListAccountRoles',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, yV.se_ListAccountRolesCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, yV.de_ListAccountRolesCommand)(t, n)
      }
    }
  ka.ListAccountRolesCommand = iP
})
var Dy = l((Ma) => {
  'use strict'
  Object.defineProperty(Ma, '__esModule', { value: !0 })
  Ma.ListAccountsCommand = Ma.$Command = void 0
  var Sxe = q(),
    bxe = k(),
    bV = v()
  Object.defineProperty(Ma, '$Command', {
    enumerable: !0,
    get: function () {
      return bV.Command
    },
  })
  var vxe = D(),
    Cxe = Yo(),
    SV = Rl(),
    aP = class e extends bV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, bxe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Sxe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'ListAccountsCommand',
            inputFilterSensitiveLog: Cxe.ListAccountsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (d) => d,
            [vxe.SMITHY_CONTEXT_KEY]: {
              service: 'SWBPortalService',
              operation: 'ListAccounts',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, SV.se_ListAccountsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, SV.de_ListAccountsCommand)(t, n)
      }
    }
  Ma.ListAccountsCommand = aP
})
var dP = l((La) => {
  'use strict'
  Object.defineProperty(La, '__esModule', { value: !0 })
  La.LogoutCommand = La.$Command = void 0
  var Txe = q(),
    wxe = k(),
    CV = v()
  Object.defineProperty(La, '$Command', {
    enumerable: !0,
    get: function () {
      return CV.Command
    },
  })
  var Ixe = D(),
    xxe = Yo(),
    vV = Rl(),
    cP = class e extends CV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, wxe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Txe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'LogoutCommand',
            inputFilterSensitiveLog: xxe.LogoutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (d) => d,
            [Ixe.SMITHY_CONTEXT_KEY]: {
              service: 'SWBPortalService',
              operation: 'Logout',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, vV.se_LogoutCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, vV.de_LogoutCommand)(t, n)
      }
    }
  La.LogoutCommand = cP
})
var TV = l((Oy) => {
  'use strict'
  Object.defineProperty(Oy, '__esModule', { value: !0 })
  Oy.SSO = void 0
  var Pxe = v(),
    Rxe = oP(),
    Dxe = Ry(),
    Axe = Dy(),
    Oxe = dP(),
    Nxe = Pl(),
    qxe = {
      GetRoleCredentialsCommand: Rxe.GetRoleCredentialsCommand,
      ListAccountRolesCommand: Dxe.ListAccountRolesCommand,
      ListAccountsCommand: Axe.ListAccountsCommand,
      LogoutCommand: Oxe.LogoutCommand,
    },
    Ay = class extends Nxe.SSOClient {}
  Oy.SSO = Ay
  ;(0, Pxe.createAggregatedClient)(qxe, Ay)
})
var wV = l((Ua) => {
  'use strict'
  Object.defineProperty(Ua, '__esModule', { value: !0 })
  var Ny = (x(), w(I))
  Ny.__exportStar(oP(), Ua)
  Ny.__exportStar(Ry(), Ua)
  Ny.__exportStar(Dy(), Ua)
  Ny.__exportStar(dP(), Ua)
})
var xV = l((IV) => {
  'use strict'
  Object.defineProperty(IV, '__esModule', { value: !0 })
})
var PV = l((qy) => {
  'use strict'
  Object.defineProperty(qy, '__esModule', { value: !0 })
  qy.paginateListAccountRoles = void 0
  var kxe = Ry(),
    Mxe = Pl(),
    Lxe = async (e, t, ...n) =>
      await e.send(new kxe.ListAccountRolesCommand(t), ...n)
  async function* Uxe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.nextToken = r),
        (t.maxResults = e.pageSize),
        e.client instanceof Mxe.SSOClient)
      )
        o = await Lxe(e.client, t, ...n)
      else throw new Error('Invalid client, expected SSO | SSOClient')
      yield o
      let i = r
      ;(r = o.nextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  qy.paginateListAccountRoles = Uxe
})
var RV = l((ky) => {
  'use strict'
  Object.defineProperty(ky, '__esModule', { value: !0 })
  ky.paginateListAccounts = void 0
  var Fxe = Dy(),
    Bxe = Pl(),
    jxe = async (e, t, ...n) =>
      await e.send(new Fxe.ListAccountsCommand(t), ...n)
  async function* Gxe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.nextToken = r),
        (t.maxResults = e.pageSize),
        e.client instanceof Bxe.SSOClient)
      )
        o = await jxe(e.client, t, ...n)
      else throw new Error('Invalid client, expected SSO | SSOClient')
      yield o
      let i = r
      ;(r = o.nextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  ky.paginateListAccounts = Gxe
})
var DV = l((Dl) => {
  'use strict'
  Object.defineProperty(Dl, '__esModule', { value: !0 })
  var uP = (x(), w(I))
  uP.__exportStar(xV(), Dl)
  uP.__exportStar(PV(), Dl)
  uP.__exportStar(RV(), Dl)
})
var AV = l((lP) => {
  'use strict'
  Object.defineProperty(lP, '__esModule', { value: !0 })
  var $xe = (x(), w(I))
  $xe.__exportStar(Yo(), lP)
})
var OV = l((qr) => {
  'use strict'
  Object.defineProperty(qr, '__esModule', { value: !0 })
  qr.SSOServiceException = void 0
  var Al = (x(), w(I))
  Al.__exportStar(Pl(), qr)
  Al.__exportStar(TV(), qr)
  Al.__exportStar(wV(), qr)
  Al.__exportStar(DV(), qr)
  Al.__exportStar(AV(), qr)
  var zxe = gy()
  Object.defineProperty(qr, 'SSOServiceException', {
    enumerable: !0,
    get: function () {
      return zxe.SSOServiceException
    },
  })
})
var Uy = l((Ee) => {
  'use strict'
  Object.defineProperty(Ee, '__esModule', { value: !0 })
  Ee.UnsupportedGrantTypeException =
    Ee.UnauthorizedClientException =
    Ee.SlowDownException =
    Ee.SSOOIDCClient =
    Ee.InvalidScopeException =
    Ee.InvalidRequestException =
    Ee.InvalidClientException =
    Ee.InternalServerException =
    Ee.ExpiredTokenException =
    Ee.CreateTokenCommand =
    Ee.AuthorizationPendingException =
    Ee.AccessDeniedException =
      void 0
  var NV = Ou(),
    Hxe = Nu(),
    Vxe = qu(),
    qV = Yu(),
    Yxe = Bn(),
    Wxe = Xu(),
    Kxe = q(),
    kV = Ir(),
    Xxe = v(),
    Jxe = (e) => {
      var t, n
      return {
        ...e,
        useDualstackEndpoint:
          (t = e.useDualstackEndpoint) !== null && t !== void 0 ? t : !1,
        useFipsEndpoint:
          (n = e.useFipsEndpoint) !== null && n !== void 0 ? n : !1,
        defaultSigningName: 'awsssooidc',
      }
    },
    Qxe = { version: '3.429.0' },
    Zxe = vl(),
    My = Bn(),
    ePe = Cl(),
    MV = Ir(),
    Ol = vr(),
    LV = ua(),
    tPe = Tl(),
    nPe = Qt(),
    rPe = v(),
    sPe = Mo(),
    UV = aa(),
    FV = Ln(),
    oPe = ea(),
    QV = 'required',
    gn = 'fn',
    yn = 'argv',
    ja = 'ref',
    BV = 'isSet',
    kr = 'tree',
    Fa = 'error',
    Ba = 'endpoint',
    pP = 'PartitionResult',
    _P = 'getAttr',
    jV = { [QV]: !1, type: 'String' },
    GV = { [QV]: !0, default: !1, type: 'Boolean' },
    $V = { [ja]: 'Endpoint' },
    ZV = { [gn]: 'booleanEquals', [yn]: [{ [ja]: 'UseFIPS' }, !0] },
    eY = { [gn]: 'booleanEquals', [yn]: [{ [ja]: 'UseDualStack' }, !0] },
    rn = {},
    zV = {
      [gn]: 'booleanEquals',
      [yn]: [!0, { [gn]: _P, [yn]: [{ [ja]: pP }, 'supportsFIPS'] }],
    },
    tY = { [ja]: pP },
    HV = {
      [gn]: 'booleanEquals',
      [yn]: [!0, { [gn]: _P, [yn]: [tY, 'supportsDualStack'] }],
    },
    VV = [ZV],
    YV = [eY],
    WV = [{ [ja]: 'Region' }],
    iPe = {
      version: '1.0',
      parameters: { Region: jV, UseDualStack: GV, UseFIPS: GV, Endpoint: jV },
      rules: [
        {
          conditions: [{ [gn]: BV, [yn]: [$V] }],
          type: kr,
          rules: [
            {
              conditions: VV,
              error:
                'Invalid Configuration: FIPS and custom endpoint are not supported',
              type: Fa,
            },
            {
              conditions: YV,
              error:
                'Invalid Configuration: Dualstack and custom endpoint are not supported',
              type: Fa,
            },
            { endpoint: { url: $V, properties: rn, headers: rn }, type: Ba },
          ],
        },
        {
          conditions: [{ [gn]: BV, [yn]: WV }],
          type: kr,
          rules: [
            {
              conditions: [{ [gn]: 'aws.partition', [yn]: WV, assign: pP }],
              type: kr,
              rules: [
                {
                  conditions: [ZV, eY],
                  type: kr,
                  rules: [
                    {
                      conditions: [zV, HV],
                      type: kr,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: rn,
                            headers: rn,
                          },
                          type: Ba,
                        },
                      ],
                    },
                    {
                      error:
                        'FIPS and DualStack are enabled, but this partition does not support one or both',
                      type: Fa,
                    },
                  ],
                },
                {
                  conditions: VV,
                  type: kr,
                  rules: [
                    {
                      conditions: [zV],
                      type: kr,
                      rules: [
                        {
                          conditions: [
                            {
                              [gn]: 'stringEquals',
                              [yn]: [
                                'aws-us-gov',
                                { [gn]: _P, [yn]: [tY, 'name'] },
                              ],
                            },
                          ],
                          endpoint: {
                            url: 'https://oidc.{Region}.amazonaws.com',
                            properties: rn,
                            headers: rn,
                          },
                          type: Ba,
                        },
                        {
                          endpoint: {
                            url: 'https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}',
                            properties: rn,
                            headers: rn,
                          },
                          type: Ba,
                        },
                      ],
                    },
                    {
                      error:
                        'FIPS is enabled but this partition does not support FIPS',
                      type: Fa,
                    },
                  ],
                },
                {
                  conditions: YV,
                  type: kr,
                  rules: [
                    {
                      conditions: [HV],
                      type: kr,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: rn,
                            headers: rn,
                          },
                          type: Ba,
                        },
                      ],
                    },
                    {
                      error:
                        'DualStack is enabled but this partition does not support DualStack',
                      type: Fa,
                    },
                  ],
                },
                {
                  endpoint: {
                    url: 'https://oidc.{Region}.{PartitionResult#dnsSuffix}',
                    properties: rn,
                    headers: rn,
                  },
                  type: Ba,
                },
              ],
            },
          ],
        },
        { error: 'Invalid Configuration: Missing Region', type: Fa },
      ],
    },
    aPe = iPe,
    cPe = (e, t = {}) =>
      (0, oPe.resolveEndpoint)(aPe, { endpointParams: e, logger: t.logger }),
    dPe = (e) => {
      var t, n, r, s, o, i, a, c, u, d
      return {
        apiVersion: '2019-06-10',
        base64Decoder:
          (t = e?.base64Decoder) !== null && t !== void 0 ? t : UV.fromBase64,
        base64Encoder:
          (n = e?.base64Encoder) !== null && n !== void 0 ? n : UV.toBase64,
        disableHostPrefix:
          (r = e?.disableHostPrefix) !== null && r !== void 0 ? r : !1,
        endpointProvider:
          (s = e?.endpointProvider) !== null && s !== void 0 ? s : cPe,
        extensions: (o = e?.extensions) !== null && o !== void 0 ? o : [],
        logger:
          (i = e?.logger) !== null && i !== void 0 ? i : new rPe.NoOpLogger(),
        serviceId: (a = e?.serviceId) !== null && a !== void 0 ? a : 'SSO OIDC',
        urlParser:
          (c = e?.urlParser) !== null && c !== void 0 ? c : sPe.parseUrl,
        utf8Decoder:
          (u = e?.utf8Decoder) !== null && u !== void 0 ? u : FV.fromUtf8,
        utf8Encoder:
          (d = e?.utf8Encoder) !== null && d !== void 0 ? d : FV.toUtf8,
      }
    },
    uPe = v(),
    lPe = wl(),
    mPe = v(),
    pPe = (e) => {
      var t, n, r, s, o, i, a, c, u, d
      ;(0, mPe.emitWarningIfUnsupportedVersion)(process.version)
      let p = (0, lPe.resolveDefaultsModeConfig)(e),
        _ = () => p().then(uPe.loadConfigsForDefaultMode),
        f = dPe(e)
      return {
        ...f,
        ...e,
        runtime: 'node',
        defaultsMode: p,
        bodyLengthChecker:
          (t = e?.bodyLengthChecker) !== null && t !== void 0
            ? t
            : tPe.calculateBodyLength,
        defaultUserAgentProvider:
          (n = e?.defaultUserAgentProvider) !== null && n !== void 0
            ? n
            : (0, Zxe.defaultUserAgent)({
                serviceId: f.serviceId,
                clientVersion: Qxe.version,
              }),
        maxAttempts:
          (r = e?.maxAttempts) !== null && r !== void 0
            ? r
            : (0, Ol.loadConfig)(MV.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          (s = e?.region) !== null && s !== void 0
            ? s
            : (0, Ol.loadConfig)(
                My.NODE_REGION_CONFIG_OPTIONS,
                My.NODE_REGION_CONFIG_FILE_OPTIONS,
              ),
        requestHandler:
          (o = e?.requestHandler) !== null && o !== void 0
            ? o
            : new LV.NodeHttpHandler(_),
        retryMode:
          (i = e?.retryMode) !== null && i !== void 0
            ? i
            : (0, Ol.loadConfig)({
                ...MV.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () =>
                  (await _()).retryMode || nPe.DEFAULT_RETRY_MODE,
              }),
        sha256:
          (a = e?.sha256) !== null && a !== void 0
            ? a
            : ePe.Hash.bind(null, 'sha256'),
        streamCollector:
          (c = e?.streamCollector) !== null && c !== void 0
            ? c
            : LV.streamCollector,
        useDualstackEndpoint:
          (u = e?.useDualstackEndpoint) !== null && u !== void 0
            ? u
            : (0, Ol.loadConfig)(My.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          (d = e?.useFipsEndpoint) !== null && d !== void 0
            ? d
            : (0, Ol.loadConfig)(My.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    },
    KV = xl(),
    XV = Oe(),
    JV = v(),
    mP = (e) => e,
    _Pe = (e, t) => {
      let n = {
        ...mP((0, KV.getAwsRegionExtensionConfiguration)(e)),
        ...mP((0, JV.getDefaultExtensionConfiguration)(e)),
        ...mP((0, XV.getHttpHandlerExtensionConfiguration)(e)),
      }
      return (
        t.forEach((r) => r.configure(n)),
        {
          ...e,
          ...(0, KV.resolveAwsRegionExtensionConfiguration)(n),
          ...(0, JV.resolveDefaultRuntimeConfig)(n),
          ...(0, XV.resolveHttpHandlerRuntimeConfig)(n),
        }
      )
    },
    nY = class extends Xxe.Client {
      constructor(...[e]) {
        let t = pPe(e || {}),
          n = Jxe(t),
          r = (0, Yxe.resolveRegionConfig)(n),
          s = (0, Kxe.resolveEndpointConfig)(r),
          o = (0, kV.resolveRetryConfig)(s),
          i = (0, NV.resolveHostHeaderConfig)(o),
          a = (0, qV.resolveUserAgentConfig)(i),
          c = _Pe(a, e?.extensions || [])
        super(c),
          (this.config = c),
          this.middlewareStack.use((0, kV.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, Wxe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, NV.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, Hxe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, Vxe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, qV.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  Ee.SSOOIDCClient = nY
  var fPe = v(),
    hPe = q(),
    gPe = k(),
    yPe = v(),
    EPe = D(),
    fP = Oe(),
    T = v(),
    SPe = v(),
    At = class rY extends SPe.ServiceException {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, rY.prototype)
      }
    },
    sY = class oY extends At {
      constructor(t) {
        super({ name: 'AccessDeniedException', $fault: 'client', ...t }),
          (this.name = 'AccessDeniedException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, oY.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    }
  Ee.AccessDeniedException = sY
  var iY = class aY extends At {
    constructor(t) {
      super({ name: 'AuthorizationPendingException', $fault: 'client', ...t }),
        (this.name = 'AuthorizationPendingException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, aY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.AuthorizationPendingException = iY
  var cY = class dY extends At {
    constructor(t) {
      super({ name: 'ExpiredTokenException', $fault: 'client', ...t }),
        (this.name = 'ExpiredTokenException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, dY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.ExpiredTokenException = cY
  var uY = class lY extends At {
    constructor(t) {
      super({ name: 'InternalServerException', $fault: 'server', ...t }),
        (this.name = 'InternalServerException'),
        (this.$fault = 'server'),
        Object.setPrototypeOf(this, lY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.InternalServerException = uY
  var mY = class pY extends At {
    constructor(t) {
      super({ name: 'InvalidClientException', $fault: 'client', ...t }),
        (this.name = 'InvalidClientException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, pY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.InvalidClientException = mY
  var bPe = class _Y extends At {
      constructor(t) {
        super({ name: 'InvalidGrantException', $fault: 'client', ...t }),
          (this.name = 'InvalidGrantException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, _Y.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    },
    fY = class hY extends At {
      constructor(t) {
        super({ name: 'InvalidRequestException', $fault: 'client', ...t }),
          (this.name = 'InvalidRequestException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, hY.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    }
  Ee.InvalidRequestException = fY
  var gY = class yY extends At {
    constructor(t) {
      super({ name: 'InvalidScopeException', $fault: 'client', ...t }),
        (this.name = 'InvalidScopeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, yY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.InvalidScopeException = gY
  var EY = class SY extends At {
    constructor(t) {
      super({ name: 'SlowDownException', $fault: 'client', ...t }),
        (this.name = 'SlowDownException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, SY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.SlowDownException = EY
  var bY = class vY extends At {
    constructor(t) {
      super({ name: 'UnauthorizedClientException', $fault: 'client', ...t }),
        (this.name = 'UnauthorizedClientException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, vY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.UnauthorizedClientException = bY
  var CY = class TY extends At {
    constructor(t) {
      super({ name: 'UnsupportedGrantTypeException', $fault: 'client', ...t }),
        (this.name = 'UnsupportedGrantTypeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, TY.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.UnsupportedGrantTypeException = CY
  var vPe = class wY extends At {
      constructor(t) {
        super({
          name: 'InvalidClientMetadataException',
          $fault: 'client',
          ...t,
        }),
          (this.name = 'InvalidClientMetadataException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, wY.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    },
    CPe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = { 'content-type': 'application/json' },
        a = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/token`,
        c
      return (
        (c = JSON.stringify(
          (0, T.take)(e, {
            clientId: [],
            clientSecret: [],
            code: [],
            deviceCode: [],
            grantType: [],
            redirectUri: [],
            refreshToken: [],
            scope: (u) => (0, T._json)(u),
          }),
        )),
        new fP.HttpRequest({
          protocol: r,
          hostname: n,
          port: s,
          method: 'POST',
          headers: i,
          path: a,
          body: c,
        })
      )
    },
    TPe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = { 'content-type': 'application/json' },
        a = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/client/register`,
        c
      return (
        (c = JSON.stringify(
          (0, T.take)(e, {
            clientName: [],
            clientType: [],
            scopes: (u) => (0, T._json)(u),
          }),
        )),
        new fP.HttpRequest({
          protocol: r,
          hostname: n,
          port: s,
          method: 'POST',
          headers: i,
          path: a,
          body: c,
        })
      )
    },
    wPe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = { 'content-type': 'application/json' },
        a = `${
          o?.endsWith('/') ? o.slice(0, -1) : o || ''
        }/device_authorization`,
        c
      return (
        (c = JSON.stringify(
          (0, T.take)(e, { clientId: [], clientSecret: [], startUrl: [] }),
        )),
        new fP.HttpRequest({
          protocol: r,
          hostname: n,
          port: s,
          method: 'POST',
          headers: i,
          path: a,
          body: c,
        })
      )
    },
    IPe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return xPe(e, t)
      let n = (0, T.map)({ $metadata: ct(e) }),
        r = (0, T.expectNonNull)(
          (0, T.expectObject)(await Ly(e.body, t)),
          'body',
        ),
        s = (0, T.take)(r, {
          accessToken: T.expectString,
          expiresIn: T.expectInt32,
          idToken: T.expectString,
          refreshToken: T.expectString,
          tokenType: T.expectString,
        })
      return Object.assign(n, s), n
    },
    xPe = async (e, t) => {
      let n = { ...e, body: await EP(e.body, t) },
        r = SP(e, n.body)
      switch (r) {
        case 'AccessDeniedException':
        case 'com.amazonaws.ssooidc#AccessDeniedException':
          throw await OPe(n, t)
        case 'AuthorizationPendingException':
        case 'com.amazonaws.ssooidc#AuthorizationPendingException':
          throw await NPe(n, t)
        case 'ExpiredTokenException':
        case 'com.amazonaws.ssooidc#ExpiredTokenException':
          throw await qPe(n, t)
        case 'InternalServerException':
        case 'com.amazonaws.ssooidc#InternalServerException':
          throw await gP(n, t)
        case 'InvalidClientException':
        case 'com.amazonaws.ssooidc#InvalidClientException':
          throw await IY(n, t)
        case 'InvalidGrantException':
        case 'com.amazonaws.ssooidc#InvalidGrantException':
          throw await MPe(n, t)
        case 'InvalidRequestException':
        case 'com.amazonaws.ssooidc#InvalidRequestException':
          throw await yP(n, t)
        case 'InvalidScopeException':
        case 'com.amazonaws.ssooidc#InvalidScopeException':
          throw await xY(n, t)
        case 'SlowDownException':
        case 'com.amazonaws.ssooidc#SlowDownException':
          throw await PY(n, t)
        case 'UnauthorizedClientException':
        case 'com.amazonaws.ssooidc#UnauthorizedClientException':
          throw await RY(n, t)
        case 'UnsupportedGrantTypeException':
        case 'com.amazonaws.ssooidc#UnsupportedGrantTypeException':
          throw await LPe(n, t)
        default:
          let s = n.body
          return hP({ output: e, parsedBody: s, errorCode: r })
      }
    },
    PPe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return RPe(e, t)
      let n = (0, T.map)({ $metadata: ct(e) }),
        r = (0, T.expectNonNull)(
          (0, T.expectObject)(await Ly(e.body, t)),
          'body',
        ),
        s = (0, T.take)(r, {
          authorizationEndpoint: T.expectString,
          clientId: T.expectString,
          clientIdIssuedAt: T.expectLong,
          clientSecret: T.expectString,
          clientSecretExpiresAt: T.expectLong,
          tokenEndpoint: T.expectString,
        })
      return Object.assign(n, s), n
    },
    RPe = async (e, t) => {
      let n = { ...e, body: await EP(e.body, t) },
        r = SP(e, n.body)
      switch (r) {
        case 'InternalServerException':
        case 'com.amazonaws.ssooidc#InternalServerException':
          throw await gP(n, t)
        case 'InvalidClientMetadataException':
        case 'com.amazonaws.ssooidc#InvalidClientMetadataException':
          throw await kPe(n, t)
        case 'InvalidRequestException':
        case 'com.amazonaws.ssooidc#InvalidRequestException':
          throw await yP(n, t)
        case 'InvalidScopeException':
        case 'com.amazonaws.ssooidc#InvalidScopeException':
          throw await xY(n, t)
        default:
          let s = n.body
          return hP({ output: e, parsedBody: s, errorCode: r })
      }
    },
    DPe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return APe(e, t)
      let n = (0, T.map)({ $metadata: ct(e) }),
        r = (0, T.expectNonNull)(
          (0, T.expectObject)(await Ly(e.body, t)),
          'body',
        ),
        s = (0, T.take)(r, {
          deviceCode: T.expectString,
          expiresIn: T.expectInt32,
          interval: T.expectInt32,
          userCode: T.expectString,
          verificationUri: T.expectString,
          verificationUriComplete: T.expectString,
        })
      return Object.assign(n, s), n
    },
    APe = async (e, t) => {
      let n = { ...e, body: await EP(e.body, t) },
        r = SP(e, n.body)
      switch (r) {
        case 'InternalServerException':
        case 'com.amazonaws.ssooidc#InternalServerException':
          throw await gP(n, t)
        case 'InvalidClientException':
        case 'com.amazonaws.ssooidc#InvalidClientException':
          throw await IY(n, t)
        case 'InvalidRequestException':
        case 'com.amazonaws.ssooidc#InvalidRequestException':
          throw await yP(n, t)
        case 'SlowDownException':
        case 'com.amazonaws.ssooidc#SlowDownException':
          throw await PY(n, t)
        case 'UnauthorizedClientException':
        case 'com.amazonaws.ssooidc#UnauthorizedClientException':
          throw await RY(n, t)
        default:
          let s = n.body
          return hP({ output: e, parsedBody: s, errorCode: r })
      }
    },
    hP = (0, T.withBaseException)(At),
    OPe = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new sY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    NPe = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new iY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    qPe = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new cY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    gP = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new uY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    IY = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new mY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    kPe = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new vPe({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    MPe = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new bPe({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    yP = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new fY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    xY = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new gY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    PY = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new EY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    RY = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new bY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    LPe = async (e, t) => {
      let n = (0, T.map)({}),
        r = e.body,
        s = (0, T.take)(r, {
          error: T.expectString,
          error_description: T.expectString,
        })
      Object.assign(n, s)
      let o = new CY({ $metadata: ct(e), ...n })
      return (0, T.decorateServiceException)(o, e.body)
    },
    ct = (e) => {
      var t, n
      return {
        httpStatusCode: e.statusCode,
        requestId:
          (n =
            (t = e.headers['x-amzn-requestid']) !== null && t !== void 0
              ? t
              : e.headers['x-amzn-request-id']) !== null && n !== void 0
            ? n
            : e.headers['x-amz-request-id'],
        extendedRequestId: e.headers['x-amz-id-2'],
        cfId: e.headers['x-amz-cf-id'],
      }
    },
    UPe = (e, t) => (0, T.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    Ly = (e, t) => UPe(e, t).then((n) => (n.length ? JSON.parse(n) : {})),
    EP = async (e, t) => {
      var n
      let r = await Ly(e, t)
      return (
        (r.message = (n = r.message) !== null && n !== void 0 ? n : r.Message),
        r
      )
    },
    SP = (e, t) => {
      let n = (o, i) =>
          Object.keys(o).find((a) => a.toLowerCase() === i.toLowerCase()),
        r = (o) => {
          let i = o
          return (
            typeof i == 'number' && (i = i.toString()),
            i.indexOf(',') >= 0 && (i = i.split(',')[0]),
            i.indexOf(':') >= 0 && (i = i.split(':')[0]),
            i.indexOf('#') >= 0 && (i = i.split('#')[1]),
            i
          )
        },
        s = n(e.headers, 'x-amzn-errortype')
      if (s !== void 0) return r(e.headers[s])
      if (t.code !== void 0) return r(t.code)
      if (t.__type !== void 0) return r(t.__type)
    },
    DY = class AY extends yPe.Command {
      constructor(t) {
        super(), (this.input = t)
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, gPe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, hPe.getEndpointPlugin)(
              n,
              AY.getEndpointParameterInstructions(),
            ),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOOIDCClient',
            commandName: 'CreateTokenCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [EPe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSSOOIDCService',
              operation: 'CreateToken',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return CPe(t, n)
      }
      deserialize(t, n) {
        return IPe(t, n)
      }
    }
  Ee.CreateTokenCommand = DY
  var FPe = q(),
    BPe = k(),
    jPe = v(),
    GPe = D(),
    $Pe = class OY extends jPe.Command {
      constructor(t) {
        super(), (this.input = t)
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, BPe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, FPe.getEndpointPlugin)(
              n,
              OY.getEndpointParameterInstructions(),
            ),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOOIDCClient',
            commandName: 'RegisterClientCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [GPe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSSOOIDCService',
              operation: 'RegisterClient',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return TPe(t, n)
      }
      deserialize(t, n) {
        return PPe(t, n)
      }
    },
    zPe = q(),
    HPe = k(),
    VPe = v(),
    YPe = D(),
    WPe = class NY extends VPe.Command {
      constructor(t) {
        super(), (this.input = t)
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, HPe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, zPe.getEndpointPlugin)(
              n,
              NY.getEndpointParameterInstructions(),
            ),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'SSOOIDCClient',
            commandName: 'StartDeviceAuthorizationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [YPe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSSOOIDCService',
              operation: 'StartDeviceAuthorization',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return wPe(t, n)
      }
      deserialize(t, n) {
        return DPe(t, n)
      }
    },
    KPe = {
      CreateTokenCommand: DY,
      RegisterClientCommand: $Pe,
      StartDeviceAuthorizationCommand: WPe,
    },
    XPe = class extends nY {}
  ;(0, fPe.createAggregatedClient)(KPe, XPe)
})
var Fy = l((Ga) => {
  'use strict'
  Object.defineProperty(Ga, '__esModule', { value: !0 })
  Ga.REFRESH_MESSAGE = Ga.EXPIRE_WINDOW_MS = void 0
  Ga.EXPIRE_WINDOW_MS = 5 * 60 * 1e3
  Ga.REFRESH_MESSAGE =
    "To refresh this SSO session run 'aws sso login' with the corresponding profile."
})
var qY = l((By) => {
  'use strict'
  Object.defineProperty(By, '__esModule', { value: !0 })
  By.getSsoOidcClient = void 0
  var JPe = Uy(),
    bP = {},
    QPe = (e) => {
      if (bP[e]) return bP[e]
      let t = new JPe.SSOOIDCClient({ region: e })
      return (bP[e] = t), t
    }
  By.getSsoOidcClient = QPe
})
var kY = l((jy) => {
  'use strict'
  Object.defineProperty(jy, '__esModule', { value: !0 })
  jy.getNewSsoOidcToken = void 0
  var ZPe = Uy(),
    eRe = qY(),
    tRe = (e, t) =>
      (0, eRe.getSsoOidcClient)(t).send(
        new ZPe.CreateTokenCommand({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: 'refresh_token',
        }),
      )
  jy.getNewSsoOidcToken = tRe
})
var MY = l((Gy) => {
  'use strict'
  Object.defineProperty(Gy, '__esModule', { value: !0 })
  Gy.validateTokenExpiry = void 0
  var nRe = ye(),
    rRe = Fy(),
    sRe = (e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new nRe.TokenProviderError(
          `Token is expired. ${rRe.REFRESH_MESSAGE}`,
          !1,
        )
    }
  Gy.validateTokenExpiry = sRe
})
var LY = l(($y) => {
  'use strict'
  Object.defineProperty($y, '__esModule', { value: !0 })
  $y.validateTokenKey = void 0
  var oRe = ye(),
    iRe = Fy(),
    aRe = (e, t, n = !1) => {
      if (typeof t > 'u')
        throw new oRe.TokenProviderError(
          `Value not present for '${e}' in SSO Token${
            n ? '. Cannot refresh' : ''
          }. ${iRe.REFRESH_MESSAGE}`,
          !1,
        )
    }
  $y.validateTokenKey = aRe
})
var UY = l((zy) => {
  'use strict'
  Object.defineProperty(zy, '__esModule', { value: !0 })
  zy.writeSSOTokenToFile = void 0
  var cRe = mn(),
    dRe = require('fs'),
    { writeFile: uRe } = dRe.promises,
    lRe = (e, t) => {
      let n = (0, cRe.getSSOTokenFilepath)(e),
        r = JSON.stringify(t, null, 2)
      return uRe(n, r)
    }
  zy.writeSSOTokenToFile = lRe
})
var vP = l((Vy) => {
  'use strict'
  Object.defineProperty(Vy, '__esModule', { value: !0 })
  Vy.fromSso = void 0
  var Nl = ye(),
    Hy = mn(),
    FY = Fy(),
    mRe = kY(),
    BY = MY(),
    Wo = LY(),
    pRe = UY(),
    jY = new Date(0),
    _Re =
      (e = {}) =>
      async () => {
        let t = await (0, Hy.parseKnownFiles)(e),
          n = (0, Hy.getProfileName)(e),
          r = t[n]
        if (r) {
          if (!r.sso_session)
            throw new Nl.TokenProviderError(
              `Profile '${n}' is missing required property 'sso_session'.`,
            )
        } else
          throw new Nl.TokenProviderError(
            `Profile '${n}' could not be found in shared credentials file.`,
            !1,
          )
        let s = r.sso_session,
          i = (await (0, Hy.loadSsoSessionData)(e))[s]
        if (!i)
          throw new Nl.TokenProviderError(
            `Sso session '${s}' could not be found in shared credentials file.`,
            !1,
          )
        for (let f of ['sso_start_url', 'sso_region'])
          if (!i[f])
            throw new Nl.TokenProviderError(
              `Sso session '${s}' is missing required property '${f}'.`,
              !1,
            )
        let a = i.sso_start_url,
          c = i.sso_region,
          u
        try {
          u = await (0, Hy.getSSOTokenFromFile)(s)
        } catch {
          throw new Nl.TokenProviderError(
            `The SSO session token associated with profile=${n} was not found or is invalid. ${FY.REFRESH_MESSAGE}`,
            !1,
          )
        }
        ;(0, Wo.validateTokenKey)('accessToken', u.accessToken),
          (0, Wo.validateTokenKey)('expiresAt', u.expiresAt)
        let { accessToken: d, expiresAt: p } = u,
          _ = { token: d, expiration: new Date(p) }
        if (_.expiration.getTime() - Date.now() > FY.EXPIRE_WINDOW_MS) return _
        if (Date.now() - jY.getTime() < 30 * 1e3)
          return (0, BY.validateTokenExpiry)(_), _
        ;(0, Wo.validateTokenKey)('clientId', u.clientId, !0),
          (0, Wo.validateTokenKey)('clientSecret', u.clientSecret, !0),
          (0, Wo.validateTokenKey)('refreshToken', u.refreshToken, !0)
        try {
          jY.setTime(Date.now())
          let f = await (0, mRe.getNewSsoOidcToken)(u, c)
          ;(0, Wo.validateTokenKey)('accessToken', f.accessToken),
            (0, Wo.validateTokenKey)('expiresIn', f.expiresIn)
          let h = new Date(Date.now() + f.expiresIn * 1e3)
          try {
            await (0, pRe.writeSSOTokenToFile)(s, {
              ...u,
              accessToken: f.accessToken,
              expiresAt: h.toISOString(),
              refreshToken: f.refreshToken,
            })
          } catch {}
          return { token: f.accessToken, expiration: h }
        } catch {
          return (0, BY.validateTokenExpiry)(_), _
        }
      }
  Vy.fromSso = _Re
})
var GY = l((Yy) => {
  'use strict'
  Object.defineProperty(Yy, '__esModule', { value: !0 })
  Yy.fromStatic = void 0
  var fRe = ye(),
    hRe =
      ({ token: e }) =>
      async () => {
        if (!e || !e.token)
          throw new fRe.TokenProviderError(
            'Please pass a valid token to fromStatic',
            !1,
          )
        return e
      }
  Yy.fromStatic = hRe
})
var $Y = l((Wy) => {
  'use strict'
  Object.defineProperty(Wy, '__esModule', { value: !0 })
  Wy.nodeProvider = void 0
  var CP = ye(),
    gRe = vP(),
    yRe = (e = {}) =>
      (0, CP.memoize)(
        (0, CP.chain)((0, gRe.fromSso)(e), async () => {
          throw new CP.TokenProviderError(
            'Could not load token from any providers',
            !1,
          )
        }),
        (t) =>
          t.expiration !== void 0 && t.expiration.getTime() - Date.now() < 3e5,
        (t) => t.expiration !== void 0,
      )
  Wy.nodeProvider = yRe
})
var zY = l(($a) => {
  'use strict'
  Object.defineProperty($a, '__esModule', { value: !0 })
  var Ky = (x(), w(I))
  Ky.__exportStar(Uy(), $a)
  Ky.__exportStar(vP(), $a)
  Ky.__exportStar(GY(), $a)
  Ky.__exportStar($Y(), $a)
})
var VY = l((Xy) => {
  'use strict'
  Object.defineProperty(Xy, '__esModule', { value: !0 })
  Xy.resolveSSOCredentials = void 0
  var HY = OV(),
    ERe = zY(),
    ql = ye(),
    SRe = mn(),
    kl = !1,
    bRe = async ({
      ssoStartUrl: e,
      ssoSession: t,
      ssoAccountId: n,
      ssoRegion: r,
      ssoRoleName: s,
      ssoClient: o,
      profile: i,
    }) => {
      let a,
        c =
          'To refresh this SSO session run aws sso login with the corresponding profile.'
      if (t)
        try {
          let E = await (0, ERe.fromSso)({ profile: i })()
          a = {
            accessToken: E.token,
            expiresAt: new Date(E.expiration).toISOString(),
          }
        } catch (E) {
          throw new ql.CredentialsProviderError(E.message, kl)
        }
      else
        try {
          a = await (0, SRe.getSSOTokenFromFile)(e)
        } catch {
          throw new ql.CredentialsProviderError(
            `The SSO session associated with this profile is invalid. ${c}`,
            kl,
          )
        }
      if (new Date(a.expiresAt).getTime() - Date.now() <= 0)
        throw new ql.CredentialsProviderError(
          `The SSO session associated with this profile has expired. ${c}`,
          kl,
        )
      let { accessToken: u } = a,
        d = o || new HY.SSOClient({ region: r }),
        p
      try {
        p = await d.send(
          new HY.GetRoleCredentialsCommand({
            accountId: n,
            roleName: s,
            accessToken: u,
          }),
        )
      } catch (E) {
        throw ql.CredentialsProviderError.from(E, kl)
      }
      let {
        roleCredentials: {
          accessKeyId: _,
          secretAccessKey: f,
          sessionToken: h,
          expiration: y,
        } = {},
      } = p
      if (!_ || !f || !h || !y)
        throw new ql.CredentialsProviderError(
          'SSO returns an invalid temporary credential.',
          kl,
        )
      return {
        accessKeyId: _,
        secretAccessKey: f,
        sessionToken: h,
        expiration: new Date(y),
      }
    }
  Xy.resolveSSOCredentials = bRe
})
var TP = l((Jy) => {
  'use strict'
  Object.defineProperty(Jy, '__esModule', { value: !0 })
  Jy.validateSsoProfile = void 0
  var vRe = ye(),
    CRe = (e) => {
      let {
        sso_start_url: t,
        sso_account_id: n,
        sso_region: r,
        sso_role_name: s,
      } = e
      if (!t || !n || !r || !s)
        throw new vRe.CredentialsProviderError(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(
            e,
          ).join(', ')}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          !1,
        )
      return e
    }
  Jy.validateSsoProfile = CRe
})
var WY = l((Qy) => {
  'use strict'
  Object.defineProperty(Qy, '__esModule', { value: !0 })
  Qy.fromSSO = void 0
  var Ml = ye(),
    wP = mn(),
    TRe = jx(),
    YY = VY(),
    wRe = TP(),
    IRe =
      (e = {}) =>
      async () => {
        let {
            ssoStartUrl: t,
            ssoAccountId: n,
            ssoRegion: r,
            ssoRoleName: s,
            ssoClient: o,
            ssoSession: i,
          } = e,
          a = (0, wP.getProfileName)(e)
        if (!t && !n && !r && !s && !i) {
          let u = (await (0, wP.parseKnownFiles)(e))[a]
          if (!u)
            throw new Ml.CredentialsProviderError(`Profile ${a} was not found.`)
          if (!(0, TRe.isSsoProfile)(u))
            throw new Ml.CredentialsProviderError(
              `Profile ${a} is not configured with SSO credentials.`,
            )
          if (u?.sso_session) {
            let E = (await (0, wP.loadSsoSessionData)(e))[u.sso_session],
              C = ` configurations in profile ${a} and sso-session ${u.sso_session}`
            if (r && r !== E.sso_region)
              throw new Ml.CredentialsProviderError(
                'Conflicting SSO region' + C,
                !1,
              )
            if (t && t !== E.sso_start_url)
              throw new Ml.CredentialsProviderError(
                'Conflicting SSO start_url' + C,
                !1,
              )
            ;(u.sso_region = E.sso_region), (u.sso_start_url = E.sso_start_url)
          }
          let {
            sso_start_url: d,
            sso_account_id: p,
            sso_region: _,
            sso_role_name: f,
            sso_session: h,
          } = (0, wRe.validateSsoProfile)(u)
          return (0, YY.resolveSSOCredentials)({
            ssoStartUrl: d,
            ssoSession: h,
            ssoAccountId: p,
            ssoRegion: _,
            ssoRoleName: f,
            ssoClient: o,
            profile: a,
          })
        } else {
          if (!t || !n || !r || !s)
            throw new Ml.CredentialsProviderError(
              'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
            )
          return (0, YY.resolveSSOCredentials)({
            ssoStartUrl: t,
            ssoSession: i,
            ssoAccountId: n,
            ssoRegion: r,
            ssoRoleName: s,
            ssoClient: o,
            profile: a,
          })
        }
      }
  Qy.fromSSO = IRe
})
var XY = l((KY) => {
  'use strict'
  Object.defineProperty(KY, '__esModule', { value: !0 })
})
var eE = l((za) => {
  'use strict'
  Object.defineProperty(za, '__esModule', { value: !0 })
  var Zy = (x(), w(I))
  Zy.__exportStar(WY(), za)
  Zy.__exportStar(jx(), za)
  Zy.__exportStar(XY(), za)
  Zy.__exportStar(TP(), za)
})
var QY = l((Ha) => {
  'use strict'
  Object.defineProperty(Ha, '__esModule', { value: !0 })
  Ha.resolveSsoCredentials = Ha.isSsoProfile = void 0
  var JY = eE(),
    xRe = eE()
  Object.defineProperty(Ha, 'isSsoProfile', {
    enumerable: !0,
    get: function () {
      return xRe.isSsoProfile
    },
  })
  var PRe = (e) => {
    let {
      sso_start_url: t,
      sso_account_id: n,
      sso_session: r,
      sso_region: s,
      sso_role_name: o,
    } = (0, JY.validateSsoProfile)(e)
    return (0, JY.fromSSO)({
      ssoStartUrl: t,
      ssoAccountId: n,
      ssoSession: r,
      ssoRegion: s,
      ssoRoleName: o,
    })()
  }
  Ha.resolveSsoCredentials = PRe
})
var ZY = l((Va) => {
  'use strict'
  Object.defineProperty(Va, '__esModule', { value: !0 })
  Va.resolveStaticCredentials = Va.isStaticCredsProfile = void 0
  var RRe = (e) =>
    !!e &&
    typeof e == 'object' &&
    typeof e.aws_access_key_id == 'string' &&
    typeof e.aws_secret_access_key == 'string' &&
    ['undefined', 'string'].indexOf(typeof e.aws_session_token) > -1
  Va.isStaticCredsProfile = RRe
  var DRe = (e) =>
    Promise.resolve({
      accessKeyId: e.aws_access_key_id,
      secretAccessKey: e.aws_secret_access_key,
      sessionToken: e.aws_session_token,
    })
  Va.resolveStaticCredentials = DRe
})
var IP = l((tE) => {
  'use strict'
  Object.defineProperty(tE, '__esModule', { value: !0 })
  tE.fromWebToken = void 0
  var ARe = ye(),
    ORe = (e) => () => {
      let {
        roleArn: t,
        roleSessionName: n,
        webIdentityToken: r,
        providerId: s,
        policyArns: o,
        policy: i,
        durationSeconds: a,
        roleAssumerWithWebIdentity: c,
      } = e
      if (!c)
        throw new ARe.CredentialsProviderError(
          `Role Arn '${t}' needs to be assumed with web identity, but no role assumption callback was provided.`,
          !1,
        )
      return c({
        RoleArn: t,
        RoleSessionName: n ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: r,
        ProviderId: s,
        PolicyArns: o,
        Policy: i,
        DurationSeconds: a,
      })
    }
  tE.fromWebToken = ORe
})
var eW = l((nE) => {
  'use strict'
  Object.defineProperty(nE, '__esModule', { value: !0 })
  nE.fromTokenFile = void 0
  var NRe = ye(),
    qRe = require('fs'),
    kRe = IP(),
    MRe = 'AWS_WEB_IDENTITY_TOKEN_FILE',
    LRe = 'AWS_ROLE_ARN',
    URe = 'AWS_ROLE_SESSION_NAME',
    FRe =
      (e = {}) =>
      async () => {
        var t, n, r
        let s =
            (t = e?.webIdentityTokenFile) !== null && t !== void 0
              ? t
              : process.env[MRe],
          o = (n = e?.roleArn) !== null && n !== void 0 ? n : process.env[LRe],
          i =
            (r = e?.roleSessionName) !== null && r !== void 0
              ? r
              : process.env[URe]
        if (!s || !o)
          throw new NRe.CredentialsProviderError(
            'Web identity configuration not specified',
          )
        return (0, kRe.fromWebToken)({
          ...e,
          webIdentityToken: (0, qRe.readFileSync)(s, { encoding: 'ascii' }),
          roleArn: o,
          roleSessionName: i,
        })()
      }
  nE.fromTokenFile = FRe
})
var xP = l((rE) => {
  'use strict'
  Object.defineProperty(rE, '__esModule', { value: !0 })
  var tW = (x(), w(I))
  tW.__exportStar(eW(), rE)
  tW.__exportStar(IP(), rE)
})
var nW = l((Ya) => {
  'use strict'
  Object.defineProperty(Ya, '__esModule', { value: !0 })
  Ya.resolveWebIdentityCredentials = Ya.isWebIdentityProfile = void 0
  var BRe = xP(),
    jRe = (e) =>
      !!e &&
      typeof e == 'object' &&
      typeof e.web_identity_token_file == 'string' &&
      typeof e.role_arn == 'string' &&
      ['undefined', 'string'].indexOf(typeof e.role_session_name) > -1
  Ya.isWebIdentityProfile = jRe
  var GRe = async (e, t) =>
    (0, BRe.fromTokenFile)({
      webIdentityTokenFile: e.web_identity_token_file,
      roleArn: e.role_arn,
      roleSessionName: e.role_session_name,
      roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
    })()
  Ya.resolveWebIdentityCredentials = GRe
})
var Lx = l((oE) => {
  'use strict'
  Object.defineProperty(oE, '__esModule', { value: !0 })
  oE.resolveProfileData = void 0
  var $Re = ye(),
    rW = l3(),
    sW = h3(),
    oW = QY(),
    sE = ZY(),
    iW = nW(),
    zRe = async (e, t, n, r = {}) => {
      let s = t[e]
      if (Object.keys(r).length > 0 && (0, sE.isStaticCredsProfile)(s))
        return (0, sE.resolveStaticCredentials)(s)
      if ((0, rW.isAssumeRoleProfile)(s))
        return (0, rW.resolveAssumeRoleCredentials)(e, t, n, r)
      if ((0, sE.isStaticCredsProfile)(s))
        return (0, sE.resolveStaticCredentials)(s)
      if ((0, iW.isWebIdentityProfile)(s))
        return (0, iW.resolveWebIdentityCredentials)(s, n)
      if ((0, sW.isProcessProfile)(s))
        return (0, sW.resolveProcessCredentials)(n, e)
      if ((0, oW.isSsoProfile)(s)) return (0, oW.resolveSsoCredentials)(s)
      throw new $Re.CredentialsProviderError(
        `Profile ${e} could not be found or parsed in shared credentials file.`,
      )
    }
  oE.resolveProfileData = zRe
})
var cW = l((iE) => {
  'use strict'
  Object.defineProperty(iE, '__esModule', { value: !0 })
  iE.fromIni = void 0
  var aW = mn(),
    HRe = Lx(),
    VRe =
      (e = {}) =>
      async () => {
        let t = await (0, aW.parseKnownFiles)(e)
        return (0, HRe.resolveProfileData)((0, aW.getProfileName)(e), t, e)
      }
  iE.fromIni = VRe
})
var dW = l((PP) => {
  'use strict'
  Object.defineProperty(PP, '__esModule', { value: !0 })
  var YRe = (x(), w(I))
  YRe.__exportStar(cW(), PP)
})
var uW = l((Ko) => {
  'use strict'
  Object.defineProperty(Ko, '__esModule', { value: !0 })
  Ko.remoteProvider = Ko.ENV_IMDS_DISABLED = void 0
  var aE = Wg(),
    WRe = ye()
  Ko.ENV_IMDS_DISABLED = 'AWS_EC2_METADATA_DISABLED'
  var KRe = (e) =>
    process.env[aE.ENV_CMDS_RELATIVE_URI] || process.env[aE.ENV_CMDS_FULL_URI]
      ? (0, aE.fromContainerMetadata)(e)
      : process.env[Ko.ENV_IMDS_DISABLED]
        ? async () => {
            throw new WRe.CredentialsProviderError(
              'EC2 Instance Metadata Service access disabled',
            )
          }
        : (0, aE.fromInstanceMetadata)(e)
  Ko.remoteProvider = KRe
})
var lW = l((cE) => {
  'use strict'
  Object.defineProperty(cE, '__esModule', { value: !0 })
  cE.defaultProvider = void 0
  var XRe = Px(),
    JRe = dW(),
    QRe = Bx(),
    ZRe = eE(),
    eDe = xP(),
    RP = ye(),
    tDe = mn(),
    nDe = uW(),
    rDe = (e = {}) =>
      (0, RP.memoize)(
        (0, RP.chain)(
          ...(e.profile || process.env[tDe.ENV_PROFILE]
            ? []
            : [(0, XRe.fromEnv)()]),
          (0, ZRe.fromSSO)(e),
          (0, JRe.fromIni)(e),
          (0, QRe.fromProcess)(e),
          (0, eDe.fromTokenFile)(e),
          (0, nDe.remoteProvider)(e),
          async () => {
            throw new RP.CredentialsProviderError(
              'Could not load credentials from any providers',
              !1,
            )
          },
        ),
        (t) =>
          t.expiration !== void 0 && t.expiration.getTime() - Date.now() < 3e5,
        (t) => t.expiration !== void 0,
      )
  cE.defaultProvider = rDe
})
var AP = l((DP) => {
  'use strict'
  Object.defineProperty(DP, '__esModule', { value: !0 })
  var sDe = (x(), w(I))
  sDe.__exportStar(lW(), DP)
})
var NW = l((dE) => {
  'use strict'
  Object.defineProperty(dE, '__esModule', { value: !0 })
  dE.ruleSet = void 0
  var CW = 'required',
    Z = 'type',
    pe = 'fn',
    _e = 'argv',
    ks = 'ref',
    mW = !1,
    oDe = !0,
    Xo = 'booleanEquals',
    er = 'tree',
    Ze = 'stringEquals',
    TW = 'sigv4',
    wW = 'sts',
    IW = 'us-east-1',
    Ce = 'endpoint',
    pW = 'https://sts.{Region}.{PartitionResult#dnsSuffix}',
    Wa = 'error',
    NP = 'getAttr',
    _W = { [CW]: !1, [Z]: 'String' },
    OP = { [CW]: !0, default: !1, [Z]: 'Boolean' },
    xW = { [ks]: 'Endpoint' },
    fW = { [pe]: 'isSet', [_e]: [{ [ks]: 'Region' }] },
    et = { [ks]: 'Region' },
    hW = { [pe]: 'aws.partition', [_e]: [et], assign: 'PartitionResult' },
    PW = { [ks]: 'UseFIPS' },
    RW = { [ks]: 'UseDualStack' },
    it = {
      url: 'https://sts.amazonaws.com',
      properties: {
        authSchemes: [{ name: TW, signingName: wW, signingRegion: IW }],
      },
      headers: {},
    },
    Ot = {},
    gW = {
      conditions: [{ [pe]: Ze, [_e]: [et, 'aws-global'] }],
      [Ce]: it,
      [Z]: Ce,
    },
    DW = { [pe]: Xo, [_e]: [PW, !0] },
    AW = { [pe]: Xo, [_e]: [RW, !0] },
    yW = {
      [pe]: Xo,
      [_e]: [
        !0,
        { [pe]: NP, [_e]: [{ [ks]: 'PartitionResult' }, 'supportsFIPS'] },
      ],
    },
    OW = { [ks]: 'PartitionResult' },
    EW = {
      [pe]: Xo,
      [_e]: [!0, { [pe]: NP, [_e]: [OW, 'supportsDualStack'] }],
    },
    SW = [{ [pe]: 'isSet', [_e]: [xW] }],
    bW = [DW],
    vW = [AW],
    iDe = {
      version: '1.0',
      parameters: {
        Region: _W,
        UseDualStack: OP,
        UseFIPS: OP,
        Endpoint: _W,
        UseGlobalEndpoint: OP,
      },
      rules: [
        {
          conditions: [
            { [pe]: Xo, [_e]: [{ [ks]: 'UseGlobalEndpoint' }, oDe] },
            { [pe]: 'not', [_e]: SW },
            fW,
            hW,
            { [pe]: Xo, [_e]: [PW, mW] },
            { [pe]: Xo, [_e]: [RW, mW] },
          ],
          [Z]: er,
          rules: [
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'ap-northeast-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'ap-south-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'ap-southeast-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'ap-southeast-2'] }],
              endpoint: it,
              [Z]: Ce,
            },
            gW,
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'ca-central-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'eu-central-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'eu-north-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'eu-west-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'eu-west-2'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'eu-west-3'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'sa-east-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, IW] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'us-east-2'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'us-west-1'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              conditions: [{ [pe]: Ze, [_e]: [et, 'us-west-2'] }],
              endpoint: it,
              [Z]: Ce,
            },
            {
              endpoint: {
                url: pW,
                properties: {
                  authSchemes: [
                    { name: TW, signingName: wW, signingRegion: '{Region}' },
                  ],
                },
                headers: Ot,
              },
              [Z]: Ce,
            },
          ],
        },
        {
          conditions: SW,
          [Z]: er,
          rules: [
            {
              conditions: bW,
              error:
                'Invalid Configuration: FIPS and custom endpoint are not supported',
              [Z]: Wa,
            },
            {
              conditions: vW,
              error:
                'Invalid Configuration: Dualstack and custom endpoint are not supported',
              [Z]: Wa,
            },
            { endpoint: { url: xW, properties: Ot, headers: Ot }, [Z]: Ce },
          ],
        },
        {
          conditions: [fW],
          [Z]: er,
          rules: [
            {
              conditions: [hW],
              [Z]: er,
              rules: [
                {
                  conditions: [DW, AW],
                  [Z]: er,
                  rules: [
                    {
                      conditions: [yW, EW],
                      [Z]: er,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: Ot,
                            headers: Ot,
                          },
                          [Z]: Ce,
                        },
                      ],
                    },
                    {
                      error:
                        'FIPS and DualStack are enabled, but this partition does not support one or both',
                      [Z]: Wa,
                    },
                  ],
                },
                {
                  conditions: bW,
                  [Z]: er,
                  rules: [
                    {
                      conditions: [yW],
                      [Z]: er,
                      rules: [
                        {
                          conditions: [
                            {
                              [pe]: Ze,
                              [_e]: [
                                'aws-us-gov',
                                { [pe]: NP, [_e]: [OW, 'name'] },
                              ],
                            },
                          ],
                          endpoint: {
                            url: 'https://sts.{Region}.amazonaws.com',
                            properties: Ot,
                            headers: Ot,
                          },
                          [Z]: Ce,
                        },
                        {
                          endpoint: {
                            url: 'https://sts-fips.{Region}.{PartitionResult#dnsSuffix}',
                            properties: Ot,
                            headers: Ot,
                          },
                          [Z]: Ce,
                        },
                      ],
                    },
                    {
                      error:
                        'FIPS is enabled but this partition does not support FIPS',
                      [Z]: Wa,
                    },
                  ],
                },
                {
                  conditions: vW,
                  [Z]: er,
                  rules: [
                    {
                      conditions: [EW],
                      [Z]: er,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: Ot,
                            headers: Ot,
                          },
                          [Z]: Ce,
                        },
                      ],
                    },
                    {
                      error:
                        'DualStack is enabled but this partition does not support DualStack',
                      [Z]: Wa,
                    },
                  ],
                },
                gW,
                { endpoint: { url: pW, properties: Ot, headers: Ot }, [Z]: Ce },
              ],
            },
          ],
        },
        { error: 'Invalid Configuration: Missing Region', [Z]: Wa },
      ],
    }
  dE.ruleSet = iDe
})
var qW = l((uE) => {
  'use strict'
  Object.defineProperty(uE, '__esModule', { value: !0 })
  uE.defaultEndpointResolver = void 0
  var aDe = ea(),
    cDe = NW(),
    dDe = (e, t = {}) =>
      (0, aDe.resolveEndpoint)(cDe.ruleSet, {
        endpointParams: e,
        logger: t.logger,
      })
  uE.defaultEndpointResolver = dDe
})
var LW = l((lE) => {
  'use strict'
  Object.defineProperty(lE, '__esModule', { value: !0 })
  lE.getRuntimeConfig = void 0
  var uDe = v(),
    lDe = Mo(),
    kW = aa(),
    MW = Ln(),
    mDe = qW(),
    pDe = (e) => ({
      apiVersion: '2011-06-15',
      base64Decoder: e?.base64Decoder ?? kW.fromBase64,
      base64Encoder: e?.base64Encoder ?? kW.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? mDe.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      logger: e?.logger ?? new uDe.NoOpLogger(),
      serviceId: e?.serviceId ?? 'STS',
      urlParser: e?.urlParser ?? lDe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? MW.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? MW.toUtf8,
    })
  lE.getRuntimeConfig = pDe
})
var BW = l((pE) => {
  'use strict'
  Object.defineProperty(pE, '__esModule', { value: !0 })
  pE.getRuntimeConfig = void 0
  var _De = (x(), w(I)),
    fDe = _De.__importDefault(r2()),
    hDe = Ix(),
    gDe = AP(),
    yDe = vl(),
    mE = Bn(),
    EDe = Cl(),
    UW = Ir(),
    Ll = vr(),
    FW = ua(),
    SDe = Tl(),
    bDe = Qt(),
    vDe = LW(),
    CDe = v(),
    TDe = wl(),
    wDe = v(),
    IDe = (e) => {
      ;(0, wDe.emitWarningIfUnsupportedVersion)(process.version)
      let t = (0, TDe.resolveDefaultsModeConfig)(e),
        n = () => t().then(CDe.loadConfigsForDefaultMode),
        r = (0, vDe.getRuntimeConfig)(e)
      return {
        ...r,
        ...e,
        runtime: 'node',
        defaultsMode: t,
        bodyLengthChecker: e?.bodyLengthChecker ?? SDe.calculateBodyLength,
        credentialDefaultProvider:
          e?.credentialDefaultProvider ??
          (0, hDe.decorateDefaultCredentialProvider)(gDe.defaultProvider),
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, yDe.defaultUserAgent)({
            serviceId: r.serviceId,
            clientVersion: fDe.default.version,
          }),
        maxAttempts:
          e?.maxAttempts ??
          (0, Ll.loadConfig)(UW.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          e?.region ??
          (0, Ll.loadConfig)(
            mE.NODE_REGION_CONFIG_OPTIONS,
            mE.NODE_REGION_CONFIG_FILE_OPTIONS,
          ),
        requestHandler: e?.requestHandler ?? new FW.NodeHttpHandler(n),
        retryMode:
          e?.retryMode ??
          (0, Ll.loadConfig)({
            ...UW.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () =>
              (await n()).retryMode || bDe.DEFAULT_RETRY_MODE,
          }),
        sha256: e?.sha256 ?? EDe.Hash.bind(null, 'sha256'),
        streamCollector: e?.streamCollector ?? FW.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, Ll.loadConfig)(mE.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, Ll.loadConfig)(mE.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    }
  pE.getRuntimeConfig = IDe
})
var zW = l((_E) => {
  'use strict'
  Object.defineProperty(_E, '__esModule', { value: !0 })
  _E.resolveRuntimeExtensions = void 0
  var jW = xl(),
    GW = Oe(),
    $W = v(),
    qP = (e) => e,
    xDe = (e, t) => {
      let n = {
        ...qP((0, jW.getAwsRegionExtensionConfiguration)(e)),
        ...qP((0, $W.getDefaultExtensionConfiguration)(e)),
        ...qP((0, GW.getHttpHandlerExtensionConfiguration)(e)),
      }
      return (
        t.forEach((r) => r.configure(n)),
        {
          ...e,
          ...(0, jW.resolveAwsRegionExtensionConfiguration)(n),
          ...(0, $W.resolveDefaultRuntimeConfig)(n),
          ...(0, GW.resolveHttpHandlerRuntimeConfig)(n),
        }
      )
    }
  _E.resolveRuntimeExtensions = xDe
})
var fE = l((Ka) => {
  'use strict'
  Object.defineProperty(Ka, '__esModule', { value: !0 })
  Ka.STSClient = Ka.__Client = void 0
  var HW = Ou(),
    PDe = Nu(),
    RDe = qu(),
    DDe = t2(),
    VW = Yu(),
    ADe = Bn(),
    ODe = Xu(),
    NDe = q(),
    YW = Ir(),
    WW = v()
  Object.defineProperty(Ka, '__Client', {
    enumerable: !0,
    get: function () {
      return WW.Client
    },
  })
  var qDe = n2(),
    kDe = BW(),
    MDe = zW(),
    kP = class e extends WW.Client {
      constructor(...[t]) {
        let n = (0, kDe.getRuntimeConfig)(t || {}),
          r = (0, qDe.resolveClientEndpointParameters)(n),
          s = (0, ADe.resolveRegionConfig)(r),
          o = (0, NDe.resolveEndpointConfig)(s),
          i = (0, YW.resolveRetryConfig)(o),
          a = (0, HW.resolveHostHeaderConfig)(i),
          c = (0, DDe.resolveStsAuthConfig)(a, { stsClientCtor: e }),
          u = (0, VW.resolveUserAgentConfig)(c),
          d = (0, MDe.resolveRuntimeExtensions)(u, t?.extensions || [])
        super(d),
          (this.config = d),
          this.middlewareStack.use((0, YW.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, ODe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, HW.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, PDe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, RDe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, VW.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  Ka.STSClient = kP
})
var LP = l((Xa) => {
  'use strict'
  Object.defineProperty(Xa, '__esModule', { value: !0 })
  Xa.AssumeRoleWithSAMLCommand = Xa.$Command = void 0
  var LDe = q(),
    UDe = k(),
    JW = v()
  Object.defineProperty(Xa, '$Command', {
    enumerable: !0,
    get: function () {
      return JW.Command
    },
  })
  var FDe = D(),
    KW = Ts(),
    XW = Or(),
    MP = class e extends JW.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, UDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, LDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'AssumeRoleWithSAMLCommand',
            inputFilterSensitiveLog:
              KW.AssumeRoleWithSAMLRequestFilterSensitiveLog,
            outputFilterSensitiveLog:
              KW.AssumeRoleWithSAMLResponseFilterSensitiveLog,
            [FDe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'AssumeRoleWithSAML',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, XW.se_AssumeRoleWithSAMLCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, XW.de_AssumeRoleWithSAMLCommand)(t, n)
      }
    }
  Xa.AssumeRoleWithSAMLCommand = MP
})
var FP = l((Ja) => {
  'use strict'
  Object.defineProperty(Ja, '__esModule', { value: !0 })
  Ja.DecodeAuthorizationMessageCommand = Ja.$Command = void 0
  var BDe = Sr(),
    jDe = q(),
    GDe = k(),
    ZW = v()
  Object.defineProperty(Ja, '$Command', {
    enumerable: !0,
    get: function () {
      return ZW.Command
    },
  })
  var $De = D(),
    QW = Or(),
    UP = class e extends ZW.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, GDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, jDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, BDe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'DecodeAuthorizationMessageCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [$De.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'DecodeAuthorizationMessage',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, QW.se_DecodeAuthorizationMessageCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, QW.de_DecodeAuthorizationMessageCommand)(t, n)
      }
    }
  Ja.DecodeAuthorizationMessageCommand = UP
})
var jP = l((Qa) => {
  'use strict'
  Object.defineProperty(Qa, '__esModule', { value: !0 })
  Qa.GetAccessKeyInfoCommand = Qa.$Command = void 0
  var zDe = Sr(),
    HDe = q(),
    VDe = k(),
    t6 = v()
  Object.defineProperty(Qa, '$Command', {
    enumerable: !0,
    get: function () {
      return t6.Command
    },
  })
  var YDe = D(),
    e6 = Or(),
    BP = class e extends t6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, VDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, HDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, zDe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetAccessKeyInfoCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [YDe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'GetAccessKeyInfo',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, e6.se_GetAccessKeyInfoCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, e6.de_GetAccessKeyInfoCommand)(t, n)
      }
    }
  Qa.GetAccessKeyInfoCommand = BP
})
var $P = l((Za) => {
  'use strict'
  Object.defineProperty(Za, '__esModule', { value: !0 })
  Za.GetCallerIdentityCommand = Za.$Command = void 0
  var WDe = Sr(),
    KDe = q(),
    XDe = k(),
    r6 = v()
  Object.defineProperty(Za, '$Command', {
    enumerable: !0,
    get: function () {
      return r6.Command
    },
  })
  var JDe = D(),
    n6 = Or(),
    GP = class e extends r6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, XDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, KDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, WDe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetCallerIdentityCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [JDe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'GetCallerIdentity',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, n6.se_GetCallerIdentityCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, n6.de_GetCallerIdentityCommand)(t, n)
      }
    }
  Za.GetCallerIdentityCommand = GP
})
var HP = l((ec) => {
  'use strict'
  Object.defineProperty(ec, '__esModule', { value: !0 })
  ec.GetFederationTokenCommand = ec.$Command = void 0
  var QDe = Sr(),
    ZDe = q(),
    eAe = k(),
    o6 = v()
  Object.defineProperty(ec, '$Command', {
    enumerable: !0,
    get: function () {
      return o6.Command
    },
  })
  var tAe = D(),
    nAe = Ts(),
    s6 = Or(),
    zP = class e extends o6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, eAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, ZDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, QDe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetFederationTokenCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog:
              nAe.GetFederationTokenResponseFilterSensitiveLog,
            [tAe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'GetFederationToken',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, s6.se_GetFederationTokenCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, s6.de_GetFederationTokenCommand)(t, n)
      }
    }
  ec.GetFederationTokenCommand = zP
})
var YP = l((tc) => {
  'use strict'
  Object.defineProperty(tc, '__esModule', { value: !0 })
  tc.GetSessionTokenCommand = tc.$Command = void 0
  var rAe = Sr(),
    sAe = q(),
    oAe = k(),
    a6 = v()
  Object.defineProperty(tc, '$Command', {
    enumerable: !0,
    get: function () {
      return a6.Command
    },
  })
  var iAe = D(),
    aAe = Ts(),
    i6 = Or(),
    VP = class e extends a6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, oAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, sAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, rAe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetSessionTokenCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog:
              aAe.GetSessionTokenResponseFilterSensitiveLog,
            [iAe.SMITHY_CONTEXT_KEY]: {
              service: 'AWSSecurityTokenServiceV20110615',
              operation: 'GetSessionToken',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, i6.se_GetSessionTokenCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, i6.de_GetSessionTokenCommand)(t, n)
      }
    }
  tc.GetSessionTokenCommand = VP
})
var c6 = l((gE) => {
  'use strict'
  Object.defineProperty(gE, '__esModule', { value: !0 })
  gE.STS = void 0
  var cAe = v(),
    dAe = Mg(),
    uAe = LP(),
    lAe = Lg(),
    mAe = FP(),
    pAe = jP(),
    _Ae = $P(),
    fAe = HP(),
    hAe = YP(),
    gAe = fE(),
    yAe = {
      AssumeRoleCommand: dAe.AssumeRoleCommand,
      AssumeRoleWithSAMLCommand: uAe.AssumeRoleWithSAMLCommand,
      AssumeRoleWithWebIdentityCommand: lAe.AssumeRoleWithWebIdentityCommand,
      DecodeAuthorizationMessageCommand: mAe.DecodeAuthorizationMessageCommand,
      GetAccessKeyInfoCommand: pAe.GetAccessKeyInfoCommand,
      GetCallerIdentityCommand: _Ae.GetCallerIdentityCommand,
      GetFederationTokenCommand: fAe.GetFederationTokenCommand,
      GetSessionTokenCommand: hAe.GetSessionTokenCommand,
    },
    hE = class extends gAe.STSClient {}
  gE.STS = hE
  ;(0, cAe.createAggregatedClient)(yAe, hE)
})
var d6 = l((tr) => {
  'use strict'
  Object.defineProperty(tr, '__esModule', { value: !0 })
  var Ms = (x(), w(I))
  Ms.__exportStar(Mg(), tr)
  Ms.__exportStar(LP(), tr)
  Ms.__exportStar(Lg(), tr)
  Ms.__exportStar(FP(), tr)
  Ms.__exportStar(jP(), tr)
  Ms.__exportStar($P(), tr)
  Ms.__exportStar(HP(), tr)
  Ms.__exportStar(YP(), tr)
})
var u6 = l((WP) => {
  'use strict'
  Object.defineProperty(WP, '__esModule', { value: !0 })
  var EAe = (x(), w(I))
  EAe.__exportStar(Ts(), WP)
})
var _6 = l((nr) => {
  'use strict'
  Object.defineProperty(nr, '__esModule', { value: !0 })
  nr.decorateDefaultCredentialProvider =
    nr.getDefaultRoleAssumerWithWebIdentity =
    nr.getDefaultRoleAssumer =
      void 0
  var l6 = Ix(),
    m6 = fE(),
    p6 = (e, t) =>
      t
        ? class extends e {
            constructor(r) {
              super(r)
              for (let s of t) this.middlewareStack.use(s)
            }
          }
        : e,
    SAe = (e = {}, t) => (0, l6.getDefaultRoleAssumer)(e, p6(m6.STSClient, t))
  nr.getDefaultRoleAssumer = SAe
  var bAe = (e = {}, t) =>
    (0, l6.getDefaultRoleAssumerWithWebIdentity)(e, p6(m6.STSClient, t))
  nr.getDefaultRoleAssumerWithWebIdentity = bAe
  var vAe = (e) => (t) =>
    e({
      roleAssumer: (0, nr.getDefaultRoleAssumer)(t),
      roleAssumerWithWebIdentity: (0, nr.getDefaultRoleAssumerWithWebIdentity)(
        t,
      ),
      ...t,
    })
  nr.decorateDefaultCredentialProvider = vAe
})
var f6 = l((Mr) => {
  'use strict'
  Object.defineProperty(Mr, '__esModule', { value: !0 })
  Mr.STSServiceException = void 0
  var Ul = (x(), w(I))
  Ul.__exportStar(fE(), Mr)
  Ul.__exportStar(c6(), Mr)
  Ul.__exportStar(d6(), Mr)
  Ul.__exportStar(u6(), Mr)
  Ul.__exportStar(_6(), Mr)
  var CAe = Ag()
  Object.defineProperty(Mr, 'STSServiceException', {
    enumerable: !0,
    get: function () {
      return CAe.STSServiceException
    },
  })
})
var O6 = l((yE) => {
  'use strict'
  Object.defineProperty(yE, '__esModule', { value: !0 })
  yE.ruleSet = void 0
  var x6 = 'required',
    qt = 'fn',
    kt = 'argv',
    rc = 'ref',
    h6 = !0,
    g6 = 'isSet',
    Fl = 'booleanEquals',
    nc = 'error',
    Jo = 'endpoint',
    Lr = 'tree',
    KP = 'PartitionResult',
    XP = 'getAttr',
    y6 = 'stringEquals',
    E6 = { [x6]: !1, type: 'String' },
    S6 = { [x6]: !0, default: !1, type: 'Boolean' },
    b6 = { [rc]: 'Endpoint' },
    P6 = { [qt]: Fl, [kt]: [{ [rc]: 'UseFIPS' }, !0] },
    R6 = { [qt]: Fl, [kt]: [{ [rc]: 'UseDualStack' }, !0] },
    Nt = {},
    D6 = { [rc]: 'Region' },
    v6 = { [qt]: XP, [kt]: [{ [rc]: KP }, 'supportsFIPS'] },
    A6 = { [rc]: KP },
    C6 = {
      [qt]: Fl,
      [kt]: [!0, { [qt]: XP, [kt]: [A6, 'supportsDualStack'] }],
    },
    T6 = [P6],
    w6 = [R6],
    I6 = [D6],
    TAe = {
      version: '1.0',
      parameters: { Region: E6, UseDualStack: S6, UseFIPS: S6, Endpoint: E6 },
      rules: [
        {
          conditions: [{ [qt]: g6, [kt]: [b6] }],
          rules: [
            {
              conditions: T6,
              error:
                'Invalid Configuration: FIPS and custom endpoint are not supported',
              type: nc,
            },
            {
              conditions: w6,
              error:
                'Invalid Configuration: Dualstack and custom endpoint are not supported',
              type: nc,
            },
            { endpoint: { url: b6, properties: Nt, headers: Nt }, type: Jo },
          ],
          type: Lr,
        },
        {
          conditions: [{ [qt]: g6, [kt]: I6 }],
          rules: [
            {
              conditions: [{ [qt]: 'aws.partition', [kt]: I6, assign: KP }],
              rules: [
                {
                  conditions: [P6, R6],
                  rules: [
                    {
                      conditions: [{ [qt]: Fl, [kt]: [h6, v6] }, C6],
                      rules: [
                        {
                          endpoint: {
                            url: 'https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: Nt,
                            headers: Nt,
                          },
                          type: Jo,
                        },
                      ],
                      type: Lr,
                    },
                    {
                      error:
                        'FIPS and DualStack are enabled, but this partition does not support one or both',
                      type: nc,
                    },
                  ],
                  type: Lr,
                },
                {
                  conditions: T6,
                  rules: [
                    {
                      conditions: [{ [qt]: Fl, [kt]: [v6, h6] }],
                      rules: [
                        {
                          conditions: [
                            {
                              [qt]: y6,
                              [kt]: [
                                { [qt]: XP, [kt]: [A6, 'name'] },
                                'aws-us-gov',
                              ],
                            },
                          ],
                          endpoint: {
                            url: 'https://dynamodb.{Region}.amazonaws.com',
                            properties: Nt,
                            headers: Nt,
                          },
                          type: Jo,
                        },
                        {
                          endpoint: {
                            url: 'https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}',
                            properties: Nt,
                            headers: Nt,
                          },
                          type: Jo,
                        },
                      ],
                      type: Lr,
                    },
                    {
                      error:
                        'FIPS is enabled but this partition does not support FIPS',
                      type: nc,
                    },
                  ],
                  type: Lr,
                },
                {
                  conditions: w6,
                  rules: [
                    {
                      conditions: [C6],
                      rules: [
                        {
                          endpoint: {
                            url: 'https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}',
                            properties: Nt,
                            headers: Nt,
                          },
                          type: Jo,
                        },
                      ],
                      type: Lr,
                    },
                    {
                      error:
                        'DualStack is enabled but this partition does not support DualStack',
                      type: nc,
                    },
                  ],
                  type: Lr,
                },
                {
                  conditions: [{ [qt]: y6, [kt]: [D6, 'local'] }],
                  endpoint: {
                    url: 'http://localhost:8000',
                    properties: {
                      authSchemes: [
                        {
                          name: 'sigv4',
                          signingName: 'dynamodb',
                          signingRegion: 'us-east-1',
                        },
                      ],
                    },
                    headers: Nt,
                  },
                  type: Jo,
                },
                {
                  endpoint: {
                    url: 'https://dynamodb.{Region}.{PartitionResult#dnsSuffix}',
                    properties: Nt,
                    headers: Nt,
                  },
                  type: Jo,
                },
              ],
              type: Lr,
            },
          ],
          type: Lr,
        },
        { error: 'Invalid Configuration: Missing Region', type: nc },
      ],
    }
  yE.ruleSet = TAe
})
var N6 = l((EE) => {
  'use strict'
  Object.defineProperty(EE, '__esModule', { value: !0 })
  EE.defaultEndpointResolver = void 0
  var wAe = ea(),
    IAe = O6(),
    xAe = (e, t = {}) =>
      (0, wAe.resolveEndpoint)(IAe.ruleSet, {
        endpointParams: e,
        logger: t.logger,
      })
  EE.defaultEndpointResolver = xAe
})
var M6 = l((SE) => {
  'use strict'
  Object.defineProperty(SE, '__esModule', { value: !0 })
  SE.getRuntimeConfig = void 0
  var PAe = v(),
    RAe = Mo(),
    q6 = aa(),
    k6 = Ln(),
    DAe = N6(),
    AAe = (e) => ({
      apiVersion: '2012-08-10',
      base64Decoder: e?.base64Decoder ?? q6.fromBase64,
      base64Encoder: e?.base64Encoder ?? q6.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? DAe.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      logger: e?.logger ?? new PAe.NoOpLogger(),
      serviceId: e?.serviceId ?? 'DynamoDB',
      urlParser: e?.urlParser ?? RAe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? k6.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? k6.toUtf8,
    })
  SE.getRuntimeConfig = AAe
})
var F6 = l((vE) => {
  'use strict'
  Object.defineProperty(vE, '__esModule', { value: !0 })
  vE.getRuntimeConfig = void 0
  var OAe = (x(), w(I)),
    NAe = OAe.__importDefault(e2()),
    qAe = f6(),
    kAe = AP(),
    MAe = L0(),
    LAe = vl(),
    bE = Bn(),
    UAe = Cl(),
    L6 = Ir(),
    sc = vr(),
    U6 = ua(),
    FAe = Tl(),
    BAe = Qt(),
    jAe = M6(),
    GAe = v(),
    $Ae = wl(),
    zAe = v(),
    HAe = (e) => {
      ;(0, zAe.emitWarningIfUnsupportedVersion)(process.version)
      let t = (0, $Ae.resolveDefaultsModeConfig)(e),
        n = () => t().then(GAe.loadConfigsForDefaultMode),
        r = (0, jAe.getRuntimeConfig)(e)
      return {
        ...r,
        ...e,
        runtime: 'node',
        defaultsMode: t,
        bodyLengthChecker: e?.bodyLengthChecker ?? FAe.calculateBodyLength,
        credentialDefaultProvider:
          e?.credentialDefaultProvider ??
          (0, qAe.decorateDefaultCredentialProvider)(kAe.defaultProvider),
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, LAe.defaultUserAgent)({
            serviceId: r.serviceId,
            clientVersion: NAe.default.version,
          }),
        endpointDiscoveryEnabledProvider:
          e?.endpointDiscoveryEnabledProvider ??
          (0, sc.loadConfig)(MAe.NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS),
        maxAttempts:
          e?.maxAttempts ??
          (0, sc.loadConfig)(L6.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          e?.region ??
          (0, sc.loadConfig)(
            bE.NODE_REGION_CONFIG_OPTIONS,
            bE.NODE_REGION_CONFIG_FILE_OPTIONS,
          ),
        requestHandler: e?.requestHandler ?? new U6.NodeHttpHandler(n),
        retryMode:
          e?.retryMode ??
          (0, sc.loadConfig)({
            ...L6.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () =>
              (await n()).retryMode || BAe.DEFAULT_RETRY_MODE,
          }),
        sha256: e?.sha256 ?? UAe.Hash.bind(null, 'sha256'),
        streamCollector: e?.streamCollector ?? U6.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, sc.loadConfig)(bE.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, sc.loadConfig)(bE.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    }
  vE.getRuntimeConfig = HAe
})
var $6 = l((CE) => {
  'use strict'
  Object.defineProperty(CE, '__esModule', { value: !0 })
  CE.resolveRuntimeExtensions = void 0
  var B6 = xl(),
    j6 = Oe(),
    G6 = v(),
    JP = (e) => e,
    VAe = (e, t) => {
      let n = {
        ...JP((0, B6.getAwsRegionExtensionConfiguration)(e)),
        ...JP((0, G6.getDefaultExtensionConfiguration)(e)),
        ...JP((0, j6.getHttpHandlerExtensionConfiguration)(e)),
      }
      return (
        t.forEach((r) => r.configure(n)),
        {
          ...e,
          ...(0, B6.resolveAwsRegionExtensionConfiguration)(n),
          ...(0, G6.resolveDefaultRuntimeConfig)(n),
          ...(0, j6.resolveHttpHandlerRuntimeConfig)(n),
        }
      )
    }
  CE.resolveRuntimeExtensions = VAe
})
var Ur = l((oc) => {
  'use strict'
  Object.defineProperty(oc, '__esModule', { value: !0 })
  oc.DynamoDBClient = oc.__Client = void 0
  var YAe = L0(),
    z6 = Ou(),
    WAe = Nu(),
    KAe = qu(),
    H6 = Sr(),
    V6 = Yu(),
    XAe = Bn(),
    JAe = Xu(),
    QAe = q(),
    Y6 = Ir(),
    W6 = v()
  Object.defineProperty(oc, '__Client', {
    enumerable: !0,
    get: function () {
      return W6.Client
    },
  })
  var ZAe = xg(),
    eOe = ZH(),
    tOe = F6(),
    nOe = $6(),
    QP = class extends W6.Client {
      constructor(...[t]) {
        let n = (0, tOe.getRuntimeConfig)(t || {}),
          r = (0, eOe.resolveClientEndpointParameters)(n),
          s = (0, XAe.resolveRegionConfig)(r),
          o = (0, QAe.resolveEndpointConfig)(s),
          i = (0, Y6.resolveRetryConfig)(o),
          a = (0, z6.resolveHostHeaderConfig)(i),
          c = (0, H6.resolveAwsAuthConfig)(a),
          u = (0, V6.resolveUserAgentConfig)(c),
          d = (0, YAe.resolveEndpointDiscoveryConfig)(u, {
            endpointDiscoveryCommandCtor: ZAe.DescribeEndpointsCommand,
          }),
          p = (0, nOe.resolveRuntimeExtensions)(d, t?.extensions || [])
        super(p),
          (this.config = p),
          this.middlewareStack.use((0, Y6.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, JAe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, z6.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, WAe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, KAe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, H6.getAwsAuthPlugin)(this.config)),
          this.middlewareStack.use((0, V6.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  oc.DynamoDBClient = QP
})
var eR = l((ic) => {
  'use strict'
  Object.defineProperty(ic, '__esModule', { value: !0 })
  ic.BatchExecuteStatementCommand = ic.$Command = void 0
  var rOe = q(),
    sOe = k(),
    X6 = v()
  Object.defineProperty(ic, '$Command', {
    enumerable: !0,
    get: function () {
      return X6.Command
    },
  })
  var oOe = D(),
    K6 = F(),
    ZP = class e extends X6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, sOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, rOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'BatchExecuteStatementCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [oOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'BatchExecuteStatement',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, K6.se_BatchExecuteStatementCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, K6.de_BatchExecuteStatementCommand)(t, n)
      }
    }
  ic.BatchExecuteStatementCommand = ZP
})
var nR = l((ac) => {
  'use strict'
  Object.defineProperty(ac, '__esModule', { value: !0 })
  ac.BatchGetItemCommand = ac.$Command = void 0
  var iOe = q(),
    aOe = k(),
    Q6 = v()
  Object.defineProperty(ac, '$Command', {
    enumerable: !0,
    get: function () {
      return Q6.Command
    },
  })
  var cOe = D(),
    J6 = F(),
    tR = class e extends Q6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, aOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, iOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'BatchGetItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [cOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'BatchGetItem',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, J6.se_BatchGetItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, J6.de_BatchGetItemCommand)(t, n)
      }
    }
  ac.BatchGetItemCommand = tR
})
var sR = l((cc) => {
  'use strict'
  Object.defineProperty(cc, '__esModule', { value: !0 })
  cc.BatchWriteItemCommand = cc.$Command = void 0
  var dOe = q(),
    uOe = k(),
    e8 = v()
  Object.defineProperty(cc, '$Command', {
    enumerable: !0,
    get: function () {
      return e8.Command
    },
  })
  var lOe = D(),
    Z6 = F(),
    rR = class e extends e8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, uOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, dOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'BatchWriteItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [lOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'BatchWriteItem',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, Z6.se_BatchWriteItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Z6.de_BatchWriteItemCommand)(t, n)
      }
    }
  cc.BatchWriteItemCommand = rR
})
var iR = l((dc) => {
  'use strict'
  Object.defineProperty(dc, '__esModule', { value: !0 })
  dc.CreateBackupCommand = dc.$Command = void 0
  var mOe = q(),
    pOe = k(),
    n8 = v()
  Object.defineProperty(dc, '$Command', {
    enumerable: !0,
    get: function () {
      return n8.Command
    },
  })
  var _Oe = D(),
    t8 = F(),
    oR = class e extends n8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, pOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, mOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'CreateBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [_Oe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'CreateBackup',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, t8.se_CreateBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, t8.de_CreateBackupCommand)(t, n)
      }
    }
  dc.CreateBackupCommand = oR
})
var cR = l((uc) => {
  'use strict'
  Object.defineProperty(uc, '__esModule', { value: !0 })
  uc.CreateGlobalTableCommand = uc.$Command = void 0
  var fOe = q(),
    hOe = k(),
    s8 = v()
  Object.defineProperty(uc, '$Command', {
    enumerable: !0,
    get: function () {
      return s8.Command
    },
  })
  var gOe = D(),
    r8 = F(),
    aR = class e extends s8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, hOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, fOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'CreateGlobalTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [gOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'CreateGlobalTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, r8.se_CreateGlobalTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, r8.de_CreateGlobalTableCommand)(t, n)
      }
    }
  uc.CreateGlobalTableCommand = aR
})
var uR = l((lc) => {
  'use strict'
  Object.defineProperty(lc, '__esModule', { value: !0 })
  lc.CreateTableCommand = lc.$Command = void 0
  var yOe = q(),
    EOe = k(),
    i8 = v()
  Object.defineProperty(lc, '$Command', {
    enumerable: !0,
    get: function () {
      return i8.Command
    },
  })
  var SOe = D(),
    o8 = F(),
    dR = class e extends i8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, EOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, yOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'CreateTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [SOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'CreateTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, o8.se_CreateTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, o8.de_CreateTableCommand)(t, n)
      }
    }
  lc.CreateTableCommand = dR
})
var mR = l((mc) => {
  'use strict'
  Object.defineProperty(mc, '__esModule', { value: !0 })
  mc.DeleteBackupCommand = mc.$Command = void 0
  var bOe = q(),
    vOe = k(),
    c8 = v()
  Object.defineProperty(mc, '$Command', {
    enumerable: !0,
    get: function () {
      return c8.Command
    },
  })
  var COe = D(),
    a8 = F(),
    lR = class e extends c8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, vOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, bOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DeleteBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [COe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DeleteBackup',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, a8.se_DeleteBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, a8.de_DeleteBackupCommand)(t, n)
      }
    }
  mc.DeleteBackupCommand = lR
})
var _R = l((pc) => {
  'use strict'
  Object.defineProperty(pc, '__esModule', { value: !0 })
  pc.DeleteItemCommand = pc.$Command = void 0
  var TOe = q(),
    wOe = k(),
    u8 = v()
  Object.defineProperty(pc, '$Command', {
    enumerable: !0,
    get: function () {
      return u8.Command
    },
  })
  var IOe = D(),
    d8 = F(),
    pR = class e extends u8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, wOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, TOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DeleteItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [IOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DeleteItem',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, d8.se_DeleteItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, d8.de_DeleteItemCommand)(t, n)
      }
    }
  pc.DeleteItemCommand = pR
})
var hR = l((_c) => {
  'use strict'
  Object.defineProperty(_c, '__esModule', { value: !0 })
  _c.DeleteTableCommand = _c.$Command = void 0
  var xOe = q(),
    POe = k(),
    m8 = v()
  Object.defineProperty(_c, '$Command', {
    enumerable: !0,
    get: function () {
      return m8.Command
    },
  })
  var ROe = D(),
    l8 = F(),
    fR = class e extends m8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, POe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, xOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DeleteTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [ROe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DeleteTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, l8.se_DeleteTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, l8.de_DeleteTableCommand)(t, n)
      }
    }
  _c.DeleteTableCommand = fR
})
var yR = l((fc) => {
  'use strict'
  Object.defineProperty(fc, '__esModule', { value: !0 })
  fc.DescribeBackupCommand = fc.$Command = void 0
  var DOe = q(),
    AOe = k(),
    _8 = v()
  Object.defineProperty(fc, '$Command', {
    enumerable: !0,
    get: function () {
      return _8.Command
    },
  })
  var OOe = D(),
    p8 = F(),
    gR = class e extends _8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, AOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, DOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [OOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeBackup',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, p8.se_DescribeBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, p8.de_DescribeBackupCommand)(t, n)
      }
    }
  fc.DescribeBackupCommand = gR
})
var SR = l((hc) => {
  'use strict'
  Object.defineProperty(hc, '__esModule', { value: !0 })
  hc.DescribeContinuousBackupsCommand = hc.$Command = void 0
  var NOe = q(),
    qOe = k(),
    h8 = v()
  Object.defineProperty(hc, '$Command', {
    enumerable: !0,
    get: function () {
      return h8.Command
    },
  })
  var kOe = D(),
    f8 = F(),
    ER = class e extends h8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, qOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, NOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeContinuousBackupsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [kOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeContinuousBackups',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, f8.se_DescribeContinuousBackupsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, f8.de_DescribeContinuousBackupsCommand)(t, n)
      }
    }
  hc.DescribeContinuousBackupsCommand = ER
})
var vR = l((gc) => {
  'use strict'
  Object.defineProperty(gc, '__esModule', { value: !0 })
  gc.DescribeContributorInsightsCommand = gc.$Command = void 0
  var MOe = q(),
    LOe = k(),
    y8 = v()
  Object.defineProperty(gc, '$Command', {
    enumerable: !0,
    get: function () {
      return y8.Command
    },
  })
  var UOe = D(),
    g8 = F(),
    bR = class e extends y8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, LOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, MOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeContributorInsightsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [UOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeContributorInsights',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, g8.se_DescribeContributorInsightsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, g8.de_DescribeContributorInsightsCommand)(t, n)
      }
    }
  gc.DescribeContributorInsightsCommand = bR
})
var TR = l((yc) => {
  'use strict'
  Object.defineProperty(yc, '__esModule', { value: !0 })
  yc.DescribeExportCommand = yc.$Command = void 0
  var FOe = q(),
    BOe = k(),
    S8 = v()
  Object.defineProperty(yc, '$Command', {
    enumerable: !0,
    get: function () {
      return S8.Command
    },
  })
  var jOe = D(),
    E8 = F(),
    CR = class e extends S8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, BOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, FOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeExportCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [jOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeExport',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, E8.se_DescribeExportCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, E8.de_DescribeExportCommand)(t, n)
      }
    }
  yc.DescribeExportCommand = CR
})
var IR = l((Ec) => {
  'use strict'
  Object.defineProperty(Ec, '__esModule', { value: !0 })
  Ec.DescribeGlobalTableCommand = Ec.$Command = void 0
  var GOe = q(),
    $Oe = k(),
    v8 = v()
  Object.defineProperty(Ec, '$Command', {
    enumerable: !0,
    get: function () {
      return v8.Command
    },
  })
  var zOe = D(),
    b8 = F(),
    wR = class e extends v8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, $Oe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, GOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeGlobalTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [zOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeGlobalTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, b8.se_DescribeGlobalTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, b8.de_DescribeGlobalTableCommand)(t, n)
      }
    }
  Ec.DescribeGlobalTableCommand = wR
})
var PR = l((Sc) => {
  'use strict'
  Object.defineProperty(Sc, '__esModule', { value: !0 })
  Sc.DescribeGlobalTableSettingsCommand = Sc.$Command = void 0
  var HOe = q(),
    VOe = k(),
    T8 = v()
  Object.defineProperty(Sc, '$Command', {
    enumerable: !0,
    get: function () {
      return T8.Command
    },
  })
  var YOe = D(),
    C8 = F(),
    xR = class e extends T8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, VOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, HOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeGlobalTableSettingsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [YOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeGlobalTableSettings',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, C8.se_DescribeGlobalTableSettingsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, C8.de_DescribeGlobalTableSettingsCommand)(t, n)
      }
    }
  Sc.DescribeGlobalTableSettingsCommand = xR
})
var DR = l((bc) => {
  'use strict'
  Object.defineProperty(bc, '__esModule', { value: !0 })
  bc.DescribeImportCommand = bc.$Command = void 0
  var WOe = q(),
    KOe = k(),
    I8 = v()
  Object.defineProperty(bc, '$Command', {
    enumerable: !0,
    get: function () {
      return I8.Command
    },
  })
  var XOe = D(),
    w8 = F(),
    RR = class e extends I8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, KOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, WOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeImportCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [XOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeImport',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, w8.se_DescribeImportCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, w8.de_DescribeImportCommand)(t, n)
      }
    }
  bc.DescribeImportCommand = RR
})
var OR = l((vc) => {
  'use strict'
  Object.defineProperty(vc, '__esModule', { value: !0 })
  vc.DescribeKinesisStreamingDestinationCommand = vc.$Command = void 0
  var JOe = q(),
    QOe = k(),
    P8 = v()
  Object.defineProperty(vc, '$Command', {
    enumerable: !0,
    get: function () {
      return P8.Command
    },
  })
  var ZOe = D(),
    x8 = F(),
    AR = class e extends P8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, QOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, JOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeKinesisStreamingDestinationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [ZOe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeKinesisStreamingDestination',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, x8.se_DescribeKinesisStreamingDestinationCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, x8.de_DescribeKinesisStreamingDestinationCommand)(t, n)
      }
    }
  vc.DescribeKinesisStreamingDestinationCommand = AR
})
var qR = l((Cc) => {
  'use strict'
  Object.defineProperty(Cc, '__esModule', { value: !0 })
  Cc.DescribeLimitsCommand = Cc.$Command = void 0
  var eNe = q(),
    tNe = k(),
    D8 = v()
  Object.defineProperty(Cc, '$Command', {
    enumerable: !0,
    get: function () {
      return D8.Command
    },
  })
  var nNe = D(),
    R8 = F(),
    NR = class e extends D8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, tNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, eNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeLimitsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [nNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeLimits',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, R8.se_DescribeLimitsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, R8.de_DescribeLimitsCommand)(t, n)
      }
    }
  Cc.DescribeLimitsCommand = NR
})
var Bl = l((Tc) => {
  'use strict'
  Object.defineProperty(Tc, '__esModule', { value: !0 })
  Tc.DescribeTableCommand = Tc.$Command = void 0
  var rNe = q(),
    sNe = k(),
    O8 = v()
  Object.defineProperty(Tc, '$Command', {
    enumerable: !0,
    get: function () {
      return O8.Command
    },
  })
  var oNe = D(),
    A8 = F(),
    kR = class e extends O8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, sNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, rNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [oNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, A8.se_DescribeTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, A8.de_DescribeTableCommand)(t, n)
      }
    }
  Tc.DescribeTableCommand = kR
})
var LR = l((wc) => {
  'use strict'
  Object.defineProperty(wc, '__esModule', { value: !0 })
  wc.DescribeTableReplicaAutoScalingCommand = wc.$Command = void 0
  var iNe = q(),
    aNe = k(),
    q8 = v()
  Object.defineProperty(wc, '$Command', {
    enumerable: !0,
    get: function () {
      return q8.Command
    },
  })
  var cNe = D(),
    N8 = F(),
    MR = class e extends q8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, aNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, iNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeTableReplicaAutoScalingCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [cNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeTableReplicaAutoScaling',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, N8.se_DescribeTableReplicaAutoScalingCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, N8.de_DescribeTableReplicaAutoScalingCommand)(t, n)
      }
    }
  wc.DescribeTableReplicaAutoScalingCommand = MR
})
var FR = l((Ic) => {
  'use strict'
  Object.defineProperty(Ic, '__esModule', { value: !0 })
  Ic.DescribeTimeToLiveCommand = Ic.$Command = void 0
  var dNe = q(),
    uNe = k(),
    M8 = v()
  Object.defineProperty(Ic, '$Command', {
    enumerable: !0,
    get: function () {
      return M8.Command
    },
  })
  var lNe = D(),
    k8 = F(),
    UR = class e extends M8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, uNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, dNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeTimeToLiveCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [lNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DescribeTimeToLive',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, k8.se_DescribeTimeToLiveCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, k8.de_DescribeTimeToLiveCommand)(t, n)
      }
    }
  Ic.DescribeTimeToLiveCommand = UR
})
var jR = l((xc) => {
  'use strict'
  Object.defineProperty(xc, '__esModule', { value: !0 })
  xc.DisableKinesisStreamingDestinationCommand = xc.$Command = void 0
  var mNe = q(),
    pNe = k(),
    U8 = v()
  Object.defineProperty(xc, '$Command', {
    enumerable: !0,
    get: function () {
      return U8.Command
    },
  })
  var _Ne = D(),
    L8 = F(),
    BR = class e extends U8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, pNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, mNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DisableKinesisStreamingDestinationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [_Ne.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'DisableKinesisStreamingDestination',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, L8.se_DisableKinesisStreamingDestinationCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, L8.de_DisableKinesisStreamingDestinationCommand)(t, n)
      }
    }
  xc.DisableKinesisStreamingDestinationCommand = BR
})
var $R = l((Pc) => {
  'use strict'
  Object.defineProperty(Pc, '__esModule', { value: !0 })
  Pc.EnableKinesisStreamingDestinationCommand = Pc.$Command = void 0
  var fNe = q(),
    hNe = k(),
    B8 = v()
  Object.defineProperty(Pc, '$Command', {
    enumerable: !0,
    get: function () {
      return B8.Command
    },
  })
  var gNe = D(),
    F8 = F(),
    GR = class e extends B8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, hNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, fNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'EnableKinesisStreamingDestinationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [gNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'EnableKinesisStreamingDestination',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, F8.se_EnableKinesisStreamingDestinationCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, F8.de_EnableKinesisStreamingDestinationCommand)(t, n)
      }
    }
  Pc.EnableKinesisStreamingDestinationCommand = GR
})
var HR = l((Rc) => {
  'use strict'
  Object.defineProperty(Rc, '__esModule', { value: !0 })
  Rc.ExecuteStatementCommand = Rc.$Command = void 0
  var yNe = q(),
    ENe = k(),
    G8 = v()
  Object.defineProperty(Rc, '$Command', {
    enumerable: !0,
    get: function () {
      return G8.Command
    },
  })
  var SNe = D(),
    j8 = F(),
    zR = class e extends G8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ENe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, yNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ExecuteStatementCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [SNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ExecuteStatement',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, j8.se_ExecuteStatementCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, j8.de_ExecuteStatementCommand)(t, n)
      }
    }
  Rc.ExecuteStatementCommand = zR
})
var YR = l((Dc) => {
  'use strict'
  Object.defineProperty(Dc, '__esModule', { value: !0 })
  Dc.ExecuteTransactionCommand = Dc.$Command = void 0
  var bNe = q(),
    vNe = k(),
    z8 = v()
  Object.defineProperty(Dc, '$Command', {
    enumerable: !0,
    get: function () {
      return z8.Command
    },
  })
  var CNe = D(),
    $8 = F(),
    VR = class e extends z8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, vNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, bNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ExecuteTransactionCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [CNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ExecuteTransaction',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, $8.se_ExecuteTransactionCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, $8.de_ExecuteTransactionCommand)(t, n)
      }
    }
  Dc.ExecuteTransactionCommand = VR
})
var KR = l((Ac) => {
  'use strict'
  Object.defineProperty(Ac, '__esModule', { value: !0 })
  Ac.ExportTableToPointInTimeCommand = Ac.$Command = void 0
  var TNe = q(),
    wNe = k(),
    V8 = v()
  Object.defineProperty(Ac, '$Command', {
    enumerable: !0,
    get: function () {
      return V8.Command
    },
  })
  var INe = D(),
    H8 = F(),
    WR = class e extends V8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, wNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, TNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ExportTableToPointInTimeCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [INe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ExportTableToPointInTime',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, H8.se_ExportTableToPointInTimeCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, H8.de_ExportTableToPointInTimeCommand)(t, n)
      }
    }
  Ac.ExportTableToPointInTimeCommand = WR
})
var JR = l((Oc) => {
  'use strict'
  Object.defineProperty(Oc, '__esModule', { value: !0 })
  Oc.GetItemCommand = Oc.$Command = void 0
  var xNe = q(),
    PNe = k(),
    W8 = v()
  Object.defineProperty(Oc, '$Command', {
    enumerable: !0,
    get: function () {
      return W8.Command
    },
  })
  var RNe = D(),
    Y8 = F(),
    XR = class e extends W8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, PNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, xNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'GetItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [RNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'GetItem',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, Y8.se_GetItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Y8.de_GetItemCommand)(t, n)
      }
    }
  Oc.GetItemCommand = XR
})
var ZR = l((Nc) => {
  'use strict'
  Object.defineProperty(Nc, '__esModule', { value: !0 })
  Nc.ImportTableCommand = Nc.$Command = void 0
  var DNe = q(),
    ANe = k(),
    X8 = v()
  Object.defineProperty(Nc, '$Command', {
    enumerable: !0,
    get: function () {
      return X8.Command
    },
  })
  var ONe = D(),
    K8 = F(),
    QR = class e extends X8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ANe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, DNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ImportTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [ONe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ImportTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, K8.se_ImportTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, K8.de_ImportTableCommand)(t, n)
      }
    }
  Nc.ImportTableCommand = QR
})
var tD = l((qc) => {
  'use strict'
  Object.defineProperty(qc, '__esModule', { value: !0 })
  qc.ListBackupsCommand = qc.$Command = void 0
  var NNe = q(),
    qNe = k(),
    Q8 = v()
  Object.defineProperty(qc, '$Command', {
    enumerable: !0,
    get: function () {
      return Q8.Command
    },
  })
  var kNe = D(),
    J8 = F(),
    eD = class e extends Q8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, qNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, NNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListBackupsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [kNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListBackups',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, J8.se_ListBackupsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, J8.de_ListBackupsCommand)(t, n)
      }
    }
  qc.ListBackupsCommand = eD
})
var TE = l((kc) => {
  'use strict'
  Object.defineProperty(kc, '__esModule', { value: !0 })
  kc.ListContributorInsightsCommand = kc.$Command = void 0
  var MNe = q(),
    LNe = k(),
    eK = v()
  Object.defineProperty(kc, '$Command', {
    enumerable: !0,
    get: function () {
      return eK.Command
    },
  })
  var UNe = D(),
    Z8 = F(),
    nD = class e extends eK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, LNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, MNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListContributorInsightsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [UNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListContributorInsights',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, Z8.se_ListContributorInsightsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Z8.de_ListContributorInsightsCommand)(t, n)
      }
    }
  kc.ListContributorInsightsCommand = nD
})
var wE = l((Mc) => {
  'use strict'
  Object.defineProperty(Mc, '__esModule', { value: !0 })
  Mc.ListExportsCommand = Mc.$Command = void 0
  var FNe = q(),
    BNe = k(),
    nK = v()
  Object.defineProperty(Mc, '$Command', {
    enumerable: !0,
    get: function () {
      return nK.Command
    },
  })
  var jNe = D(),
    tK = F(),
    rD = class e extends nK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, BNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, FNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListExportsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [jNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListExports',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, tK.se_ListExportsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, tK.de_ListExportsCommand)(t, n)
      }
    }
  Mc.ListExportsCommand = rD
})
var oD = l((Lc) => {
  'use strict'
  Object.defineProperty(Lc, '__esModule', { value: !0 })
  Lc.ListGlobalTablesCommand = Lc.$Command = void 0
  var GNe = q(),
    $Ne = k(),
    sK = v()
  Object.defineProperty(Lc, '$Command', {
    enumerable: !0,
    get: function () {
      return sK.Command
    },
  })
  var zNe = D(),
    rK = F(),
    sD = class e extends sK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, $Ne.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, GNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListGlobalTablesCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [zNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListGlobalTables',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, rK.se_ListGlobalTablesCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, rK.de_ListGlobalTablesCommand)(t, n)
      }
    }
  Lc.ListGlobalTablesCommand = sD
})
var IE = l((Uc) => {
  'use strict'
  Object.defineProperty(Uc, '__esModule', { value: !0 })
  Uc.ListImportsCommand = Uc.$Command = void 0
  var HNe = q(),
    VNe = k(),
    iK = v()
  Object.defineProperty(Uc, '$Command', {
    enumerable: !0,
    get: function () {
      return iK.Command
    },
  })
  var YNe = D(),
    oK = F(),
    iD = class e extends iK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, VNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, HNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListImportsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [YNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListImports',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, oK.se_ListImportsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, oK.de_ListImportsCommand)(t, n)
      }
    }
  Uc.ListImportsCommand = iD
})
var xE = l((Fc) => {
  'use strict'
  Object.defineProperty(Fc, '__esModule', { value: !0 })
  Fc.ListTablesCommand = Fc.$Command = void 0
  var WNe = q(),
    KNe = k(),
    cK = v()
  Object.defineProperty(Fc, '$Command', {
    enumerable: !0,
    get: function () {
      return cK.Command
    },
  })
  var XNe = D(),
    aK = F(),
    aD = class e extends cK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, KNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, WNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListTablesCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [XNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListTables',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, aK.se_ListTablesCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, aK.de_ListTablesCommand)(t, n)
      }
    }
  Fc.ListTablesCommand = aD
})
var dD = l((Bc) => {
  'use strict'
  Object.defineProperty(Bc, '__esModule', { value: !0 })
  Bc.ListTagsOfResourceCommand = Bc.$Command = void 0
  var JNe = q(),
    QNe = k(),
    uK = v()
  Object.defineProperty(Bc, '$Command', {
    enumerable: !0,
    get: function () {
      return uK.Command
    },
  })
  var ZNe = D(),
    dK = F(),
    cD = class e extends uK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, QNe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, JNe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListTagsOfResourceCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [ZNe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'ListTagsOfResource',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, dK.se_ListTagsOfResourceCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, dK.de_ListTagsOfResourceCommand)(t, n)
      }
    }
  Bc.ListTagsOfResourceCommand = cD
})
var lD = l((jc) => {
  'use strict'
  Object.defineProperty(jc, '__esModule', { value: !0 })
  jc.PutItemCommand = jc.$Command = void 0
  var eqe = q(),
    tqe = k(),
    mK = v()
  Object.defineProperty(jc, '$Command', {
    enumerable: !0,
    get: function () {
      return mK.Command
    },
  })
  var nqe = D(),
    lK = F(),
    uD = class e extends mK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, tqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, eqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'PutItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [nqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'PutItem',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, lK.se_PutItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, lK.de_PutItemCommand)(t, n)
      }
    }
  jc.PutItemCommand = uD
})
var PE = l((Gc) => {
  'use strict'
  Object.defineProperty(Gc, '__esModule', { value: !0 })
  Gc.QueryCommand = Gc.$Command = void 0
  var rqe = q(),
    sqe = k(),
    _K = v()
  Object.defineProperty(Gc, '$Command', {
    enumerable: !0,
    get: function () {
      return _K.Command
    },
  })
  var oqe = D(),
    pK = F(),
    mD = class e extends _K.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, sqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, rqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'QueryCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [oqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'Query',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, pK.se_QueryCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, pK.de_QueryCommand)(t, n)
      }
    }
  Gc.QueryCommand = mD
})
var _D = l(($c) => {
  'use strict'
  Object.defineProperty($c, '__esModule', { value: !0 })
  $c.RestoreTableFromBackupCommand = $c.$Command = void 0
  var iqe = q(),
    aqe = k(),
    hK = v()
  Object.defineProperty($c, '$Command', {
    enumerable: !0,
    get: function () {
      return hK.Command
    },
  })
  var cqe = D(),
    fK = F(),
    pD = class e extends hK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, aqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, iqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'RestoreTableFromBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [cqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'RestoreTableFromBackup',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, fK.se_RestoreTableFromBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, fK.de_RestoreTableFromBackupCommand)(t, n)
      }
    }
  $c.RestoreTableFromBackupCommand = pD
})
var hD = l((zc) => {
  'use strict'
  Object.defineProperty(zc, '__esModule', { value: !0 })
  zc.RestoreTableToPointInTimeCommand = zc.$Command = void 0
  var dqe = q(),
    uqe = k(),
    yK = v()
  Object.defineProperty(zc, '$Command', {
    enumerable: !0,
    get: function () {
      return yK.Command
    },
  })
  var lqe = D(),
    gK = F(),
    fD = class e extends yK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, uqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, dqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'RestoreTableToPointInTimeCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [lqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'RestoreTableToPointInTime',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, gK.se_RestoreTableToPointInTimeCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, gK.de_RestoreTableToPointInTimeCommand)(t, n)
      }
    }
  zc.RestoreTableToPointInTimeCommand = fD
})
var RE = l((Hc) => {
  'use strict'
  Object.defineProperty(Hc, '__esModule', { value: !0 })
  Hc.ScanCommand = Hc.$Command = void 0
  var mqe = q(),
    pqe = k(),
    SK = v()
  Object.defineProperty(Hc, '$Command', {
    enumerable: !0,
    get: function () {
      return SK.Command
    },
  })
  var _qe = D(),
    EK = F(),
    gD = class e extends SK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, pqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, mqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ScanCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [_qe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'Scan',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, EK.se_ScanCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, EK.de_ScanCommand)(t, n)
      }
    }
  Hc.ScanCommand = gD
})
var ED = l((Vc) => {
  'use strict'
  Object.defineProperty(Vc, '__esModule', { value: !0 })
  Vc.TagResourceCommand = Vc.$Command = void 0
  var fqe = q(),
    hqe = k(),
    vK = v()
  Object.defineProperty(Vc, '$Command', {
    enumerable: !0,
    get: function () {
      return vK.Command
    },
  })
  var gqe = D(),
    bK = F(),
    yD = class e extends vK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, hqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, fqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'TagResourceCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [gqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'TagResource',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, bK.se_TagResourceCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, bK.de_TagResourceCommand)(t, n)
      }
    }
  Vc.TagResourceCommand = yD
})
var bD = l((Yc) => {
  'use strict'
  Object.defineProperty(Yc, '__esModule', { value: !0 })
  Yc.TransactGetItemsCommand = Yc.$Command = void 0
  var yqe = q(),
    Eqe = k(),
    TK = v()
  Object.defineProperty(Yc, '$Command', {
    enumerable: !0,
    get: function () {
      return TK.Command
    },
  })
  var Sqe = D(),
    CK = F(),
    SD = class e extends TK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Eqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, yqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'TransactGetItemsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Sqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'TransactGetItems',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, CK.se_TransactGetItemsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, CK.de_TransactGetItemsCommand)(t, n)
      }
    }
  Yc.TransactGetItemsCommand = SD
})
var CD = l((Wc) => {
  'use strict'
  Object.defineProperty(Wc, '__esModule', { value: !0 })
  Wc.TransactWriteItemsCommand = Wc.$Command = void 0
  var bqe = q(),
    vqe = k(),
    IK = v()
  Object.defineProperty(Wc, '$Command', {
    enumerable: !0,
    get: function () {
      return IK.Command
    },
  })
  var Cqe = D(),
    wK = F(),
    vD = class e extends IK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, vqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, bqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'TransactWriteItemsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Cqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'TransactWriteItems',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, wK.se_TransactWriteItemsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, wK.de_TransactWriteItemsCommand)(t, n)
      }
    }
  Wc.TransactWriteItemsCommand = vD
})
var wD = l((Kc) => {
  'use strict'
  Object.defineProperty(Kc, '__esModule', { value: !0 })
  Kc.UntagResourceCommand = Kc.$Command = void 0
  var Tqe = q(),
    wqe = k(),
    PK = v()
  Object.defineProperty(Kc, '$Command', {
    enumerable: !0,
    get: function () {
      return PK.Command
    },
  })
  var Iqe = D(),
    xK = F(),
    TD = class e extends PK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, wqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Tqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UntagResourceCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Iqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UntagResource',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, xK.se_UntagResourceCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, xK.de_UntagResourceCommand)(t, n)
      }
    }
  Kc.UntagResourceCommand = TD
})
var xD = l((Xc) => {
  'use strict'
  Object.defineProperty(Xc, '__esModule', { value: !0 })
  Xc.UpdateContinuousBackupsCommand = Xc.$Command = void 0
  var xqe = q(),
    Pqe = k(),
    DK = v()
  Object.defineProperty(Xc, '$Command', {
    enumerable: !0,
    get: function () {
      return DK.Command
    },
  })
  var Rqe = D(),
    RK = F(),
    ID = class e extends DK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Pqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, xqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateContinuousBackupsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Rqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateContinuousBackups',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, RK.se_UpdateContinuousBackupsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, RK.de_UpdateContinuousBackupsCommand)(t, n)
      }
    }
  Xc.UpdateContinuousBackupsCommand = ID
})
var RD = l((Jc) => {
  'use strict'
  Object.defineProperty(Jc, '__esModule', { value: !0 })
  Jc.UpdateContributorInsightsCommand = Jc.$Command = void 0
  var Dqe = q(),
    Aqe = k(),
    OK = v()
  Object.defineProperty(Jc, '$Command', {
    enumerable: !0,
    get: function () {
      return OK.Command
    },
  })
  var Oqe = D(),
    AK = F(),
    PD = class e extends OK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Aqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Dqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateContributorInsightsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Oqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateContributorInsights',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, AK.se_UpdateContributorInsightsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, AK.de_UpdateContributorInsightsCommand)(t, n)
      }
    }
  Jc.UpdateContributorInsightsCommand = PD
})
var AD = l((Qc) => {
  'use strict'
  Object.defineProperty(Qc, '__esModule', { value: !0 })
  Qc.UpdateGlobalTableCommand = Qc.$Command = void 0
  var Nqe = q(),
    qqe = k(),
    qK = v()
  Object.defineProperty(Qc, '$Command', {
    enumerable: !0,
    get: function () {
      return qK.Command
    },
  })
  var kqe = D(),
    NK = F(),
    DD = class e extends qK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, qqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Nqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateGlobalTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [kqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateGlobalTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, NK.se_UpdateGlobalTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, NK.de_UpdateGlobalTableCommand)(t, n)
      }
    }
  Qc.UpdateGlobalTableCommand = DD
})
var ND = l((Zc) => {
  'use strict'
  Object.defineProperty(Zc, '__esModule', { value: !0 })
  Zc.UpdateGlobalTableSettingsCommand = Zc.$Command = void 0
  var Mqe = q(),
    Lqe = k(),
    MK = v()
  Object.defineProperty(Zc, '$Command', {
    enumerable: !0,
    get: function () {
      return MK.Command
    },
  })
  var Uqe = D(),
    kK = F(),
    OD = class e extends MK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Lqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Mqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateGlobalTableSettingsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Uqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateGlobalTableSettings',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, kK.se_UpdateGlobalTableSettingsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, kK.de_UpdateGlobalTableSettingsCommand)(t, n)
      }
    }
  Zc.UpdateGlobalTableSettingsCommand = OD
})
var kD = l((ed) => {
  'use strict'
  Object.defineProperty(ed, '__esModule', { value: !0 })
  ed.UpdateItemCommand = ed.$Command = void 0
  var Fqe = q(),
    Bqe = k(),
    UK = v()
  Object.defineProperty(ed, '$Command', {
    enumerable: !0,
    get: function () {
      return UK.Command
    },
  })
  var jqe = D(),
    LK = F(),
    qD = class e extends UK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Bqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Fqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [jqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateItem',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, LK.se_UpdateItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, LK.de_UpdateItemCommand)(t, n)
      }
    }
  ed.UpdateItemCommand = qD
})
var LD = l((td) => {
  'use strict'
  Object.defineProperty(td, '__esModule', { value: !0 })
  td.UpdateTableCommand = td.$Command = void 0
  var Gqe = q(),
    $qe = k(),
    BK = v()
  Object.defineProperty(td, '$Command', {
    enumerable: !0,
    get: function () {
      return BK.Command
    },
  })
  var zqe = D(),
    FK = F(),
    MD = class e extends BK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, $qe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Gqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [zqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateTable',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, FK.se_UpdateTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, FK.de_UpdateTableCommand)(t, n)
      }
    }
  td.UpdateTableCommand = MD
})
var FD = l((nd) => {
  'use strict'
  Object.defineProperty(nd, '__esModule', { value: !0 })
  nd.UpdateTableReplicaAutoScalingCommand = nd.$Command = void 0
  var Hqe = q(),
    Vqe = k(),
    GK = v()
  Object.defineProperty(nd, '$Command', {
    enumerable: !0,
    get: function () {
      return GK.Command
    },
  })
  var Yqe = D(),
    jK = F(),
    UD = class e extends GK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Vqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Hqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateTableReplicaAutoScalingCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Yqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateTableReplicaAutoScaling',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, jK.se_UpdateTableReplicaAutoScalingCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, jK.de_UpdateTableReplicaAutoScalingCommand)(t, n)
      }
    }
  nd.UpdateTableReplicaAutoScalingCommand = UD
})
var jD = l((rd) => {
  'use strict'
  Object.defineProperty(rd, '__esModule', { value: !0 })
  rd.UpdateTimeToLiveCommand = rd.$Command = void 0
  var Wqe = q(),
    Kqe = k(),
    zK = v()
  Object.defineProperty(rd, '$Command', {
    enumerable: !0,
    get: function () {
      return zK.Command
    },
  })
  var Xqe = D(),
    $K = F(),
    BD = class e extends zK.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Kqe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Wqe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          c = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateTimeToLiveCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
            [Xqe.SMITHY_CONTEXT_KEY]: {
              service: 'DynamoDB_20120810',
              operation: 'UpdateTimeToLive',
            },
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), c)
      }
      serialize(t, n) {
        return (0, $K.se_UpdateTimeToLiveCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, $K.de_UpdateTimeToLiveCommand)(t, n)
      }
    }
  rd.UpdateTimeToLiveCommand = BD
})
var HK = l((AE) => {
  'use strict'
  Object.defineProperty(AE, '__esModule', { value: !0 })
  AE.DynamoDB = void 0
  var Jqe = v(),
    Qqe = eR(),
    Zqe = nR(),
    e1e = sR(),
    t1e = iR(),
    n1e = cR(),
    r1e = uR(),
    s1e = mR(),
    o1e = _R(),
    i1e = hR(),
    a1e = yR(),
    c1e = SR(),
    d1e = vR(),
    u1e = xg(),
    l1e = TR(),
    m1e = IR(),
    p1e = PR(),
    _1e = DR(),
    f1e = OR(),
    h1e = qR(),
    g1e = Bl(),
    y1e = LR(),
    E1e = FR(),
    S1e = jR(),
    b1e = $R(),
    v1e = HR(),
    C1e = YR(),
    T1e = KR(),
    w1e = JR(),
    I1e = ZR(),
    x1e = tD(),
    P1e = TE(),
    R1e = wE(),
    D1e = oD(),
    A1e = IE(),
    O1e = xE(),
    N1e = dD(),
    q1e = lD(),
    k1e = PE(),
    M1e = _D(),
    L1e = hD(),
    U1e = RE(),
    F1e = ED(),
    B1e = bD(),
    j1e = CD(),
    G1e = wD(),
    $1e = xD(),
    z1e = RD(),
    H1e = AD(),
    V1e = ND(),
    Y1e = kD(),
    W1e = LD(),
    K1e = FD(),
    X1e = jD(),
    J1e = Ur(),
    Q1e = {
      BatchExecuteStatementCommand: Qqe.BatchExecuteStatementCommand,
      BatchGetItemCommand: Zqe.BatchGetItemCommand,
      BatchWriteItemCommand: e1e.BatchWriteItemCommand,
      CreateBackupCommand: t1e.CreateBackupCommand,
      CreateGlobalTableCommand: n1e.CreateGlobalTableCommand,
      CreateTableCommand: r1e.CreateTableCommand,
      DeleteBackupCommand: s1e.DeleteBackupCommand,
      DeleteItemCommand: o1e.DeleteItemCommand,
      DeleteTableCommand: i1e.DeleteTableCommand,
      DescribeBackupCommand: a1e.DescribeBackupCommand,
      DescribeContinuousBackupsCommand: c1e.DescribeContinuousBackupsCommand,
      DescribeContributorInsightsCommand:
        d1e.DescribeContributorInsightsCommand,
      DescribeEndpointsCommand: u1e.DescribeEndpointsCommand,
      DescribeExportCommand: l1e.DescribeExportCommand,
      DescribeGlobalTableCommand: m1e.DescribeGlobalTableCommand,
      DescribeGlobalTableSettingsCommand:
        p1e.DescribeGlobalTableSettingsCommand,
      DescribeImportCommand: _1e.DescribeImportCommand,
      DescribeKinesisStreamingDestinationCommand:
        f1e.DescribeKinesisStreamingDestinationCommand,
      DescribeLimitsCommand: h1e.DescribeLimitsCommand,
      DescribeTableCommand: g1e.DescribeTableCommand,
      DescribeTableReplicaAutoScalingCommand:
        y1e.DescribeTableReplicaAutoScalingCommand,
      DescribeTimeToLiveCommand: E1e.DescribeTimeToLiveCommand,
      DisableKinesisStreamingDestinationCommand:
        S1e.DisableKinesisStreamingDestinationCommand,
      EnableKinesisStreamingDestinationCommand:
        b1e.EnableKinesisStreamingDestinationCommand,
      ExecuteStatementCommand: v1e.ExecuteStatementCommand,
      ExecuteTransactionCommand: C1e.ExecuteTransactionCommand,
      ExportTableToPointInTimeCommand: T1e.ExportTableToPointInTimeCommand,
      GetItemCommand: w1e.GetItemCommand,
      ImportTableCommand: I1e.ImportTableCommand,
      ListBackupsCommand: x1e.ListBackupsCommand,
      ListContributorInsightsCommand: P1e.ListContributorInsightsCommand,
      ListExportsCommand: R1e.ListExportsCommand,
      ListGlobalTablesCommand: D1e.ListGlobalTablesCommand,
      ListImportsCommand: A1e.ListImportsCommand,
      ListTablesCommand: O1e.ListTablesCommand,
      ListTagsOfResourceCommand: N1e.ListTagsOfResourceCommand,
      PutItemCommand: q1e.PutItemCommand,
      QueryCommand: k1e.QueryCommand,
      RestoreTableFromBackupCommand: M1e.RestoreTableFromBackupCommand,
      RestoreTableToPointInTimeCommand: L1e.RestoreTableToPointInTimeCommand,
      ScanCommand: U1e.ScanCommand,
      TagResourceCommand: F1e.TagResourceCommand,
      TransactGetItemsCommand: B1e.TransactGetItemsCommand,
      TransactWriteItemsCommand: j1e.TransactWriteItemsCommand,
      UntagResourceCommand: G1e.UntagResourceCommand,
      UpdateContinuousBackupsCommand: $1e.UpdateContinuousBackupsCommand,
      UpdateContributorInsightsCommand: z1e.UpdateContributorInsightsCommand,
      UpdateGlobalTableCommand: H1e.UpdateGlobalTableCommand,
      UpdateGlobalTableSettingsCommand: V1e.UpdateGlobalTableSettingsCommand,
      UpdateItemCommand: Y1e.UpdateItemCommand,
      UpdateTableCommand: W1e.UpdateTableCommand,
      UpdateTableReplicaAutoScalingCommand:
        K1e.UpdateTableReplicaAutoScalingCommand,
      UpdateTimeToLiveCommand: X1e.UpdateTimeToLiveCommand,
    },
    DE = class extends J1e.DynamoDBClient {}
  AE.DynamoDB = DE
  ;(0, Jqe.createAggregatedClient)(Q1e, DE)
})
var VK = l((U) => {
  'use strict'
  Object.defineProperty(U, '__esModule', { value: !0 })
  var H = (x(), w(I))
  H.__exportStar(eR(), U)
  H.__exportStar(nR(), U)
  H.__exportStar(sR(), U)
  H.__exportStar(iR(), U)
  H.__exportStar(cR(), U)
  H.__exportStar(uR(), U)
  H.__exportStar(mR(), U)
  H.__exportStar(_R(), U)
  H.__exportStar(hR(), U)
  H.__exportStar(yR(), U)
  H.__exportStar(SR(), U)
  H.__exportStar(vR(), U)
  H.__exportStar(xg(), U)
  H.__exportStar(TR(), U)
  H.__exportStar(IR(), U)
  H.__exportStar(PR(), U)
  H.__exportStar(DR(), U)
  H.__exportStar(OR(), U)
  H.__exportStar(qR(), U)
  H.__exportStar(Bl(), U)
  H.__exportStar(LR(), U)
  H.__exportStar(FR(), U)
  H.__exportStar(jR(), U)
  H.__exportStar($R(), U)
  H.__exportStar(HR(), U)
  H.__exportStar(YR(), U)
  H.__exportStar(KR(), U)
  H.__exportStar(JR(), U)
  H.__exportStar(ZR(), U)
  H.__exportStar(tD(), U)
  H.__exportStar(TE(), U)
  H.__exportStar(wE(), U)
  H.__exportStar(oD(), U)
  H.__exportStar(IE(), U)
  H.__exportStar(xE(), U)
  H.__exportStar(dD(), U)
  H.__exportStar(lD(), U)
  H.__exportStar(PE(), U)
  H.__exportStar(_D(), U)
  H.__exportStar(hD(), U)
  H.__exportStar(RE(), U)
  H.__exportStar(ED(), U)
  H.__exportStar(bD(), U)
  H.__exportStar(CD(), U)
  H.__exportStar(wD(), U)
  H.__exportStar(xD(), U)
  H.__exportStar(RD(), U)
  H.__exportStar(AD(), U)
  H.__exportStar(ND(), U)
  H.__exportStar(kD(), U)
  H.__exportStar(LD(), U)
  H.__exportStar(FD(), U)
  H.__exportStar(jD(), U)
})
var WK = l((YK) => {
  'use strict'
  Object.defineProperty(YK, '__esModule', { value: !0 })
})
var KK = l((OE) => {
  'use strict'
  Object.defineProperty(OE, '__esModule', { value: !0 })
  OE.paginateListContributorInsights = void 0
  var Z1e = TE(),
    eke = Ur(),
    tke = async (e, t, ...n) =>
      await e.send(new Z1e.ListContributorInsightsCommand(t), ...n)
  async function* nke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.NextToken = r),
        (t.MaxResults = e.pageSize),
        e.client instanceof eke.DynamoDBClient)
      )
        o = await tke(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.NextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  OE.paginateListContributorInsights = nke
})
var XK = l((NE) => {
  'use strict'
  Object.defineProperty(NE, '__esModule', { value: !0 })
  NE.paginateListExports = void 0
  var rke = wE(),
    ske = Ur(),
    oke = async (e, t, ...n) =>
      await e.send(new rke.ListExportsCommand(t), ...n)
  async function* ike(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.NextToken = r),
        (t.MaxResults = e.pageSize),
        e.client instanceof ske.DynamoDBClient)
      )
        o = await oke(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.NextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  NE.paginateListExports = ike
})
var JK = l((qE) => {
  'use strict'
  Object.defineProperty(qE, '__esModule', { value: !0 })
  qE.paginateListImports = void 0
  var ake = IE(),
    cke = Ur(),
    dke = async (e, t, ...n) =>
      await e.send(new ake.ListImportsCommand(t), ...n)
  async function* uke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.NextToken = r),
        (t.PageSize = e.pageSize),
        e.client instanceof cke.DynamoDBClient)
      )
        o = await dke(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.NextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  qE.paginateListImports = uke
})
var QK = l((kE) => {
  'use strict'
  Object.defineProperty(kE, '__esModule', { value: !0 })
  kE.paginateListTables = void 0
  var lke = xE(),
    mke = Ur(),
    pke = async (e, t, ...n) => await e.send(new lke.ListTablesCommand(t), ...n)
  async function* _ke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartTableName = r),
        (t.Limit = e.pageSize),
        e.client instanceof mke.DynamoDBClient)
      )
        o = await pke(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.LastEvaluatedTableName),
        (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  kE.paginateListTables = _ke
})
var ZK = l((ME) => {
  'use strict'
  Object.defineProperty(ME, '__esModule', { value: !0 })
  ME.paginateQuery = void 0
  var fke = PE(),
    hke = Ur(),
    gke = async (e, t, ...n) => await e.send(new fke.QueryCommand(t), ...n)
  async function* yke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof hke.DynamoDBClient)
      )
        o = await gke(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.LastEvaluatedKey), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  ME.paginateQuery = yke
})
var e4 = l((LE) => {
  'use strict'
  Object.defineProperty(LE, '__esModule', { value: !0 })
  LE.paginateScan = void 0
  var Eke = RE(),
    Ske = Ur(),
    bke = async (e, t, ...n) => await e.send(new Eke.ScanCommand(t), ...n)
  async function* vke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof Ske.DynamoDBClient)
      )
        o = await bke(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.LastEvaluatedKey), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  LE.paginateScan = vke
})
var t4 = l((Fr) => {
  'use strict'
  Object.defineProperty(Fr, '__esModule', { value: !0 })
  var Qo = (x(), w(I))
  Qo.__exportStar(WK(), Fr)
  Qo.__exportStar(KK(), Fr)
  Qo.__exportStar(XK(), Fr)
  Qo.__exportStar(JK(), Fr)
  Qo.__exportStar(QK(), Fr)
  Qo.__exportStar(ZK(), Fr)
  Qo.__exportStar(e4(), Fr)
})
var GD = l((UE) => {
  'use strict'
  Object.defineProperty(UE, '__esModule', { value: !0 })
  UE.sleep = void 0
  var Cke = (e) => new Promise((t) => setTimeout(t, e * 1e3))
  UE.sleep = Cke
})
var BE = l((Br) => {
  'use strict'
  Object.defineProperty(Br, '__esModule', { value: !0 })
  Br.checkExceptions = Br.WaiterState = Br.waiterServiceDefaults = void 0
  Br.waiterServiceDefaults = { minDelay: 2, maxDelay: 120 }
  var FE
  ;(function (e) {
    ;(e.ABORTED = 'ABORTED'),
      (e.FAILURE = 'FAILURE'),
      (e.SUCCESS = 'SUCCESS'),
      (e.RETRY = 'RETRY'),
      (e.TIMEOUT = 'TIMEOUT')
  })((FE = Br.WaiterState || (Br.WaiterState = {})))
  var Tke = (e) => {
    if (e.state === FE.ABORTED) {
      let t = new Error(
        `${JSON.stringify({ ...e, reason: 'Request was aborted' })}`,
      )
      throw ((t.name = 'AbortError'), t)
    } else if (e.state === FE.TIMEOUT) {
      let t = new Error(
        `${JSON.stringify({ ...e, reason: 'Waiter has timed out' })}`,
      )
      throw ((t.name = 'TimeoutError'), t)
    } else if (e.state !== FE.SUCCESS)
      throw new Error(`${JSON.stringify({ result: e })}`)
    return e
  }
  Br.checkExceptions = Tke
})
var n4 = l((GE) => {
  'use strict'
  Object.defineProperty(GE, '__esModule', { value: !0 })
  GE.runPolling = void 0
  var wke = GD(),
    jE = BE(),
    Ike = (e, t, n, r) => {
      if (r > n) return t
      let s = e * 2 ** (r - 1)
      return xke(e, s)
    },
    xke = (e, t) => e + Math.random() * (t - e),
    Pke = async (
      {
        minDelay: e,
        maxDelay: t,
        maxWaitTime: n,
        abortController: r,
        client: s,
        abortSignal: o,
      },
      i,
      a,
    ) => {
      var c
      let { state: u, reason: d } = await a(s, i)
      if (u !== jE.WaiterState.RETRY) return { state: u, reason: d }
      let p = 1,
        _ = Date.now() + n * 1e3,
        f = Math.log(t / e) / Math.log(2) + 1
      for (;;) {
        if (
          (!((c = r?.signal) === null || c === void 0) && c.aborted) ||
          o?.aborted
        )
          return { state: jE.WaiterState.ABORTED }
        let h = Ike(e, t, f, p)
        if (Date.now() + h * 1e3 > _) return { state: jE.WaiterState.TIMEOUT }
        await (0, wke.sleep)(h)
        let { state: y, reason: E } = await a(s, i)
        if (y !== jE.WaiterState.RETRY) return { state: y, reason: E }
        p += 1
      }
    }
  GE.runPolling = Pke
})
var r4 = l(($E) => {
  'use strict'
  Object.defineProperty($E, '__esModule', { value: !0 })
  $E.validateWaiterOptions = void 0
  var Rke = (e) => {
    if (e.maxWaitTime < 1)
      throw new Error('WaiterConfiguration.maxWaitTime must be greater than 0')
    if (e.minDelay < 1)
      throw new Error('WaiterConfiguration.minDelay must be greater than 0')
    if (e.maxDelay < 1)
      throw new Error('WaiterConfiguration.maxDelay must be greater than 0')
    if (e.maxWaitTime <= e.minDelay)
      throw new Error(
        `WaiterConfiguration.maxWaitTime [${e.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
      )
    if (e.maxDelay < e.minDelay)
      throw new Error(
        `WaiterConfiguration.maxDelay [${e.maxDelay}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
      )
  }
  $E.validateWaiterOptions = Rke
})
var o4 = l((zE) => {
  'use strict'
  Object.defineProperty(zE, '__esModule', { value: !0 })
  var s4 = (x(), w(I))
  s4.__exportStar(GD(), zE)
  s4.__exportStar(r4(), zE)
})
var c4 = l((HE) => {
  'use strict'
  Object.defineProperty(HE, '__esModule', { value: !0 })
  HE.createWaiter = void 0
  var Dke = n4(),
    Ake = o4(),
    a4 = BE(),
    i4 = async (e) =>
      new Promise((t) => {
        e.onabort = () => t({ state: a4.WaiterState.ABORTED })
      }),
    Oke = async (e, t, n) => {
      let r = { ...a4.waiterServiceDefaults, ...e }
      ;(0, Ake.validateWaiterOptions)(r)
      let s = [(0, Dke.runPolling)(r, t, n)]
      return (
        e.abortController && s.push(i4(e.abortController.signal)),
        e.abortSignal && s.push(i4(e.abortSignal)),
        Promise.race(s)
      )
    }
  HE.createWaiter = Oke
})
var $D = l((VE) => {
  'use strict'
  Object.defineProperty(VE, '__esModule', { value: !0 })
  var d4 = (x(), w(I))
  d4.__exportStar(c4(), VE)
  d4.__exportStar(BE(), VE)
})
var l4 = l((od) => {
  'use strict'
  Object.defineProperty(od, '__esModule', { value: !0 })
  od.waitUntilTableExists = od.waitForTableExists = void 0
  var sd = $D(),
    Nke = Bl(),
    u4 = async (e, t) => {
      let n
      try {
        let r = await e.send(new Nke.DescribeTableCommand(t))
        n = r
        try {
          if ((() => r.Table.TableStatus)() === 'ACTIVE')
            return { state: sd.WaiterState.SUCCESS, reason: n }
        } catch {}
      } catch (r) {
        if (((n = r), r.name && r.name == 'ResourceNotFoundException'))
          return { state: sd.WaiterState.RETRY, reason: n }
      }
      return { state: sd.WaiterState.RETRY, reason: n }
    },
    qke = async (e, t) => {
      let n = { minDelay: 20, maxDelay: 120 }
      return (0, sd.createWaiter)({ ...n, ...e }, t, u4)
    }
  od.waitForTableExists = qke
  var kke = async (e, t) => {
    let n = { minDelay: 20, maxDelay: 120 },
      r = await (0, sd.createWaiter)({ ...n, ...e }, t, u4)
    return (0, sd.checkExceptions)(r)
  }
  od.waitUntilTableExists = kke
})
var p4 = l((id) => {
  'use strict'
  Object.defineProperty(id, '__esModule', { value: !0 })
  id.waitUntilTableNotExists = id.waitForTableNotExists = void 0
  var jl = $D(),
    Mke = Bl(),
    m4 = async (e, t) => {
      let n
      try {
        n = await e.send(new Mke.DescribeTableCommand(t))
      } catch (r) {
        if (((n = r), r.name && r.name == 'ResourceNotFoundException'))
          return { state: jl.WaiterState.SUCCESS, reason: n }
      }
      return { state: jl.WaiterState.RETRY, reason: n }
    },
    Lke = async (e, t) => {
      let n = { minDelay: 20, maxDelay: 120 }
      return (0, jl.createWaiter)({ ...n, ...e }, t, m4)
    }
  id.waitForTableNotExists = Lke
  var Uke = async (e, t) => {
    let n = { minDelay: 20, maxDelay: 120 },
      r = await (0, jl.createWaiter)({ ...n, ...e }, t, m4)
    return (0, jl.checkExceptions)(r)
  }
  id.waitUntilTableNotExists = Uke
})
var f4 = l((YE) => {
  'use strict'
  Object.defineProperty(YE, '__esModule', { value: !0 })
  var _4 = (x(), w(I))
  _4.__exportStar(l4(), YE)
  _4.__exportStar(p4(), YE)
})
var h4 = l((zD) => {
  'use strict'
  Object.defineProperty(zD, '__esModule', { value: !0 })
  var Fke = (x(), w(I))
  Fke.__exportStar(VI(), zD)
})
var dt = l((rr) => {
  'use strict'
  Object.defineProperty(rr, '__esModule', { value: !0 })
  rr.DynamoDBServiceException = void 0
  var ad = (x(), w(I))
  ad.__exportStar(Ur(), rr)
  ad.__exportStar(HK(), rr)
  ad.__exportStar(VK(), rr)
  ad.__exportStar(t4(), rr)
  ad.__exportStar(f4(), rr)
  ad.__exportStar(h4(), rr)
  var Bke = Sg()
  Object.defineProperty(rr, 'DynamoDBServiceException', {
    enumerable: !0,
    get: function () {
      return Bke.DynamoDBServiceException
    },
  })
})
var HD = l((Zo) => {
  'use strict'
  Object.defineProperty(Zo, '__esModule', { value: !0 })
  Zo.convertToAttr = void 0
  var jke = (e, t) => {
    var n, r, s, o, i, a
    if (e === void 0)
      throw new Error(
        'Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.',
      )
    if (e === null && typeof e == 'object') return WE()
    if (Array.isArray(e)) return Gke(e, t)
    if (
      ((n = e?.constructor) === null || n === void 0 ? void 0 : n.name) ===
      'Set'
    )
      return $ke(e, t)
    if (
      ((r = e?.constructor) === null || r === void 0 ? void 0 : r.name) ===
      'Map'
    )
      return zke(e, t)
    if (
      ((s = e?.constructor) === null || s === void 0 ? void 0 : s.name) ===
        'Object' ||
      (!e.constructor && typeof e == 'object')
    )
      return g4(e, t)
    if (C4(e)) return e.length === 0 && t?.convertEmptyValues ? WE() : E4(e)
    if (
      typeof e == 'boolean' ||
      ((o = e?.constructor) === null || o === void 0 ? void 0 : o.name) ===
        'Boolean'
    )
      return { BOOL: e.valueOf() }
    if (
      typeof e == 'number' ||
      ((i = e?.constructor) === null || i === void 0 ? void 0 : i.name) ===
        'Number'
    )
      return v4(e)
    if (typeof e == 'bigint') return b4(e)
    if (
      typeof e == 'string' ||
      ((a = e?.constructor) === null || a === void 0 ? void 0 : a.name) ===
        'String'
    )
      return e.length === 0 && t?.convertEmptyValues ? WE() : S4(e)
    if (t?.convertClassInstanceToMap && typeof e == 'object') return g4(e, t)
    throw new Error(
      `Unsupported type passed: ${e}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`,
    )
  }
  Zo.convertToAttr = jke
  var Gke = (e, t) => ({
      L: e
        .filter(
          (n) =>
            !t?.removeUndefinedValues ||
            (t?.removeUndefinedValues && n !== void 0),
        )
        .map((n) => (0, Zo.convertToAttr)(n, t)),
    }),
    $ke = (e, t) => {
      let n = t?.removeUndefinedValues
        ? new Set([...e].filter((s) => s !== void 0))
        : e
      if (!t?.removeUndefinedValues && n.has(void 0))
        throw new Error(
          'Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.',
        )
      if (n.size === 0) {
        if (t?.convertEmptyValues) return WE()
        throw new Error(
          'Pass a non-empty set, or options.convertEmptyValues=true.',
        )
      }
      let r = n.values().next().value
      if (typeof r == 'number')
        return {
          NS: Array.from(n)
            .map(v4)
            .map((s) => s.N),
        }
      if (typeof r == 'bigint')
        return {
          NS: Array.from(n)
            .map(b4)
            .map((s) => s.N),
        }
      if (typeof r == 'string')
        return {
          SS: Array.from(n)
            .map(S4)
            .map((s) => s.S),
        }
      if (C4(r))
        return {
          BS: Array.from(n)
            .map(E4)
            .map((s) => s.B),
        }
      throw new Error(
        'Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.',
      )
    },
    zke = (e, t) => ({
      M: ((n) => {
        let r = {}
        for (let [s, o] of n)
          typeof o != 'function' &&
            (o !== void 0 || !t?.removeUndefinedValues) &&
            (r[s] = (0, Zo.convertToAttr)(o, t))
        return r
      })(e),
    }),
    g4 = (e, t) => ({
      M: ((n) => {
        let r = {}
        for (let s in n) {
          let o = n[s]
          typeof o != 'function' &&
            (o !== void 0 || !t?.removeUndefinedValues) &&
            (r[s] = (0, Zo.convertToAttr)(o, t))
        }
        return r
      })(e),
    }),
    WE = () => ({ NULL: !0 }),
    E4 = (e) => ({ B: e }),
    S4 = (e) => ({ S: e.toString() }),
    b4 = (e) => ({ N: e.toString() }),
    y4 = (e) => {
      throw new Error(
        `${e} ${
          typeof BigInt == 'function'
            ? 'Use BigInt.'
            : 'Pass string value instead.'
        } `,
      )
    },
    v4 = (e) => {
      if (
        [Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
          .map((t) => t.toString())
          .includes(e.toString())
      )
        throw new Error(`Special numeric value ${e.toString()} is not allowed`)
      return (
        e > Number.MAX_SAFE_INTEGER
          ? y4(
              `Number ${e.toString()} is greater than Number.MAX_SAFE_INTEGER.`,
            )
          : e < Number.MIN_SAFE_INTEGER &&
            y4(
              `Number ${e.toString()} is lesser than Number.MIN_SAFE_INTEGER.`,
            ),
        { N: e.toString() }
      )
    },
    C4 = (e) => {
      let t = [
        'ArrayBuffer',
        'Blob',
        'Buffer',
        'DataView',
        'File',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Uint16Array',
        'Int32Array',
        'Uint32Array',
        'Float32Array',
        'Float64Array',
        'BigInt64Array',
        'BigUint64Array',
      ]
      return e?.constructor ? t.includes(e.constructor.name) : !1
    }
})
var VD = l((cd) => {
  'use strict'
  Object.defineProperty(cd, '__esModule', { value: !0 })
  cd.convertToNative = void 0
  var Hke = (e, t) => {
    for (let [n, r] of Object.entries(e))
      if (r !== void 0)
        switch (n) {
          case 'NULL':
            return null
          case 'BOOL':
            return !!r
          case 'N':
            return T4(r, t)
          case 'B':
            return I4(r)
          case 'S':
            return w4(r)
          case 'L':
            return Vke(r, t)
          case 'M':
            return Yke(r, t)
          case 'NS':
            return new Set(r.map((s) => T4(s, t)))
          case 'BS':
            return new Set(r.map(I4))
          case 'SS':
            return new Set(r.map(w4))
          default:
            throw new Error(`Unsupported type passed: ${n}`)
        }
    throw new Error(`No value defined: ${JSON.stringify(e)}`)
  }
  cd.convertToNative = Hke
  var T4 = (e, t) => {
      if (t?.wrapNumbers) return { value: e }
      let n = Number(e),
        r = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
      if (
        (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) &&
        !r.includes(n)
      )
        if (typeof BigInt == 'function')
          try {
            return BigInt(e)
          } catch {
            throw new Error(
              `${e} can't be converted to BigInt. Set options.wrapNumbers to get string value.`,
            )
          }
        else
          throw new Error(
            `${e} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`,
          )
      return n
    },
    w4 = (e) => e,
    I4 = (e) => e,
    Vke = (e, t) => e.map((n) => (0, cd.convertToNative)(n, t)),
    Yke = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => ((n[r] = (0, cd.convertToNative)(s, t)), n),
        {},
      )
})
var x4 = l((KE) => {
  'use strict'
  Object.defineProperty(KE, '__esModule', { value: !0 })
  KE.marshall = void 0
  var Wke = HD()
  function Kke(e, t) {
    let n = (0, Wke.convertToAttr)(e, t),
      [r, s] = Object.entries(n)[0]
    switch (r) {
      case 'M':
      case 'L':
        return t?.convertTopLevelContainer ? n : s
      case 'SS':
      case 'NS':
      case 'BS':
      case 'S':
      case 'N':
      case 'B':
      case 'NULL':
      case 'BOOL':
      case '$unknown':
      default:
        return n
    }
  }
  KE.marshall = Kke
})
var R4 = l((P4) => {
  'use strict'
  Object.defineProperty(P4, '__esModule', { value: !0 })
})
var A4 = l((XE) => {
  'use strict'
  Object.defineProperty(XE, '__esModule', { value: !0 })
  XE.unmarshall = void 0
  var D4 = VD(),
    Xke = (e, t) =>
      t?.convertWithoutMapWrapper
        ? (0, D4.convertToNative)(e, t)
        : (0, D4.convertToNative)({ M: e }, t)
  XE.unmarshall = Xke
})
var O4 = l((ei) => {
  'use strict'
  Object.defineProperty(ei, '__esModule', { value: !0 })
  var Gl = (x(), w(I))
  Gl.__exportStar(HD(), ei)
  Gl.__exportStar(VD(), ei)
  Gl.__exportStar(x4(), ei)
  Gl.__exportStar(R4(), ei)
  Gl.__exportStar(A4(), ei)
})
var ut = l((Mt) => {
  'use strict'
  Object.defineProperty(Mt, '__esModule', { value: !0 })
  Mt.unmarshallOutput =
    Mt.marshallInput =
    Mt.ALL_MEMBERS =
    Mt.ALL_VALUES =
    Mt.SELF =
      void 0
  var q4 = O4()
  Mt.SELF = null
  Mt.ALL_VALUES = {}
  Mt.ALL_MEMBERS = []
  var N4 = '*',
    JE = (e, t, n) => {
      if (e !== void 0) {
        if (n == null) return t(e)
        {
          let r = Object.keys(n),
            s = r.length === 1 && r[0] === N4,
            o = r.length >= 1 && !s,
            i = r.length === 0
          if (o) return YD(e, t, n)
          if (i) return Jke(e, t, Mt.SELF)
          if (s)
            return Object.entries(e ?? {}).reduce(
              (a, [c, u]) => ((a[c] = JE(u, t, n[N4])), a),
              Array.isArray(e) ? [] : {},
            )
        }
      }
    },
    YD = (e, t, n) => {
      let r
      Array.isArray(e) ? (r = [...e]) : (r = { ...e })
      for (let [s, o] of Object.entries(n)) {
        let i = JE(e[s], t, o)
        i !== void 0 && (r[s] = i)
      }
      return r
    },
    Jke = (e, t, n) =>
      Array.isArray(e)
        ? e.map((r) => JE(r, t, n))
        : Object.entries(e).reduce((r, [s, o]) => {
            let i = JE(o, t, n)
            return i !== void 0 && (r[s] = i), r
          }, {}),
    Qke = (e, t, n) => YD(e, (s) => (0, q4.marshall)(s, n), t)
  Mt.marshallInput = Qke
  var Zke = (e, t, n) => YD(e, (s) => (0, q4.unmarshall)(s, n), t)
  Mt.unmarshallOutput = Zke
})
var yt = l((ZE) => {
  'use strict'
  Object.defineProperty(ZE, '__esModule', { value: !0 })
  ZE.DynamoDBDocumentClientCommand = void 0
  var eMe = v(),
    k4 = ut(),
    QE = class e extends eMe.Command {
      addMarshallingMiddleware(t) {
        var n, r
        let { marshallOptions: s = {}, unmarshallOptions: o = {} } =
          t.translateConfig || {}
        ;(s.convertTopLevelContainer =
          (n = s.convertTopLevelContainer) !== null && n !== void 0 ? n : !0),
          (o.convertWithoutMapWrapper =
            (r = o.convertWithoutMapWrapper) !== null && r !== void 0 ? r : !0),
          this.clientCommand.middlewareStack.addRelativeTo(
            (i, a) => async (c) => {
              ;(c.input = (0, k4.marshallInput)(
                this.input,
                this.inputKeyNodes,
                s,
              )),
                (a.dynamoDbDocumentClientOptions =
                  a.dynamoDbDocumentClientOptions ||
                  e.defaultLogFilterOverrides)
              let u = c.input
              return (
                (a.dynamoDbDocumentClientOptions.overrideInputFilterSensitiveLog =
                  () => {
                    var d
                    return (d = a.inputFilterSensitiveLog) === null ||
                      d === void 0
                      ? void 0
                      : d.call(a, u)
                  }),
                i(c)
              )
            },
            {
              name: 'DocumentMarshall',
              relation: 'before',
              toMiddleware: 'serializerMiddleware',
              override: !0,
            },
          ),
          this.clientCommand.middlewareStack.addRelativeTo(
            (i, a) => async (c) => {
              let u = await i(c),
                d = u.output
              return (
                (a.dynamoDbDocumentClientOptions =
                  a.dynamoDbDocumentClientOptions ||
                  e.defaultLogFilterOverrides),
                (a.dynamoDbDocumentClientOptions.overrideOutputFilterSensitiveLog =
                  () => {
                    var p
                    return (p = a.outputFilterSensitiveLog) === null ||
                      p === void 0
                      ? void 0
                      : p.call(a, d)
                  }),
                (u.output = (0, k4.unmarshallOutput)(
                  u.output,
                  this.outputKeyNodes,
                  o,
                )),
                u
              )
            },
            {
              name: 'DocumentUnmarshall',
              relation: 'before',
              toMiddleware: 'deserializerMiddleware',
              override: !0,
            },
          )
      }
    }
  ZE.DynamoDBDocumentClientCommand = QE
  QE.defaultLogFilterOverrides = {
    overrideInputFilterSensitiveLog(...e) {},
    overrideOutputFilterSensitiveLog(...e) {},
  }
})
var XD = l((Ls) => {
  'use strict'
  Object.defineProperty(Ls, '__esModule', { value: !0 })
  Ls.BatchExecuteStatementCommand =
    Ls.$Command =
    Ls.DynamoDBDocumentClientCommand =
      void 0
  var tMe = dt(),
    nMe = v()
  Object.defineProperty(Ls, '$Command', {
    enumerable: !0,
    get: function () {
      return nMe.Command
    },
  })
  var M4 = yt()
  Object.defineProperty(Ls, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return M4.DynamoDBDocumentClientCommand
    },
  })
  var WD = ut(),
    KD = class extends M4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            Statements: { '*': { Parameters: WD.ALL_MEMBERS } },
          }),
          (this.outputKeyNodes = {
            Responses: {
              '*': { Error: { Item: WD.ALL_VALUES }, Item: WD.ALL_VALUES },
            },
          }),
          (this.clientCommand = new tMe.BatchExecuteStatementCommand(
            this.input,
          )),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Ls.BatchExecuteStatementCommand = KD
})
var ZD = l((Us) => {
  'use strict'
  Object.defineProperty(Us, '__esModule', { value: !0 })
  Us.BatchGetCommand = Us.$Command = Us.DynamoDBDocumentClientCommand = void 0
  var rMe = dt(),
    sMe = v()
  Object.defineProperty(Us, '$Command', {
    enumerable: !0,
    get: function () {
      return sMe.Command
    },
  })
  var L4 = yt()
  Object.defineProperty(Us, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return L4.DynamoDBDocumentClientCommand
    },
  })
  var JD = ut(),
    QD = class extends L4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            RequestItems: { '*': { Keys: { '*': JD.ALL_VALUES } } },
          }),
          (this.outputKeyNodes = {
            Responses: { '*': { '*': JD.ALL_VALUES } },
            UnprocessedKeys: { '*': { Keys: { '*': JD.ALL_VALUES } } },
          }),
          (this.clientCommand = new rMe.BatchGetItemCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Us.BatchGetCommand = QD
})
var tA = l((Fs) => {
  'use strict'
  Object.defineProperty(Fs, '__esModule', { value: !0 })
  Fs.BatchWriteCommand = Fs.$Command = Fs.DynamoDBDocumentClientCommand = void 0
  var oMe = dt(),
    iMe = v()
  Object.defineProperty(Fs, '$Command', {
    enumerable: !0,
    get: function () {
      return iMe.Command
    },
  })
  var U4 = yt()
  Object.defineProperty(Fs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return U4.DynamoDBDocumentClientCommand
    },
  })
  var $l = ut(),
    eA = class extends U4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            RequestItems: {
              '*': {
                '*': {
                  PutRequest: { Item: $l.ALL_VALUES },
                  DeleteRequest: { Key: $l.ALL_VALUES },
                },
              },
            },
          }),
          (this.outputKeyNodes = {
            UnprocessedItems: {
              '*': {
                '*': {
                  PutRequest: { Item: $l.ALL_VALUES },
                  DeleteRequest: { Key: $l.ALL_VALUES },
                },
              },
            },
            ItemCollectionMetrics: {
              '*': { '*': { ItemCollectionKey: $l.ALL_VALUES } },
            },
          }),
          (this.clientCommand = new oMe.BatchWriteItemCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Fs.BatchWriteCommand = eA
})
var rA = l((Bs) => {
  'use strict'
  Object.defineProperty(Bs, '__esModule', { value: !0 })
  Bs.DeleteCommand = Bs.$Command = Bs.DynamoDBDocumentClientCommand = void 0
  var aMe = dt(),
    cMe = v()
  Object.defineProperty(Bs, '$Command', {
    enumerable: !0,
    get: function () {
      return cMe.Command
    },
  })
  var F4 = yt()
  Object.defineProperty(Bs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return F4.DynamoDBDocumentClientCommand
    },
  })
  var dd = ut(),
    nA = class extends F4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            Key: dd.ALL_VALUES,
            Expected: {
              '*': { Value: dd.SELF, AttributeValueList: dd.ALL_MEMBERS },
            },
            ExpressionAttributeValues: dd.ALL_VALUES,
          }),
          (this.outputKeyNodes = {
            Attributes: dd.ALL_VALUES,
            ItemCollectionMetrics: { ItemCollectionKey: dd.ALL_VALUES },
          }),
          (this.clientCommand = new aMe.DeleteItemCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Bs.DeleteCommand = nA
})
var iA = l((js) => {
  'use strict'
  Object.defineProperty(js, '__esModule', { value: !0 })
  js.ExecuteStatementCommand =
    js.$Command =
    js.DynamoDBDocumentClientCommand =
      void 0
  var dMe = dt(),
    uMe = v()
  Object.defineProperty(js, '$Command', {
    enumerable: !0,
    get: function () {
      return uMe.Command
    },
  })
  var B4 = yt()
  Object.defineProperty(js, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return B4.DynamoDBDocumentClientCommand
    },
  })
  var sA = ut(),
    oA = class extends B4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = { Parameters: sA.ALL_MEMBERS }),
          (this.outputKeyNodes = {
            Items: { '*': sA.ALL_VALUES },
            LastEvaluatedKey: sA.ALL_VALUES,
          }),
          (this.clientCommand = new dMe.ExecuteStatementCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  js.ExecuteStatementCommand = oA
})
var cA = l((Gs) => {
  'use strict'
  Object.defineProperty(Gs, '__esModule', { value: !0 })
  Gs.ExecuteTransactionCommand =
    Gs.$Command =
    Gs.DynamoDBDocumentClientCommand =
      void 0
  var lMe = dt(),
    mMe = v()
  Object.defineProperty(Gs, '$Command', {
    enumerable: !0,
    get: function () {
      return mMe.Command
    },
  })
  var G4 = yt()
  Object.defineProperty(Gs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return G4.DynamoDBDocumentClientCommand
    },
  })
  var j4 = ut(),
    aA = class extends G4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            TransactStatements: { '*': { Parameters: j4.ALL_MEMBERS } },
          }),
          (this.outputKeyNodes = {
            Responses: { '*': { Item: j4.ALL_VALUES } },
          }),
          (this.clientCommand = new lMe.ExecuteTransactionCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Gs.ExecuteTransactionCommand = aA
})
var uA = l(($s) => {
  'use strict'
  Object.defineProperty($s, '__esModule', { value: !0 })
  $s.GetCommand = $s.$Command = $s.DynamoDBDocumentClientCommand = void 0
  var pMe = dt(),
    _Me = v()
  Object.defineProperty($s, '$Command', {
    enumerable: !0,
    get: function () {
      return _Me.Command
    },
  })
  var z4 = yt()
  Object.defineProperty($s, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return z4.DynamoDBDocumentClientCommand
    },
  })
  var $4 = ut(),
    dA = class extends z4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = { Key: $4.ALL_VALUES }),
          (this.outputKeyNodes = { Item: $4.ALL_VALUES }),
          (this.clientCommand = new pMe.GetItemCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  $s.GetCommand = dA
})
var mA = l((zs) => {
  'use strict'
  Object.defineProperty(zs, '__esModule', { value: !0 })
  zs.PutCommand = zs.$Command = zs.DynamoDBDocumentClientCommand = void 0
  var fMe = dt(),
    hMe = v()
  Object.defineProperty(zs, '$Command', {
    enumerable: !0,
    get: function () {
      return hMe.Command
    },
  })
  var H4 = yt()
  Object.defineProperty(zs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return H4.DynamoDBDocumentClientCommand
    },
  })
  var ud = ut(),
    lA = class extends H4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            Item: ud.ALL_VALUES,
            Expected: {
              '*': { Value: ud.SELF, AttributeValueList: ud.ALL_MEMBERS },
            },
            ExpressionAttributeValues: ud.ALL_VALUES,
          }),
          (this.outputKeyNodes = {
            Attributes: ud.ALL_VALUES,
            ItemCollectionMetrics: { ItemCollectionKey: ud.ALL_VALUES },
          }),
          (this.clientCommand = new fMe.PutItemCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  zs.PutCommand = lA
})
var eS = l((Hs) => {
  'use strict'
  Object.defineProperty(Hs, '__esModule', { value: !0 })
  Hs.QueryCommand = Hs.$Command = Hs.DynamoDBDocumentClientCommand = void 0
  var gMe = dt(),
    yMe = v()
  Object.defineProperty(Hs, '$Command', {
    enumerable: !0,
    get: function () {
      return yMe.Command
    },
  })
  var V4 = yt()
  Object.defineProperty(Hs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return V4.DynamoDBDocumentClientCommand
    },
  })
  var ld = ut(),
    pA = class extends V4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            KeyConditions: { '*': { AttributeValueList: ld.ALL_MEMBERS } },
            QueryFilter: { '*': { AttributeValueList: ld.ALL_MEMBERS } },
            ExclusiveStartKey: ld.ALL_VALUES,
            ExpressionAttributeValues: ld.ALL_VALUES,
          }),
          (this.outputKeyNodes = {
            Items: { '*': ld.ALL_VALUES },
            LastEvaluatedKey: ld.ALL_VALUES,
          }),
          (this.clientCommand = new gMe.QueryCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Hs.QueryCommand = pA
})
var tS = l((Vs) => {
  'use strict'
  Object.defineProperty(Vs, '__esModule', { value: !0 })
  Vs.ScanCommand = Vs.$Command = Vs.DynamoDBDocumentClientCommand = void 0
  var EMe = dt(),
    SMe = v()
  Object.defineProperty(Vs, '$Command', {
    enumerable: !0,
    get: function () {
      return SMe.Command
    },
  })
  var Y4 = yt()
  Object.defineProperty(Vs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return Y4.DynamoDBDocumentClientCommand
    },
  })
  var zl = ut(),
    _A = class extends Y4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            ScanFilter: { '*': { AttributeValueList: zl.ALL_MEMBERS } },
            ExclusiveStartKey: zl.ALL_VALUES,
            ExpressionAttributeValues: zl.ALL_VALUES,
          }),
          (this.outputKeyNodes = {
            Items: { '*': zl.ALL_VALUES },
            LastEvaluatedKey: zl.ALL_VALUES,
          }),
          (this.clientCommand = new EMe.ScanCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Vs.ScanCommand = _A
})
var hA = l((Ys) => {
  'use strict'
  Object.defineProperty(Ys, '__esModule', { value: !0 })
  Ys.TransactGetCommand =
    Ys.$Command =
    Ys.DynamoDBDocumentClientCommand =
      void 0
  var bMe = dt(),
    vMe = v()
  Object.defineProperty(Ys, '$Command', {
    enumerable: !0,
    get: function () {
      return vMe.Command
    },
  })
  var K4 = yt()
  Object.defineProperty(Ys, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return K4.DynamoDBDocumentClientCommand
    },
  })
  var W4 = ut(),
    fA = class extends K4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            TransactItems: { '*': { Get: { Key: W4.ALL_VALUES } } },
          }),
          (this.outputKeyNodes = {
            Responses: { '*': { Item: W4.ALL_VALUES } },
          }),
          (this.clientCommand = new bMe.TransactGetItemsCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Ys.TransactGetCommand = fA
})
var yA = l((Ws) => {
  'use strict'
  Object.defineProperty(Ws, '__esModule', { value: !0 })
  Ws.TransactWriteCommand =
    Ws.$Command =
    Ws.DynamoDBDocumentClientCommand =
      void 0
  var CMe = dt(),
    TMe = v()
  Object.defineProperty(Ws, '$Command', {
    enumerable: !0,
    get: function () {
      return TMe.Command
    },
  })
  var X4 = yt()
  Object.defineProperty(Ws, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return X4.DynamoDBDocumentClientCommand
    },
  })
  var jr = ut(),
    gA = class extends X4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            TransactItems: {
              '*': {
                ConditionCheck: {
                  Key: jr.ALL_VALUES,
                  ExpressionAttributeValues: jr.ALL_VALUES,
                },
                Put: {
                  Item: jr.ALL_VALUES,
                  ExpressionAttributeValues: jr.ALL_VALUES,
                },
                Delete: {
                  Key: jr.ALL_VALUES,
                  ExpressionAttributeValues: jr.ALL_VALUES,
                },
                Update: {
                  Key: jr.ALL_VALUES,
                  ExpressionAttributeValues: jr.ALL_VALUES,
                },
              },
            },
          }),
          (this.outputKeyNodes = {
            ItemCollectionMetrics: {
              '*': { '*': { ItemCollectionKey: jr.ALL_VALUES } },
            },
          }),
          (this.clientCommand = new CMe.TransactWriteItemsCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Ws.TransactWriteCommand = gA
})
var SA = l((Ks) => {
  'use strict'
  Object.defineProperty(Ks, '__esModule', { value: !0 })
  Ks.UpdateCommand = Ks.$Command = Ks.DynamoDBDocumentClientCommand = void 0
  var wMe = dt(),
    IMe = v()
  Object.defineProperty(Ks, '$Command', {
    enumerable: !0,
    get: function () {
      return IMe.Command
    },
  })
  var J4 = yt()
  Object.defineProperty(Ks, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return J4.DynamoDBDocumentClientCommand
    },
  })
  var ti = ut(),
    EA = class extends J4.DynamoDBDocumentClientCommand {
      constructor(t) {
        super(),
          (this.input = t),
          (this.inputKeyNodes = {
            Key: ti.ALL_VALUES,
            AttributeUpdates: { '*': { Value: ti.SELF } },
            Expected: {
              '*': { Value: ti.SELF, AttributeValueList: ti.ALL_MEMBERS },
            },
            ExpressionAttributeValues: ti.ALL_VALUES,
          }),
          (this.outputKeyNodes = {
            Attributes: ti.ALL_VALUES,
            ItemCollectionMetrics: { ItemCollectionKey: ti.ALL_VALUES },
          }),
          (this.clientCommand = new wMe.UpdateItemCommand(this.input)),
          (this.middlewareStack = this.clientCommand.middlewareStack)
      }
      resolveMiddleware(t, n, r) {
        this.addMarshallingMiddleware(n)
        let s = t.concat(this.middlewareStack),
          o = this.clientCommand.resolveMiddleware(s, n, r)
        return async () => o(this.clientCommand)
      }
    }
  Ks.UpdateCommand = EA
})
var Hl = l((md) => {
  'use strict'
  Object.defineProperty(md, '__esModule', { value: !0 })
  md.DynamoDBDocumentClient = md.__Client = void 0
  var Q4 = v()
  Object.defineProperty(md, '__Client', {
    enumerable: !0,
    get: function () {
      return Q4.Client
    },
  })
  var bA = class e extends Q4.Client {
    constructor(t, n) {
      super(t.config),
        (this.config = t.config),
        (this.config.translateConfig = n),
        (this.middlewareStack = t.middlewareStack)
    }
    static from(t, n) {
      return new e(t, n)
    }
    destroy() {}
  }
  md.DynamoDBDocumentClient = bA
})
var rS = l((nS) => {
  'use strict'
  Object.defineProperty(nS, '__esModule', { value: !0 })
  nS.DynamoDBDocument = void 0
  var xMe = XD(),
    PMe = ZD(),
    RMe = tA(),
    DMe = rA(),
    AMe = iA(),
    OMe = cA(),
    NMe = uA(),
    qMe = mA(),
    kMe = eS(),
    MMe = tS(),
    LMe = hA(),
    UMe = yA(),
    FMe = SA(),
    BMe = Hl(),
    vA = class e extends BMe.DynamoDBDocumentClient {
      static from(t, n) {
        return new e(t, n)
      }
      batchExecuteStatement(t, n, r) {
        let s = new xMe.BatchExecuteStatementCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      batchGet(t, n, r) {
        let s = new PMe.BatchGetCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      batchWrite(t, n, r) {
        let s = new RMe.BatchWriteCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      delete(t, n, r) {
        let s = new DMe.DeleteCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      executeStatement(t, n, r) {
        let s = new AMe.ExecuteStatementCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      executeTransaction(t, n, r) {
        let s = new OMe.ExecuteTransactionCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      get(t, n, r) {
        let s = new NMe.GetCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      put(t, n, r) {
        let s = new qMe.PutCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      query(t, n, r) {
        let s = new kMe.QueryCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      scan(t, n, r) {
        let s = new MMe.ScanCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      transactGet(t, n, r) {
        let s = new LMe.TransactGetCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      transactWrite(t, n, r) {
        let s = new UMe.TransactWriteCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      update(t, n, r) {
        let s = new FMe.UpdateCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
    }
  nS.DynamoDBDocument = vA
})
var Z4 = l((lt) => {
  'use strict'
  Object.defineProperty(lt, '__esModule', { value: !0 })
  var Lt = (x(), w(I))
  Lt.__exportStar(XD(), lt)
  Lt.__exportStar(ZD(), lt)
  Lt.__exportStar(tA(), lt)
  Lt.__exportStar(rA(), lt)
  Lt.__exportStar(iA(), lt)
  Lt.__exportStar(cA(), lt)
  Lt.__exportStar(uA(), lt)
  Lt.__exportStar(mA(), lt)
  Lt.__exportStar(eS(), lt)
  Lt.__exportStar(tS(), lt)
  Lt.__exportStar(hA(), lt)
  Lt.__exportStar(yA(), lt)
  Lt.__exportStar(SA(), lt)
})
var t5 = l((e5) => {
  'use strict'
  Object.defineProperty(e5, '__esModule', { value: !0 })
})
var n5 = l((sS) => {
  'use strict'
  Object.defineProperty(sS, '__esModule', { value: !0 })
  sS.paginateQuery = void 0
  var jMe = eS(),
    GMe = rS(),
    $Me = Hl(),
    zMe = async (e, t, ...n) => await e.send(new jMe.QueryCommand(t), ...n),
    HMe = async (e, t, ...n) => await e.query(t, ...n)
  async function* VMe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof GMe.DynamoDBDocument)
      )
        o = await HMe(e.client, t, ...n)
      else if (e.client instanceof $Me.DynamoDBDocumentClient)
        o = await zMe(e.client, t, ...n)
      else
        throw new Error(
          'Invalid client, expected DynamoDBDocument | DynamoDBDocumentClient',
        )
      yield o, (r = o.LastEvaluatedKey), (s = !!r)
    }
    return void 0
  }
  sS.paginateQuery = VMe
})
var r5 = l((oS) => {
  'use strict'
  Object.defineProperty(oS, '__esModule', { value: !0 })
  oS.paginateScan = void 0
  var YMe = tS(),
    WMe = rS(),
    KMe = Hl(),
    XMe = async (e, t, ...n) => await e.send(new YMe.ScanCommand(t), ...n),
    JMe = async (e, t, ...n) => await e.scan(t, ...n)
  async function* QMe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof WMe.DynamoDBDocument)
      )
        o = await JMe(e.client, t, ...n)
      else if (e.client instanceof KMe.DynamoDBDocumentClient)
        o = await XMe(e.client, t, ...n)
      else
        throw new Error(
          'Invalid client, expected DynamoDBDocument | DynamoDBDocumentClient',
        )
      yield o, (r = o.LastEvaluatedKey), (s = !!r)
    }
    return void 0
  }
  oS.paginateScan = QMe
})
var s5 = l((Vl) => {
  'use strict'
  Object.defineProperty(Vl, '__esModule', { value: !0 })
  var CA = (x(), w(I))
  CA.__exportStar(t5(), Vl)
  CA.__exportStar(n5(), Vl)
  CA.__exportStar(r5(), Vl)
})
var aS = l((pd) => {
  'use strict'
  Object.defineProperty(pd, '__esModule', { value: !0 })
  var iS = (x(), w(I))
  iS.__exportStar(rS(), pd)
  iS.__exportStar(Hl(), pd)
  iS.__exportStar(Z4(), pd)
  iS.__exportStar(s5(), pd)
})
var rLe = {}
fd(rLe, { handler: () => nLe })
module.exports = w(rLe)
var PA = sn(Gk())
var $k = (e) => {
  let t = process.env[e]
  if (!t) throw new Error(`Missing ${e} environment variable`)
  return t
}
var zk = (e) =>
  e
    .split('&')
    .map((t) => t.split('=').map(decodeURIComponent))
    .reduce((t, [n, r]) => ({ ...t, [n]: r }), {})
var Hk = (e, t) => {
  if (t.includes(e)) return e
}
var Vk = process.env.NODE_ENV === 'test' ? 'test_' : 'pomodoro_',
  Yk = { users: `${Vk}users`, appSumoCodes: `${Vk}app_sumo_codes` }
var Wl = sn(aS())
var TA = (e, t) => e.reduce((n, r, s) => ((n[r] = t[s]), n), {})
var ni = (e) => `#${e.replace('.', '_')}`,
  cS = (e) => `:${e}`,
  Yl = (e) => e.join(', '),
  dS = (e) => ({ ExpressionAttributeNames: TA(e.map(ni), e) }),
  wA = (e) => {
    let t = Object.keys(e)
    return {
      ...dS(t),
      ExpressionAttributeValues: TA(t.map(cS), Object.values(e)),
    }
  }
var o5 = sn(dt()),
  i5 = sn(aS()),
  ZMe = new o5.DynamoDBClient(),
  IA = i5.DynamoDBDocumentClient.from(ZMe, {
    marshallOptions: { removeUndefinedValues: !0 },
  })
var m5 = sn(aS())
var a5 = (e) => e == null
var c5 = (e, t, n) =>
  Object.entries(e).reduce((r, [s, o]) => {
    let i = t(s, o)
    return (r[i][s] = o), r
  }, n)
var d5 = (e) => {
  let t = Object.keys(e)
  return {
    UpdateExpression: `set ${Yl(t.map((n) => [ni(n), cS(n)].join(' = ')))}`,
    ...wA(e),
  }
}
var u5 = (e) => {
  let t = Object.keys(e)
  return { UpdateExpression: `remove ${Yl(t.map(ni))}`, ...dS(t) }
}
function l5(e) {
  return e.filter((t) => t !== void 0)
}
function xA(e, t) {
  let n = t[e]
  return n()
}
var p5 = ({ tableName: e, key: t, fields: n }) => {
  let r = c5(n, (o, i) => (a5(i) ? 'remove' : 'update'), {
      remove: {},
      update: {},
    }),
    s = l5(
      Object.entries(r).map(([o, i]) => {
        if (Object.keys(i).length !== 0)
          return new m5.UpdateCommand({
            TableName: e,
            Key: t,
            ...xA(o, { update: () => d5(i), remove: () => u5(i) }),
          })
      }),
    )
  return Promise.all(s.map((o) => IA.send(o)))
}
var _5 = async (e, t) => p5({ tableName: Yk.users, key: { id: e }, fields: t })
var f5 = (e) => {
  if (e === 'past_due') return 'pastDue'
  if (e === 'deleted' || e === 'active') return 'active'
  throw new Error(`Unknown subscription status: ${e}`)
}
var eLe = [
    'subscription_created',
    'subscription_updated',
    'subscription_cancelled',
    'subscription_payment_succeeded',
    'subscription_payment_failed',
    'subscription_payment_refunded',
  ],
  h5 = async (e) => {
    if (!Hk(e.alert_name, eLe)) {
      console.log(
        `Received unsupported alert from Paddle Classic: ${e.alert_name}`,
      )
      return
    }
    console.log(`Processing ${e.alert_name} event from Paddle Classic`)
    let { userId: n } = JSON.parse(e.passthrough),
      r = {
        provider: 'paddleClassic',
        id: e.subscription_id,
        planId: e.subscription_plan_id,
        status: f5(e.status),
        nextBilledAt: e.next_bill_date
          ? new Date(e.next_bill_date).getTime()
          : void 0,
        endsAt: e.cancellation_effective_date
          ? new Date(e.cancellation_effective_date).getTime()
          : void 0,
      }
    await _5(n, { subscription: r })
  }
PA.AWSLambda.init({ dsn: $k('SENTRY_KEY') })
var tLe = async ({ body: e }) => {
    if (!e)
      return (
        console.log('Received empty body from Paddle Classic'),
        { statusCode: 400 }
      )
    console.log(`Received encoded event from Paddle Classic: ${e}`)
    let t = zk(e)
    return (
      console.log(`Parsed event from Paddle Classic: ${JSON.stringify(t)}`),
      await h5(t),
      { statusCode: 200 }
    )
  },
  nLe = PA.AWSLambda.wrapHandler(tLe)
0 && (module.exports = { handler })
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=lambda.js.map
