'use strict'
var J4 = Object.create
var cl = Object.defineProperty
var X4 = Object.getOwnPropertyDescriptor
var Q4 = Object.getOwnPropertyNames
var Z4 = Object.getPrototypeOf,
  eK = Object.prototype.hasOwnProperty
var ce = (e, t) => () => (e && (t = e((e = 0))), t)
var l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
  Mc = (e, t) => {
    for (var n in t) cl(e, n, { get: t[n], enumerable: !0 })
  },
  AD = (e, t, n, r) => {
    if ((t && typeof t == 'object') || typeof t == 'function')
      for (let s of Q4(t))
        !eK.call(e, s) &&
          s !== n &&
          cl(e, s, {
            get: () => t[s],
            enumerable: !(r = X4(t, s)) || r.enumerable,
          })
    return e
  }
var ln = (e, t, n) => (
    (n = e != null ? J4(Z4(e)) : {}),
    AD(
      t || !e || !e.__esModule
        ? cl(n, 'default', { value: e, enumerable: !0 })
        : n,
      e,
    )
  ),
  w = (e) => AD(cl({}, '__esModule', { value: !0 }), e)
var AE = l((DE) => {
  Object.defineProperty(DE, '__esModule', { value: !0 })
  function tK(e, t) {
    return e ?? t()
  }
  DE._nullishCoalesce = tK
})
var OD = l((OE) => {
  Object.defineProperty(OE, '__esModule', { value: !0 })
  var nK = AE()
  async function rK(e, t) {
    return nK._nullishCoalesce(e, t)
  }
  OE._asyncNullishCoalesce = rK
})
var qE = l((NE) => {
  Object.defineProperty(NE, '__esModule', { value: !0 })
  async function sK(e) {
    let t,
      n = e[0],
      r = 1
    for (; r < e.length; ) {
      let s = e[r],
        o = e[r + 1]
      if (
        ((r += 2),
        (s === 'optionalAccess' || s === 'optionalCall') && n == null)
      )
        return
      s === 'access' || s === 'optionalAccess'
        ? ((t = n), (n = await o(n)))
        : (s === 'call' || s === 'optionalCall') &&
          ((n = await o((...i) => n.call(t, ...i))), (t = void 0))
    }
    return n
  }
  NE._asyncOptionalChain = sK
})
var ND = l((kE) => {
  Object.defineProperty(kE, '__esModule', { value: !0 })
  var oK = qE()
  async function iK(e) {
    let t = await oK._asyncOptionalChain(e)
    return t ?? !0
  }
  kE._asyncOptionalChainDelete = iK
})
var qD = l((dl) => {
  Object.defineProperty(dl, '__esModule', { value: !0 })
  function aK(e, t, n) {
    dl[t] = e[n]
  }
  dl._createNamedExportFrom = aK
})
var kD = l((Fc) => {
  Object.defineProperty(Fc, '__esModule', { value: !0 })
  function cK(e) {
    Object.keys(e)
      .filter((t) => t !== 'default' && t !== '__esModule' && !(t in Fc))
      .forEach((t) => (Fc[t] = e[t]))
  }
  Fc._createStarExport = cK
})
var MD = l((ME) => {
  Object.defineProperty(ME, '__esModule', { value: !0 })
  function dK(e) {
    return e.__esModule ? e.default : e
  }
  ME._interopDefault = dK
})
var FD = l((FE) => {
  Object.defineProperty(FE, '__esModule', { value: !0 })
  function uK(e) {
    return e.__esModule ? e : { ...e, default: e }
  }
  FE._interopNamespace = uK
})
var UD = l((UE) => {
  Object.defineProperty(UE, '__esModule', { value: !0 })
  function lK(e) {
    return { __proto__: null, default: e }
  }
  UE._interopNamespaceDefaultOnly = lK
})
var LD = l((LE) => {
  Object.defineProperty(LE, '__esModule', { value: !0 })
  function mK(e) {
    return e.__esModule ? e : { default: e }
  }
  LE._interopRequireDefault = mK
})
var BD = l((BE) => {
  Object.defineProperty(BE, '__esModule', { value: !0 })
  function pK(e) {
    return e.__esModule ? e : { ...e, default: e }
  }
  BE._interopRequireWildcard = pK
})
var GE = l((jE) => {
  Object.defineProperty(jE, '__esModule', { value: !0 })
  function fK(e) {
    let t,
      n = e[0],
      r = 1
    for (; r < e.length; ) {
      let s = e[r],
        o = e[r + 1]
      if (
        ((r += 2),
        (s === 'optionalAccess' || s === 'optionalCall') && n == null)
      )
        return
      s === 'access' || s === 'optionalAccess'
        ? ((t = n), (n = o(n)))
        : (s === 'call' || s === 'optionalCall') &&
          ((n = o((...i) => n.call(t, ...i))), (t = void 0))
    }
    return n
  }
  jE._optionalChain = fK
})
var jD = l(($E) => {
  Object.defineProperty($E, '__esModule', { value: !0 })
  var _K = GE()
  function hK(e) {
    let t = _K._optionalChain(e)
    return t ?? !0
  }
  $E._optionalChainDelete = hK
})
var ge = l((at) => {
  Object.defineProperty(at, '__esModule', { value: !0 })
  var yK = OD(),
    gK = qE(),
    EK = ND(),
    SK = qD(),
    bK = kD(),
    vK = MD(),
    CK = FD(),
    wK = UD(),
    TK = LD(),
    xK = BD(),
    IK = AE(),
    PK = GE(),
    RK = jD()
  at._asyncNullishCoalesce = yK._asyncNullishCoalesce
  at._asyncOptionalChain = gK._asyncOptionalChain
  at._asyncOptionalChainDelete = EK._asyncOptionalChainDelete
  at._createNamedExportFrom = SK._createNamedExportFrom
  at._createStarExport = bK._createStarExport
  at._interopDefault = vK._interopDefault
  at._interopNamespace = CK._interopNamespace
  at._interopNamespaceDefaultOnly = wK._interopNamespaceDefaultOnly
  at._interopRequireDefault = TK._interopRequireDefault
  at._interopRequireWildcard = xK._interopRequireWildcard
  at._nullishCoalesce = IK._nullishCoalesce
  at._optionalChain = PK._optionalChain
  at._optionalChainDelete = RK._optionalChainDelete
})
var en = l((Qe) => {
  Object.defineProperty(Qe, '__esModule', { value: !0 })
  var GD = Object.prototype.toString
  function DK(e) {
    switch (GD.call(e)) {
      case '[object Error]':
      case '[object Exception]':
      case '[object DOMException]':
        return !0
      default:
        return ul(e, Error)
    }
  }
  function jo(e, t) {
    return GD.call(e) === `[object ${t}]`
  }
  function AK(e) {
    return jo(e, 'ErrorEvent')
  }
  function OK(e) {
    return jo(e, 'DOMError')
  }
  function NK(e) {
    return jo(e, 'DOMException')
  }
  function qK(e) {
    return jo(e, 'String')
  }
  function kK(e) {
    return e === null || (typeof e != 'object' && typeof e != 'function')
  }
  function $D(e) {
    return jo(e, 'Object')
  }
  function MK(e) {
    return typeof Event < 'u' && ul(e, Event)
  }
  function FK(e) {
    return typeof Element < 'u' && ul(e, Element)
  }
  function UK(e) {
    return jo(e, 'RegExp')
  }
  function LK(e) {
    return !!(e && e.then && typeof e.then == 'function')
  }
  function BK(e) {
    return (
      $D(e) &&
      'nativeEvent' in e &&
      'preventDefault' in e &&
      'stopPropagation' in e
    )
  }
  function jK(e) {
    return typeof e == 'number' && e !== e
  }
  function ul(e, t) {
    try {
      return e instanceof t
    } catch {
      return !1
    }
  }
  Qe.isDOMError = OK
  Qe.isDOMException = NK
  Qe.isElement = FK
  Qe.isError = DK
  Qe.isErrorEvent = AK
  Qe.isEvent = MK
  Qe.isInstanceOf = ul
  Qe.isNaN = jK
  Qe.isPlainObject = $D
  Qe.isPrimitive = kK
  Qe.isRegExp = UK
  Qe.isString = qK
  Qe.isSyntheticEvent = BK
  Qe.isThenable = LK
})
var Uc = l((Bs) => {
  Object.defineProperty(Bs, '__esModule', { value: !0 })
  var zE = en()
  function GK(e, t = 0) {
    return typeof e != 'string' || t === 0 || e.length <= t
      ? e
      : `${e.slice(0, t)}...`
  }
  function $K(e, t) {
    let n = e,
      r = n.length
    if (r <= 150) return n
    t > r && (t = r)
    let s = Math.max(t - 60, 0)
    s < 5 && (s = 0)
    let o = Math.min(s + 140, r)
    return (
      o > r - 5 && (o = r),
      o === r && (s = Math.max(o - 140, 0)),
      (n = n.slice(s, o)),
      s > 0 && (n = `'{snip} ${n}`),
      o < r && (n += ' {snip}'),
      n
    )
  }
  function zK(e, t) {
    if (!Array.isArray(e)) return ''
    let n = []
    for (let r = 0; r < e.length; r++) {
      let s = e[r]
      try {
        n.push(String(s))
      } catch {
        n.push('[value cannot be serialized]')
      }
    }
    return n.join(t)
  }
  function zD(e, t, n = !1) {
    return zE.isString(e)
      ? zE.isRegExp(t)
        ? t.test(e)
        : zE.isString(t)
        ? n
          ? e === t
          : e.includes(t)
        : !1
      : !1
  }
  function HK(e, t = [], n = !1) {
    return t.some((r) => zD(e, r, n))
  }
  Bs.isMatchingPattern = zD
  Bs.safeJoin = zK
  Bs.snipLine = $K
  Bs.stringMatchesSomePattern = HK
  Bs.truncate = GK
})
var VD = l((VE) => {
  Object.defineProperty(VE, '__esModule', { value: !0 })
  var HE = en(),
    WK = Uc()
  function VK(e, t, n = 250, r, s, o, i) {
    if (
      !o.exception ||
      !o.exception.values ||
      !i ||
      !HE.isInstanceOf(i.originalException, Error)
    )
      return
    let c =
      o.exception.values.length > 0
        ? o.exception.values[o.exception.values.length - 1]
        : void 0
    c &&
      (o.exception.values = YK(
        WE(e, t, s, i.originalException, r, o.exception.values, c, 0),
        n,
      ))
  }
  function WE(e, t, n, r, s, o, i, c) {
    if (o.length >= n + 1) return o
    let a = [...o]
    if (HE.isInstanceOf(r[s], Error)) {
      HD(i, c)
      let u = e(t, r[s]),
        d = a.length
      WD(u, s, d, c), (a = WE(e, t, n, r[s], s, [u, ...a], u, d))
    }
    return (
      Array.isArray(r.errors) &&
        r.errors.forEach((u, d) => {
          if (HE.isInstanceOf(u, Error)) {
            HD(i, c)
            let p = e(t, u),
              f = a.length
            WD(p, `errors[${d}]`, f, c),
              (a = WE(e, t, n, u, s, [p, ...a], p, f))
          }
        }),
      a
    )
  }
  function HD(e, t) {
    ;(e.mechanism = e.mechanism || { type: 'generic', handled: !0 }),
      (e.mechanism = {
        ...e.mechanism,
        is_exception_group: !0,
        exception_id: t,
      })
  }
  function WD(e, t, n, r) {
    ;(e.mechanism = e.mechanism || { type: 'generic', handled: !0 }),
      (e.mechanism = {
        ...e.mechanism,
        type: 'chained',
        source: t,
        exception_id: n,
        parent_id: r,
      })
  }
  function YK(e, t) {
    return e.map((n) => (n.value && (n.value = WK.truncate(n.value, t)), n))
  }
  VE.applyAggregateErrorsToEvent = VK
})
var Qn = l((Lc) => {
  Object.defineProperty(Lc, '__esModule', { value: !0 })
  function ll(e) {
    return e && e.Math == Math ? e : void 0
  }
  var YE =
    (typeof globalThis == 'object' && ll(globalThis)) ||
    (typeof window == 'object' && ll(window)) ||
    (typeof self == 'object' && ll(self)) ||
    (typeof global == 'object' && ll(global)) ||
    (function () {
      return this
    })() ||
    {}
  function KK() {
    return YE
  }
  function JK(e, t, n) {
    let r = n || YE,
      s = (r.__SENTRY__ = r.__SENTRY__ || {})
    return s[e] || (s[e] = t())
  }
  Lc.GLOBAL_OBJ = YE
  Lc.getGlobalObject = KK
  Lc.getGlobalSingleton = JK
})
var KE = l((Bc) => {
  Object.defineProperty(Bc, '__esModule', { value: !0 })
  var XK = en(),
    QK = Qn(),
    ml = QK.getGlobalObject(),
    ZK = 80
  function e5(e, t = {}) {
    try {
      let n = e,
        r = 5,
        s = [],
        o = 0,
        i = 0,
        c = ' > ',
        a = c.length,
        u,
        d = Array.isArray(t) ? t : t.keyAttrs,
        p = (!Array.isArray(t) && t.maxStringLength) || ZK
      for (
        ;
        n &&
        o++ < r &&
        ((u = t5(n, d)),
        !(u === 'html' || (o > 1 && i + s.length * a + u.length >= p)));

      )
        s.push(u), (i += u.length), (n = n.parentNode)
      return s.reverse().join(c)
    } catch {
      return '<unknown>'
    }
  }
  function t5(e, t) {
    let n = e,
      r = [],
      s,
      o,
      i,
      c,
      a
    if (!n || !n.tagName) return ''
    r.push(n.tagName.toLowerCase())
    let u =
      t && t.length
        ? t.filter((p) => n.getAttribute(p)).map((p) => [p, n.getAttribute(p)])
        : null
    if (u && u.length)
      u.forEach((p) => {
        r.push(`[${p[0]}="${p[1]}"]`)
      })
    else if (
      (n.id && r.push(`#${n.id}`), (s = n.className), s && XK.isString(s))
    )
      for (o = s.split(/\s+/), a = 0; a < o.length; a++) r.push(`.${o[a]}`)
    let d = ['aria-label', 'type', 'name', 'title', 'alt']
    for (a = 0; a < d.length; a++)
      (i = d[a]), (c = n.getAttribute(i)), c && r.push(`[${i}="${c}"]`)
    return r.join('')
  }
  function n5() {
    try {
      return ml.document.location.href
    } catch {
      return ''
    }
  }
  function r5(e) {
    return ml.document && ml.document.querySelector
      ? ml.document.querySelector(e)
      : null
  }
  Bc.getDomElement = r5
  Bc.getLocationHref = n5
  Bc.htmlTreeAsString = e5
})
var Go = l((js) => {
  Object.defineProperty(js, '__esModule', { value: !0 })
  var pl = Qn(),
    s5 = 'Sentry Logger ',
    fl = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace']
  function KD(e) {
    if (!('console' in pl.GLOBAL_OBJ)) return e()
    let t = pl.GLOBAL_OBJ.console,
      n = {}
    fl.forEach((r) => {
      let s = t[r] && t[r].__sentry_original__
      r in t && s && ((n[r] = t[r]), (t[r] = s))
    })
    try {
      return e()
    } finally {
      Object.keys(n).forEach((r) => {
        t[r] = n[r]
      })
    }
  }
  function YD() {
    let e = !1,
      t = {
        enable: () => {
          e = !0
        },
        disable: () => {
          e = !1
        },
      }
    return (
      typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__
        ? fl.forEach((n) => {
            t[n] = (...r) => {
              e &&
                KD(() => {
                  pl.GLOBAL_OBJ.console[n](`${s5}[${n}]:`, ...r)
                })
            }
          })
        : fl.forEach((n) => {
            t[n] = () => {}
          }),
      t
    )
  }
  js.logger = void 0
  typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__
    ? (js.logger = pl.getGlobalSingleton('logger', YD))
    : (js.logger = YD())
  js.CONSOLE_LEVELS = fl
  js.consoleSandbox = KD
})
var JE = l((jc) => {
  Object.defineProperty(jc, '__esModule', { value: !0 })
  var _l = Go(),
    o5 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/
  function i5(e) {
    return e === 'http' || e === 'https'
  }
  function a5(e, t = !1) {
    let {
      host: n,
      path: r,
      pass: s,
      port: o,
      projectId: i,
      protocol: c,
      publicKey: a,
    } = e
    return `${c}://${a}${t && s ? `:${s}` : ''}@${n}${o ? `:${o}` : ''}/${
      r && `${r}/`
    }${i}`
  }
  function JD(e) {
    let t = o5.exec(e)
    if (!t) {
      console.error(`Invalid Sentry Dsn: ${e}`)
      return
    }
    let [n, r, s = '', o, i = '', c] = t.slice(1),
      a = '',
      u = c,
      d = u.split('/')
    if ((d.length > 1 && ((a = d.slice(0, -1).join('/')), (u = d.pop())), u)) {
      let p = u.match(/^\d+/)
      p && (u = p[0])
    }
    return XD({
      host: o,
      pass: s,
      path: a,
      projectId: u,
      port: i,
      protocol: n,
      publicKey: r,
    })
  }
  function XD(e) {
    return {
      protocol: e.protocol,
      publicKey: e.publicKey || '',
      pass: e.pass || '',
      host: e.host,
      port: e.port || '',
      path: e.path || '',
      projectId: e.projectId,
    }
  }
  function c5(e) {
    if (!(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__)) return !0
    let { port: t, projectId: n, protocol: r } = e
    return ['protocol', 'publicKey', 'host', 'projectId'].find((i) =>
      e[i] ? !1 : (_l.logger.error(`Invalid Sentry Dsn: ${i} missing`), !0),
    )
      ? !1
      : n.match(/^\d+$/)
      ? i5(r)
        ? t && isNaN(parseInt(t, 10))
          ? (_l.logger.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1)
          : !0
        : (_l.logger.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1)
      : (_l.logger.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1)
  }
  function d5(e) {
    let t = typeof e == 'string' ? JD(e) : XD(e)
    if (!(!t || !c5(t))) return t
  }
  jc.dsnFromString = JD
  jc.dsnToString = a5
  jc.makeDsn = d5
})
var ZE = l((QE) => {
  Object.defineProperty(QE, '__esModule', { value: !0 })
  var XE = class extends Error {
    constructor(t, n = 'warn') {
      super(t),
        (this.message = t),
        (this.name = new.target.prototype.constructor.name),
        Object.setPrototypeOf(this, new.target.prototype),
        (this.logLevel = n)
    }
  }
  QE.SentryError = XE
})
var zo = l((tn) => {
  Object.defineProperty(tn, '__esModule', { value: !0 })
  var u5 = KE(),
    $o = en(),
    QD = Uc()
  function l5(e, t, n) {
    if (!(t in e)) return
    let r = e[t],
      s = n(r)
    if (typeof s == 'function')
      try {
        nA(s, r)
      } catch {}
    e[t] = s
  }
  function tA(e, t, n) {
    Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 })
  }
  function nA(e, t) {
    let n = t.prototype || {}
    ;(e.prototype = t.prototype = n), tA(e, '__sentry_original__', t)
  }
  function m5(e) {
    return e.__sentry_original__
  }
  function p5(e) {
    return Object.keys(e)
      .map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`)
      .join('&')
  }
  function rA(e) {
    if ($o.isError(e))
      return { message: e.message, name: e.name, stack: e.stack, ...eA(e) }
    if ($o.isEvent(e)) {
      let t = {
        type: e.type,
        target: ZD(e.target),
        currentTarget: ZD(e.currentTarget),
        ...eA(e),
      }
      return (
        typeof CustomEvent < 'u' &&
          $o.isInstanceOf(e, CustomEvent) &&
          (t.detail = e.detail),
        t
      )
    } else return e
  }
  function ZD(e) {
    try {
      return $o.isElement(e)
        ? u5.htmlTreeAsString(e)
        : Object.prototype.toString.call(e)
    } catch {
      return '<unknown>'
    }
  }
  function eA(e) {
    if (typeof e == 'object' && e !== null) {
      let t = {}
      for (let n in e)
        Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n])
      return t
    } else return {}
  }
  function f5(e, t = 40) {
    let n = Object.keys(rA(e))
    if ((n.sort(), !n.length)) return '[object has no keys]'
    if (n[0].length >= t) return QD.truncate(n[0], t)
    for (let r = n.length; r > 0; r--) {
      let s = n.slice(0, r).join(', ')
      if (!(s.length > t)) return r === n.length ? s : QD.truncate(s, t)
    }
    return ''
  }
  function _5(e) {
    return eS(e, new Map())
  }
  function eS(e, t) {
    if ($o.isPlainObject(e)) {
      let n = t.get(e)
      if (n !== void 0) return n
      let r = {}
      t.set(e, r)
      for (let s of Object.keys(e)) typeof e[s] < 'u' && (r[s] = eS(e[s], t))
      return r
    }
    if (Array.isArray(e)) {
      let n = t.get(e)
      if (n !== void 0) return n
      let r = []
      return (
        t.set(e, r),
        e.forEach((s) => {
          r.push(eS(s, t))
        }),
        r
      )
    }
    return e
  }
  function h5(e) {
    let t
    switch (!0) {
      case e == null:
        t = new String(e)
        break
      case typeof e == 'symbol' || typeof e == 'bigint':
        t = Object(e)
        break
      case $o.isPrimitive(e):
        t = new e.constructor(e)
        break
      default:
        t = e
        break
    }
    return t
  }
  tn.addNonEnumerableProperty = tA
  tn.convertToPlainObject = rA
  tn.dropUndefinedKeys = _5
  tn.extractExceptionKeysForMessage = f5
  tn.fill = l5
  tn.getOriginalFunction = m5
  tn.markFunctionWrapped = nA
  tn.objectify = h5
  tn.urlEncode = p5
})
var sA = l((tS) => {
  Object.defineProperty(tS, '__esModule', { value: !0 })
  function y5(e) {
    let t = /^\s*[-]{4,}$/,
      n = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/
    return (r) => {
      let s = r.match(n)
      if (s) {
        let o, i, c, a, u
        if (s[1]) {
          c = s[1]
          let h = c.lastIndexOf('.')
          if ((c[h - 1] === '.' && h--, h > 0)) {
            ;(o = c.slice(0, h)), (i = c.slice(h + 1))
            let g = o.indexOf('.Module')
            g > 0 && ((c = c.slice(g + 1)), (o = o.slice(0, g)))
          }
          a = void 0
        }
        i && ((a = o), (u = i)),
          i === '<anonymous>' && ((u = void 0), (c = void 0)),
          c === void 0 && ((u = u || '<anonymous>'), (c = a ? `${a}.${u}` : u))
        let d = s[2] && s[2].startsWith('file://') ? s[2].slice(7) : s[2],
          p = s[5] === 'native'
        !d && s[5] && !p && (d = s[5])
        let _ =
          !(
            p ||
            (d &&
              !d.startsWith('/') &&
              !d.includes(':\\') &&
              !d.startsWith('.') &&
              !d.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))
          ) &&
          d !== void 0 &&
          !d.includes('node_modules/')
        return {
          filename: d,
          module: e ? e(d) : void 0,
          function: c,
          lineno: parseInt(s[3], 10) || void 0,
          colno: parseInt(s[4], 10) || void 0,
          in_app: _,
        }
      }
      if (r.match(t)) return { filename: r }
    }
  }
  tS.node = y5
})
var hl = l((Gs) => {
  Object.defineProperty(Gs, '__esModule', { value: !0 })
  var g5 = sA(),
    aA = 50,
    oA = /\(error: (.*)\)/,
    iA = /captureMessage|captureException/
  function cA(...e) {
    let t = e.sort((n, r) => n[0] - r[0]).map((n) => n[1])
    return (n, r = 0) => {
      let s = [],
        o = n.split(`
`)
      for (let i = r; i < o.length; i++) {
        let c = o[i]
        if (c.length > 1024) continue
        let a = oA.test(c) ? c.replace(oA, '$1') : c
        if (!a.match(/\S*Error: /)) {
          for (let u of t) {
            let d = u(a)
            if (d) {
              s.push(d)
              break
            }
          }
          if (s.length >= aA) break
        }
      }
      return dA(s)
    }
  }
  function E5(e) {
    return Array.isArray(e) ? cA(...e) : e
  }
  function dA(e) {
    if (!e.length) return []
    let t = Array.from(e)
    return (
      /sentryWrapped/.test(t[t.length - 1].function || '') && t.pop(),
      t.reverse(),
      iA.test(t[t.length - 1].function || '') &&
        (t.pop(), iA.test(t[t.length - 1].function || '') && t.pop()),
      t
        .slice(0, aA)
        .map((n) => ({
          ...n,
          filename: n.filename || t[t.length - 1].filename,
          function: n.function || '?',
        }))
    )
  }
  var nS = '<anonymous>'
  function S5(e) {
    try {
      return !e || typeof e != 'function' ? nS : e.name || nS
    } catch {
      return nS
    }
  }
  function b5(e) {
    return [90, g5.node(e)]
  }
  Gs.createStackParser = cA
  Gs.getFunctionName = S5
  Gs.nodeStackLineParser = b5
  Gs.stackParserFromStackParserOptions = E5
  Gs.stripSentryFramesAndReverse = dA
})
var oS = l((mn) => {
  Object.defineProperty(mn, '__esModule', { value: !0 })
  var v5 = Go(),
    C5 = Qn(),
    yl = C5.getGlobalObject()
  function w5() {
    try {
      return new ErrorEvent(''), !0
    } catch {
      return !1
    }
  }
  function T5() {
    try {
      return new DOMError(''), !0
    } catch {
      return !1
    }
  }
  function x5() {
    try {
      return new DOMException(''), !0
    } catch {
      return !1
    }
  }
  function sS() {
    if (!('fetch' in yl)) return !1
    try {
      return (
        new Headers(), new Request('http://www.example.com'), new Response(), !0
      )
    } catch {
      return !1
    }
  }
  function rS(e) {
    return (
      e && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
    )
  }
  function I5() {
    if (!sS()) return !1
    if (rS(yl.fetch)) return !0
    let e = !1,
      t = yl.document
    if (t && typeof t.createElement == 'function')
      try {
        let n = t.createElement('iframe')
        ;(n.hidden = !0),
          t.head.appendChild(n),
          n.contentWindow &&
            n.contentWindow.fetch &&
            (e = rS(n.contentWindow.fetch)),
          t.head.removeChild(n)
      } catch (n) {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          v5.logger.warn(
            'Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ',
            n,
          )
      }
    return e
  }
  function P5() {
    return 'ReportingObserver' in yl
  }
  function R5() {
    if (!sS()) return !1
    try {
      return new Request('_', { referrerPolicy: 'origin' }), !0
    } catch {
      return !1
    }
  }
  mn.isNativeFetch = rS
  mn.supportsDOMError = T5
  mn.supportsDOMException = x5
  mn.supportsErrorEvent = w5
  mn.supportsFetch = sS
  mn.supportsNativeFetch = I5
  mn.supportsReferrerPolicy = R5
  mn.supportsReportingObserver = P5
})
var aS = l((iS) => {
  Object.defineProperty(iS, '__esModule', { value: !0 })
  var D5 = Qn(),
    gl = D5.getGlobalObject()
  function A5() {
    let e = gl.chrome,
      t = e && e.app && e.app.runtime,
      n = 'history' in gl && !!gl.history.pushState && !!gl.history.replaceState
    return !t && n
  }
  iS.supportsHistory = A5
})
var _A = l((zc) => {
  Object.defineProperty(zc, '__esModule', { value: !0 })
  var uA = en(),
    dS = Go(),
    pn = zo(),
    O5 = hl(),
    N5 = oS(),
    q5 = Qn(),
    k5 = aS(),
    Se = q5.getGlobalObject(),
    Gc = '__sentry_xhr_v2__',
    $c = {},
    lA = {}
  function M5(e) {
    if (!lA[e])
      switch (((lA[e] = !0), e)) {
        case 'console':
          U5()
          break
        case 'dom':
          H5()
          break
        case 'xhr':
          B5()
          break
        case 'fetch':
          L5()
          break
        case 'history':
          j5()
          break
        case 'error':
          W5()
          break
        case 'unhandledrejection':
          V5()
          break
        default:
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            dS.logger.warn('unknown instrumentation type:', e)
          return
      }
  }
  function F5(e, t) {
    ;($c[e] = $c[e] || []), $c[e].push(t), M5(e)
  }
  function nn(e, t) {
    if (!(!e || !$c[e]))
      for (let n of $c[e] || [])
        try {
          n(t)
        } catch (r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            dS.logger.error(
              `Error while triggering instrumentation handler.
Type: ${e}
Name: ${O5.getFunctionName(n)}
Error:`,
              r,
            )
        }
  }
  function U5() {
    'console' in Se &&
      dS.CONSOLE_LEVELS.forEach(function (e) {
        e in Se.console &&
          pn.fill(Se.console, e, function (t) {
            return function (...n) {
              nn('console', { args: n, level: e }), t && t.apply(Se.console, n)
            }
          })
      })
  }
  function L5() {
    N5.supportsNativeFetch() &&
      pn.fill(Se, 'fetch', function (e) {
        return function (...t) {
          let { method: n, url: r } = fA(t),
            s = {
              args: t,
              fetchData: { method: n, url: r },
              startTimestamp: Date.now(),
            }
          return (
            nn('fetch', { ...s }),
            e.apply(Se, t).then(
              (o) => (
                nn('fetch', { ...s, endTimestamp: Date.now(), response: o }), o
              ),
              (o) => {
                throw (
                  (nn('fetch', { ...s, endTimestamp: Date.now(), error: o }), o)
                )
              },
            )
          )
        }
      })
  }
  function cS(e, t) {
    return !!e && typeof e == 'object' && !!e[t]
  }
  function mA(e) {
    return typeof e == 'string'
      ? e
      : e
      ? cS(e, 'url')
        ? e.url
        : e.toString
        ? e.toString()
        : ''
      : ''
  }
  function fA(e) {
    if (e.length === 0) return { method: 'GET', url: '' }
    if (e.length === 2) {
      let [n, r] = e
      return {
        url: mA(n),
        method: cS(r, 'method') ? String(r.method).toUpperCase() : 'GET',
      }
    }
    let t = e[0]
    return {
      url: mA(t),
      method: cS(t, 'method') ? String(t.method).toUpperCase() : 'GET',
    }
  }
  function B5() {
    if (!('XMLHttpRequest' in Se)) return
    let e = XMLHttpRequest.prototype
    pn.fill(e, 'open', function (t) {
      return function (...n) {
        let r = n[1],
          s = (this[Gc] = {
            method: uA.isString(n[0]) ? n[0].toUpperCase() : n[0],
            url: n[1],
            request_headers: {},
          })
        uA.isString(r) &&
          s.method === 'POST' &&
          r.match(/sentry_key/) &&
          (this.__sentry_own_request__ = !0)
        let o = () => {
          let i = this[Gc]
          if (i && this.readyState === 4) {
            try {
              i.status_code = this.status
            } catch {}
            nn('xhr', {
              args: n,
              endTimestamp: Date.now(),
              startTimestamp: Date.now(),
              xhr: this,
            })
          }
        }
        return (
          'onreadystatechange' in this &&
          typeof this.onreadystatechange == 'function'
            ? pn.fill(this, 'onreadystatechange', function (i) {
                return function (...c) {
                  return o(), i.apply(this, c)
                }
              })
            : this.addEventListener('readystatechange', o),
          pn.fill(this, 'setRequestHeader', function (i) {
            return function (...c) {
              let [a, u] = c,
                d = this[Gc]
              return (
                d && (d.request_headers[a.toLowerCase()] = u), i.apply(this, c)
              )
            }
          }),
          t.apply(this, n)
        )
      }
    }),
      pn.fill(e, 'send', function (t) {
        return function (...n) {
          let r = this[Gc]
          return (
            r && n[0] !== void 0 && (r.body = n[0]),
            nn('xhr', { args: n, startTimestamp: Date.now(), xhr: this }),
            t.apply(this, n)
          )
        }
      })
  }
  var El
  function j5() {
    if (!k5.supportsHistory()) return
    let e = Se.onpopstate
    Se.onpopstate = function (...n) {
      let r = Se.location.href,
        s = El
      if (((El = r), nn('history', { from: s, to: r }), e))
        try {
          return e.apply(this, n)
        } catch {}
    }
    function t(n) {
      return function (...r) {
        let s = r.length > 2 ? r[2] : void 0
        if (s) {
          let o = El,
            i = String(s)
          ;(El = i), nn('history', { from: o, to: i })
        }
        return n.apply(this, r)
      }
    }
    pn.fill(Se.history, 'pushState', t), pn.fill(Se.history, 'replaceState', t)
  }
  var G5 = 1e3,
    Sl,
    bl
  function $5(e, t) {
    if (!e || e.type !== t.type) return !0
    try {
      if (e.target !== t.target) return !0
    } catch {}
    return !1
  }
  function z5(e) {
    if (e.type !== 'keypress') return !1
    try {
      let t = e.target
      if (!t || !t.tagName) return !0
      if (
        t.tagName === 'INPUT' ||
        t.tagName === 'TEXTAREA' ||
        t.isContentEditable
      )
        return !1
    } catch {}
    return !0
  }
  function pA(e, t = !1) {
    return (n) => {
      if (!n || bl === n || z5(n)) return
      let r = n.type === 'keypress' ? 'input' : n.type
      Sl === void 0
        ? (e({ event: n, name: r, global: t }), (bl = n))
        : $5(bl, n) && (e({ event: n, name: r, global: t }), (bl = n)),
        clearTimeout(Sl),
        (Sl = Se.setTimeout(() => {
          Sl = void 0
        }, G5))
    }
  }
  function H5() {
    if (!('document' in Se)) return
    let e = nn.bind(null, 'dom'),
      t = pA(e, !0)
    Se.document.addEventListener('click', t, !1),
      Se.document.addEventListener('keypress', t, !1),
      ['EventTarget', 'Node'].forEach((n) => {
        let r = Se[n] && Se[n].prototype
        !r ||
          !r.hasOwnProperty ||
          !r.hasOwnProperty('addEventListener') ||
          (pn.fill(r, 'addEventListener', function (s) {
            return function (o, i, c) {
              if (o === 'click' || o == 'keypress')
                try {
                  let a = this,
                    u = (a.__sentry_instrumentation_handlers__ =
                      a.__sentry_instrumentation_handlers__ || {}),
                    d = (u[o] = u[o] || { refCount: 0 })
                  if (!d.handler) {
                    let p = pA(e)
                    ;(d.handler = p), s.call(this, o, p, c)
                  }
                  d.refCount++
                } catch {}
              return s.call(this, o, i, c)
            }
          }),
          pn.fill(r, 'removeEventListener', function (s) {
            return function (o, i, c) {
              if (o === 'click' || o == 'keypress')
                try {
                  let a = this,
                    u = a.__sentry_instrumentation_handlers__ || {},
                    d = u[o]
                  d &&
                    (d.refCount--,
                    d.refCount <= 0 &&
                      (s.call(this, o, d.handler, c),
                      (d.handler = void 0),
                      delete u[o]),
                    Object.keys(u).length === 0 &&
                      delete a.__sentry_instrumentation_handlers__)
                } catch {}
              return s.call(this, o, i, c)
            }
          }))
      })
  }
  var vl = null
  function W5() {
    ;(vl = Se.onerror),
      (Se.onerror = function (e, t, n, r, s) {
        return (
          nn('error', { column: r, error: s, line: n, msg: e, url: t }),
          vl && !vl.__SENTRY_LOADER__ ? vl.apply(this, arguments) : !1
        )
      }),
      (Se.onerror.__SENTRY_INSTRUMENTED__ = !0)
  }
  var Cl = null
  function V5() {
    ;(Cl = Se.onunhandledrejection),
      (Se.onunhandledrejection = function (e) {
        return (
          nn('unhandledrejection', e),
          Cl && !Cl.__SENTRY_LOADER__ ? Cl.apply(this, arguments) : !0
        )
      }),
      (Se.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0)
  }
  zc.SENTRY_XHR_DATA_KEY = Gc
  zc.addInstrumentationHandler = F5
  zc.parseFetchArgs = fA
})
var lS = l((uS) => {
  Object.defineProperty(uS, '__esModule', { value: !0 })
  function Y5() {
    let e = typeof WeakSet == 'function',
      t = e ? new WeakSet() : []
    function n(s) {
      if (e) return t.has(s) ? !0 : (t.add(s), !1)
      for (let o = 0; o < t.length; o++) if (t[o] === s) return !0
      return t.push(s), !1
    }
    function r(s) {
      if (e) t.delete(s)
      else
        for (let o = 0; o < t.length; o++)
          if (t[o] === s) {
            t.splice(o, 1)
            break
          }
    }
    return [n, r]
  }
  uS.memoBuilder = Y5
})
var pS = l((fn) => {
  Object.defineProperty(fn, '__esModule', { value: !0 })
  var K5 = zo(),
    mS = Uc(),
    J5 = Qn()
  function X5() {
    let e = J5.GLOBAL_OBJ,
      t = e.crypto || e.msCrypto
    if (t && t.randomUUID) return t.randomUUID().replace(/-/g, '')
    let n =
      t && t.getRandomValues
        ? () => t.getRandomValues(new Uint8Array(1))[0]
        : () => Math.random() * 16
    return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (r) =>
      (r ^ ((n() & 15) >> (r / 4))).toString(16),
    )
  }
  function hA(e) {
    return e.exception && e.exception.values ? e.exception.values[0] : void 0
  }
  function Q5(e) {
    let { message: t, event_id: n } = e
    if (t) return t
    let r = hA(e)
    return r
      ? r.type && r.value
        ? `${r.type}: ${r.value}`
        : r.type || r.value || n || '<unknown>'
      : n || '<unknown>'
  }
  function Z5(e, t, n) {
    let r = (e.exception = e.exception || {}),
      s = (r.values = r.values || []),
      o = (s[0] = s[0] || {})
    o.value || (o.value = t || ''), o.type || (o.type = n || 'Error')
  }
  function e9(e, t) {
    let n = hA(e)
    if (!n) return
    let r = { type: 'generic', handled: !0 },
      s = n.mechanism
    if (((n.mechanism = { ...r, ...s, ...t }), t && 'data' in t)) {
      let o = { ...(s && s.data), ...t.data }
      n.mechanism.data = o
    }
  }
  var t9 =
    /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/
  function n9(e) {
    let t = e.match(t9) || [],
      n = parseInt(t[1], 10),
      r = parseInt(t[2], 10),
      s = parseInt(t[3], 10)
    return {
      buildmetadata: t[5],
      major: isNaN(n) ? void 0 : n,
      minor: isNaN(r) ? void 0 : r,
      patch: isNaN(s) ? void 0 : s,
      prerelease: t[4],
    }
  }
  function r9(e, t, n = 5) {
    if (t.lineno === void 0) return
    let r = e.length,
      s = Math.max(Math.min(r - 1, t.lineno - 1), 0)
    ;(t.pre_context = e
      .slice(Math.max(0, s - n), s)
      .map((o) => mS.snipLine(o, 0))),
      (t.context_line = mS.snipLine(e[Math.min(r - 1, s)], t.colno || 0)),
      (t.post_context = e
        .slice(Math.min(s + 1, r), s + 1 + n)
        .map((o) => mS.snipLine(o, 0)))
  }
  function s9(e) {
    if (e && e.__sentry_captured__) return !0
    try {
      K5.addNonEnumerableProperty(e, '__sentry_captured__', !0)
    } catch {}
    return !1
  }
  function o9(e) {
    return Array.isArray(e) ? e : [e]
  }
  fn.addContextToFrame = r9
  fn.addExceptionMechanism = e9
  fn.addExceptionTypeValue = Z5
  fn.arrayify = o9
  fn.checkOrSetAlreadyCaught = s9
  fn.getEventDescription = Q5
  fn.parseSemver = n9
  fn.uuid4 = X5
})
var fS = l((wl) => {
  Object.defineProperty(wl, '__esModule', { value: !0 })
  function i9() {
    return typeof __SENTRY_BROWSER_BUNDLE__ < 'u' && !!__SENTRY_BROWSER_BUNDLE__
  }
  function a9() {
    return 'npm'
  }
  wl.getSDKSource = a9
  wl.isBrowserBundle = i9
})
var _S = l((Hc, xl) => {
  Object.defineProperty(Hc, '__esModule', { value: !0 })
  var c9 = fS()
  function d9() {
    return (
      !c9.isBrowserBundle() &&
      Object.prototype.toString.call(typeof process < 'u' ? process : 0) ===
        '[object process]'
    )
  }
  function Tl(e, t) {
    return e.require(t)
  }
  function u9(e) {
    let t
    try {
      t = Tl(xl, e)
    } catch {}
    try {
      let { cwd: n } = Tl(xl, 'process')
      t = Tl(xl, `${n()}/node_modules/${e}`)
    } catch {}
    return t
  }
  Hc.dynamicRequire = Tl
  Hc.isNodeEnv = d9
  Hc.loadModule = u9
})
var Pl = l((Wc) => {
  Object.defineProperty(Wc, '__esModule', { value: !0 })
  var yA = en(),
    l9 = lS(),
    m9 = zo(),
    p9 = hl()
  function gA(e, t = 100, n = 1 / 0) {
    try {
      return Il('', e, t, n)
    } catch (r) {
      return { ERROR: `**non-serializable** (${r})` }
    }
  }
  function EA(e, t = 3, n = 100 * 1024) {
    let r = gA(e, t)
    return y9(r) > n ? EA(e, t - 1, n) : r
  }
  function Il(e, t, n = 1 / 0, r = 1 / 0, s = l9.memoBuilder()) {
    let [o, i] = s
    if (
      t == null ||
      (['number', 'boolean', 'string'].includes(typeof t) && !yA.isNaN(t))
    )
      return t
    let c = f9(e, t)
    if (!c.startsWith('[object ')) return c
    if (t.__sentry_skip_normalization__) return t
    let a =
      typeof t.__sentry_override_normalization_depth__ == 'number'
        ? t.__sentry_override_normalization_depth__
        : n
    if (a === 0) return c.replace('object ', '')
    if (o(t)) return '[Circular ~]'
    let u = t
    if (u && typeof u.toJSON == 'function')
      try {
        let _ = u.toJSON()
        return Il('', _, a - 1, r, s)
      } catch {}
    let d = Array.isArray(t) ? [] : {},
      p = 0,
      f = m9.convertToPlainObject(t)
    for (let _ in f) {
      if (!Object.prototype.hasOwnProperty.call(f, _)) continue
      if (p >= r) {
        d[_] = '[MaxProperties ~]'
        break
      }
      let h = f[_]
      ;(d[_] = Il(_, h, a - 1, r, s)), p++
    }
    return i(t), d
  }
  function f9(e, t) {
    try {
      if (e === 'domain' && t && typeof t == 'object' && t._events)
        return '[Domain]'
      if (e === 'domainEmitter') return '[DomainEmitter]'
      if (typeof global < 'u' && t === global) return '[Global]'
      if (typeof window < 'u' && t === window) return '[Window]'
      if (typeof document < 'u' && t === document) return '[Document]'
      if (yA.isSyntheticEvent(t)) return '[SyntheticEvent]'
      if (typeof t == 'number' && t !== t) return '[NaN]'
      if (typeof t == 'function') return `[Function: ${p9.getFunctionName(t)}]`
      if (typeof t == 'symbol') return `[${String(t)}]`
      if (typeof t == 'bigint') return `[BigInt: ${String(t)}]`
      let n = _9(t)
      return /^HTML(\w*)Element$/.test(n)
        ? `[HTMLElement: ${n}]`
        : `[object ${n}]`
    } catch (n) {
      return `**non-serializable** (${n})`
    }
  }
  function _9(e) {
    let t = Object.getPrototypeOf(e)
    return t ? t.constructor.name : 'null prototype'
  }
  function h9(e) {
    return ~-encodeURI(e).split(/%..|./).length
  }
  function y9(e) {
    return h9(JSON.stringify(e))
  }
  Wc.normalize = gA
  Wc.normalizeToSize = EA
  Wc.walk = Il
})
var TA = l((Zn) => {
  Object.defineProperty(Zn, '__esModule', { value: !0 })
  function bA(e, t) {
    let n = 0
    for (let r = e.length - 1; r >= 0; r--) {
      let s = e[r]
      s === '.'
        ? e.splice(r, 1)
        : s === '..'
        ? (e.splice(r, 1), n++)
        : n && (e.splice(r, 1), n--)
    }
    if (t) for (; n--; n) e.unshift('..')
    return e
  }
  var g9 =
    /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/
  function vA(e) {
    let t = e.length > 1024 ? `<truncated>${e.slice(-1024)}` : e,
      n = g9.exec(t)
    return n ? n.slice(1) : []
  }
  function hS(...e) {
    let t = '',
      n = !1
    for (let r = e.length - 1; r >= -1 && !n; r--) {
      let s = r >= 0 ? e[r] : '/'
      s && ((t = `${s}/${t}`), (n = s.charAt(0) === '/'))
    }
    return (
      (t = bA(
        t.split('/').filter((r) => !!r),
        !n,
      ).join('/')),
      (n ? '/' : '') + t || '.'
    )
  }
  function SA(e) {
    let t = 0
    for (; t < e.length && e[t] === ''; t++);
    let n = e.length - 1
    for (; n >= 0 && e[n] === ''; n--);
    return t > n ? [] : e.slice(t, n - t + 1)
  }
  function E9(e, t) {
    ;(e = hS(e).slice(1)), (t = hS(t).slice(1))
    let n = SA(e.split('/')),
      r = SA(t.split('/')),
      s = Math.min(n.length, r.length),
      o = s
    for (let c = 0; c < s; c++)
      if (n[c] !== r[c]) {
        o = c
        break
      }
    let i = []
    for (let c = o; c < n.length; c++) i.push('..')
    return (i = i.concat(r.slice(o))), i.join('/')
  }
  function CA(e) {
    let t = wA(e),
      n = e.slice(-1) === '/',
      r = bA(
        e.split('/').filter((s) => !!s),
        !t,
      ).join('/')
    return !r && !t && (r = '.'), r && n && (r += '/'), (t ? '/' : '') + r
  }
  function wA(e) {
    return e.charAt(0) === '/'
  }
  function S9(...e) {
    return CA(e.join('/'))
  }
  function b9(e) {
    let t = vA(e),
      n = t[0],
      r = t[1]
    return !n && !r ? '.' : (r && (r = r.slice(0, r.length - 1)), n + r)
  }
  function v9(e, t) {
    let n = vA(e)[2]
    return (
      t &&
        n.slice(t.length * -1) === t &&
        (n = n.slice(0, n.length - t.length)),
      n
    )
  }
  Zn.basename = v9
  Zn.dirname = b9
  Zn.isAbsolute = wA
  Zn.join = S9
  Zn.normalizePath = CA
  Zn.relative = E9
  Zn.resolve = hS
})
var yS = l((Yc) => {
  Object.defineProperty(Yc, '__esModule', { value: !0 })
  var C9 = en(),
    er
  ;(function (e) {
    e[(e.PENDING = 0)] = 'PENDING'
    let n = 1
    e[(e.RESOLVED = n)] = 'RESOLVED'
    let r = 2
    e[(e.REJECTED = r)] = 'REJECTED'
  })(er || (er = {}))
  function w9(e) {
    return new Vc((t) => {
      t(e)
    })
  }
  function T9(e) {
    return new Vc((t, n) => {
      n(e)
    })
  }
  var Vc = class e {
    constructor(t) {
      e.prototype.__init.call(this),
        e.prototype.__init2.call(this),
        e.prototype.__init3.call(this),
        e.prototype.__init4.call(this),
        (this._state = er.PENDING),
        (this._handlers = [])
      try {
        t(this._resolve, this._reject)
      } catch (n) {
        this._reject(n)
      }
    }
    then(t, n) {
      return new e((r, s) => {
        this._handlers.push([
          !1,
          (o) => {
            if (!t) r(o)
            else
              try {
                r(t(o))
              } catch (i) {
                s(i)
              }
          },
          (o) => {
            if (!n) s(o)
            else
              try {
                r(n(o))
              } catch (i) {
                s(i)
              }
          },
        ]),
          this._executeHandlers()
      })
    }
    catch(t) {
      return this.then((n) => n, t)
    }
    finally(t) {
      return new e((n, r) => {
        let s, o
        return this.then(
          (i) => {
            ;(o = !1), (s = i), t && t()
          },
          (i) => {
            ;(o = !0), (s = i), t && t()
          },
        ).then(() => {
          if (o) {
            r(s)
            return
          }
          n(s)
        })
      })
    }
    __init() {
      this._resolve = (t) => {
        this._setResult(er.RESOLVED, t)
      }
    }
    __init2() {
      this._reject = (t) => {
        this._setResult(er.REJECTED, t)
      }
    }
    __init3() {
      this._setResult = (t, n) => {
        if (this._state === er.PENDING) {
          if (C9.isThenable(n)) {
            n.then(this._resolve, this._reject)
            return
          }
          ;(this._state = t), (this._value = n), this._executeHandlers()
        }
      }
    }
    __init4() {
      this._executeHandlers = () => {
        if (this._state === er.PENDING) return
        let t = this._handlers.slice()
        ;(this._handlers = []),
          t.forEach((n) => {
            n[0] ||
              (this._state === er.RESOLVED && n[1](this._value),
              this._state === er.REJECTED && n[2](this._value),
              (n[0] = !0))
          })
      }
    }
  }
  Yc.SyncPromise = Vc
  Yc.rejectedSyncPromise = T9
  Yc.resolvedSyncPromise = w9
})
var xA = l((ES) => {
  Object.defineProperty(ES, '__esModule', { value: !0 })
  var x9 = ZE(),
    gS = yS()
  function I9(e) {
    let t = []
    function n() {
      return e === void 0 || t.length < e
    }
    function r(i) {
      return t.splice(t.indexOf(i), 1)[0]
    }
    function s(i) {
      if (!n())
        return gS.rejectedSyncPromise(
          new x9.SentryError(
            'Not adding Promise because buffer limit was reached.',
          ),
        )
      let c = i()
      return (
        t.indexOf(c) === -1 && t.push(c),
        c.then(() => r(c)).then(null, () => r(c).then(null, () => {})),
        c
      )
    }
    function o(i) {
      return new gS.SyncPromise((c, a) => {
        let u = t.length
        if (!u) return c(!0)
        let d = setTimeout(() => {
          i && i > 0 && c(!1)
        }, i)
        t.forEach((p) => {
          gS.resolvedSyncPromise(p).then(() => {
            --u || (clearTimeout(d), c(!0))
          }, a)
        })
      })
    }
    return { $: t, add: s, drain: o }
  }
  ES.makePromiseBuffer = I9
})
var SS = l((Ho) => {
  Object.defineProperty(Ho, '__esModule', { value: !0 })
  function P9(e) {
    if (!e) return {}
    let t = e.match(
      /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,
    )
    if (!t) return {}
    let n = t[6] || '',
      r = t[8] || ''
    return {
      host: t[4],
      path: t[5],
      protocol: t[2],
      search: n,
      hash: r,
      relative: t[5] + n + r,
    }
  }
  function R9(e) {
    return e.split(/[\?#]/, 1)[0]
  }
  function D9(e) {
    return e.split(/\\?\//).filter((t) => t.length > 0 && t !== ',').length
  }
  function A9(e) {
    let { protocol: t, host: n, path: r } = e,
      s =
        (n &&
          n
            .replace(/^.*@/, '[filtered]:[filtered]@')
            .replace(':80', '')
            .replace(':443', '')) ||
        ''
    return `${t ? `${t}://` : ''}${s}${r}`
  }
  Ho.getNumberOfUrlSegments = D9
  Ho.getSanitizedUrlString = A9
  Ho.parseUrl = P9
  Ho.stripUrlQueryAndFragment = R9
})
var RA = l((Wo) => {
  Object.defineProperty(Wo, '__esModule', { value: !0 })
  var IA = en(),
    O9 = Pl(),
    N9 = SS(),
    q9 = { ip: !1, request: !0, transaction: !0, user: !0 },
    k9 = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'],
    M9 = ['id', 'username', 'email']
  function F9(e, t, n) {
    e &&
      ((!e.metadata.source || e.metadata.source === 'url') &&
        e.setName(...Rl(t, { path: !0, method: !0 })),
      e.setData('url', t.originalUrl || t.url),
      t.baseUrl && e.setData('baseUrl', t.baseUrl),
      e.setData('query', PA(t, n)))
  }
  function Rl(e, t = {}) {
    let n = e.method && e.method.toUpperCase(),
      r = '',
      s = 'url'
    t.customRoute || e.route
      ? ((r = t.customRoute || `${e.baseUrl || ''}${e.route && e.route.path}`),
        (s = 'route'))
      : (e.originalUrl || e.url) &&
        (r = N9.stripUrlQueryAndFragment(e.originalUrl || e.url || ''))
    let o = ''
    return (
      t.method && n && (o += n),
      t.method && t.path && (o += ' '),
      t.path && r && (o += r),
      [o, s]
    )
  }
  function U9(e, t) {
    switch (t) {
      case 'path':
        return Rl(e, { path: !0 })[0]
      case 'handler':
        return (
          (e.route &&
            e.route.stack &&
            e.route.stack[0] &&
            e.route.stack[0].name) ||
          '<anonymous>'
        )
      case 'methodPath':
      default:
        return Rl(e, { path: !0, method: !0 })[0]
    }
  }
  function L9(e, t) {
    let n = {}
    return (
      (Array.isArray(t) ? t : M9).forEach((s) => {
        e && s in e && (n[s] = e[s])
      }),
      n
    )
  }
  function bS(e, t) {
    let { include: n = k9, deps: r } = t || {},
      s = {},
      o = e.headers || {},
      i = e.method,
      c = e.hostname || e.host || o.host || '<no host>',
      a =
        e.protocol === 'https' || (e.socket && e.socket.encrypted)
          ? 'https'
          : 'http',
      u = e.originalUrl || e.url || '',
      d = `${a}://${c}${u}`
    return (
      n.forEach((p) => {
        switch (p) {
          case 'headers': {
            s.headers = o
            break
          }
          case 'method': {
            s.method = i
            break
          }
          case 'url': {
            s.url = d
            break
          }
          case 'cookies': {
            s.cookies =
              e.cookies ||
              (o.cookie && r && r.cookie && r.cookie.parse(o.cookie)) ||
              {}
            break
          }
          case 'query_string': {
            s.query_string = PA(e, r)
            break
          }
          case 'data': {
            if (i === 'GET' || i === 'HEAD') break
            e.body !== void 0 &&
              (s.data = IA.isString(e.body)
                ? e.body
                : JSON.stringify(O9.normalize(e.body)))
            break
          }
          default:
            ;({}).hasOwnProperty.call(e, p) && (s[p] = e[p])
        }
      }),
      s
    )
  }
  function B9(e, t, n) {
    let r = { ...q9, ...(n && n.include) }
    if (r.request) {
      let s = Array.isArray(r.request)
        ? bS(t, { include: r.request, deps: n && n.deps })
        : bS(t, { deps: n && n.deps })
      e.request = { ...e.request, ...s }
    }
    if (r.user) {
      let s = t.user && IA.isPlainObject(t.user) ? L9(t.user, r.user) : {}
      Object.keys(s).length && (e.user = { ...e.user, ...s })
    }
    if (r.ip) {
      let s = t.ip || (t.socket && t.socket.remoteAddress)
      s && (e.user = { ...e.user, ip_address: s })
    }
    return (
      r.transaction && !e.transaction && (e.transaction = U9(t, r.transaction)),
      e
    )
  }
  function PA(e, t) {
    let n = e.originalUrl || e.url || ''
    if (n)
      return (
        n.startsWith('/') && (n = `http://dogs.are.great${n}`),
        e.query ||
          (typeof URL !== void 0 && new URL(n).search.replace('?', '')) ||
          (t && t.url && t.url.parse(n).query) ||
          void 0
      )
  }
  Wo.addRequestDataToEvent = B9
  Wo.addRequestDataToTransaction = F9
  Wo.extractPathForTransaction = Rl
  Wo.extractRequestData = bS
})
var OA = l((Kc) => {
  Object.defineProperty(Kc, '__esModule', { value: !0 })
  var DA = ['fatal', 'error', 'warning', 'log', 'info', 'debug']
  function j9(e) {
    return AA(e)
  }
  function AA(e) {
    return e === 'warn' ? 'warning' : DA.includes(e) ? e : 'log'
  }
  Kc.severityFromString = j9
  Kc.severityLevelFromString = AA
  Kc.validSeverityLevels = DA
})
var CS = l((Ft, FA) => {
  Object.defineProperty(Ft, '__esModule', { value: !0 })
  var qA = _S(),
    G9 = Qn(),
    kA = G9.getGlobalObject(),
    vS = { nowSeconds: () => Date.now() / 1e3 }
  function $9() {
    let { performance: e } = kA
    if (!e || !e.now) return
    let t = Date.now() - e.now()
    return { now: () => e.now(), timeOrigin: t }
  }
  function z9() {
    try {
      return qA.dynamicRequire(FA, 'perf_hooks').performance
    } catch {
      return
    }
  }
  var Dl = qA.isNodeEnv() ? z9() : $9(),
    NA =
      Dl === void 0
        ? vS
        : { nowSeconds: () => (Dl.timeOrigin + Dl.now()) / 1e3 },
    H9 = vS.nowSeconds.bind(vS),
    MA = NA.nowSeconds.bind(NA),
    W9 = MA,
    V9 = Dl !== void 0
  Ft._browserPerformanceTimeOriginMode = void 0
  var Y9 = (() => {
    let { performance: e } = kA
    if (!e || !e.now) {
      Ft._browserPerformanceTimeOriginMode = 'none'
      return
    }
    let t = 3600 * 1e3,
      n = e.now(),
      r = Date.now(),
      s = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t,
      o = s < t,
      i = e.timing && e.timing.navigationStart,
      a = typeof i == 'number' ? Math.abs(i + n - r) : t,
      u = a < t
    return o || u
      ? s <= a
        ? ((Ft._browserPerformanceTimeOriginMode = 'timeOrigin'), e.timeOrigin)
        : ((Ft._browserPerformanceTimeOriginMode = 'navigationStart'), i)
      : ((Ft._browserPerformanceTimeOriginMode = 'dateNow'), r)
  })()
  Ft.browserPerformanceTimeOrigin = Y9
  Ft.dateTimestampInSeconds = H9
  Ft.timestampInSeconds = MA
  Ft.timestampWithMs = W9
  Ft.usingPerformanceAPI = V9
})
var TS = l((qr) => {
  Object.defineProperty(qr, '__esModule', { value: !0 })
  var K9 = en(),
    J9 = Go(),
    X9 = 'baggage',
    wS = 'sentry-',
    LA = /^sentry-/,
    BA = 8192
  function Q9(e) {
    if (!K9.isString(e) && !Array.isArray(e)) return
    let t = {}
    if (Array.isArray(e))
      t = e.reduce((r, s) => {
        let o = UA(s)
        return { ...r, ...o }
      }, {})
    else {
      if (!e) return
      t = UA(e)
    }
    let n = Object.entries(t).reduce((r, [s, o]) => {
      if (s.match(LA)) {
        let i = s.slice(wS.length)
        r[i] = o
      }
      return r
    }, {})
    if (Object.keys(n).length > 0) return n
  }
  function Z9(e) {
    if (!e) return
    let t = Object.entries(e).reduce(
      (n, [r, s]) => (s && (n[`${wS}${r}`] = s), n),
      {},
    )
    return e7(t)
  }
  function UA(e) {
    return e
      .split(',')
      .map((t) => t.split('=').map((n) => decodeURIComponent(n.trim())))
      .reduce((t, [n, r]) => ((t[n] = r), t), {})
  }
  function e7(e) {
    if (Object.keys(e).length !== 0)
      return Object.entries(e).reduce((t, [n, r], s) => {
        let o = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`,
          i = s === 0 ? o : `${t},${o}`
        return i.length > BA
          ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              J9.logger.warn(
                `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`,
              ),
            t)
          : i
      }, '')
  }
  qr.BAGGAGE_HEADER_NAME = X9
  qr.MAX_BAGGAGE_STRING_LENGTH = BA
  qr.SENTRY_BAGGAGE_KEY_PREFIX = wS
  qr.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = LA
  qr.baggageHeaderToDynamicSamplingContext = Q9
  qr.dynamicSamplingContextToSentryBaggageHeader = Z9
})
var $A = l((Vo) => {
  Object.defineProperty(Vo, '__esModule', { value: !0 })
  var t7 = TS(),
    Al = pS(),
    jA = new RegExp('^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$')
  function GA(e) {
    if (!e) return
    let t = e.match(jA)
    if (!t) return
    let n
    return (
      t[3] === '1' ? (n = !0) : t[3] === '0' && (n = !1),
      { traceId: t[1], parentSampled: n, parentSpanId: t[2] }
    )
  }
  function n7(e, t) {
    let n = GA(e),
      r = t7.baggageHeaderToDynamicSamplingContext(t),
      { traceId: s, parentSpanId: o, parentSampled: i } = n || {},
      c = {
        traceId: s || Al.uuid4(),
        spanId: Al.uuid4().substring(16),
        sampled: i === void 0 ? !1 : i,
      }
    return (
      o && (c.parentSpanId = o),
      r && (c.dsc = r),
      { traceparentData: n, dynamicSamplingContext: r, propagationContext: c }
    )
  }
  function r7(e = Al.uuid4(), t = Al.uuid4().substring(16), n) {
    let r = ''
    return n !== void 0 && (r = n ? '-1' : '-0'), `${e}-${t}${r}`
  }
  Vo.TRACEPARENT_REGEXP = jA
  Vo.extractTraceparentData = GA
  Vo.generateSentryTraceHeader = r7
  Vo.tracingContextFromHeaders = n7
})
var IS = l((Ut) => {
  Object.defineProperty(Ut, '__esModule', { value: !0 })
  var s7 = JE(),
    o7 = Pl(),
    zA = zo()
  function i7(e, t = []) {
    return [e, t]
  }
  function a7(e, t) {
    let [n, r] = e
    return [n, [...r, t]]
  }
  function HA(e, t) {
    let n = e[1]
    for (let r of n) {
      let s = r[0].type
      if (t(r, s)) return !0
    }
    return !1
  }
  function c7(e, t) {
    return HA(e, (n, r) => t.includes(r))
  }
  function xS(e, t) {
    return (t || new TextEncoder()).encode(e)
  }
  function d7(e, t) {
    let [n, r] = e,
      s = JSON.stringify(n)
    function o(i) {
      typeof s == 'string'
        ? (s = typeof i == 'string' ? s + i : [xS(s, t), i])
        : s.push(typeof i == 'string' ? xS(i, t) : i)
    }
    for (let i of r) {
      let [c, a] = i
      if (
        (o(`
${JSON.stringify(c)}
`),
        typeof a == 'string' || a instanceof Uint8Array)
      )
        o(a)
      else {
        let u
        try {
          u = JSON.stringify(a)
        } catch {
          u = JSON.stringify(o7.normalize(a))
        }
        o(u)
      }
    }
    return typeof s == 'string' ? s : u7(s)
  }
  function u7(e) {
    let t = e.reduce((s, o) => s + o.length, 0),
      n = new Uint8Array(t),
      r = 0
    for (let s of e) n.set(s, r), (r += s.length)
    return n
  }
  function l7(e, t, n) {
    let r = typeof e == 'string' ? t.encode(e) : e
    function s(a) {
      let u = r.subarray(0, a)
      return (r = r.subarray(a + 1)), u
    }
    function o() {
      let a = r.indexOf(10)
      return a < 0 && (a = r.length), JSON.parse(n.decode(s(a)))
    }
    let i = o(),
      c = []
    for (; r.length; ) {
      let a = o(),
        u = typeof a.length == 'number' ? a.length : void 0
      c.push([a, u ? s(u) : o()])
    }
    return [i, c]
  }
  function m7(e, t) {
    let n = typeof e.data == 'string' ? xS(e.data, t) : e.data
    return [
      zA.dropUndefinedKeys({
        type: 'attachment',
        length: n.length,
        filename: e.filename,
        content_type: e.contentType,
        attachment_type: e.attachmentType,
      }),
      n,
    ]
  }
  var p7 = {
    session: 'session',
    sessions: 'session',
    attachment: 'attachment',
    transaction: 'transaction',
    event: 'error',
    client_report: 'internal',
    user_report: 'default',
    profile: 'profile',
    replay_event: 'replay',
    replay_recording: 'replay',
    check_in: 'monitor',
  }
  function f7(e) {
    return p7[e]
  }
  function _7(e) {
    if (!e || !e.sdk) return
    let { name: t, version: n } = e.sdk
    return { name: t, version: n }
  }
  function h7(e, t, n, r) {
    let s =
      e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext
    return {
      event_id: e.event_id,
      sent_at: new Date().toISOString(),
      ...(t && { sdk: t }),
      ...(!!n && { dsn: s7.dsnToString(r) }),
      ...(s && { trace: zA.dropUndefinedKeys({ ...s }) }),
    }
  }
  Ut.addItemToEnvelope = a7
  Ut.createAttachmentEnvelopeItem = m7
  Ut.createEnvelope = i7
  Ut.createEventEnvelopeHeaders = h7
  Ut.envelopeContainsItemType = c7
  Ut.envelopeItemTypeToDataCategory = f7
  Ut.forEachEnvelopeItem = HA
  Ut.getSdkMetadataForEnvelopeHeader = _7
  Ut.parseEnvelope = l7
  Ut.serializeEnvelope = d7
})
var WA = l((PS) => {
  Object.defineProperty(PS, '__esModule', { value: !0 })
  var y7 = IS(),
    g7 = CS()
  function E7(e, t, n) {
    let r = [
      { type: 'client_report' },
      { timestamp: n || g7.dateTimestampInSeconds(), discarded_events: e },
    ]
    return y7.createEnvelope(t ? { dsn: t } : {}, [r])
  }
  PS.createClientReportEnvelope = E7
})
var JA = l(($s) => {
  Object.defineProperty($s, '__esModule', { value: !0 })
  var VA = 60 * 1e3
  function YA(e, t = Date.now()) {
    let n = parseInt(`${e}`, 10)
    if (!isNaN(n)) return n * 1e3
    let r = Date.parse(`${e}`)
    return isNaN(r) ? VA : r - t
  }
  function KA(e, t) {
    return e[t] || e.all || 0
  }
  function S7(e, t, n = Date.now()) {
    return KA(e, t) > n
  }
  function b7(e, { statusCode: t, headers: n }, r = Date.now()) {
    let s = { ...e },
      o = n && n['x-sentry-rate-limits'],
      i = n && n['retry-after']
    if (o)
      for (let c of o.trim().split(',')) {
        let [a, u] = c.split(':', 2),
          d = parseInt(a, 10),
          p = (isNaN(d) ? 60 : d) * 1e3
        if (!u) s.all = r + p
        else for (let f of u.split(';')) s[f] = r + p
      }
    else i ? (s.all = r + YA(i, r)) : t === 429 && (s.all = r + 60 * 1e3)
    return s
  }
  $s.DEFAULT_RETRY_AFTER = VA
  $s.disabledUntil = KA
  $s.isRateLimited = S7
  $s.parseRetryAfterHeader = YA
  $s.updateRateLimits = b7
})
var ZA = l((RS) => {
  Object.defineProperty(RS, '__esModule', { value: !0 })
  function XA(e, t, n) {
    let r = t.match(/([a-z_]+)\.(.*)/i)
    if (r === null) e[t] = n
    else {
      let s = e[r[1]]
      XA(s, r[2], n)
    }
  }
  function v7(e, t, n = {}) {
    return Array.isArray(t) ? QA(e, t, n) : C7(e, t, n)
  }
  function QA(e, t, n) {
    let r = t.find((s) => s.name === e.name)
    if (r) {
      for (let [s, o] of Object.entries(n)) XA(r, s, o)
      return t
    }
    return [...t, e]
  }
  function C7(e, t, n) {
    return (s) => {
      let o = t(s)
      return e.allowExclusionByUser && !o.find((c) => c.name === e.name)
        ? o
        : QA(e, o, n)
    }
  }
  RS.addOrUpdateIntegration = v7
})
var eO = l((DS) => {
  Object.defineProperty(DS, '__esModule', { value: !0 })
  function w7(e) {
    let t = [],
      n = {}
    return {
      add(r, s) {
        for (; t.length >= e; ) {
          let o = t.shift()
          o !== void 0 && delete n[o]
        }
        n[r] && this.delete(r), t.push(r), (n[r] = s)
      },
      clear() {
        ;(n = {}), (t = [])
      },
      get(r) {
        return n[r]
      },
      size() {
        return t.length
      },
      delete(r) {
        if (!n[r]) return !1
        delete n[r]
        for (let s = 0; s < t.length; s++)
          if (t[s] === r) {
            t.splice(s, 1)
            break
          }
        return !0
      },
    }
  }
  DS.makeFifoCache = w7
})
var tO = l((AS) => {
  Object.defineProperty(AS, '__esModule', { value: !0 })
  function T7(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')
  }
  AS.escapeStringForRegex = T7
})
var A = l((b) => {
  Object.defineProperty(b, '__esModule', { value: !0 })
  var x7 = VD(),
    OS = KE(),
    NS = JE(),
    I7 = ZE(),
    qS = Qn(),
    kS = _A(),
    pt = en(),
    MS = Go(),
    P7 = lS(),
    kr = pS(),
    FS = _S(),
    US = Pl(),
    tr = zo(),
    zs = TA(),
    R7 = xA(),
    Ol = RA(),
    LS = OA(),
    Jc = hl(),
    Xc = Uc(),
    Mr = oS(),
    BS = yS(),
    Yo = CS(),
    Nl = $A(),
    nO = fS(),
    _n = IS(),
    D7 = WA(),
    Qc = JA(),
    Ko = TS(),
    ql = SS(),
    A7 = ZA(),
    O7 = eO(),
    N7 = tO(),
    q7 = aS()
  b.applyAggregateErrorsToEvent = x7.applyAggregateErrorsToEvent
  b.getDomElement = OS.getDomElement
  b.getLocationHref = OS.getLocationHref
  b.htmlTreeAsString = OS.htmlTreeAsString
  b.dsnFromString = NS.dsnFromString
  b.dsnToString = NS.dsnToString
  b.makeDsn = NS.makeDsn
  b.SentryError = I7.SentryError
  b.GLOBAL_OBJ = qS.GLOBAL_OBJ
  b.getGlobalObject = qS.getGlobalObject
  b.getGlobalSingleton = qS.getGlobalSingleton
  b.SENTRY_XHR_DATA_KEY = kS.SENTRY_XHR_DATA_KEY
  b.addInstrumentationHandler = kS.addInstrumentationHandler
  b.parseFetchArgs = kS.parseFetchArgs
  b.isDOMError = pt.isDOMError
  b.isDOMException = pt.isDOMException
  b.isElement = pt.isElement
  b.isError = pt.isError
  b.isErrorEvent = pt.isErrorEvent
  b.isEvent = pt.isEvent
  b.isInstanceOf = pt.isInstanceOf
  b.isNaN = pt.isNaN
  b.isPlainObject = pt.isPlainObject
  b.isPrimitive = pt.isPrimitive
  b.isRegExp = pt.isRegExp
  b.isString = pt.isString
  b.isSyntheticEvent = pt.isSyntheticEvent
  b.isThenable = pt.isThenable
  b.CONSOLE_LEVELS = MS.CONSOLE_LEVELS
  b.consoleSandbox = MS.consoleSandbox
  Object.defineProperty(b, 'logger', { enumerable: !0, get: () => MS.logger })
  b.memoBuilder = P7.memoBuilder
  b.addContextToFrame = kr.addContextToFrame
  b.addExceptionMechanism = kr.addExceptionMechanism
  b.addExceptionTypeValue = kr.addExceptionTypeValue
  b.arrayify = kr.arrayify
  b.checkOrSetAlreadyCaught = kr.checkOrSetAlreadyCaught
  b.getEventDescription = kr.getEventDescription
  b.parseSemver = kr.parseSemver
  b.uuid4 = kr.uuid4
  b.dynamicRequire = FS.dynamicRequire
  b.isNodeEnv = FS.isNodeEnv
  b.loadModule = FS.loadModule
  b.normalize = US.normalize
  b.normalizeToSize = US.normalizeToSize
  b.walk = US.walk
  b.addNonEnumerableProperty = tr.addNonEnumerableProperty
  b.convertToPlainObject = tr.convertToPlainObject
  b.dropUndefinedKeys = tr.dropUndefinedKeys
  b.extractExceptionKeysForMessage = tr.extractExceptionKeysForMessage
  b.fill = tr.fill
  b.getOriginalFunction = tr.getOriginalFunction
  b.markFunctionWrapped = tr.markFunctionWrapped
  b.objectify = tr.objectify
  b.urlEncode = tr.urlEncode
  b.basename = zs.basename
  b.dirname = zs.dirname
  b.isAbsolute = zs.isAbsolute
  b.join = zs.join
  b.normalizePath = zs.normalizePath
  b.relative = zs.relative
  b.resolve = zs.resolve
  b.makePromiseBuffer = R7.makePromiseBuffer
  b.addRequestDataToEvent = Ol.addRequestDataToEvent
  b.addRequestDataToTransaction = Ol.addRequestDataToTransaction
  b.extractPathForTransaction = Ol.extractPathForTransaction
  b.extractRequestData = Ol.extractRequestData
  b.severityFromString = LS.severityFromString
  b.severityLevelFromString = LS.severityLevelFromString
  b.validSeverityLevels = LS.validSeverityLevels
  b.createStackParser = Jc.createStackParser
  b.getFunctionName = Jc.getFunctionName
  b.nodeStackLineParser = Jc.nodeStackLineParser
  b.stackParserFromStackParserOptions = Jc.stackParserFromStackParserOptions
  b.stripSentryFramesAndReverse = Jc.stripSentryFramesAndReverse
  b.isMatchingPattern = Xc.isMatchingPattern
  b.safeJoin = Xc.safeJoin
  b.snipLine = Xc.snipLine
  b.stringMatchesSomePattern = Xc.stringMatchesSomePattern
  b.truncate = Xc.truncate
  b.isNativeFetch = Mr.isNativeFetch
  b.supportsDOMError = Mr.supportsDOMError
  b.supportsDOMException = Mr.supportsDOMException
  b.supportsErrorEvent = Mr.supportsErrorEvent
  b.supportsFetch = Mr.supportsFetch
  b.supportsNativeFetch = Mr.supportsNativeFetch
  b.supportsReferrerPolicy = Mr.supportsReferrerPolicy
  b.supportsReportingObserver = Mr.supportsReportingObserver
  b.SyncPromise = BS.SyncPromise
  b.rejectedSyncPromise = BS.rejectedSyncPromise
  b.resolvedSyncPromise = BS.resolvedSyncPromise
  Object.defineProperty(b, '_browserPerformanceTimeOriginMode', {
    enumerable: !0,
    get: () => Yo._browserPerformanceTimeOriginMode,
  })
  b.browserPerformanceTimeOrigin = Yo.browserPerformanceTimeOrigin
  b.dateTimestampInSeconds = Yo.dateTimestampInSeconds
  b.timestampInSeconds = Yo.timestampInSeconds
  b.timestampWithMs = Yo.timestampWithMs
  b.usingPerformanceAPI = Yo.usingPerformanceAPI
  b.TRACEPARENT_REGEXP = Nl.TRACEPARENT_REGEXP
  b.extractTraceparentData = Nl.extractTraceparentData
  b.generateSentryTraceHeader = Nl.generateSentryTraceHeader
  b.tracingContextFromHeaders = Nl.tracingContextFromHeaders
  b.getSDKSource = nO.getSDKSource
  b.isBrowserBundle = nO.isBrowserBundle
  b.addItemToEnvelope = _n.addItemToEnvelope
  b.createAttachmentEnvelopeItem = _n.createAttachmentEnvelopeItem
  b.createEnvelope = _n.createEnvelope
  b.createEventEnvelopeHeaders = _n.createEventEnvelopeHeaders
  b.envelopeContainsItemType = _n.envelopeContainsItemType
  b.envelopeItemTypeToDataCategory = _n.envelopeItemTypeToDataCategory
  b.forEachEnvelopeItem = _n.forEachEnvelopeItem
  b.getSdkMetadataForEnvelopeHeader = _n.getSdkMetadataForEnvelopeHeader
  b.parseEnvelope = _n.parseEnvelope
  b.serializeEnvelope = _n.serializeEnvelope
  b.createClientReportEnvelope = D7.createClientReportEnvelope
  b.DEFAULT_RETRY_AFTER = Qc.DEFAULT_RETRY_AFTER
  b.disabledUntil = Qc.disabledUntil
  b.isRateLimited = Qc.isRateLimited
  b.parseRetryAfterHeader = Qc.parseRetryAfterHeader
  b.updateRateLimits = Qc.updateRateLimits
  b.BAGGAGE_HEADER_NAME = Ko.BAGGAGE_HEADER_NAME
  b.MAX_BAGGAGE_STRING_LENGTH = Ko.MAX_BAGGAGE_STRING_LENGTH
  b.SENTRY_BAGGAGE_KEY_PREFIX = Ko.SENTRY_BAGGAGE_KEY_PREFIX
  b.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = Ko.SENTRY_BAGGAGE_KEY_PREFIX_REGEX
  b.baggageHeaderToDynamicSamplingContext =
    Ko.baggageHeaderToDynamicSamplingContext
  b.dynamicSamplingContextToSentryBaggageHeader =
    Ko.dynamicSamplingContextToSentryBaggageHeader
  b.getNumberOfUrlSegments = ql.getNumberOfUrlSegments
  b.getSanitizedUrlString = ql.getSanitizedUrlString
  b.parseUrl = ql.parseUrl
  b.stripUrlQueryAndFragment = ql.stripUrlQueryAndFragment
  b.addOrUpdateIntegration = A7.addOrUpdateIntegration
  b.makeFifoCache = O7.makeFifoCache
  b.escapeStringForRegex = N7.escapeStringForRegex
  b.supportsHistory = q7.supportsHistory
})
var Zc = l((jS) => {
  Object.defineProperty(jS, '__esModule', { value: !0 })
  var k7 = 'production'
  jS.DEFAULT_ENVIRONMENT = k7
})
var nd = l((td) => {
  Object.defineProperty(td, '__esModule', { value: !0 })
  var ed = A()
  function M7(e) {
    let t = ed.timestampInSeconds(),
      n = {
        sid: ed.uuid4(),
        init: !0,
        timestamp: t,
        started: t,
        duration: 0,
        status: 'ok',
        errors: 0,
        ignoreDuration: !1,
        toJSON: () => U7(n),
      }
    return e && GS(n, e), n
  }
  function GS(e, t = {}) {
    if (
      (t.user &&
        (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address),
        !e.did &&
          !t.did &&
          (e.did = t.user.id || t.user.email || t.user.username)),
      (e.timestamp = t.timestamp || ed.timestampInSeconds()),
      t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
      t.sid && (e.sid = t.sid.length === 32 ? t.sid : ed.uuid4()),
      t.init !== void 0 && (e.init = t.init),
      !e.did && t.did && (e.did = `${t.did}`),
      typeof t.started == 'number' && (e.started = t.started),
      e.ignoreDuration)
    )
      e.duration = void 0
    else if (typeof t.duration == 'number') e.duration = t.duration
    else {
      let n = e.timestamp - e.started
      e.duration = n >= 0 ? n : 0
    }
    t.release && (e.release = t.release),
      t.environment && (e.environment = t.environment),
      !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
      !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
      typeof t.errors == 'number' && (e.errors = t.errors),
      t.status && (e.status = t.status)
  }
  function F7(e, t) {
    let n = {}
    t ? (n = { status: t }) : e.status === 'ok' && (n = { status: 'exited' }),
      GS(e, n)
  }
  function U7(e) {
    return ed.dropUndefinedKeys({
      sid: `${e.sid}`,
      init: e.init,
      started: new Date(e.started * 1e3).toISOString(),
      timestamp: new Date(e.timestamp * 1e3).toISOString(),
      status: e.status,
      errors: e.errors,
      did:
        typeof e.did == 'number' || typeof e.did == 'string'
          ? `${e.did}`
          : void 0,
      duration: e.duration,
      attrs: {
        release: e.release,
        environment: e.environment,
        ip_address: e.ipAddress,
        user_agent: e.userAgent,
      },
    })
  }
  td.closeSession = F7
  td.makeSession = M7
  td.updateSession = GS
})
var rd = l((kl) => {
  Object.defineProperty(kl, '__esModule', { value: !0 })
  var nr = A(),
    L7 = nd(),
    B7 = 100,
    $S = class e {
      constructor() {
        ;(this._notifyingListeners = !1),
          (this._scopeListeners = []),
          (this._eventProcessors = []),
          (this._breadcrumbs = []),
          (this._attachments = []),
          (this._user = {}),
          (this._tags = {}),
          (this._extra = {}),
          (this._contexts = {}),
          (this._sdkProcessingMetadata = {}),
          (this._propagationContext = rO())
      }
      static clone(t) {
        let n = new e()
        return (
          t &&
            ((n._breadcrumbs = [...t._breadcrumbs]),
            (n._tags = { ...t._tags }),
            (n._extra = { ...t._extra }),
            (n._contexts = { ...t._contexts }),
            (n._user = t._user),
            (n._level = t._level),
            (n._span = t._span),
            (n._session = t._session),
            (n._transactionName = t._transactionName),
            (n._fingerprint = t._fingerprint),
            (n._eventProcessors = [...t._eventProcessors]),
            (n._requestSession = t._requestSession),
            (n._attachments = [...t._attachments]),
            (n._sdkProcessingMetadata = { ...t._sdkProcessingMetadata }),
            (n._propagationContext = { ...t._propagationContext })),
          n
        )
      }
      addScopeListener(t) {
        this._scopeListeners.push(t)
      }
      addEventProcessor(t) {
        return this._eventProcessors.push(t), this
      }
      setUser(t) {
        return (
          (this._user = t || {}),
          this._session && L7.updateSession(this._session, { user: t }),
          this._notifyScopeListeners(),
          this
        )
      }
      getUser() {
        return this._user
      }
      getRequestSession() {
        return this._requestSession
      }
      setRequestSession(t) {
        return (this._requestSession = t), this
      }
      setTags(t) {
        return (
          (this._tags = { ...this._tags, ...t }),
          this._notifyScopeListeners(),
          this
        )
      }
      setTag(t, n) {
        return (
          (this._tags = { ...this._tags, [t]: n }),
          this._notifyScopeListeners(),
          this
        )
      }
      setExtras(t) {
        return (
          (this._extra = { ...this._extra, ...t }),
          this._notifyScopeListeners(),
          this
        )
      }
      setExtra(t, n) {
        return (
          (this._extra = { ...this._extra, [t]: n }),
          this._notifyScopeListeners(),
          this
        )
      }
      setFingerprint(t) {
        return (this._fingerprint = t), this._notifyScopeListeners(), this
      }
      setLevel(t) {
        return (this._level = t), this._notifyScopeListeners(), this
      }
      setTransactionName(t) {
        return (this._transactionName = t), this._notifyScopeListeners(), this
      }
      setContext(t, n) {
        return (
          n === null ? delete this._contexts[t] : (this._contexts[t] = n),
          this._notifyScopeListeners(),
          this
        )
      }
      setSpan(t) {
        return (this._span = t), this._notifyScopeListeners(), this
      }
      getSpan() {
        return this._span
      }
      getTransaction() {
        let t = this.getSpan()
        return t && t.transaction
      }
      setSession(t) {
        return (
          t ? (this._session = t) : delete this._session,
          this._notifyScopeListeners(),
          this
        )
      }
      getSession() {
        return this._session
      }
      update(t) {
        if (!t) return this
        if (typeof t == 'function') {
          let n = t(this)
          return n instanceof e ? n : this
        }
        return (
          t instanceof e
            ? ((this._tags = { ...this._tags, ...t._tags }),
              (this._extra = { ...this._extra, ...t._extra }),
              (this._contexts = { ...this._contexts, ...t._contexts }),
              t._user && Object.keys(t._user).length && (this._user = t._user),
              t._level && (this._level = t._level),
              t._fingerprint && (this._fingerprint = t._fingerprint),
              t._requestSession && (this._requestSession = t._requestSession),
              t._propagationContext &&
                (this._propagationContext = t._propagationContext))
            : nr.isPlainObject(t) &&
              ((t = t),
              (this._tags = { ...this._tags, ...t.tags }),
              (this._extra = { ...this._extra, ...t.extra }),
              (this._contexts = { ...this._contexts, ...t.contexts }),
              t.user && (this._user = t.user),
              t.level && (this._level = t.level),
              t.fingerprint && (this._fingerprint = t.fingerprint),
              t.requestSession && (this._requestSession = t.requestSession),
              t.propagationContext &&
                (this._propagationContext = t.propagationContext)),
          this
        )
      }
      clear() {
        return (
          (this._breadcrumbs = []),
          (this._tags = {}),
          (this._extra = {}),
          (this._user = {}),
          (this._contexts = {}),
          (this._level = void 0),
          (this._transactionName = void 0),
          (this._fingerprint = void 0),
          (this._requestSession = void 0),
          (this._span = void 0),
          (this._session = void 0),
          this._notifyScopeListeners(),
          (this._attachments = []),
          (this._propagationContext = rO()),
          this
        )
      }
      addBreadcrumb(t, n) {
        let r = typeof n == 'number' ? n : B7
        if (r <= 0) return this
        let s = { timestamp: nr.dateTimestampInSeconds(), ...t }
        return (
          (this._breadcrumbs = [...this._breadcrumbs, s].slice(-r)),
          this._notifyScopeListeners(),
          this
        )
      }
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
      }
      clearBreadcrumbs() {
        return (this._breadcrumbs = []), this._notifyScopeListeners(), this
      }
      addAttachment(t) {
        return this._attachments.push(t), this
      }
      getAttachments() {
        return this._attachments
      }
      clearAttachments() {
        return (this._attachments = []), this
      }
      applyToEvent(t, n = {}) {
        if (
          (this._extra &&
            Object.keys(this._extra).length &&
            (t.extra = { ...this._extra, ...t.extra }),
          this._tags &&
            Object.keys(this._tags).length &&
            (t.tags = { ...this._tags, ...t.tags }),
          this._user &&
            Object.keys(this._user).length &&
            (t.user = { ...this._user, ...t.user }),
          this._contexts &&
            Object.keys(this._contexts).length &&
            (t.contexts = { ...this._contexts, ...t.contexts }),
          this._level && (t.level = this._level),
          this._transactionName && (t.transaction = this._transactionName),
          this._span)
        ) {
          t.contexts = { trace: this._span.getTraceContext(), ...t.contexts }
          let r = this._span.transaction
          if (r) {
            t.sdkProcessingMetadata = {
              dynamicSamplingContext: r.getDynamicSamplingContext(),
              ...t.sdkProcessingMetadata,
            }
            let s = r.name
            s && (t.tags = { transaction: s, ...t.tags })
          }
        }
        return (
          this._applyFingerprint(t),
          (t.breadcrumbs = [...(t.breadcrumbs || []), ...this._breadcrumbs]),
          (t.breadcrumbs = t.breadcrumbs.length > 0 ? t.breadcrumbs : void 0),
          (t.sdkProcessingMetadata = {
            ...t.sdkProcessingMetadata,
            ...this._sdkProcessingMetadata,
            propagationContext: this._propagationContext,
          }),
          this._notifyEventProcessors([...sO(), ...this._eventProcessors], t, n)
        )
      }
      setSDKProcessingMetadata(t) {
        return (
          (this._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata,
            ...t,
          }),
          this
        )
      }
      setPropagationContext(t) {
        return (this._propagationContext = t), this
      }
      getPropagationContext() {
        return this._propagationContext
      }
      _notifyEventProcessors(t, n, r, s = 0) {
        return new nr.SyncPromise((o, i) => {
          let c = t[s]
          if (n === null || typeof c != 'function') o(n)
          else {
            let a = c({ ...n }, r)
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              c.id &&
              a === null &&
              nr.logger.log(`Event processor "${c.id}" dropped event`),
              nr.isThenable(a)
                ? a
                    .then((u) =>
                      this._notifyEventProcessors(t, u, r, s + 1).then(o),
                    )
                    .then(null, i)
                : this._notifyEventProcessors(t, a, r, s + 1)
                    .then(o)
                    .then(null, i)
          }
        })
      }
      _notifyScopeListeners() {
        this._notifyingListeners ||
          ((this._notifyingListeners = !0),
          this._scopeListeners.forEach((t) => {
            t(this)
          }),
          (this._notifyingListeners = !1))
      }
      _applyFingerprint(t) {
        ;(t.fingerprint = t.fingerprint ? nr.arrayify(t.fingerprint) : []),
          this._fingerprint &&
            (t.fingerprint = t.fingerprint.concat(this._fingerprint)),
          t.fingerprint && !t.fingerprint.length && delete t.fingerprint
      }
    }
  function sO() {
    return nr.getGlobalSingleton('globalEventProcessors', () => [])
  }
  function j7(e) {
    sO().push(e)
  }
  function rO() {
    return {
      traceId: nr.uuid4(),
      spanId: nr.uuid4().substring(16),
      sampled: !1,
    }
  }
  kl.Scope = $S
  kl.addGlobalEventProcessor = j7
})
var rn = l((Bt) => {
  Object.defineProperty(Bt, '__esModule', { value: !0 })
  var Lt = A(),
    G7 = Zc(),
    HS = rd(),
    zS = nd(),
    Ml = 4,
    $7 = 100,
    Jo = class {
      constructor(t, n = new HS.Scope(), r = Ml) {
        ;(this._version = r),
          (this._stack = [{ scope: n }]),
          t && this.bindClient(t)
      }
      isOlderThan(t) {
        return this._version < t
      }
      bindClient(t) {
        let n = this.getStackTop()
        ;(n.client = t), t && t.setupIntegrations && t.setupIntegrations()
      }
      pushScope() {
        let t = HS.Scope.clone(this.getScope())
        return this.getStack().push({ client: this.getClient(), scope: t }), t
      }
      popScope() {
        return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
      }
      withScope(t) {
        let n = this.pushScope()
        try {
          t(n)
        } finally {
          this.popScope()
        }
      }
      getClient() {
        return this.getStackTop().client
      }
      getScope() {
        return this.getStackTop().scope
      }
      getStack() {
        return this._stack
      }
      getStackTop() {
        return this._stack[this._stack.length - 1]
      }
      captureException(t, n) {
        let r = (this._lastEventId = n && n.event_id ? n.event_id : Lt.uuid4()),
          s = new Error('Sentry syntheticException')
        return (
          this._withClient((o, i) => {
            o.captureException(
              t,
              {
                originalException: t,
                syntheticException: s,
                ...n,
                event_id: r,
              },
              i,
            )
          }),
          r
        )
      }
      captureMessage(t, n, r) {
        let s = (this._lastEventId = r && r.event_id ? r.event_id : Lt.uuid4()),
          o = new Error(t)
        return (
          this._withClient((i, c) => {
            i.captureMessage(
              t,
              n,
              {
                originalException: t,
                syntheticException: o,
                ...r,
                event_id: s,
              },
              c,
            )
          }),
          s
        )
      }
      captureEvent(t, n) {
        let r = n && n.event_id ? n.event_id : Lt.uuid4()
        return (
          t.type || (this._lastEventId = r),
          this._withClient((s, o) => {
            s.captureEvent(t, { ...n, event_id: r }, o)
          }),
          r
        )
      }
      lastEventId() {
        return this._lastEventId
      }
      addBreadcrumb(t, n) {
        let { scope: r, client: s } = this.getStackTop()
        if (!s) return
        let { beforeBreadcrumb: o = null, maxBreadcrumbs: i = $7 } =
          (s.getOptions && s.getOptions()) || {}
        if (i <= 0) return
        let a = { timestamp: Lt.dateTimestampInSeconds(), ...t },
          u = o ? Lt.consoleSandbox(() => o(a, n)) : a
        u !== null &&
          (s.emit && s.emit('beforeAddBreadcrumb', u, n), r.addBreadcrumb(u, i))
      }
      setUser(t) {
        this.getScope().setUser(t)
      }
      setTags(t) {
        this.getScope().setTags(t)
      }
      setExtras(t) {
        this.getScope().setExtras(t)
      }
      setTag(t, n) {
        this.getScope().setTag(t, n)
      }
      setExtra(t, n) {
        this.getScope().setExtra(t, n)
      }
      setContext(t, n) {
        this.getScope().setContext(t, n)
      }
      configureScope(t) {
        let { scope: n, client: r } = this.getStackTop()
        r && t(n)
      }
      run(t) {
        let n = WS(this)
        try {
          t(this)
        } finally {
          WS(n)
        }
      }
      getIntegration(t) {
        let n = this.getClient()
        if (!n) return null
        try {
          return n.getIntegration(t)
        } catch {
          return (
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Lt.logger.warn(
                `Cannot retrieve integration ${t.id} from the current Hub`,
              ),
            null
          )
        }
      }
      startTransaction(t, n) {
        let r = this._callExtensionMethod('startTransaction', t, n)
        return (
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            !r &&
            console.warn(`Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
`),
          r
        )
      }
      traceHeaders() {
        return this._callExtensionMethod('traceHeaders')
      }
      captureSession(t = !1) {
        if (t) return this.endSession()
        this._sendSessionUpdate()
      }
      endSession() {
        let n = this.getStackTop().scope,
          r = n.getSession()
        r && zS.closeSession(r), this._sendSessionUpdate(), n.setSession()
      }
      startSession(t) {
        let { scope: n, client: r } = this.getStackTop(),
          { release: s, environment: o = G7.DEFAULT_ENVIRONMENT } =
            (r && r.getOptions()) || {},
          { userAgent: i } = Lt.GLOBAL_OBJ.navigator || {},
          c = zS.makeSession({
            release: s,
            environment: o,
            user: n.getUser(),
            ...(i && { userAgent: i }),
            ...t,
          }),
          a = n.getSession && n.getSession()
        return (
          a && a.status === 'ok' && zS.updateSession(a, { status: 'exited' }),
          this.endSession(),
          n.setSession(c),
          c
        )
      }
      shouldSendDefaultPii() {
        let t = this.getClient(),
          n = t && t.getOptions()
        return !!(n && n.sendDefaultPii)
      }
      _sendSessionUpdate() {
        let { scope: t, client: n } = this.getStackTop(),
          r = t.getSession()
        r && n && n.captureSession && n.captureSession(r)
      }
      _withClient(t) {
        let { scope: n, client: r } = this.getStackTop()
        r && t(r, n)
      }
      _callExtensionMethod(t, ...n) {
        let s = Hs().__SENTRY__
        if (s && s.extensions && typeof s.extensions[t] == 'function')
          return s.extensions[t].apply(this, n)
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Lt.logger.warn(
            `Extension method ${t} couldn't be found, doing nothing.`,
          )
      }
    }
  function Hs() {
    return (
      (Lt.GLOBAL_OBJ.__SENTRY__ = Lt.GLOBAL_OBJ.__SENTRY__ || {
        extensions: {},
        hub: void 0,
      }),
      Lt.GLOBAL_OBJ
    )
  }
  function WS(e) {
    let t = Hs(),
      n = sd(t)
    return Fl(t, e), n
  }
  function z7() {
    let e = Hs()
    if (e.__SENTRY__ && e.__SENTRY__.acs) {
      let t = e.__SENTRY__.acs.getCurrentHub()
      if (t) return t
    }
    return oO(e)
  }
  function oO(e = Hs()) {
    return (!iO(e) || sd(e).isOlderThan(Ml)) && Fl(e, new Jo()), sd(e)
  }
  function H7(e, t = oO()) {
    if (!iO(e) || sd(e).isOlderThan(Ml)) {
      let n = t.getStackTop()
      Fl(e, new Jo(n.client, HS.Scope.clone(n.scope)))
    }
  }
  function W7(e) {
    let t = Hs()
    ;(t.__SENTRY__ = t.__SENTRY__ || {}), (t.__SENTRY__.acs = e)
  }
  function V7(e, t = {}) {
    let n = Hs()
    return n.__SENTRY__ && n.__SENTRY__.acs
      ? n.__SENTRY__.acs.runWithAsyncContext(e, t)
      : e()
  }
  function iO(e) {
    return !!(e && e.__SENTRY__ && e.__SENTRY__.hub)
  }
  function sd(e) {
    return Lt.getGlobalSingleton('hub', () => new Jo(), e)
  }
  function Fl(e, t) {
    if (!e) return !1
    let n = (e.__SENTRY__ = e.__SENTRY__ || {})
    return (n.hub = t), !0
  }
  Bt.API_VERSION = Ml
  Bt.Hub = Jo
  Bt.ensureHubOnCarrier = H7
  Bt.getCurrentHub = z7
  Bt.getHubFromCarrier = sd
  Bt.getMainCarrier = Hs
  Bt.makeMain = WS
  Bt.runWithAsyncContext = V7
  Bt.setAsyncContextStrategy = W7
  Bt.setHubOnCarrier = Fl
})
var Ul = l((VS) => {
  Object.defineProperty(VS, '__esModule', { value: !0 })
  var Y7 = rn()
  function K7(e) {
    if (typeof __SENTRY_TRACING__ == 'boolean' && !__SENTRY_TRACING__) return !1
    let t = Y7.getCurrentHub().getClient(),
      n = e || (t && t.getOptions())
    return (
      !!n &&
      (n.enableTracing || 'tracesSampleRate' in n || 'tracesSampler' in n)
    )
  }
  VS.hasTracingEnabled = K7
})
var Ll = l((Xo) => {
  Object.defineProperty(Xo, '__esModule', { value: !0 })
  var J7 = rn(),
    YS = A()
  function X7(e) {
    return (e || J7.getCurrentHub()).getScope().getTransaction()
  }
  Xo.TRACEPARENT_REGEXP = YS.TRACEPARENT_REGEXP
  Xo.extractTraceparentData = YS.extractTraceparentData
  Xo.stripUrlQueryAndFragment = YS.stripUrlQueryAndFragment
  Xo.getActiveTransaction = X7
})
var cO = l((XS) => {
  Object.defineProperty(XS, '__esModule', { value: !0 })
  var KS = A(),
    Q7 = Ll(),
    aO = !1
  function Z7() {
    aO ||
      ((aO = !0),
      KS.addInstrumentationHandler('error', JS),
      KS.addInstrumentationHandler('unhandledrejection', JS))
  }
  function JS() {
    let e = Q7.getActiveTransaction()
    if (e) {
      let t = 'internal_error'
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        KS.logger.log(`[Tracing] Transaction: ${t} -> Global error occured`),
        e.setStatus(t)
    }
  }
  JS.tag = 'sentry_tracingErrorCallback'
  XS.registerErrorInstrumentation = Z7
})
var Bl = l((od) => {
  Object.defineProperty(od, '__esModule', { value: !0 })
  var hn = A(),
    QS = class {
      constructor(t = 1e3) {
        ;(this._maxlen = t), (this.spans = [])
      }
      add(t) {
        this.spans.length > this._maxlen
          ? (t.spanRecorder = void 0)
          : this.spans.push(t)
      }
    },
    ZS = class e {
      constructor(t) {
        if (
          ((this.traceId = hn.uuid4()),
          (this.spanId = hn.uuid4().substring(16)),
          (this.startTimestamp = hn.timestampInSeconds()),
          (this.tags = {}),
          (this.data = {}),
          (this.instrumenter = 'sentry'),
          !t)
        )
          return this
        t.traceId && (this.traceId = t.traceId),
          t.spanId && (this.spanId = t.spanId),
          t.parentSpanId && (this.parentSpanId = t.parentSpanId),
          'sampled' in t && (this.sampled = t.sampled),
          t.op && (this.op = t.op),
          t.description && (this.description = t.description),
          t.name && (this.description = t.name),
          t.data && (this.data = t.data),
          t.tags && (this.tags = t.tags),
          t.status && (this.status = t.status),
          t.startTimestamp && (this.startTimestamp = t.startTimestamp),
          t.endTimestamp && (this.endTimestamp = t.endTimestamp),
          t.instrumenter && (this.instrumenter = t.instrumenter)
      }
      startChild(t) {
        let n = new e({
          ...t,
          parentSpanId: this.spanId,
          sampled: this.sampled,
          traceId: this.traceId,
        })
        if (
          ((n.spanRecorder = this.spanRecorder),
          n.spanRecorder && n.spanRecorder.add(n),
          (n.transaction = this.transaction),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) && n.transaction)
        ) {
          let r = (t && t.op) || '< unknown op >',
            s = n.transaction.name || '< unknown name >',
            o = n.transaction.spanId,
            i = `[Tracing] Starting '${r}' span on transaction '${s}' (${o}).`
          ;(n.transaction.metadata.spanMetadata[n.spanId] = { logMessage: i }),
            hn.logger.log(i)
        }
        return n
      }
      setTag(t, n) {
        return (this.tags = { ...this.tags, [t]: n }), this
      }
      setData(t, n) {
        return (this.data = { ...this.data, [t]: n }), this
      }
      setStatus(t) {
        return (this.status = t), this
      }
      setHttpStatus(t) {
        this.setTag('http.status_code', String(t)),
          this.setData('http.response.status_code', t)
        let n = dO(t)
        return n !== 'unknown_error' && this.setStatus(n), this
      }
      setName(t) {
        this.description = t
      }
      isSuccess() {
        return this.status === 'ok'
      }
      finish(t) {
        if (
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          this.transaction &&
          this.transaction.spanId !== this.spanId
        ) {
          let { logMessage: n } =
            this.transaction.metadata.spanMetadata[this.spanId]
          n && hn.logger.log(n.replace('Starting', 'Finishing'))
        }
        this.endTimestamp = typeof t == 'number' ? t : hn.timestampInSeconds()
      }
      toTraceparent() {
        return hn.generateSentryTraceHeader(
          this.traceId,
          this.spanId,
          this.sampled,
        )
      }
      toContext() {
        return hn.dropUndefinedKeys({
          data: this.data,
          description: this.description,
          endTimestamp: this.endTimestamp,
          op: this.op,
          parentSpanId: this.parentSpanId,
          sampled: this.sampled,
          spanId: this.spanId,
          startTimestamp: this.startTimestamp,
          status: this.status,
          tags: this.tags,
          traceId: this.traceId,
        })
      }
      updateWithContext(t) {
        return (
          (this.data = t.data || {}),
          (this.description = t.description),
          (this.endTimestamp = t.endTimestamp),
          (this.op = t.op),
          (this.parentSpanId = t.parentSpanId),
          (this.sampled = t.sampled),
          (this.spanId = t.spanId || this.spanId),
          (this.startTimestamp = t.startTimestamp || this.startTimestamp),
          (this.status = t.status),
          (this.tags = t.tags || {}),
          (this.traceId = t.traceId || this.traceId),
          this
        )
      }
      getTraceContext() {
        return hn.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          trace_id: this.traceId,
        })
      }
      toJSON() {
        return hn.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : void 0,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          start_timestamp: this.startTimestamp,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
          timestamp: this.endTimestamp,
          trace_id: this.traceId,
        })
      }
    }
  function dO(e) {
    if (e < 400 && e >= 100) return 'ok'
    if (e >= 400 && e < 500)
      switch (e) {
        case 401:
          return 'unauthenticated'
        case 403:
          return 'permission_denied'
        case 404:
          return 'not_found'
        case 409:
          return 'already_exists'
        case 413:
          return 'failed_precondition'
        case 429:
          return 'resource_exhausted'
        default:
          return 'invalid_argument'
      }
    if (e >= 500 && e < 600)
      switch (e) {
        case 501:
          return 'unimplemented'
        case 503:
          return 'unavailable'
        case 504:
          return 'deadline_exceeded'
        default:
          return 'internal_error'
      }
    return 'unknown_error'
  }
  od.Span = ZS
  od.SpanRecorder = QS
  od.spanStatusfromHttpCode = dO
})
var jl = l((eb) => {
  Object.defineProperty(eb, '__esModule', { value: !0 })
  var eJ = A(),
    tJ = Zc()
  function nJ(e, t, n) {
    let r = t.getOptions(),
      { publicKey: s } = t.getDsn() || {},
      { segment: o } = (n && n.getUser()) || {},
      i = eJ.dropUndefinedKeys({
        environment: r.environment || tJ.DEFAULT_ENVIRONMENT,
        release: r.release,
        user_segment: o,
        public_key: s,
        trace_id: e,
      })
    return t.emit && t.emit('createDsc', i), i
  }
  eb.getDynamicSamplingContextFromClient = nJ
})
var Gl = l((nb) => {
  Object.defineProperty(nb, '__esModule', { value: !0 })
  var id = A(),
    uO = rn(),
    rJ = jl(),
    lO = Bl(),
    tb = class extends lO.Span {
      constructor(t, n) {
        super(t),
          delete this.description,
          (this._measurements = {}),
          (this._contexts = {}),
          (this._hub = n || uO.getCurrentHub()),
          (this._name = t.name || ''),
          (this.metadata = {
            source: 'custom',
            ...t.metadata,
            spanMetadata: {},
          }),
          (this._trimEnd = t.trimEnd),
          (this.transaction = this)
        let r = this.metadata.dynamicSamplingContext
        r && (this._frozenDynamicSamplingContext = { ...r })
      }
      get name() {
        return this._name
      }
      set name(t) {
        this.setName(t)
      }
      setName(t, n = 'custom') {
        ;(this._name = t), (this.metadata.source = n)
      }
      initSpanRecorder(t = 1e3) {
        this.spanRecorder || (this.spanRecorder = new lO.SpanRecorder(t)),
          this.spanRecorder.add(this)
      }
      setContext(t, n) {
        n === null ? delete this._contexts[t] : (this._contexts[t] = n)
      }
      setMeasurement(t, n, r = '') {
        this._measurements[t] = { value: n, unit: r }
      }
      setMetadata(t) {
        this.metadata = { ...this.metadata, ...t }
      }
      finish(t) {
        if (this.endTimestamp !== void 0) return
        this.name ||
          ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            id.logger.warn(
              'Transaction has no name, falling back to `<unlabeled transaction>`.',
            ),
          (this.name = '<unlabeled transaction>')),
          super.finish(t)
        let n = this._hub.getClient()
        if (
          (n && n.emit && n.emit('finishTransaction', this),
          this.sampled !== !0)
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            id.logger.log(
              '[Tracing] Discarding transaction because its trace was not chosen to be sampled.',
            ),
            n && n.recordDroppedEvent('sample_rate', 'transaction')
          return
        }
        let r = this.spanRecorder
          ? this.spanRecorder.spans.filter((c) => c !== this && c.endTimestamp)
          : []
        this._trimEnd &&
          r.length > 0 &&
          (this.endTimestamp = r.reduce((c, a) =>
            c.endTimestamp && a.endTimestamp
              ? c.endTimestamp > a.endTimestamp
                ? c
                : a
              : c,
          ).endTimestamp)
        let s = this.metadata,
          o = {
            contexts: { ...this._contexts, trace: this.getTraceContext() },
            spans: r,
            start_timestamp: this.startTimestamp,
            tags: this.tags,
            timestamp: this.endTimestamp,
            transaction: this.name,
            type: 'transaction',
            sdkProcessingMetadata: {
              ...s,
              dynamicSamplingContext: this.getDynamicSamplingContext(),
            },
            ...(s.source && { transaction_info: { source: s.source } }),
          }
        return (
          Object.keys(this._measurements).length > 0 &&
            ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              id.logger.log(
                '[Measurements] Adding measurements to transaction',
                JSON.stringify(this._measurements, void 0, 2),
              ),
            (o.measurements = this._measurements)),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            id.logger.log(
              `[Tracing] Finishing ${this.op} transaction: ${this.name}.`,
            ),
          this._hub.captureEvent(o)
        )
      }
      toContext() {
        let t = super.toContext()
        return id.dropUndefinedKeys({
          ...t,
          name: this.name,
          trimEnd: this._trimEnd,
        })
      }
      updateWithContext(t) {
        return (
          super.updateWithContext(t),
          (this.name = t.name || ''),
          (this._trimEnd = t.trimEnd),
          this
        )
      }
      getDynamicSamplingContext() {
        if (this._frozenDynamicSamplingContext)
          return this._frozenDynamicSamplingContext
        let t = this._hub || uO.getCurrentHub(),
          n = t.getClient()
        if (!n) return {}
        let r = t.getScope(),
          s = rJ.getDynamicSamplingContextFromClient(this.traceId, n, r),
          o = this.metadata.sampleRate
        o !== void 0 && (s.sample_rate = `${o}`)
        let i = this.metadata.source
        return (
          i && i !== 'url' && (s.transaction = this.name),
          this.sampled !== void 0 && (s.sampled = String(this.sampled)),
          s
        )
      }
      setHub(t) {
        this._hub = t
      }
    }
  nb.Transaction = tb
})
var sb = l((ad) => {
  Object.defineProperty(ad, '__esModule', { value: !0 })
  var $e = A(),
    sJ = Bl(),
    oJ = Gl(),
    $l = { idleTimeout: 1e3, finalTimeout: 3e4, heartbeatInterval: 5e3 },
    iJ = 'finishReason',
    Qo = [
      'heartbeatFailed',
      'idleTimeout',
      'documentHidden',
      'finalTimeout',
      'externalFinish',
      'cancelled',
    ],
    zl = class extends sJ.SpanRecorder {
      constructor(t, n, r, s) {
        super(s),
          (this._pushActivity = t),
          (this._popActivity = n),
          (this.transactionSpanId = r)
      }
      add(t) {
        t.spanId !== this.transactionSpanId &&
          ((t.finish = (n) => {
            ;(t.endTimestamp =
              typeof n == 'number' ? n : $e.timestampInSeconds()),
              this._popActivity(t.spanId)
          }),
          t.endTimestamp === void 0 && this._pushActivity(t.spanId)),
          super.add(t)
      }
    },
    rb = class extends oJ.Transaction {
      constructor(
        t,
        n,
        r = $l.idleTimeout,
        s = $l.finalTimeout,
        o = $l.heartbeatInterval,
        i = !1,
      ) {
        super(t, n),
          (this._idleHub = n),
          (this._idleTimeout = r),
          (this._finalTimeout = s),
          (this._heartbeatInterval = o),
          (this._onScope = i),
          (this.activities = {}),
          (this._heartbeatCounter = 0),
          (this._finished = !1),
          (this._idleTimeoutCanceledPermanently = !1),
          (this._beforeFinishCallbacks = []),
          (this._finishReason = Qo[4]),
          i &&
            ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              $e.logger.log(
                `Setting idle transaction on scope. Span ID: ${this.spanId}`,
              ),
            n.configureScope((c) => c.setSpan(this))),
          this._restartIdleTimeout(),
          setTimeout(() => {
            this._finished ||
              (this.setStatus('deadline_exceeded'),
              (this._finishReason = Qo[3]),
              this.finish())
          }, this._finalTimeout)
      }
      finish(t = $e.timestampInSeconds()) {
        if (
          ((this._finished = !0),
          (this.activities = {}),
          this.op === 'ui.action.click' && this.setTag(iJ, this._finishReason),
          this.spanRecorder)
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            $e.logger.log(
              '[Tracing] finishing IdleTransaction',
              new Date(t * 1e3).toISOString(),
              this.op,
            )
          for (let n of this._beforeFinishCallbacks) n(this, t)
          ;(this.spanRecorder.spans = this.spanRecorder.spans.filter((n) => {
            if (n.spanId === this.spanId) return !0
            n.endTimestamp ||
              ((n.endTimestamp = t),
              n.setStatus('cancelled'),
              (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                $e.logger.log(
                  '[Tracing] cancelling span since transaction ended early',
                  JSON.stringify(n, void 0, 2),
                ))
            let r = n.startTimestamp < t,
              s = (this._finalTimeout + this._idleTimeout) / 1e3,
              o = n.endTimestamp - this.startTimestamp < s
            if (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) {
              let i = JSON.stringify(n, void 0, 2)
              r
                ? o ||
                  $e.logger.log(
                    '[Tracing] discarding Span since it finished after Transaction final timeout',
                    i,
                  )
                : $e.logger.log(
                    '[Tracing] discarding Span since it happened after Transaction was finished',
                    i,
                  )
            }
            return r && o
          })),
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              $e.logger.log('[Tracing] flushing IdleTransaction')
        } else
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            $e.logger.log('[Tracing] No active IdleTransaction')
        if (this._onScope) {
          let n = this._idleHub.getScope()
          n.getTransaction() === this && n.setSpan(void 0)
        }
        return super.finish(t)
      }
      registerBeforeFinishCallback(t) {
        this._beforeFinishCallbacks.push(t)
      }
      initSpanRecorder(t) {
        if (!this.spanRecorder) {
          let n = (s) => {
              this._finished || this._pushActivity(s)
            },
            r = (s) => {
              this._finished || this._popActivity(s)
            }
          ;(this.spanRecorder = new zl(n, r, this.spanId, t)),
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              $e.logger.log('Starting heartbeat'),
            this._pingHeartbeat()
        }
        this.spanRecorder.add(this)
      }
      cancelIdleTimeout(
        t,
        { restartOnChildSpanChange: n } = { restartOnChildSpanChange: !0 },
      ) {
        ;(this._idleTimeoutCanceledPermanently = n === !1),
          this._idleTimeoutID &&
            (clearTimeout(this._idleTimeoutID),
            (this._idleTimeoutID = void 0),
            Object.keys(this.activities).length === 0 &&
              this._idleTimeoutCanceledPermanently &&
              ((this._finishReason = Qo[5]), this.finish(t)))
      }
      setFinishReason(t) {
        this._finishReason = t
      }
      _restartIdleTimeout(t) {
        this.cancelIdleTimeout(),
          (this._idleTimeoutID = setTimeout(() => {
            !this._finished &&
              Object.keys(this.activities).length === 0 &&
              ((this._finishReason = Qo[1]), this.finish(t))
          }, this._idleTimeout))
      }
      _pushActivity(t) {
        this.cancelIdleTimeout(void 0, {
          restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently,
        }),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            $e.logger.log(`[Tracing] pushActivity: ${t}`),
          (this.activities[t] = !0),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            $e.logger.log(
              '[Tracing] new activities count',
              Object.keys(this.activities).length,
            )
      }
      _popActivity(t) {
        if (
          (this.activities[t] &&
            ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              $e.logger.log(`[Tracing] popActivity ${t}`),
            delete this.activities[t],
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              $e.logger.log(
                '[Tracing] new activities count',
                Object.keys(this.activities).length,
              )),
          Object.keys(this.activities).length === 0)
        ) {
          let n = $e.timestampInSeconds()
          this._idleTimeoutCanceledPermanently
            ? ((this._finishReason = Qo[5]), this.finish(n))
            : this._restartIdleTimeout(n + this._idleTimeout / 1e3)
        }
      }
      _beat() {
        if (this._finished) return
        let t = Object.keys(this.activities).join('')
        t === this._prevHeartbeatString
          ? this._heartbeatCounter++
          : (this._heartbeatCounter = 1),
          (this._prevHeartbeatString = t),
          this._heartbeatCounter >= 3
            ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                $e.logger.log(
                  '[Tracing] Transaction finished because of no change for 3 heart beats',
                ),
              this.setStatus('deadline_exceeded'),
              (this._finishReason = Qo[0]),
              this.finish())
            : this._pingHeartbeat()
      }
      _pingHeartbeat() {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          $e.logger.log(
            `pinging Heartbeat -> current counter: ${this._heartbeatCounter}`,
          ),
          setTimeout(() => {
            this._beat()
          }, this._heartbeatInterval)
      }
    }
  ad.IdleTransaction = rb
  ad.IdleTransactionSpanRecorder = zl
  ad.TRACING_DEFAULTS = $l
})
var pO = l((Hl) => {
  Object.defineProperty(Hl, '__esModule', { value: !0 })
  var Fr = A(),
    aJ = rn(),
    cJ = Ul(),
    dJ = cO(),
    uJ = sb(),
    lJ = Gl()
  function mJ() {
    let t = this.getScope().getSpan()
    return t ? { 'sentry-trace': t.toTraceparent() } : {}
  }
  function mO(e, t, n) {
    if (!cJ.hasTracingEnabled(t)) return (e.sampled = !1), e
    if (e.sampled !== void 0)
      return e.setMetadata({ sampleRate: Number(e.sampled) }), e
    let r
    return (
      typeof t.tracesSampler == 'function'
        ? ((r = t.tracesSampler(n)), e.setMetadata({ sampleRate: Number(r) }))
        : n.parentSampled !== void 0
        ? (r = n.parentSampled)
        : typeof t.tracesSampleRate < 'u'
        ? ((r = t.tracesSampleRate), e.setMetadata({ sampleRate: Number(r) }))
        : ((r = 1), e.setMetadata({ sampleRate: r })),
      pJ(r)
        ? r
          ? ((e.sampled = Math.random() < r),
            e.sampled
              ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  Fr.logger.log(
                    `[Tracing] starting ${e.op} transaction - ${e.name}`,
                  ),
                e)
              : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  Fr.logger.log(
                    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
                      r,
                    )})`,
                  ),
                e))
          : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Fr.logger.log(
                `[Tracing] Discarding transaction because ${
                  typeof t.tracesSampler == 'function'
                    ? 'tracesSampler returned 0 or false'
                    : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'
                }`,
              ),
            (e.sampled = !1),
            e)
        : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Fr.logger.warn(
              '[Tracing] Discarding transaction because of invalid sample rate.',
            ),
          (e.sampled = !1),
          e)
    )
  }
  function pJ(e) {
    return Fr.isNaN(e) || !(typeof e == 'number' || typeof e == 'boolean')
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Fr.logger.warn(
            `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
              e,
            )} of type ${JSON.stringify(typeof e)}.`,
          ),
        !1)
      : e < 0 || e > 1
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Fr.logger.warn(
            `[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${e}.`,
          ),
        !1)
      : !0
  }
  function fJ(e, t) {
    let n = this.getClient(),
      r = (n && n.getOptions()) || {},
      s = r.instrumenter || 'sentry',
      o = e.instrumenter || 'sentry'
    s !== o &&
      ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Fr.logger
          .error(`A transaction was started with instrumenter=\`${o}\`, but the SDK is configured with the \`${s}\` instrumenter.
The transaction will not be sampled. Please use the ${s} instrumentation to start transactions.`),
      (e.sampled = !1))
    let i = new lJ.Transaction(e, this)
    return (
      (i = mO(i, r, {
        parentSampled: e.parentSampled,
        transactionContext: e,
        ...t,
      })),
      i.sampled &&
        i.initSpanRecorder(r._experiments && r._experiments.maxSpans),
      n && n.emit && n.emit('startTransaction', i),
      i
    )
  }
  function _J(e, t, n, r, s, o, i) {
    let c = e.getClient(),
      a = (c && c.getOptions()) || {},
      u = new uJ.IdleTransaction(t, e, n, r, i, s)
    return (
      (u = mO(u, a, {
        parentSampled: t.parentSampled,
        transactionContext: t,
        ...o,
      })),
      u.sampled &&
        u.initSpanRecorder(a._experiments && a._experiments.maxSpans),
      c && c.emit && c.emit('startTransaction', u),
      u
    )
  }
  function hJ() {
    let e = aJ.getMainCarrier()
    e.__SENTRY__ &&
      ((e.__SENTRY__.extensions = e.__SENTRY__.extensions || {}),
      e.__SENTRY__.extensions.startTransaction ||
        (e.__SENTRY__.extensions.startTransaction = fJ),
      e.__SENTRY__.extensions.traceHeaders ||
        (e.__SENTRY__.extensions.traceHeaders = mJ),
      dJ.registerErrorInstrumentation())
  }
  Hl.addTracingExtensions = hJ
  Hl.startIdleTransaction = _J
})
var fO = l((cd) => {
  Object.defineProperty(cd, '__esModule', { value: !0 })
  cd.SpanStatus = void 0
  ;(function (e) {
    let t = 'ok'
    e.Ok = t
    let n = 'deadline_exceeded'
    e.DeadlineExceeded = n
    let r = 'unauthenticated'
    e.Unauthenticated = r
    let s = 'permission_denied'
    e.PermissionDenied = s
    let o = 'not_found'
    e.NotFound = o
    let i = 'resource_exhausted'
    e.ResourceExhausted = i
    let c = 'invalid_argument'
    e.InvalidArgument = c
    let a = 'unimplemented'
    e.Unimplemented = a
    let u = 'unavailable'
    e.Unavailable = u
    let d = 'internal_error'
    e.InternalError = d
    let p = 'unknown_error'
    e.UnknownError = p
    let f = 'cancelled'
    e.Cancelled = f
    let _ = 'already_exists'
    e.AlreadyExists = _
    let h = 'failed_precondition'
    e.FailedPrecondition = h
    let g = 'aborted'
    e.Aborted = g
    let E = 'out_of_range'
    e.OutOfRange = E
    let P = 'data_loss'
    e.DataLoss = P
  })(cd.SpanStatus || (cd.SpanStatus = {}))
})
var _O = l((ob) => {
  Object.defineProperty(ob, '__esModule', { value: !0 })
  var yJ = A(),
    gJ = rn(),
    EJ = Ul()
  function SJ(e, t, n = () => {}) {
    let r = { ...e }
    r.name !== void 0 && r.description === void 0 && (r.description = r.name)
    let s = gJ.getCurrentHub(),
      o = s.getScope(),
      i = o.getSpan()
    function c() {
      if (EJ.hasTracingEnabled())
        return i ? i.startChild(r) : s.startTransaction(r)
    }
    let a = c()
    o.setSpan(a)
    function u() {
      a && a.finish(), s.getScope().setSpan(i)
    }
    let d
    try {
      d = t(a)
    } catch (p) {
      throw (a && a.setStatus('internal_error'), n(p), u(), p)
    }
    return (
      yJ.isThenable(d)
        ? Promise.resolve(d).then(
            () => {
              u()
            },
            (p) => {
              a && a.setStatus('internal_error'), n(p), u()
            },
          )
        : u(),
      d
    )
  }
  ob.trace = SJ
})
var hO = l((ib) => {
  Object.defineProperty(ib, '__esModule', { value: !0 })
  var bJ = Ll()
  function vJ(e, t, n) {
    let r = bJ.getActiveTransaction()
    r && r.setMeasurement(e, t, n)
  }
  ib.setMeasurement = vJ
})
var yO = l((Me) => {
  Object.defineProperty(Me, '__esModule', { value: !0 })
  var dd = A(),
    ze = rn()
  function CJ(e, t) {
    return ze.getCurrentHub().captureException(e, { captureContext: t })
  }
  function wJ(e, t) {
    let n = typeof t == 'string' ? t : void 0,
      r = typeof t != 'string' ? { captureContext: t } : void 0
    return ze.getCurrentHub().captureMessage(e, n, r)
  }
  function TJ(e, t) {
    return ze.getCurrentHub().captureEvent(e, t)
  }
  function xJ(e) {
    ze.getCurrentHub().configureScope(e)
  }
  function IJ(e) {
    ze.getCurrentHub().addBreadcrumb(e)
  }
  function PJ(e, t) {
    ze.getCurrentHub().setContext(e, t)
  }
  function RJ(e) {
    ze.getCurrentHub().setExtras(e)
  }
  function DJ(e, t) {
    ze.getCurrentHub().setExtra(e, t)
  }
  function AJ(e) {
    ze.getCurrentHub().setTags(e)
  }
  function OJ(e, t) {
    ze.getCurrentHub().setTag(e, t)
  }
  function NJ(e) {
    ze.getCurrentHub().setUser(e)
  }
  function qJ(e) {
    ze.getCurrentHub().withScope(e)
  }
  function kJ(e, t) {
    return ze.getCurrentHub().startTransaction({ ...e }, t)
  }
  function MJ(e, t) {
    let n = ze.getCurrentHub(),
      r = n.getScope(),
      s = n.getClient()
    if (!s)
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        dd.logger.warn('Cannot capture check-in. No client defined.')
    else if (!s.captureCheckIn)
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        dd.logger.warn(
          'Cannot capture check-in. Client does not support sending check-ins.',
        )
    else return s.captureCheckIn(e, t, r)
    return dd.uuid4()
  }
  async function FJ(e) {
    let t = ze.getCurrentHub().getClient()
    return t
      ? t.flush(e)
      : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          dd.logger.warn('Cannot flush events. No client defined.'),
        Promise.resolve(!1))
  }
  async function UJ(e) {
    let t = ze.getCurrentHub().getClient()
    return t
      ? t.close(e)
      : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          dd.logger.warn(
            'Cannot flush events and disable SDK. No client defined.',
          ),
        Promise.resolve(!1))
  }
  function LJ() {
    return ze.getCurrentHub().lastEventId()
  }
  Me.addBreadcrumb = IJ
  Me.captureCheckIn = MJ
  Me.captureEvent = TJ
  Me.captureException = CJ
  Me.captureMessage = wJ
  Me.close = UJ
  Me.configureScope = xJ
  Me.flush = FJ
  Me.lastEventId = LJ
  Me.setContext = PJ
  Me.setExtra = DJ
  Me.setExtras = RJ
  Me.setTag = OJ
  Me.setTags = AJ
  Me.setUser = NJ
  Me.startTransaction = kJ
  Me.withScope = qJ
})
var gO = l((cb) => {
  Object.defineProperty(cb, '__esModule', { value: !0 })
  var BJ = A(),
    jJ = rn(),
    ab = class {
      constructor(t, n) {
        ;(this._client = t),
          (this.flushTimeout = 60),
          (this._pendingAggregates = {}),
          (this._isEnabled = !0),
          (this._intervalId = setInterval(
            () => this.flush(),
            this.flushTimeout * 1e3,
          )),
          (this._sessionAttrs = n)
      }
      flush() {
        let t = this.getSessionAggregates()
        t.aggregates.length !== 0 &&
          ((this._pendingAggregates = {}), this._client.sendSession(t))
      }
      getSessionAggregates() {
        let t = Object.keys(this._pendingAggregates).map(
            (r) => this._pendingAggregates[parseInt(r)],
          ),
          n = { attrs: this._sessionAttrs, aggregates: t }
        return BJ.dropUndefinedKeys(n)
      }
      close() {
        clearInterval(this._intervalId), (this._isEnabled = !1), this.flush()
      }
      incrementSessionStatusCount() {
        if (!this._isEnabled) return
        let t = jJ.getCurrentHub().getScope(),
          n = t.getRequestSession()
        n &&
          n.status &&
          (this._incrementSessionStatusCount(n.status, new Date()),
          t.setRequestSession(void 0))
      }
      _incrementSessionStatusCount(t, n) {
        let r = new Date(n).setSeconds(0, 0)
        this._pendingAggregates[r] = this._pendingAggregates[r] || {}
        let s = this._pendingAggregates[r]
        switch ((s.started || (s.started = new Date(r).toISOString()), t)) {
          case 'errored':
            return (s.errored = (s.errored || 0) + 1), s.errored
          case 'ok':
            return (s.exited = (s.exited || 0) + 1), s.exited
          default:
            return (s.crashed = (s.crashed || 0) + 1), s.crashed
        }
      }
    }
  cb.SessionFlusher = ab
})
var Vl = l((Wl) => {
  Object.defineProperty(Wl, '__esModule', { value: !0 })
  var db = A(),
    GJ = '7'
  function EO(e) {
    let t = e.protocol ? `${e.protocol}:` : '',
      n = e.port ? `:${e.port}` : ''
    return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ''}/api/`
  }
  function $J(e) {
    return `${EO(e)}${e.projectId}/envelope/`
  }
  function zJ(e, t) {
    return db.urlEncode({
      sentry_key: e.publicKey,
      sentry_version: GJ,
      ...(t && { sentry_client: `${t.name}/${t.version}` }),
    })
  }
  function HJ(e, t = {}) {
    let n = typeof t == 'string' ? t : t.tunnel,
      r = typeof t == 'string' || !t._metadata ? void 0 : t._metadata.sdk
    return n || `${$J(e)}?${zJ(e, r)}`
  }
  function WJ(e, t) {
    let n = db.makeDsn(e)
    if (!n) return ''
    let r = `${EO(n)}embed/error-page/`,
      s = `dsn=${db.dsnToString(n)}`
    for (let o in t)
      if (o !== 'dsn')
        if (o === 'user') {
          let i = t.user
          if (!i) continue
          i.name && (s += `&name=${encodeURIComponent(i.name)}`),
            i.email && (s += `&email=${encodeURIComponent(i.email)}`)
        } else s += `&${encodeURIComponent(o)}=${encodeURIComponent(t[o])}`
    return `${r}?${s}`
  }
  Wl.getEnvelopeEndpointWithUrlEncodedAuth = HJ
  Wl.getReportDialogEndpoint = WJ
})
var SO = l((Yl) => {
  Object.defineProperty(Yl, '__esModule', { value: !0 })
  var Zo = A()
  function VJ(e, t) {
    return (
      t &&
        ((e.sdk = e.sdk || {}),
        (e.sdk.name = e.sdk.name || t.name),
        (e.sdk.version = e.sdk.version || t.version),
        (e.sdk.integrations = [
          ...(e.sdk.integrations || []),
          ...(t.integrations || []),
        ]),
        (e.sdk.packages = [...(e.sdk.packages || []), ...(t.packages || [])])),
      e
    )
  }
  function YJ(e, t, n, r) {
    let s = Zo.getSdkMetadataForEnvelopeHeader(n),
      o = {
        sent_at: new Date().toISOString(),
        ...(s && { sdk: s }),
        ...(!!r && { dsn: Zo.dsnToString(t) }),
      },
      i =
        'aggregates' in e
          ? [{ type: 'sessions' }, e]
          : [{ type: 'session' }, e.toJSON()]
    return Zo.createEnvelope(o, [i])
  }
  function KJ(e, t, n, r) {
    let s = Zo.getSdkMetadataForEnvelopeHeader(n),
      o = e.type && e.type !== 'replay_event' ? e.type : 'event'
    VJ(e, n && n.sdk)
    let i = Zo.createEventEnvelopeHeaders(e, s, r, t)
    delete e.sdkProcessingMetadata
    let c = [{ type: o }, e]
    return Zo.createEnvelope(i, [c])
  }
  Yl.createEventEnvelope = KJ
  Yl.createSessionEnvelope = YJ
})
var lb = l((ei) => {
  Object.defineProperty(ei, '__esModule', { value: !0 })
  var bO = A(),
    JJ = rn(),
    XJ = rd(),
    ub = []
  function QJ(e) {
    let t = {}
    return (
      e.forEach((n) => {
        let { name: r } = n,
          s = t[r]
        ;(s && !s.isDefaultInstance && n.isDefaultInstance) || (t[r] = n)
      }),
      Object.keys(t).map((n) => t[n])
    )
  }
  function ZJ(e) {
    let t = e.defaultIntegrations || [],
      n = e.integrations
    t.forEach((i) => {
      i.isDefaultInstance = !0
    })
    let r
    Array.isArray(n)
      ? (r = [...t, ...n])
      : typeof n == 'function'
      ? (r = bO.arrayify(n(t)))
      : (r = t)
    let s = QJ(r),
      o = tX(s, (i) => i.name === 'Debug')
    if (o !== -1) {
      let [i] = s.splice(o, 1)
      s.push(i)
    }
    return s
  }
  function eX(e) {
    let t = {}
    return (
      e.forEach((n) => {
        n && vO(n, t)
      }),
      t
    )
  }
  function vO(e, t) {
    ;(t[e.name] = e),
      ub.indexOf(e.name) === -1 &&
        (e.setupOnce(XJ.addGlobalEventProcessor, JJ.getCurrentHub),
        ub.push(e.name),
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          bO.logger.log(`Integration installed: ${e.name}`))
  }
  function tX(e, t) {
    for (let n = 0; n < e.length; n++) if (t(e[n]) === !0) return n
    return -1
  }
  ei.getIntegrationsToSetup = ZJ
  ei.installedIntegrations = ub
  ei.setupIntegration = vO
  ei.setupIntegrations = eX
})
var mb = l((ud) => {
  Object.defineProperty(ud, '__esModule', { value: !0 })
  var Ct = A(),
    nX = Zc(),
    rX = rd()
  function sX(e, t, n, r) {
    let { normalizeDepth: s = 3, normalizeMaxBreadth: o = 1e3 } = e,
      i = {
        ...t,
        event_id: t.event_id || n.event_id || Ct.uuid4(),
        timestamp: t.timestamp || Ct.dateTimestampInSeconds(),
      },
      c = n.integrations || e.integrations.map((d) => d.name)
    oX(i, e), iX(i, c), t.type === void 0 && wO(i, e.stackParser)
    let a = r
    n.captureContext && (a = rX.Scope.clone(a).update(n.captureContext))
    let u = Ct.resolvedSyncPromise(i)
    if (a) {
      if (a.getAttachments) {
        let d = [...(n.attachments || []), ...a.getAttachments()]
        d.length && (n.attachments = d)
      }
      u = a.applyToEvent(i, n)
    }
    return u.then(
      (d) => (d && TO(d), typeof s == 'number' && s > 0 ? aX(d, s, o) : d),
    )
  }
  function oX(e, t) {
    let { environment: n, release: r, dist: s, maxValueLength: o = 250 } = t
    'environment' in e ||
      (e.environment = 'environment' in t ? n : nX.DEFAULT_ENVIRONMENT),
      e.release === void 0 && r !== void 0 && (e.release = r),
      e.dist === void 0 && s !== void 0 && (e.dist = s),
      e.message && (e.message = Ct.truncate(e.message, o))
    let i = e.exception && e.exception.values && e.exception.values[0]
    i && i.value && (i.value = Ct.truncate(i.value, o))
    let c = e.request
    c && c.url && (c.url = Ct.truncate(c.url, o))
  }
  var CO = new WeakMap()
  function wO(e, t) {
    let n = Ct.GLOBAL_OBJ._sentryDebugIds
    if (!n) return
    let r,
      s = CO.get(t)
    s ? (r = s) : ((r = new Map()), CO.set(t, r))
    let o = Object.keys(n).reduce((i, c) => {
      let a,
        u = r.get(c)
      u ? (a = u) : ((a = t(c)), r.set(c, a))
      for (let d = a.length - 1; d >= 0; d--) {
        let p = a[d]
        if (p.filename) {
          i[p.filename] = n[c]
          break
        }
      }
      return i
    }, {})
    try {
      e.exception.values.forEach((i) => {
        i.stacktrace.frames.forEach((c) => {
          c.filename && (c.debug_id = o[c.filename])
        })
      })
    } catch {}
  }
  function TO(e) {
    let t = {}
    try {
      e.exception.values.forEach((r) => {
        r.stacktrace.frames.forEach((s) => {
          s.debug_id &&
            (s.abs_path
              ? (t[s.abs_path] = s.debug_id)
              : s.filename && (t[s.filename] = s.debug_id),
            delete s.debug_id)
        })
      })
    } catch {}
    if (Object.keys(t).length === 0) return
    ;(e.debug_meta = e.debug_meta || {}),
      (e.debug_meta.images = e.debug_meta.images || [])
    let n = e.debug_meta.images
    Object.keys(t).forEach((r) => {
      n.push({ type: 'sourcemap', code_file: r, debug_id: t[r] })
    })
  }
  function iX(e, t) {
    t.length > 0 &&
      ((e.sdk = e.sdk || {}),
      (e.sdk.integrations = [...(e.sdk.integrations || []), ...t]))
  }
  function aX(e, t, n) {
    if (!e) return null
    let r = {
      ...e,
      ...(e.breadcrumbs && {
        breadcrumbs: e.breadcrumbs.map((s) => ({
          ...s,
          ...(s.data && { data: Ct.normalize(s.data, t, n) }),
        })),
      }),
      ...(e.user && { user: Ct.normalize(e.user, t, n) }),
      ...(e.contexts && { contexts: Ct.normalize(e.contexts, t, n) }),
      ...(e.extra && { extra: Ct.normalize(e.extra, t, n) }),
    }
    return (
      e.contexts &&
        e.contexts.trace &&
        r.contexts &&
        ((r.contexts.trace = e.contexts.trace),
        e.contexts.trace.data &&
          (r.contexts.trace.data = Ct.normalize(e.contexts.trace.data, t, n))),
      e.spans &&
        (r.spans = e.spans.map(
          (s) => (s.data && (s.data = Ct.normalize(s.data, t, n)), s),
        )),
      r
    )
  }
  ud.applyDebugIds = wO
  ud.applyDebugMeta = TO
  ud.prepareEvent = sX
})
var OO = l((fb) => {
  Object.defineProperty(fb, '__esModule', { value: !0 })
  var oe = A(),
    cX = Vl(),
    xO = SO(),
    IO = lb(),
    PO = nd(),
    dX = jl(),
    uX = mb(),
    RO = "Not capturing exception because it's already been captured.",
    pb = class {
      constructor(t) {
        if (
          ((this._options = t),
          (this._integrations = {}),
          (this._integrationsInitialized = !1),
          (this._numProcessing = 0),
          (this._outcomes = {}),
          (this._hooks = {}),
          t.dsn
            ? (this._dsn = oe.makeDsn(t.dsn))
            : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              oe.logger.warn('No DSN provided, client will not do anything.'),
          this._dsn)
        ) {
          let n = cX.getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, t)
          this._transport = t.transport({
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...t.transportOptions,
            url: n,
          })
        }
      }
      captureException(t, n, r) {
        if (oe.checkOrSetAlreadyCaught(t)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            oe.logger.log(RO)
          return
        }
        let s = n && n.event_id
        return (
          this._process(
            this.eventFromException(t, n)
              .then((o) => this._captureEvent(o, n, r))
              .then((o) => {
                s = o
              }),
          ),
          s
        )
      }
      captureMessage(t, n, r, s) {
        let o = r && r.event_id,
          i = oe.isPrimitive(t)
            ? this.eventFromMessage(String(t), n, r)
            : this.eventFromException(t, r)
        return (
          this._process(
            i
              .then((c) => this._captureEvent(c, r, s))
              .then((c) => {
                o = c
              }),
          ),
          o
        )
      }
      captureEvent(t, n, r) {
        if (
          n &&
          n.originalException &&
          oe.checkOrSetAlreadyCaught(n.originalException)
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            oe.logger.log(RO)
          return
        }
        let s = n && n.event_id
        return (
          this._process(
            this._captureEvent(t, n, r).then((o) => {
              s = o
            }),
          ),
          s
        )
      }
      captureSession(t) {
        if (!this._isEnabled()) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            oe.logger.warn('SDK not enabled, will not capture session.')
          return
        }
        typeof t.release != 'string'
          ? (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            oe.logger.warn(
              'Discarded session because of missing or non-string release',
            )
          : (this.sendSession(t), PO.updateSession(t, { init: !1 }))
      }
      getDsn() {
        return this._dsn
      }
      getOptions() {
        return this._options
      }
      getSdkMetadata() {
        return this._options._metadata
      }
      getTransport() {
        return this._transport
      }
      flush(t) {
        let n = this._transport
        return n
          ? this._isClientDoneProcessing(t).then((r) =>
              n.flush(t).then((s) => r && s),
            )
          : oe.resolvedSyncPromise(!0)
      }
      close(t) {
        return this.flush(t).then((n) => ((this.getOptions().enabled = !1), n))
      }
      setupIntegrations() {
        this._isEnabled() &&
          !this._integrationsInitialized &&
          ((this._integrations = IO.setupIntegrations(
            this._options.integrations,
          )),
          (this._integrationsInitialized = !0))
      }
      getIntegrationById(t) {
        return this._integrations[t]
      }
      getIntegration(t) {
        try {
          return this._integrations[t.id] || null
        } catch {
          return (
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              oe.logger.warn(
                `Cannot retrieve integration ${t.id} from the current Client`,
              ),
            null
          )
        }
      }
      addIntegration(t) {
        IO.setupIntegration(t, this._integrations)
      }
      sendEvent(t, n = {}) {
        if (this._dsn) {
          let r = xO.createEventEnvelope(
            t,
            this._dsn,
            this._options._metadata,
            this._options.tunnel,
          )
          for (let o of n.attachments || [])
            r = oe.addItemToEnvelope(
              r,
              oe.createAttachmentEnvelopeItem(
                o,
                this._options.transportOptions &&
                  this._options.transportOptions.textEncoder,
              ),
            )
          let s = this._sendEnvelope(r)
          s && s.then((o) => this.emit('afterSendEvent', t, o), null)
        }
      }
      sendSession(t) {
        if (this._dsn) {
          let n = xO.createSessionEnvelope(
            t,
            this._dsn,
            this._options._metadata,
            this._options.tunnel,
          )
          this._sendEnvelope(n)
        }
      }
      recordDroppedEvent(t, n, r) {
        if (this._options.sendClientReports) {
          let s = `${t}:${n}`
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            oe.logger.log(`Adding outcome: "${s}"`),
            (this._outcomes[s] = this._outcomes[s] + 1 || 1)
        }
      }
      on(t, n) {
        this._hooks[t] || (this._hooks[t] = []), this._hooks[t].push(n)
      }
      emit(t, ...n) {
        this._hooks[t] && this._hooks[t].forEach((r) => r(...n))
      }
      _updateSessionFromEvent(t, n) {
        let r = !1,
          s = !1,
          o = n.exception && n.exception.values
        if (o) {
          s = !0
          for (let a of o) {
            let u = a.mechanism
            if (u && u.handled === !1) {
              r = !0
              break
            }
          }
        }
        let i = t.status === 'ok'
        ;((i && t.errors === 0) || (i && r)) &&
          (PO.updateSession(t, {
            ...(r && { status: 'crashed' }),
            errors: t.errors || Number(s || r),
          }),
          this.captureSession(t))
      }
      _isClientDoneProcessing(t) {
        return new oe.SyncPromise((n) => {
          let r = 0,
            s = 1,
            o = setInterval(() => {
              this._numProcessing == 0
                ? (clearInterval(o), n(!0))
                : ((r += s), t && r >= t && (clearInterval(o), n(!1)))
            }, s)
        })
      }
      _isEnabled() {
        return this.getOptions().enabled !== !1 && this._dsn !== void 0
      }
      _prepareEvent(t, n, r) {
        let s = this.getOptions(),
          o = Object.keys(this._integrations)
        return (
          !n.integrations && o.length > 0 && (n.integrations = o),
          uX.prepareEvent(s, t, n, r).then((i) => {
            if (i === null) return i
            let { propagationContext: c } = i.sdkProcessingMetadata || {}
            if (!(i.contexts && i.contexts.trace) && c) {
              let { traceId: u, spanId: d, parentSpanId: p, dsc: f } = c
              i.contexts = {
                trace: { trace_id: u, span_id: d, parent_span_id: p },
                ...i.contexts,
              }
              let _ = f || dX.getDynamicSamplingContextFromClient(u, this, r)
              i.sdkProcessingMetadata = {
                dynamicSamplingContext: _,
                ...i.sdkProcessingMetadata,
              }
            }
            return i
          })
        )
      }
      _captureEvent(t, n = {}, r) {
        return this._processEvent(t, n, r).then(
          (s) => s.event_id,
          (s) => {
            if (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) {
              let o = s
              o.logLevel === 'log'
                ? oe.logger.log(o.message)
                : oe.logger.warn(o)
            }
          },
        )
      }
      _processEvent(t, n, r) {
        let s = this.getOptions(),
          { sampleRate: o } = s
        if (!this._isEnabled())
          return oe.rejectedSyncPromise(
            new oe.SentryError(
              'SDK not enabled, will not capture event.',
              'log',
            ),
          )
        let i = AO(t),
          c = DO(t),
          a = t.type || 'error',
          u = `before send for type \`${a}\``
        if (c && typeof o == 'number' && Math.random() > o)
          return (
            this.recordDroppedEvent('sample_rate', 'error', t),
            oe.rejectedSyncPromise(
              new oe.SentryError(
                `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
                'log',
              ),
            )
          )
        let d = a === 'replay_event' ? 'replay' : a
        return this._prepareEvent(t, n, r)
          .then((p) => {
            if (p === null)
              throw (
                (this.recordDroppedEvent('event_processor', d, t),
                new oe.SentryError(
                  'An event processor returned `null`, will not send event.',
                  'log',
                ))
              )
            if (n.data && n.data.__sentry__ === !0) return p
            let _ = mX(s, p, n)
            return lX(_, u)
          })
          .then((p) => {
            if (p === null)
              throw (
                (this.recordDroppedEvent('before_send', d, t),
                new oe.SentryError(
                  `${u} returned \`null\`, will not send event.`,
                  'log',
                ))
              )
            let f = r && r.getSession()
            !i && f && this._updateSessionFromEvent(f, p)
            let _ = p.transaction_info
            if (i && _ && p.transaction !== t.transaction) {
              let h = 'custom'
              p.transaction_info = { ..._, source: h }
            }
            return this.sendEvent(p, n), p
          })
          .then(null, (p) => {
            throw p instanceof oe.SentryError
              ? p
              : (this.captureException(p, {
                  data: { __sentry__: !0 },
                  originalException: p,
                }),
                new oe.SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${p}`))
          })
      }
      _process(t) {
        this._numProcessing++,
          t.then(
            (n) => (this._numProcessing--, n),
            (n) => (this._numProcessing--, n),
          )
      }
      _sendEnvelope(t) {
        if (this._transport && this._dsn)
          return (
            this.emit('beforeEnvelope', t),
            this._transport.send(t).then(null, (n) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                oe.logger.error('Error while sending event:', n)
            })
          )
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          oe.logger.error('Transport disabled')
      }
      _clearOutcomes() {
        let t = this._outcomes
        return (
          (this._outcomes = {}),
          Object.keys(t).map((n) => {
            let [r, s] = n.split(':')
            return { reason: r, category: s, quantity: t[n] }
          })
        )
      }
    }
  function lX(e, t) {
    let n = `${t} must return \`null\` or a valid event.`
    if (oe.isThenable(e))
      return e.then(
        (r) => {
          if (!oe.isPlainObject(r) && r !== null) throw new oe.SentryError(n)
          return r
        },
        (r) => {
          throw new oe.SentryError(`${t} rejected with ${r}`)
        },
      )
    if (!oe.isPlainObject(e) && e !== null) throw new oe.SentryError(n)
    return e
  }
  function mX(e, t, n) {
    let { beforeSend: r, beforeSendTransaction: s } = e
    return DO(t) && r ? r(t, n) : AO(t) && s ? s(t, n) : t
  }
  function DO(e) {
    return e.type === void 0
  }
  function AO(e) {
    return e.type === 'transaction'
  }
  fb.BaseClient = pb
})
var NO = l((_b) => {
  Object.defineProperty(_b, '__esModule', { value: !0 })
  var pX = A(),
    fX = rn()
  function _X(e, t) {
    t.debug === !0 &&
      (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__
        ? pX.logger.enable()
        : console.warn(
            '[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.',
          ))
    let n = fX.getCurrentHub()
    n.getScope().update(t.initialScope)
    let s = new e(t)
    n.bindClient(s)
  }
  _b.initAndBind = _X
})
var MO = l((Kl) => {
  Object.defineProperty(Kl, '__esModule', { value: !0 })
  var ft = A(),
    kO = 30
  function hX(e, t, n = ft.makePromiseBuffer(e.bufferSize || kO)) {
    let r = {},
      s = (i) => n.drain(i)
    function o(i) {
      let c = []
      if (
        (ft.forEachEnvelopeItem(i, (p, f) => {
          let _ = ft.envelopeItemTypeToDataCategory(f)
          if (ft.isRateLimited(r, _)) {
            let h = qO(p, f)
            e.recordDroppedEvent('ratelimit_backoff', _, h)
          } else c.push(p)
        }),
        c.length === 0)
      )
        return ft.resolvedSyncPromise()
      let a = ft.createEnvelope(i[0], c),
        u = (p) => {
          ft.forEachEnvelopeItem(a, (f, _) => {
            let h = qO(f, _)
            e.recordDroppedEvent(p, ft.envelopeItemTypeToDataCategory(_), h)
          })
        },
        d = () =>
          t({ body: ft.serializeEnvelope(a, e.textEncoder) }).then(
            (p) => (
              p.statusCode !== void 0 &&
                (p.statusCode < 200 || p.statusCode >= 300) &&
                (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                ft.logger.warn(
                  `Sentry responded with status code ${p.statusCode} to sent event.`,
                ),
              (r = ft.updateRateLimits(r, p)),
              p
            ),
            (p) => {
              throw (u('network_error'), p)
            },
          )
      return n.add(d).then(
        (p) => p,
        (p) => {
          if (p instanceof ft.SentryError)
            return (
              (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                ft.logger.error(
                  'Skipped sending event because buffer is full.',
                ),
              u('queue_overflow'),
              ft.resolvedSyncPromise()
            )
          throw p
        },
      )
    }
    return (o.__sentry__baseTransport__ = !0), { send: o, flush: s }
  }
  function qO(e, t) {
    if (!(t !== 'event' && t !== 'transaction'))
      return Array.isArray(e) ? e[1] : void 0
  }
  Kl.DEFAULT_TRANSPORT_BUFFER_SIZE = kO
  Kl.createTransport = hX
})
var UO = l((ld) => {
  Object.defineProperty(ld, '__esModule', { value: !0 })
  var yb = A(),
    FO = 100,
    gb = 5e3,
    yX = 36e5
  function hb(e, t) {
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      yb.logger.info(`[Offline]: ${e}`, t)
  }
  function gX(e) {
    return (t) => {
      let n = e(t),
        r = t.createStore ? t.createStore(t) : void 0,
        s = gb,
        o
      function i(d, p, f) {
        return yb.envelopeContainsItemType(d, [
          'replay_event',
          'replay_recording',
          'client_report',
        ])
          ? !1
          : t.shouldStore
          ? t.shouldStore(d, p, f)
          : !0
      }
      function c(d) {
        r &&
          (o && clearTimeout(o),
          (o = setTimeout(async () => {
            o = void 0
            let p = await r.pop()
            p &&
              (hb('Attempting to send previously queued event'),
              u(p).catch((f) => {
                hb('Failed to retry sending', f)
              }))
          }, d)),
          typeof o != 'number' && o.unref && o.unref())
      }
      function a() {
        o || (c(s), (s = Math.min(s * 2, yX)))
      }
      async function u(d) {
        try {
          let p = await n.send(d),
            f = FO
          if (p) {
            if (p.headers && p.headers['retry-after'])
              f = yb.parseRetryAfterHeader(p.headers['retry-after'])
            else if ((p.statusCode || 0) >= 400) return p
          }
          return c(f), (s = gb), p
        } catch (p) {
          if (r && (await i(d, p, s)))
            return (
              await r.insert(d), a(), hb('Error sending. Event queued', p), {}
            )
          throw p
        }
      }
      return t.flushAtStartup && a(), { send: u, flush: (d) => n.flush(d) }
    }
  }
  ld.MIN_DELAY = FO
  ld.START_DELAY = gb
  ld.makeOfflineTransport = gX
})
var BO = l((Jl) => {
  Object.defineProperty(Jl, '__esModule', { value: !0 })
  var LO = A(),
    EX = Vl()
  function Eb(e, t) {
    let n
    return (
      LO.forEachEnvelopeItem(
        e,
        (r, s) => (
          t.includes(s) && (n = Array.isArray(r) ? r[1] : void 0), !!n
        ),
      ),
      n
    )
  }
  function SX(e, t) {
    return (n) => {
      let r = e(n)
      return {
        send: async (s) => {
          let o = Eb(s, ['event', 'transaction', 'profile', 'replay_event'])
          return o && (o.release = t), r.send(s)
        },
        flush: (s) => r.flush(s),
      }
    }
  }
  function bX(e, t) {
    return (n) => {
      let r = e(n),
        s = {}
      function o(a, u) {
        let d = u ? `${a}:${u}` : a
        if (!s[d]) {
          let p = LO.dsnFromString(a)
          if (!p) return
          let f = EX.getEnvelopeEndpointWithUrlEncodedAuth(p)
          s[d] = u ? SX(e, u)({ ...n, url: f }) : e({ ...n, url: f })
        }
        return s[d]
      }
      async function i(a) {
        function u(f) {
          let _ = f && f.length ? f : ['event']
          return Eb(a, _)
        }
        let d = t({ envelope: a, getEvent: u })
          .map((f) =>
            typeof f == 'string' ? o(f, void 0) : o(f.dsn, f.release),
          )
          .filter((f) => !!f)
        return (
          d.length === 0 && d.push(r),
          (await Promise.all(d.map((f) => f.send(a))))[0]
        )
      }
      async function c(a) {
        let u = [...Object.keys(s).map((p) => s[p]), r]
        return (await Promise.all(u.map((p) => p.flush(a)))).every((p) => p)
      }
      return { send: i, flush: c }
    }
  }
  Jl.eventFromEnvelope = Eb
  Jl.makeMultiplexedTransport = bX
})
var jO = l((Sb) => {
  Object.defineProperty(Sb, '__esModule', { value: !0 })
  var vX = '7.64.0'
  Sb.SDK_VERSION = vX
})
var vb = l((bb) => {
  Object.defineProperty(bb, '__esModule', { value: !0 })
  var CX = A(),
    GO,
    Xl = class e {
      static __initStatic() {
        this.id = 'FunctionToString'
      }
      constructor() {
        this.name = e.id
      }
      setupOnce() {
        GO = Function.prototype.toString
        try {
          Function.prototype.toString = function (...t) {
            let n = CX.getOriginalFunction(this) || this
            return GO.apply(n, t)
          }
        } catch {}
      }
    }
  Xl.__initStatic()
  bb.FunctionToString = Xl
})
var Cb = l((md) => {
  Object.defineProperty(md, '__esModule', { value: !0 })
  var Le = A(),
    wX = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/],
    TX = [
      /^.*healthcheck.*$/,
      /^.*healthy.*$/,
      /^.*live.*$/,
      /^.*ready.*$/,
      /^.*heartbeat.*$/,
      /^.*\/health$/,
      /^.*\/healthz$/,
    ],
    Ql = class e {
      static __initStatic() {
        this.id = 'InboundFilters'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._options = t)
      }
      setupOnce(t, n) {
        let r = (s) => {
          let o = n()
          if (o) {
            let i = o.getIntegration(e)
            if (i) {
              let c = o.getClient(),
                a = c ? c.getOptions() : {},
                u = $O(i._options, a)
              return zO(s, u) ? null : s
            }
          }
          return s
        }
        ;(r.id = this.name), t(r)
      }
    }
  Ql.__initStatic()
  function $O(e = {}, t = {}) {
    return {
      allowUrls: [...(e.allowUrls || []), ...(t.allowUrls || [])],
      denyUrls: [...(e.denyUrls || []), ...(t.denyUrls || [])],
      ignoreErrors: [
        ...(e.ignoreErrors || []),
        ...(t.ignoreErrors || []),
        ...(e.disableErrorDefaults ? [] : wX),
      ],
      ignoreTransactions: [
        ...(e.ignoreTransactions || []),
        ...(t.ignoreTransactions || []),
        ...(e.disableTransactionDefaults ? [] : TX),
      ],
      ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0,
    }
  }
  function zO(e, t) {
    return t.ignoreInternal && AX(e)
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Le.logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${Le.getEventDescription(e)}`),
        !0)
      : xX(e, t.ignoreErrors)
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Le.logger
            .warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Le.getEventDescription(e)}`),
        !0)
      : IX(e, t.ignoreTransactions)
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Le.logger
            .warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Le.getEventDescription(e)}`),
        !0)
      : PX(e, t.denyUrls)
      ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Le.logger
            .warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Le.getEventDescription(e)}.
Url: ${Zl(e)}`),
        !0)
      : RX(e, t.allowUrls)
      ? !1
      : ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Le.logger
            .warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Le.getEventDescription(e)}.
Url: ${Zl(e)}`),
        !0)
  }
  function xX(e, t) {
    return e.type || !t || !t.length
      ? !1
      : DX(e).some((n) => Le.stringMatchesSomePattern(n, t))
  }
  function IX(e, t) {
    if (e.type !== 'transaction' || !t || !t.length) return !1
    let n = e.transaction
    return n ? Le.stringMatchesSomePattern(n, t) : !1
  }
  function PX(e, t) {
    if (!t || !t.length) return !1
    let n = Zl(e)
    return n ? Le.stringMatchesSomePattern(n, t) : !1
  }
  function RX(e, t) {
    if (!t || !t.length) return !0
    let n = Zl(e)
    return n ? Le.stringMatchesSomePattern(n, t) : !0
  }
  function DX(e) {
    if (e.message) return [e.message]
    if (e.exception) {
      let { values: t } = e.exception
      try {
        let { type: n = '', value: r = '' } = (t && t[t.length - 1]) || {}
        return [`${r}`, `${n}: ${r}`]
      } catch {
        return (
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Le.logger.error(
              `Cannot extract message for event ${Le.getEventDescription(e)}`,
            ),
          []
        )
      }
    }
    return []
  }
  function AX(e) {
    try {
      return e.exception.values[0].type === 'SentryError'
    } catch {}
    return !1
  }
  function OX(e = []) {
    for (let t = e.length - 1; t >= 0; t--) {
      let n = e[t]
      if (n && n.filename !== '<anonymous>' && n.filename !== '[native code]')
        return n.filename || null
    }
    return null
  }
  function Zl(e) {
    try {
      let t
      try {
        t = e.exception.values[0].stacktrace.frames
      } catch {}
      return t ? OX(t) : null
    } catch {
      return (
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Le.logger.error(
            `Cannot extract url for event ${Le.getEventDescription(e)}`,
          ),
        null
      )
    }
  }
  md.InboundFilters = Ql
  md._mergeOptions = $O
  md._shouldDropEvent = zO
})
var HO = l((em) => {
  Object.defineProperty(em, '__esModule', { value: !0 })
  var NX = vb(),
    qX = Cb()
  em.FunctionToString = NX.FunctionToString
  em.InboundFilters = qX.InboundFilters
})
var WO = l((Tb) => {
  Object.defineProperty(Tb, '__esModule', { value: !0 })
  var wb = A()
  function kX(e, t, n, r, s) {
    let o = { sent_at: new Date().toISOString() }
    n && n.sdk && (o.sdk = { name: n.sdk.name, version: n.sdk.version }),
      r && s && (o.dsn = wb.dsnToString(s)),
      t && (o.trace = wb.dropUndefinedKeys(t))
    let i = MX(e)
    return wb.createEnvelope(o, [i])
  }
  function MX(e) {
    return [{ type: 'check_in' }, e]
  }
  Tb.createCheckInEnvelope = kX
})
var JO = l((pd) => {
  Object.defineProperty(pd, '__esModule', { value: !0 })
  var xb = A(),
    YO = new Map(),
    VO = new Set()
  function FX(e) {
    if (xb.GLOBAL_OBJ._sentryModuleMetadata)
      for (let t of Object.keys(xb.GLOBAL_OBJ._sentryModuleMetadata)) {
        let n = xb.GLOBAL_OBJ._sentryModuleMetadata[t]
        if (VO.has(t)) continue
        VO.add(t)
        let r = e(t)
        for (let s of r.reverse())
          if (s.filename) {
            YO.set(s.filename, n)
            break
          }
      }
  }
  function KO(e, t) {
    return FX(e), YO.get(t)
  }
  function UX(e, t) {
    try {
      t.exception.values.forEach((n) => {
        if (n.stacktrace)
          for (let r of n.stacktrace.frames || []) {
            if (!r.filename) continue
            let s = KO(e, r.filename)
            s && (r.module_metadata = s)
          }
      })
    } catch {}
  }
  function LX(e) {
    try {
      e.exception.values.forEach((t) => {
        if (t.stacktrace)
          for (let n of t.stacktrace.frames || []) delete n.module_metadata
      })
    } catch {}
  }
  pd.addMetadataToStackFrames = UX
  pd.getMetadataForUrl = KO
  pd.stripMetadataFromStackFrames = LX
})
var QO = l((Ib) => {
  Object.defineProperty(Ib, '__esModule', { value: !0 })
  var BX = A(),
    XO = JO(),
    tm = class e {
      static __initStatic() {
        this.id = 'ModuleMetadata'
      }
      constructor() {
        this.name = e.id
      }
      setupOnce(t, n) {
        let r = n().getClient()
        if (!r || typeof r.on != 'function') return
        r.on('beforeEnvelope', (o) => {
          BX.forEachEnvelopeItem(o, (i, c) => {
            if (c === 'event') {
              let a = Array.isArray(i) ? i[1] : void 0
              a && (XO.stripMetadataFromStackFrames(a), (i[1] = a))
            }
          })
        })
        let s = r.getOptions().stackParser
        t((o) => (XO.addMetadataToStackFrames(s, o), o))
      }
    }
  tm.__initStatic()
  Ib.ModuleMetadata = tm
})
var be = l((N) => {
  Object.defineProperty(N, '__esModule', { value: !0 })
  var ZO = pO(),
    eN = sb(),
    tN = Bl(),
    jX = Gl(),
    GX = Ll(),
    $X = fO(),
    zX = _O(),
    HX = jl(),
    WX = hO(),
    He = yO(),
    rr = rn(),
    Pb = nd(),
    VX = gO(),
    nN = rd(),
    rN = Vl(),
    YX = OO(),
    KX = NO(),
    JX = MO(),
    XX = UO(),
    QX = BO(),
    ZX = jO(),
    eQ = lb(),
    tQ = HO(),
    nQ = mb(),
    rQ = WO(),
    sQ = Ul(),
    oQ = Zc(),
    iQ = QO(),
    aQ = vb(),
    cQ = Cb(),
    dQ = A()
  N.addTracingExtensions = ZO.addTracingExtensions
  N.startIdleTransaction = ZO.startIdleTransaction
  N.IdleTransaction = eN.IdleTransaction
  N.TRACING_DEFAULTS = eN.TRACING_DEFAULTS
  N.Span = tN.Span
  N.spanStatusfromHttpCode = tN.spanStatusfromHttpCode
  N.Transaction = jX.Transaction
  N.getActiveTransaction = GX.getActiveTransaction
  Object.defineProperty(N, 'SpanStatus', {
    enumerable: !0,
    get: () => $X.SpanStatus,
  })
  N.trace = zX.trace
  N.getDynamicSamplingContextFromClient = HX.getDynamicSamplingContextFromClient
  N.setMeasurement = WX.setMeasurement
  N.addBreadcrumb = He.addBreadcrumb
  N.captureCheckIn = He.captureCheckIn
  N.captureEvent = He.captureEvent
  N.captureException = He.captureException
  N.captureMessage = He.captureMessage
  N.close = He.close
  N.configureScope = He.configureScope
  N.flush = He.flush
  N.lastEventId = He.lastEventId
  N.setContext = He.setContext
  N.setExtra = He.setExtra
  N.setExtras = He.setExtras
  N.setTag = He.setTag
  N.setTags = He.setTags
  N.setUser = He.setUser
  N.startTransaction = He.startTransaction
  N.withScope = He.withScope
  N.Hub = rr.Hub
  N.ensureHubOnCarrier = rr.ensureHubOnCarrier
  N.getCurrentHub = rr.getCurrentHub
  N.getHubFromCarrier = rr.getHubFromCarrier
  N.getMainCarrier = rr.getMainCarrier
  N.makeMain = rr.makeMain
  N.runWithAsyncContext = rr.runWithAsyncContext
  N.setAsyncContextStrategy = rr.setAsyncContextStrategy
  N.setHubOnCarrier = rr.setHubOnCarrier
  N.closeSession = Pb.closeSession
  N.makeSession = Pb.makeSession
  N.updateSession = Pb.updateSession
  N.SessionFlusher = VX.SessionFlusher
  N.Scope = nN.Scope
  N.addGlobalEventProcessor = nN.addGlobalEventProcessor
  N.getEnvelopeEndpointWithUrlEncodedAuth =
    rN.getEnvelopeEndpointWithUrlEncodedAuth
  N.getReportDialogEndpoint = rN.getReportDialogEndpoint
  N.BaseClient = YX.BaseClient
  N.initAndBind = KX.initAndBind
  N.createTransport = JX.createTransport
  N.makeOfflineTransport = XX.makeOfflineTransport
  N.makeMultiplexedTransport = QX.makeMultiplexedTransport
  N.SDK_VERSION = ZX.SDK_VERSION
  N.getIntegrationsToSetup = eQ.getIntegrationsToSetup
  N.Integrations = tQ
  N.prepareEvent = nQ.prepareEvent
  N.createCheckInEnvelope = rQ.createCheckInEnvelope
  N.hasTracingEnabled = sQ.hasTracingEnabled
  N.DEFAULT_ENVIRONMENT = oQ.DEFAULT_ENVIRONMENT
  N.ModuleMetadata = iQ.ModuleMetadata
  N.FunctionToString = aQ.FunctionToString
  N.InboundFilters = cQ.InboundFilters
  N.extractTraceparentData = dQ.extractTraceparentData
})
var Ur = l((Rb) => {
  var { _optionalChain: sN } = ge()
  Object.defineProperty(Rb, '__esModule', { value: !0 })
  function uQ(e) {
    let t = sN([
      e,
      'call',
      (r) => r(),
      'access',
      (r) => r.getClient,
      'call',
      (r) => r(),
      'optionalAccess',
      (r) => r.getOptions,
      'call',
      (r) => r(),
    ])
    return (
      (sN([t, 'optionalAccess', (r) => r.instrumenter]) || 'sentry') !==
      'sentry'
    )
  }
  Rb.shouldDisableAutoInstrumentation = uQ
})
var iN = l((Db) => {
  var { _optionalChain: fd } = ge()
  Object.defineProperty(Db, '__esModule', { value: !0 })
  var sn = A(),
    lQ = Ur(),
    nm = class e {
      static __initStatic() {
        this.id = 'Express'
      }
      constructor(t = {}) {
        ;(this.name = e.id),
          (this._router = t.router || t.app),
          (this._methods = (Array.isArray(t.methods) ? t.methods : []).concat(
            'use',
          ))
      }
      setupOnce(t, n) {
        if (!this._router) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            sn.logger.error('ExpressIntegration is missing an Express instance')
          return
        }
        if (lQ.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            sn.logger.log(
              'Express Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        fQ(this._router, this._methods), _Q(this._router)
      }
    }
  nm.__initStatic()
  function oN(e, t) {
    let n = e.length
    switch (n) {
      case 2:
        return function (r, s) {
          let o = s.__sentry_transaction
          if (o) {
            let i = o.startChild({
              description: e.name,
              op: `middleware.express.${t}`,
            })
            s.once('finish', () => {
              i.finish()
            })
          }
          return e.call(this, r, s)
        }
      case 3:
        return function (r, s, o) {
          let i = s.__sentry_transaction,
            c = fd([
              i,
              'optionalAccess',
              (a) => a.startChild,
              'call',
              (a) => a({ description: e.name, op: `middleware.express.${t}` }),
            ])
          e.call(this, r, s, function (...a) {
            fd([c, 'optionalAccess', (u) => u.finish, 'call', (u) => u()]),
              o.call(this, ...a)
          })
        }
      case 4:
        return function (r, s, o, i) {
          let c = o.__sentry_transaction,
            a = fd([
              c,
              'optionalAccess',
              (u) => u.startChild,
              'call',
              (u) => u({ description: e.name, op: `middleware.express.${t}` }),
            ])
          e.call(this, r, s, o, function (...u) {
            fd([a, 'optionalAccess', (d) => d.finish, 'call', (d) => d()]),
              i.call(this, ...u)
          })
        }
      default:
        throw new Error(`Express middleware takes 2-4 arguments. Got: ${n}`)
    }
  }
  function mQ(e, t) {
    return e.map((n) =>
      typeof n == 'function'
        ? oN(n, t)
        : Array.isArray(n)
        ? n.map((r) => (typeof r == 'function' ? oN(r, t) : r))
        : n,
    )
  }
  function pQ(e, t) {
    let n = e[t]
    return (
      (e[t] = function (...r) {
        return n.call(this, ...mQ(r, t))
      }),
      e
    )
  }
  function fQ(e, t = []) {
    t.forEach((n) => pQ(e, n))
  }
  function _Q(e) {
    let t = 'settings' in e
    t && e._router === void 0 && e.lazyrouter && e.lazyrouter()
    let n = t ? e._router : e
    if (!n) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        sn.logger.debug(
          'Cannot instrument router for URL Parameterization (did not find a valid router).',
        ),
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          sn.logger.debug(
            'Routing instrumentation is currently only supported in Express 4.',
          )
      return
    }
    let r = Object.getPrototypeOf(n),
      s = r.process_params
    r.process_params = function (i, c, a, u, d) {
      a._reconstructedRoute || (a._reconstructedRoute = '')
      let {
        layerRoutePath: p,
        isRegex: f,
        isArray: _,
        numExtraSegments: h,
      } = hQ(i)
      ;(p || f || _) && (a._hasParameters = !0)
      let E = (p || i.path || '')
        .split('/')
        .filter((ye) => ye.length > 0 && (f || _ || !ye.includes('*')))
        .join('/')
      E && E.length > 0 && (a._reconstructedRoute += `/${E}${f ? '/' : ''}`)
      let P = sn.getNumberOfUrlSegments(a.originalUrl || '') + h,
        z = sn.getNumberOfUrlSegments(a._reconstructedRoute)
      if (P === z) {
        a._hasParameters ||
          (a._reconstructedRoute !== a.originalUrl &&
            (a._reconstructedRoute = a.originalUrl
              ? sn.stripUrlQueryAndFragment(a.originalUrl)
              : a.originalUrl))
        let ye = u.__sentry_transaction
        if (ye && ye.metadata.source !== 'custom') {
          let fe = a._reconstructedRoute || '/'
          ye.setName(
            ...sn.extractPathForTransaction(a, {
              path: !0,
              method: !0,
              customRoute: fe,
            }),
          )
        }
      }
      return s.call(this, i, c, a, u, d)
    }
  }
  function hQ(e) {
    let t = fd([e, 'access', (i) => i.route, 'optionalAccess', (i) => i.path]),
      n = sn.isRegExp(t),
      r = Array.isArray(t)
    if (!t) return { isRegex: n, isArray: r, numExtraSegments: 0 }
    let s = r ? Math.max(yQ(t) - sn.getNumberOfUrlSegments(e.path || ''), 0) : 0
    return {
      layerRoutePath: gQ(r, t),
      isRegex: n,
      isArray: r,
      numExtraSegments: s,
    }
  }
  function yQ(e) {
    return e.reduce((t, n) => t + sn.getNumberOfUrlSegments(n.toString()), 0)
  }
  function gQ(e, t) {
    return e ? t.map((n) => n.toString()).join(',') : t && t.toString()
  }
  Db.Express = nm
})
var aN = l((Ab) => {
  var { _optionalChain: Ws } = ge()
  Object.defineProperty(Ab, '__esModule', { value: !0 })
  var ti = A(),
    EQ = Ur(),
    rm = class e {
      static __initStatic() {
        this.id = 'Postgres'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._usePgNative = !!t.usePgNative)
      }
      loadDependency() {
        return (this._module = this._module || ti.loadModule('pg'))
      }
      setupOnce(t, n) {
        if (EQ.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            ti.logger.log(
              'Postgres Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let r = this.loadDependency()
        if (!r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            ti.logger.error(
              'Postgres Integration was unable to require `pg` package.',
            )
          return
        }
        if (
          this._usePgNative &&
          !Ws([r, 'access', (o) => o.native, 'optionalAccess', (o) => o.Client])
        ) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            ti.logger.error(
              "Postgres Integration was unable to access 'pg-native' bindings.",
            )
          return
        }
        let { Client: s } = this._usePgNative ? r.native : r
        ti.fill(s.prototype, 'query', function (o) {
          return function (i, c, a) {
            let u = n().getScope(),
              d = Ws([
                u,
                'optionalAccess',
                (h) => h.getSpan,
                'call',
                (h) => h(),
              ]),
              p = { 'db.system': 'postgresql' }
            try {
              this.database && (p['db.name'] = this.database),
                this.host && (p['server.address'] = this.host),
                this.port && (p['server.port'] = this.port),
                this.user && (p['db.user'] = this.user)
            } catch {}
            let f = Ws([
              d,
              'optionalAccess',
              (h) => h.startChild,
              'call',
              (h) =>
                h({
                  description: typeof i == 'string' ? i : i.text,
                  op: 'db',
                  data: p,
                }),
            ])
            if (typeof a == 'function')
              return o.call(this, i, c, function (h, g) {
                Ws([f, 'optionalAccess', (E) => E.finish, 'call', (E) => E()]),
                  a(h, g)
              })
            if (typeof c == 'function')
              return o.call(this, i, function (h, g) {
                Ws([f, 'optionalAccess', (E) => E.finish, 'call', (E) => E()]),
                  c(h, g)
              })
            let _ = typeof c < 'u' ? o.call(this, i, c) : o.call(this, i)
            return ti.isThenable(_)
              ? _.then(
                  (h) => (
                    Ws([
                      f,
                      'optionalAccess',
                      (g) => g.finish,
                      'call',
                      (g) => g(),
                    ]),
                    h
                  ),
                )
              : (Ws([f, 'optionalAccess', (h) => h.finish, 'call', (h) => h()]),
                _)
          }
        })
      }
    }
  rm.__initStatic()
  Ab.Postgres = rm
})
var cN = l((Ob) => {
  var { _optionalChain: sm } = ge()
  Object.defineProperty(Ob, '__esModule', { value: !0 })
  var _d = A(),
    SQ = Ur(),
    om = class e {
      static __initStatic() {
        this.id = 'Mysql'
      }
      constructor() {
        this.name = e.id
      }
      loadDependency() {
        return (this._module =
          this._module || _d.loadModule('mysql/lib/Connection.js'))
      }
      setupOnce(t, n) {
        if (SQ.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            _d.logger.log(
              'Mysql Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let r = this.loadDependency()
        if (!r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            _d.logger.error(
              'Mysql Integration was unable to require `mysql` package.',
            )
          return
        }
        let s
        try {
          r.prototype.connect = new Proxy(r.prototype.connect, {
            apply(i, c, a) {
              return s || (s = c.config), i.apply(c, a)
            },
          })
        } catch {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            _d.logger.error(
              'Mysql Integration was unable to instrument `mysql` config.',
            )
        }
        function o() {
          return s
            ? {
                'server.address': s.host,
                'server.port': s.port,
                'db.user': s.user,
              }
            : {}
        }
        _d.fill(r, 'createQuery', function (i) {
          return function (c, a, u) {
            let d = n().getScope(),
              p = sm([
                d,
                'optionalAccess',
                (_) => _.getSpan,
                'call',
                (_) => _(),
              ]),
              f = sm([
                p,
                'optionalAccess',
                (_) => _.startChild,
                'call',
                (_) =>
                  _({
                    description: typeof c == 'string' ? c : c.sql,
                    op: 'db',
                    data: { ...o(), 'db.system': 'mysql' },
                  }),
              ])
            return typeof u == 'function'
              ? i.call(this, c, a, function (_, h, g) {
                  sm([
                    f,
                    'optionalAccess',
                    (E) => E.finish,
                    'call',
                    (E) => E(),
                  ]),
                    u(_, h, g)
                })
              : typeof a == 'function'
              ? i.call(this, c, function (_, h, g) {
                  sm([
                    f,
                    'optionalAccess',
                    (E) => E.finish,
                    'call',
                    (E) => E(),
                  ]),
                    a(_, h, g)
                })
              : i.call(this, c, a, u)
          }
        })
      }
    }
  om.__initStatic()
  Ob.Mysql = om
})
var dN = l((Nb) => {
  var { _optionalChain: Lr } = ge()
  Object.defineProperty(Nb, '__esModule', { value: !0 })
  var hd = A(),
    bQ = Ur(),
    vQ = [
      'aggregate',
      'bulkWrite',
      'countDocuments',
      'createIndex',
      'createIndexes',
      'deleteMany',
      'deleteOne',
      'distinct',
      'drop',
      'dropIndex',
      'dropIndexes',
      'estimatedDocumentCount',
      'find',
      'findOne',
      'findOneAndDelete',
      'findOneAndReplace',
      'findOneAndUpdate',
      'indexes',
      'indexExists',
      'indexInformation',
      'initializeOrderedBulkOp',
      'insertMany',
      'insertOne',
      'isCapped',
      'mapReduce',
      'options',
      'parallelCollectionScan',
      'rename',
      'replaceOne',
      'stats',
      'updateMany',
      'updateOne',
    ],
    CQ = {
      bulkWrite: ['operations'],
      countDocuments: ['query'],
      createIndex: ['fieldOrSpec'],
      createIndexes: ['indexSpecs'],
      deleteMany: ['filter'],
      deleteOne: ['filter'],
      distinct: ['key', 'query'],
      dropIndex: ['indexName'],
      find: ['query'],
      findOne: ['query'],
      findOneAndDelete: ['filter'],
      findOneAndReplace: ['filter', 'replacement'],
      findOneAndUpdate: ['filter', 'update'],
      indexExists: ['indexes'],
      insertMany: ['docs'],
      insertOne: ['doc'],
      mapReduce: ['map', 'reduce'],
      rename: ['newName'],
      replaceOne: ['filter', 'doc'],
      updateMany: ['filter', 'update'],
      updateOne: ['filter', 'update'],
    }
  function wQ(e) {
    return e && typeof e == 'object' && e.once && typeof e.once == 'function'
  }
  var im = class e {
    static __initStatic() {
      this.id = 'Mongo'
    }
    constructor(t = {}) {
      ;(this.name = e.id),
        (this._operations = Array.isArray(t.operations) ? t.operations : vQ),
        (this._describeOperations =
          'describeOperations' in t ? t.describeOperations : !0),
        (this._useMongoose = !!t.useMongoose)
    }
    loadDependency() {
      let t = this._useMongoose ? 'mongoose' : 'mongodb'
      return (this._module = this._module || hd.loadModule(t))
    }
    setupOnce(t, n) {
      if (bQ.shouldDisableAutoInstrumentation(n)) {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          hd.logger.log(
            'Mongo Integration is skipped because of instrumenter configuration.',
          )
        return
      }
      let r = this.loadDependency()
      if (!r) {
        let s = this._useMongoose ? 'mongoose' : 'mongodb'
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          hd.logger.error(
            `Mongo Integration was unable to require \`${s}\` package.`,
          )
        return
      }
      this._instrumentOperations(r.Collection, this._operations, n)
    }
    _instrumentOperations(t, n, r) {
      n.forEach((s) => this._patchOperation(t, s, r))
    }
    _patchOperation(t, n, r) {
      if (!(n in t.prototype)) return
      let s = this._getSpanContextFromOperationArguments.bind(this)
      hd.fill(t.prototype, n, function (o) {
        return function (...i) {
          let c = i[i.length - 1],
            a = r().getScope(),
            u = Lr([a, 'optionalAccess', (p) => p.getSpan, 'call', (p) => p()])
          if (typeof c != 'function' || (n === 'mapReduce' && i.length === 2)) {
            let p = Lr([
                u,
                'optionalAccess',
                (_) => _.startChild,
                'call',
                (_) => _(s(this, n, i)),
              ]),
              f = o.call(this, ...i)
            if (hd.isThenable(f))
              return f.then(
                (_) => (
                  Lr([
                    p,
                    'optionalAccess',
                    (h) => h.finish,
                    'call',
                    (h) => h(),
                  ]),
                  _
                ),
              )
            if (wQ(f)) {
              let _ = f
              try {
                _.once('close', () => {
                  Lr([p, 'optionalAccess', (h) => h.finish, 'call', (h) => h()])
                })
              } catch {
                Lr([p, 'optionalAccess', (g) => g.finish, 'call', (g) => g()])
              }
              return _
            } else
              return (
                Lr([p, 'optionalAccess', (_) => _.finish, 'call', (_) => _()]),
                f
              )
          }
          let d = Lr([
            u,
            'optionalAccess',
            (p) => p.startChild,
            'call',
            (p) => p(s(this, n, i.slice(0, -1))),
          ])
          return o.call(this, ...i.slice(0, -1), function (p, f) {
            Lr([d, 'optionalAccess', (_) => _.finish, 'call', (_) => _()]),
              c(p, f)
          })
        }
      })
    }
    _getSpanContextFromOperationArguments(t, n, r) {
      let s = {
          'db.system': 'mongodb',
          'db.name': t.dbName,
          'db.operation': n,
          'db.mongodb.collection': t.collectionName,
        },
        o = { op: 'db', description: n, data: s },
        i = CQ[n],
        c = Array.isArray(this._describeOperations)
          ? this._describeOperations.includes(n)
          : this._describeOperations
      if (!i || !c) return o
      try {
        if (n === 'mapReduce') {
          let [a, u] = r
          ;(s[i[0]] = typeof a == 'string' ? a : a.name || '<anonymous>'),
            (s[i[1]] = typeof u == 'string' ? u : u.name || '<anonymous>')
        } else
          for (let a = 0; a < i.length; a++)
            s[`db.mongodb.${i[a]}`] = JSON.stringify(r[a])
      } catch {}
      return o
    }
  }
  im.__initStatic()
  Nb.Mongo = im
})
var mN = l((qb) => {
  Object.defineProperty(qb, '__esModule', { value: !0 })
  var uN = be(),
    lN = A(),
    TQ = Ur()
  function xQ(e) {
    return !!e && !!e.$use
  }
  var am = class e {
    static __initStatic() {
      this.id = 'Prisma'
    }
    constructor(t = {}) {
      if (((this.name = e.id), xQ(t.client) && !t.client._sentryInstrumented)) {
        lN.addNonEnumerableProperty(t.client, '_sentryInstrumented', !0)
        let n = {}
        try {
          let r = t.client._engineConfig
          if (r) {
            let { activeProvider: s, clientVersion: o } = r
            s && (n['db.system'] = s), o && (n['db.prisma.version'] = o)
          }
        } catch {}
        t.client.$use((r, s) => {
          if (TQ.shouldDisableAutoInstrumentation(uN.getCurrentHub)) return s(r)
          let o = r.action,
            i = r.model
          return uN.trace(
            {
              name: i ? `${i} ${o}` : o,
              op: 'db.sql.prisma',
              data: { ...n, 'db.operation': o },
            },
            () => s(r),
          )
        })
      } else
        (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          lN.logger.warn(
            'Unsupported Prisma client provided to PrismaIntegration. Provided client:',
            t.client,
          )
    }
    setupOnce() {}
  }
  am.__initStatic()
  qb.Prisma = am
})
var pN = l((kb) => {
  var { _optionalChain: Vs } = ge()
  Object.defineProperty(kb, '__esModule', { value: !0 })
  var yd = A(),
    IQ = Ur(),
    cm = class e {
      static __initStatic() {
        this.id = 'GraphQL'
      }
      constructor() {
        this.name = e.id
      }
      loadDependency() {
        return (this._module =
          this._module || yd.loadModule('graphql/execution/execute.js'))
      }
      setupOnce(t, n) {
        if (IQ.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            yd.logger.log(
              'GraphQL Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let r = this.loadDependency()
        if (!r) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            yd.logger.error(
              'GraphQL Integration was unable to require graphql/execution package.',
            )
          return
        }
        yd.fill(r, 'execute', function (s) {
          return function (...o) {
            let i = n().getScope(),
              c = Vs([
                i,
                'optionalAccess',
                (d) => d.getSpan,
                'call',
                (d) => d(),
              ]),
              a = Vs([
                c,
                'optionalAccess',
                (d) => d.startChild,
                'call',
                (d) => d({ description: 'execute', op: 'graphql.execute' }),
              ])
            Vs([i, 'optionalAccess', (d) => d.setSpan, 'call', (d) => d(a)])
            let u = s.call(this, ...o)
            return yd.isThenable(u)
              ? u.then(
                  (d) => (
                    Vs([
                      a,
                      'optionalAccess',
                      (p) => p.finish,
                      'call',
                      (p) => p(),
                    ]),
                    Vs([
                      i,
                      'optionalAccess',
                      (p) => p.setSpan,
                      'call',
                      (p) => p(c),
                    ]),
                    d
                  ),
                )
              : (Vs([a, 'optionalAccess', (d) => d.finish, 'call', (d) => d()]),
                Vs([
                  i,
                  'optionalAccess',
                  (d) => d.setSpan,
                  'call',
                  (d) => d(c),
                ]),
                u)
          }
        })
      }
    }
  cm.__initStatic()
  kb.GraphQL = cm
})
var _N = l((Mb) => {
  var { _optionalChain: dm } = ge()
  Object.defineProperty(Mb, '__esModule', { value: !0 })
  var Ze = A(),
    PQ = Ur(),
    um = class e {
      static __initStatic() {
        this.id = 'Apollo'
      }
      constructor(t = { useNestjs: !1 }) {
        ;(this.name = e.id), (this._useNest = !!t.useNestjs)
      }
      loadDependency() {
        return (
          this._useNest
            ? (this._module = this._module || Ze.loadModule('@nestjs/graphql'))
            : (this._module =
                this._module || Ze.loadModule('apollo-server-core')),
          this._module
        )
      }
      setupOnce(t, n) {
        if (PQ.shouldDisableAutoInstrumentation(n)) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Ze.logger.log(
              'Apollo Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        if (this._useNest) {
          let r = this.loadDependency()
          if (!r) {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ze.logger.error(
                'Apollo-NestJS Integration was unable to require @nestjs/graphql package.',
              )
            return
          }
          Ze.fill(r.GraphQLFactory.prototype, 'mergeWithSchema', function (s) {
            return function (...o) {
              return (
                Ze.fill(this.resolversExplorerService, 'explore', function (i) {
                  return function () {
                    let c = Ze.arrayify(i.call(this))
                    return fN(c, n)
                  }
                }),
                s.call(this, ...o)
              )
            }
          })
        } else {
          let r = this.loadDependency()
          if (!r) {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Ze.logger.error(
                'Apollo Integration was unable to require apollo-server-core package.',
              )
            return
          }
          Ze.fill(
            r.ApolloServerBase.prototype,
            'constructSchema',
            function (s) {
              return function () {
                if (!this.config.resolvers)
                  return (
                    (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                      (this.config.schema
                        ? (Ze.logger.warn(
                            'Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.If you are using NestJS with Apollo, please use `Sentry.Integrations.Apollo({ useNestjs: true })` instead.',
                          ),
                          Ze.logger.warn())
                        : this.config.modules &&
                          Ze.logger.warn(
                            'Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.',
                          ),
                      Ze.logger.error(
                        'Skipping tracing as no resolvers found on the `ApolloServer` instance.',
                      )),
                    s.call(this)
                  )
                let o = Ze.arrayify(this.config.resolvers)
                return (this.config.resolvers = fN(o, n)), s.call(this)
              }
            },
          )
        }
      }
    }
  um.__initStatic()
  function fN(e, t) {
    return e.map(
      (n) => (
        Object.keys(n).forEach((r) => {
          Object.keys(n[r]).forEach((s) => {
            typeof n[r][s] == 'function' && RQ(n, r, s, t)
          })
        }),
        n
      ),
    )
  }
  function RQ(e, t, n, r) {
    Ze.fill(e[t], n, function (s) {
      return function (...o) {
        let i = r().getScope(),
          c = dm([i, 'optionalAccess', (d) => d.getSpan, 'call', (d) => d()]),
          a = dm([
            c,
            'optionalAccess',
            (d) => d.startChild,
            'call',
            (d) => d({ description: `${t}.${n}`, op: 'graphql.resolve' }),
          ]),
          u = s.call(this, ...o)
        return Ze.isThenable(u)
          ? u.then(
              (d) => (
                dm([a, 'optionalAccess', (p) => p.finish, 'call', (p) => p()]),
                d
              ),
            )
          : (dm([a, 'optionalAccess', (d) => d.finish, 'call', (d) => d()]), u)
      }
    })
  }
  Mb.Apollo = um
})
var hN = l((Fb, Br) => {
  Object.defineProperty(Fb, '__esModule', { value: !0 })
  var Ys = A(),
    DQ = [
      () => {
        let e = Ys.dynamicRequire(Br, './apollo')
        return new e.Apollo()
      },
      () => {
        let e = Ys.dynamicRequire(Br, './apollo')
        return new e.Apollo({ useNestjs: !0 })
      },
      () => {
        let e = Ys.dynamicRequire(Br, './graphql')
        return new e.GraphQL()
      },
      () => {
        let e = Ys.dynamicRequire(Br, './mongo')
        return new e.Mongo()
      },
      () => {
        let e = Ys.dynamicRequire(Br, './mongo')
        return new e.Mongo({ mongoose: !0 })
      },
      () => {
        let e = Ys.dynamicRequire(Br, './mysql')
        return new e.Mysql()
      },
      () => {
        let e = Ys.dynamicRequire(Br, './postgres')
        return new e.Postgres()
      },
    ]
  Fb.lazyLoadedNodePerformanceMonitoringIntegrations = DQ
})
var sr = l((Ub) => {
  Object.defineProperty(Ub, '__esModule', { value: !0 })
  var AQ = A(),
    OQ = AQ.GLOBAL_OBJ
  Ub.WINDOW = OQ
})
var gN = l((Lb) => {
  Object.defineProperty(Lb, '__esModule', { value: !0 })
  var NQ = be(),
    yN = A(),
    lm = sr()
  function qQ() {
    lm.WINDOW && lm.WINDOW.document
      ? lm.WINDOW.document.addEventListener('visibilitychange', () => {
          let e = NQ.getActiveTransaction()
          if (lm.WINDOW.document.hidden && e) {
            let t = 'cancelled'
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              yN.logger.log(
                `[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${e.op}`,
              ),
              e.status || e.setStatus(t),
              e.setTag('visibilitychange', 'document.hidden'),
              e.finish()
          }
        })
      : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        yN.logger.warn(
          '[Tracing] Could not set up background tab detection due to lack of global document',
        )
  }
  Lb.registerBackgroundTabDetection = qQ
})
var mm = l((Bb) => {
  Object.defineProperty(Bb, '__esModule', { value: !0 })
  var kQ = (e, t, n) => {
    let r, s
    return (o) => {
      t.value >= 0 &&
        (o || n) &&
        ((s = t.value - (r || 0)),
        (s || r === void 0) && ((r = t.value), (t.delta = s), e(t)))
    }
  }
  Bb.bindReporter = kQ
})
var EN = l((jb) => {
  Object.defineProperty(jb, '__esModule', { value: !0 })
  var MQ = () =>
    `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`
  jb.generateUniqueID = MQ
})
var $b = l((Gb) => {
  Object.defineProperty(Gb, '__esModule', { value: !0 })
  var gd = sr(),
    FQ = () => {
      let e = gd.WINDOW.performance.timing,
        t = gd.WINDOW.performance.navigation.type,
        n = {
          entryType: 'navigation',
          startTime: 0,
          type: t == 2 ? 'back_forward' : t === 1 ? 'reload' : 'navigate',
        }
      for (let r in e)
        r !== 'navigationStart' &&
          r !== 'toJSON' &&
          (n[r] = Math.max(e[r] - e.navigationStart, 0))
      return n
    },
    UQ = () =>
      gd.WINDOW.__WEB_VITALS_POLYFILL__
        ? gd.WINDOW.performance &&
          ((performance.getEntriesByType &&
            performance.getEntriesByType('navigation')[0]) ||
            FQ())
        : gd.WINDOW.performance &&
          performance.getEntriesByType &&
          performance.getEntriesByType('navigation')[0]
  Gb.getNavigationEntry = UQ
})
var Hb = l((zb) => {
  Object.defineProperty(zb, '__esModule', { value: !0 })
  var LQ = $b(),
    BQ = () => {
      let e = LQ.getNavigationEntry()
      return (e && e.activationStart) || 0
    }
  zb.getActivationStart = BQ
})
var pm = l((Wb) => {
  Object.defineProperty(Wb, '__esModule', { value: !0 })
  var jQ = sr(),
    GQ = EN(),
    $Q = Hb(),
    zQ = $b(),
    HQ = (e, t) => {
      let n = zQ.getNavigationEntry(),
        r = 'navigate'
      return (
        n &&
          (jQ.WINDOW.document.prerendering || $Q.getActivationStart() > 0
            ? (r = 'prerender')
            : (r = n.type.replace(/_/g, '-'))),
        {
          name: e,
          value: typeof t > 'u' ? -1 : t,
          rating: 'good',
          delta: 0,
          entries: [],
          id: GQ.generateUniqueID(),
          navigationType: r,
        }
      )
    }
  Wb.initMetric = HQ
})
var Ed = l((Vb) => {
  Object.defineProperty(Vb, '__esModule', { value: !0 })
  var WQ = (e, t, n) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(e)) {
        let r = new PerformanceObserver((s) => {
          t(s.getEntries())
        })
        return r.observe(Object.assign({ type: e, buffered: !0 }, n || {})), r
      }
    } catch {}
  }
  Vb.observe = WQ
})
var Sd = l((Yb) => {
  Object.defineProperty(Yb, '__esModule', { value: !0 })
  var VQ = sr(),
    YQ = (e, t) => {
      let n = (r) => {
        ;(r.type === 'pagehide' ||
          VQ.WINDOW.document.visibilityState === 'hidden') &&
          (e(r),
          t &&
            (removeEventListener('visibilitychange', n, !0),
            removeEventListener('pagehide', n, !0)))
      }
      addEventListener('visibilitychange', n, !0),
        addEventListener('pagehide', n, !0)
    }
  Yb.onHidden = YQ
})
var SN = l((Kb) => {
  Object.defineProperty(Kb, '__esModule', { value: !0 })
  var KQ = mm(),
    JQ = pm(),
    XQ = Ed(),
    QQ = Sd(),
    ZQ = (e) => {
      let t = JQ.initMetric('CLS', 0),
        n,
        r = 0,
        s = [],
        o = (c) => {
          c.forEach((a) => {
            if (!a.hadRecentInput) {
              let u = s[0],
                d = s[s.length - 1]
              r &&
              s.length !== 0 &&
              a.startTime - d.startTime < 1e3 &&
              a.startTime - u.startTime < 5e3
                ? ((r += a.value), s.push(a))
                : ((r = a.value), (s = [a])),
                r > t.value && ((t.value = r), (t.entries = s), n && n())
            }
          })
        },
        i = XQ.observe('layout-shift', o)
      if (i) {
        n = KQ.bindReporter(e, t)
        let c = () => {
          o(i.takeRecords()), n(!0)
        }
        return QQ.onHidden(c), c
      }
    }
  Kb.onCLS = ZQ
})
var _m = l((Jb) => {
  Object.defineProperty(Jb, '__esModule', { value: !0 })
  var bN = sr(),
    eZ = Sd(),
    fm = -1,
    tZ = () =>
      bN.WINDOW.document.visibilityState === 'hidden' &&
      !bN.WINDOW.document.prerendering
        ? 0
        : 1 / 0,
    nZ = () => {
      eZ.onHidden(({ timeStamp: e }) => {
        fm = e
      }, !0)
    },
    rZ = () => (
      fm < 0 && ((fm = tZ()), nZ()),
      {
        get firstHiddenTime() {
          return fm
        },
      }
    )
  Jb.getVisibilityWatcher = rZ
})
var vN = l((Xb) => {
  Object.defineProperty(Xb, '__esModule', { value: !0 })
  var sZ = mm(),
    oZ = _m(),
    iZ = pm(),
    aZ = Ed(),
    cZ = Sd(),
    dZ = (e) => {
      let t = oZ.getVisibilityWatcher(),
        n = iZ.initMetric('FID'),
        r,
        s = (c) => {
          c.startTime < t.firstHiddenTime &&
            ((n.value = c.processingStart - c.startTime),
            n.entries.push(c),
            r(!0))
        },
        o = (c) => {
          c.forEach(s)
        },
        i = aZ.observe('first-input', o)
      ;(r = sZ.bindReporter(e, n)),
        i &&
          cZ.onHidden(() => {
            o(i.takeRecords()), i.disconnect()
          }, !0)
    }
  Xb.onFID = dZ
})
var wN = l((Qb) => {
  Object.defineProperty(Qb, '__esModule', { value: !0 })
  var uZ = mm(),
    lZ = Hb(),
    mZ = _m(),
    pZ = pm(),
    fZ = Ed(),
    _Z = Sd(),
    CN = {},
    hZ = (e) => {
      let t = mZ.getVisibilityWatcher(),
        n = pZ.initMetric('LCP'),
        r,
        s = (i) => {
          let c = i[i.length - 1]
          if (c) {
            let a = Math.max(c.startTime - lZ.getActivationStart(), 0)
            a < t.firstHiddenTime && ((n.value = a), (n.entries = [c]), r())
          }
        },
        o = fZ.observe('largest-contentful-paint', s)
      if (o) {
        r = uZ.bindReporter(e, n)
        let i = () => {
          CN[n.id] ||
            (s(o.takeRecords()), o.disconnect(), (CN[n.id] = !0), r(!0))
        }
        return (
          ['keydown', 'click'].forEach((c) => {
            addEventListener(c, i, { once: !0, capture: !0 })
          }),
          _Z.onHidden(i, !0),
          i
        )
      }
    }
  Qb.onLCP = hZ
})
var TN = l((hm) => {
  Object.defineProperty(hm, '__esModule', { value: !0 })
  function yZ(e) {
    return typeof e == 'number' && isFinite(e)
  }
  function gZ(e, { startTimestamp: t, ...n }) {
    return (
      t && e.startTimestamp > t && (e.startTimestamp = t),
      e.startChild({ startTimestamp: t, ...n })
    )
  }
  hm._startChild = gZ
  hm.isMeasurementValue = yZ
})
var ON = l((jr) => {
  Object.defineProperty(jr, '__esModule', { value: !0 })
  var IN = be(),
    Fe = A(),
    Ks = sr(),
    EZ = SN(),
    SZ = vN(),
    bZ = wN(),
    vZ = _m(),
    PN = Ed(),
    or = TN()
  function Ue(e) {
    return e / 1e3
  }
  function RN() {
    return Ks.WINDOW && Ks.WINDOW.addEventListener && Ks.WINDOW.performance
  }
  var xN = 0,
    Ie = {},
    yn,
    bd
  function CZ() {
    let e = RN()
    if (e && Fe.browserPerformanceTimeOrigin) {
      e.mark && Ks.WINDOW.performance.mark('sentry-tracing-init'), PZ()
      let t = xZ(),
        n = IZ()
      return () => {
        t && t(), n && n()
      }
    }
    return () => {}
  }
  function wZ() {
    let e = (t) => {
      for (let n of t) {
        let r = IN.getActiveTransaction()
        if (!r) return
        let s = Ue(Fe.browserPerformanceTimeOrigin + n.startTime),
          o = Ue(n.duration)
        r.startChild({
          description: 'Main UI thread blocked',
          op: 'ui.long-task',
          startTimestamp: s,
          endTimestamp: s + o,
        })
      }
    }
    PN.observe('longtask', e)
  }
  function TZ() {
    let e = (t) => {
      for (let n of t) {
        let r = IN.getActiveTransaction()
        if (!r) return
        if (n.name === 'click') {
          let s = Ue(Fe.browserPerformanceTimeOrigin + n.startTime),
            o = Ue(n.duration)
          r.startChild({
            description: Fe.htmlTreeAsString(n.target),
            op: `ui.interaction.${n.name}`,
            startTimestamp: s,
            endTimestamp: s + o,
          })
        }
      }
    }
    PN.observe('event', e, { durationThreshold: 0 })
  }
  function xZ() {
    return EZ.onCLS((e) => {
      let t = e.entries.pop()
      t &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Fe.logger.log('[Measurements] Adding CLS'),
        (Ie.cls = { value: e.value, unit: '' }),
        (bd = t))
    })
  }
  function IZ() {
    return bZ.onLCP((e) => {
      let t = e.entries.pop()
      t &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Fe.logger.log('[Measurements] Adding LCP'),
        (Ie.lcp = { value: e.value, unit: 'millisecond' }),
        (yn = t))
    })
  }
  function PZ() {
    SZ.onFID((e) => {
      let t = e.entries.pop()
      if (!t) return
      let n = Ue(Fe.browserPerformanceTimeOrigin),
        r = Ue(t.startTime)
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Fe.logger.log('[Measurements] Adding FID'),
        (Ie.fid = { value: e.value, unit: 'millisecond' }),
        (Ie['mark.fid'] = { value: n + r, unit: 'second' })
    })
  }
  function RZ(e) {
    let t = RN()
    if (
      !t ||
      !Ks.WINDOW.performance.getEntries ||
      !Fe.browserPerformanceTimeOrigin
    )
      return
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      Fe.logger.log('[Tracing] Adding & adjusting spans using Performance API')
    let n = Ue(Fe.browserPerformanceTimeOrigin),
      r = t.getEntries(),
      s,
      o
    if (
      (r.slice(xN).forEach((i) => {
        let c = Ue(i.startTime),
          a = Ue(i.duration)
        if (!(e.op === 'navigation' && n + c < e.startTimestamp))
          switch (i.entryType) {
            case 'navigation': {
              DZ(e, i, n),
                (s = n + Ue(i.responseStart)),
                (o = n + Ue(i.requestStart))
              break
            }
            case 'mark':
            case 'paint':
            case 'measure': {
              DN(e, i, c, a, n)
              let u = vZ.getVisibilityWatcher(),
                d = i.startTime < u.firstHiddenTime
              i.name === 'first-paint' &&
                d &&
                ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                  Fe.logger.log('[Measurements] Adding FP'),
                (Ie.fp = { value: i.startTime, unit: 'millisecond' })),
                i.name === 'first-contentful-paint' &&
                  d &&
                  ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                    Fe.logger.log('[Measurements] Adding FCP'),
                  (Ie.fcp = { value: i.startTime, unit: 'millisecond' }))
              break
            }
            case 'resource': {
              let u = i.name.replace(Ks.WINDOW.location.origin, '')
              AN(e, i, u, c, a, n)
              break
            }
          }
      }),
      (xN = Math.max(r.length - 1, 0)),
      OZ(e),
      e.op === 'pageload')
    ) {
      typeof s == 'number' &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Fe.logger.log('[Measurements] Adding TTFB'),
        (Ie.ttfb = {
          value: (s - e.startTimestamp) * 1e3,
          unit: 'millisecond',
        }),
        typeof o == 'number' &&
          o <= s &&
          (Ie['ttfb.requestTime'] = {
            value: (s - o) * 1e3,
            unit: 'millisecond',
          })),
        ['fcp', 'fp', 'lcp'].forEach((c) => {
          if (!Ie[c] || n >= e.startTimestamp) return
          let a = Ie[c].value,
            u = n + Ue(a),
            d = Math.abs((u - e.startTimestamp) * 1e3),
            p = d - a
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Fe.logger.log(
              `[Measurements] Normalized ${c} from ${a} to ${d} (${p})`,
            ),
            (Ie[c].value = d)
        })
      let i = Ie['mark.fid']
      i &&
        Ie.fid &&
        (or._startChild(e, {
          description: 'first input delay',
          endTimestamp: i.value + Ue(Ie.fid.value),
          op: 'ui.action',
          startTimestamp: i.value,
        }),
        delete Ie['mark.fid']),
        'fcp' in Ie || delete Ie.cls,
        Object.keys(Ie).forEach((c) => {
          e.setMeasurement(c, Ie[c].value, Ie[c].unit)
        }),
        NZ(e)
    }
    ;(yn = void 0), (bd = void 0), (Ie = {})
  }
  function DN(e, t, n, r, s) {
    let o = s + n,
      i = o + r
    return (
      or._startChild(e, {
        description: t.name,
        endTimestamp: i,
        op: t.entryType,
        startTimestamp: o,
      }),
      o
    )
  }
  function DZ(e, t, n) {
    ;[
      'unloadEvent',
      'redirect',
      'domContentLoadedEvent',
      'loadEvent',
      'connect',
    ].forEach((r) => {
      ym(e, t, r, n)
    }),
      ym(e, t, 'secureConnection', n, 'TLS/SSL', 'connectEnd'),
      ym(e, t, 'fetch', n, 'cache', 'domainLookupStart'),
      ym(e, t, 'domainLookup', n, 'DNS'),
      AZ(e, t, n)
  }
  function ym(e, t, n, r, s, o) {
    let i = o ? t[o] : t[`${n}End`],
      c = t[`${n}Start`]
    !c ||
      !i ||
      or._startChild(e, {
        op: 'browser',
        description: s || n,
        startTimestamp: r + Ue(c),
        endTimestamp: r + Ue(i),
      })
  }
  function AZ(e, t, n) {
    or._startChild(e, {
      op: 'browser',
      description: 'request',
      startTimestamp: n + Ue(t.requestStart),
      endTimestamp: n + Ue(t.responseEnd),
    }),
      or._startChild(e, {
        op: 'browser',
        description: 'response',
        startTimestamp: n + Ue(t.responseStart),
        endTimestamp: n + Ue(t.responseEnd),
      })
  }
  function AN(e, t, n, r, s, o) {
    if (t.initiatorType === 'xmlhttprequest' || t.initiatorType === 'fetch')
      return
    let i = {}
    'transferSize' in t && (i['http.response_transfer_size'] = t.transferSize),
      'encodedBodySize' in t &&
        (i['http.response_content_length'] = t.encodedBodySize),
      'decodedBodySize' in t &&
        (i['http.decoded_response_content_length'] = t.decodedBodySize),
      'renderBlockingStatus' in t &&
        (i['resource.render_blocking_status'] = t.renderBlockingStatus)
    let c = o + r,
      a = c + s
    or._startChild(e, {
      description: n,
      endTimestamp: a,
      op: t.initiatorType ? `resource.${t.initiatorType}` : 'resource.other',
      startTimestamp: c,
      data: i,
    })
  }
  function OZ(e) {
    let t = Ks.WINDOW.navigator
    if (!t) return
    let n = t.connection
    n &&
      (n.effectiveType && e.setTag('effectiveConnectionType', n.effectiveType),
      n.type && e.setTag('connectionType', n.type),
      or.isMeasurementValue(n.rtt) &&
        (Ie['connection.rtt'] = { value: n.rtt, unit: 'millisecond' })),
      or.isMeasurementValue(t.deviceMemory) &&
        e.setTag('deviceMemory', `${t.deviceMemory} GB`),
      or.isMeasurementValue(t.hardwareConcurrency) &&
        e.setTag('hardwareConcurrency', String(t.hardwareConcurrency))
  }
  function NZ(e) {
    yn &&
      ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Fe.logger.log('[Measurements] Adding LCP Data'),
      yn.element && e.setTag('lcp.element', Fe.htmlTreeAsString(yn.element)),
      yn.id && e.setTag('lcp.id', yn.id),
      yn.url && e.setTag('lcp.url', yn.url.trim().slice(0, 200)),
      e.setTag('lcp.size', yn.size)),
      bd &&
        bd.sources &&
        ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Fe.logger.log('[Measurements] Adding CLS Data'),
        bd.sources.forEach((t, n) =>
          e.setTag(`cls.source.${n + 1}`, Fe.htmlTreeAsString(t.node)),
        ))
  }
  jr._addMeasureSpans = DN
  jr._addResourceSpans = AN
  jr.addPerformanceEntries = RZ
  jr.startTrackingInteractions = TZ
  jr.startTrackingLongTasks = wZ
  jr.startTrackingWebVitals = CZ
})
var ev = l((En) => {
  Object.defineProperty(En, '__esModule', { value: !0 })
  var ni = be(),
    et = A(),
    gm = ['localhost', /^\/(?!\/)/],
    Zb = {
      traceFetch: !0,
      traceXHR: !0,
      enableHTTPTimings: !0,
      tracingOrigins: gm,
      tracePropagationTargets: gm,
    }
  function qZ(e) {
    let {
        traceFetch: t,
        traceXHR: n,
        tracePropagationTargets: r,
        tracingOrigins: s,
        shouldCreateSpanForRequest: o,
        enableHTTPTimings: i,
      } = { traceFetch: Zb.traceFetch, traceXHR: Zb.traceXHR, ...e },
      c = typeof o == 'function' ? o : (d) => !0,
      a = (d) => MN(d, r || s),
      u = {}
    t &&
      et.addInstrumentationHandler('fetch', (d) => {
        let p = FN(d, c, a, u)
        i && p && NN(p)
      }),
      n &&
        et.addInstrumentationHandler('xhr', (d) => {
          let p = LN(d, c, a, u)
          i && p && NN(p)
        })
  }
  function NN(e) {
    let t = e.data.url,
      n = new PerformanceObserver((r) => {
        r.getEntries().forEach((o) => {
          ;(o.initiatorType === 'fetch' ||
            o.initiatorType === 'xmlhttprequest') &&
            o.name.endsWith(t) &&
            (kZ(o).forEach((c) => e.setData(...c)), n.disconnect())
        })
      })
    n.observe({ entryTypes: ['resource'] })
  }
  function kN(e) {
    let t = 'unknown',
      n = 'unknown',
      r = ''
    for (let s of e) {
      if (s === '/') {
        ;[t, n] = e.split('/')
        break
      }
      if (!isNaN(Number(s))) {
        ;(t = r === 'h' ? 'http' : r), (n = e.split(r)[1])
        break
      }
      r += s
    }
    return r === e && (t = r), { name: t, version: n }
  }
  function gn(e) {
    return (
      ((et.browserPerformanceTimeOrigin || performance.timeOrigin) + e) / 1e3
    )
  }
  function kZ(e) {
    let { name: t, version: n } = kN(e.nextHopProtocol),
      r = []
    return (
      r.push(['network.protocol.version', n], ['network.protocol.name', t]),
      et.browserPerformanceTimeOrigin
        ? [
            ...r,
            ['http.request.redirect_start', gn(e.redirectStart)],
            ['http.request.fetch_start', gn(e.fetchStart)],
            ['http.request.domain_lookup_start', gn(e.domainLookupStart)],
            ['http.request.domain_lookup_end', gn(e.domainLookupEnd)],
            ['http.request.connect_start', gn(e.connectStart)],
            [
              'http.request.secure_connection_start',
              gn(e.secureConnectionStart),
            ],
            ['http.request.connection_end', gn(e.connectEnd)],
            ['http.request.request_start', gn(e.requestStart)],
            ['http.request.response_start', gn(e.responseStart)],
            ['http.request.response_end', gn(e.responseEnd)],
          ]
        : r
    )
  }
  function MN(e, t) {
    return et.stringMatchesSomePattern(e, t || gm)
  }
  function FN(e, t, n, r) {
    if (!ni.hasTracingEnabled() || !e.fetchData) return
    let s = t(e.fetchData.url)
    if (e.endTimestamp && s) {
      let f = e.fetchData.__span
      if (!f) return
      let _ = r[f]
      if (_) {
        if (e.response) {
          _.setHttpStatus(e.response.status)
          let h =
              e.response &&
              e.response.headers &&
              e.response.headers.get('content-length'),
            g = parseInt(h)
          g > 0 && _.setData('http.response_content_length', g)
        } else e.error && _.setStatus('internal_error')
        _.finish(), delete r[f]
      }
      return
    }
    let o = ni.getCurrentHub(),
      i = o.getScope(),
      c = o.getClient(),
      a = i.getSpan(),
      { method: u, url: d } = e.fetchData,
      p =
        s && a
          ? a.startChild({
              data: { url: d, type: 'fetch', 'http.method': u },
              description: `${u} ${d}`,
              op: 'http.client',
            })
          : void 0
    if (
      (p && ((e.fetchData.__span = p.spanId), (r[p.spanId] = p)),
      n(e.fetchData.url) && c)
    ) {
      let f = e.args[0]
      e.args[1] = e.args[1] || {}
      let _ = e.args[1]
      _.headers = UN(f, c, i, _, p)
    }
    return p
  }
  function UN(e, t, n, r, s) {
    let o = s || n.getSpan(),
      i = o && o.transaction,
      { traceId: c, sampled: a, dsc: u } = n.getPropagationContext(),
      d = o ? o.toTraceparent() : et.generateSentryTraceHeader(c, void 0, a),
      p = i
        ? i.getDynamicSamplingContext()
        : u || ni.getDynamicSamplingContextFromClient(c, t, n),
      f = et.dynamicSamplingContextToSentryBaggageHeader(p),
      _ =
        typeof Request < 'u' && et.isInstanceOf(e, Request)
          ? e.headers
          : r.headers
    if (_)
      if (typeof Headers < 'u' && et.isInstanceOf(_, Headers)) {
        let h = new Headers(_)
        return (
          h.append('sentry-trace', d),
          f && h.append(et.BAGGAGE_HEADER_NAME, f),
          h
        )
      } else if (Array.isArray(_)) {
        let h = [..._, ['sentry-trace', d]]
        return f && h.push([et.BAGGAGE_HEADER_NAME, f]), h
      } else {
        let h = 'baggage' in _ ? _.baggage : void 0,
          g = []
        return (
          Array.isArray(h) ? g.push(...h) : h && g.push(h),
          f && g.push(f),
          {
            ..._,
            'sentry-trace': d,
            baggage: g.length > 0 ? g.join(',') : void 0,
          }
        )
      }
    else return { 'sentry-trace': d, baggage: f }
  }
  function LN(e, t, n, r) {
    let s = e.xhr,
      o = s && s[et.SENTRY_XHR_DATA_KEY]
    if (!ni.hasTracingEnabled() || (s && s.__sentry_own_request__) || !s || !o)
      return
    let i = t(o.url)
    if (e.endTimestamp && i) {
      let p = s.__sentry_xhr_span_id__
      if (!p) return
      let f = r[p]
      f && (f.setHttpStatus(o.status_code), f.finish(), delete r[p])
      return
    }
    let c = ni.getCurrentHub(),
      a = c.getScope(),
      u = a.getSpan(),
      d =
        i && u
          ? u.startChild({
              data: {
                ...o.data,
                type: 'xhr',
                'http.method': o.method,
                url: o.url,
              },
              description: `${o.method} ${o.url}`,
              op: 'http.client',
            })
          : void 0
    if (
      (d &&
        ((s.__sentry_xhr_span_id__ = d.spanId),
        (r[s.__sentry_xhr_span_id__] = d)),
      s.setRequestHeader && n(o.url))
    )
      if (d) {
        let p = d && d.transaction,
          f = p && p.getDynamicSamplingContext(),
          _ = et.dynamicSamplingContextToSentryBaggageHeader(f)
        qN(s, d.toTraceparent(), _)
      } else {
        let p = c.getClient(),
          { traceId: f, sampled: _, dsc: h } = a.getPropagationContext(),
          g = et.generateSentryTraceHeader(f, void 0, _),
          E =
            h || (p ? ni.getDynamicSamplingContextFromClient(f, p, a) : void 0),
          P = et.dynamicSamplingContextToSentryBaggageHeader(E)
        qN(s, g, P)
      }
    return d
  }
  function qN(e, t, n) {
    try {
      e.setRequestHeader('sentry-trace', t),
        n && e.setRequestHeader(et.BAGGAGE_HEADER_NAME, n)
    } catch {}
  }
  En.DEFAULT_TRACE_PROPAGATION_TARGETS = gm
  En.addTracingHeadersToFetchRequest = UN
  En.defaultRequestInstrumentationOptions = Zb
  En.extractNetworkProtocol = kN
  En.fetchCallback = FN
  En.instrumentOutgoingRequests = qZ
  En.shouldAttachHeaders = MN
  En.xhrCallback = LN
})
var BN = l((tv) => {
  Object.defineProperty(tv, '__esModule', { value: !0 })
  var vd = A(),
    Cd = sr()
  function MZ(e, t = !0, n = !0) {
    if (!Cd.WINDOW || !Cd.WINDOW.location) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        vd.logger.warn(
          'Could not initialize routing instrumentation due to invalid location',
        )
      return
    }
    let r = Cd.WINDOW.location.href,
      s
    t &&
      (s = e({
        name: Cd.WINDOW.location.pathname,
        startTimestamp: vd.browserPerformanceTimeOrigin
          ? vd.browserPerformanceTimeOrigin / 1e3
          : void 0,
        op: 'pageload',
        metadata: { source: 'url' },
      })),
      n &&
        vd.addInstrumentationHandler('history', ({ to: o, from: i }) => {
          if (i === void 0 && r && r.indexOf(o) !== -1) {
            r = void 0
            return
          }
          i !== o &&
            ((r = void 0),
            s &&
              ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                vd.logger.log(
                  `[Tracing] Finishing current transaction with op: ${s.op}`,
                ),
              s.finish()),
            (s = e({
              name: Cd.WINDOW.location.pathname,
              op: 'navigation',
              metadata: { source: 'url' },
            })))
        })
  }
  tv.instrumentRoutingWithDefaults = MZ
})
var zN = l((Td) => {
  Object.defineProperty(Td, '__esModule', { value: !0 })
  var wd = be(),
    ir = A(),
    FZ = gN(),
    Em = ON(),
    GN = ev(),
    UZ = BN(),
    jN = sr(),
    $N = 'BrowserTracing',
    LZ = {
      ...wd.TRACING_DEFAULTS,
      markBackgroundTransactions: !0,
      routingInstrumentation: UZ.instrumentRoutingWithDefaults,
      startTransactionOnLocationChange: !0,
      startTransactionOnPageLoad: !0,
      enableLongTask: !0,
      _experiments: {},
      ...GN.defaultRequestInstrumentationOptions,
    },
    nv = class {
      constructor(t) {
        ;(this.name = $N),
          (this._hasSetTracePropagationTargets = !1),
          wd.addTracingExtensions(),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            (this._hasSetTracePropagationTargets = !!(
              t &&
              (t.tracePropagationTargets || t.tracingOrigins)
            )),
          (this.options = { ...LZ, ...t }),
          this.options._experiments.enableLongTask !== void 0 &&
            (this.options.enableLongTask =
              this.options._experiments.enableLongTask),
          t &&
            !t.tracePropagationTargets &&
            t.tracingOrigins &&
            (this.options.tracePropagationTargets = t.tracingOrigins),
          (this._collectWebVitals = Em.startTrackingWebVitals()),
          this.options.enableLongTask && Em.startTrackingLongTasks(),
          this.options._experiments.enableInteractions &&
            Em.startTrackingInteractions()
      }
      setupOnce(t, n) {
        this._getCurrentHub = n
        let s = n().getClient(),
          o = s && s.getOptions(),
          {
            routingInstrumentation: i,
            startTransactionOnLocationChange: c,
            startTransactionOnPageLoad: a,
            markBackgroundTransactions: u,
            traceFetch: d,
            traceXHR: p,
            shouldCreateSpanForRequest: f,
            enableHTTPTimings: _,
            _experiments: h,
          } = this.options,
          g = o && o.tracePropagationTargets,
          E = g || this.options.tracePropagationTargets
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          this._hasSetTracePropagationTargets &&
          g &&
          ir.logger.warn(
            '[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.',
          ),
          i(
            (P) => {
              let z = this._createRouteTransaction(P)
              return (
                this.options._experiments.onStartRouteTransaction &&
                  this.options._experiments.onStartRouteTransaction(z, P, n),
                z
              )
            },
            a,
            c,
          ),
          u && FZ.registerBackgroundTabDetection(),
          h.enableInteractions && this._registerInteractionListener(),
          GN.instrumentOutgoingRequests({
            traceFetch: d,
            traceXHR: p,
            tracePropagationTargets: E,
            shouldCreateSpanForRequest: f,
            enableHTTPTimings: _,
          })
      }
      _createRouteTransaction(t) {
        if (!this._getCurrentHub) {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            ir.logger.warn(
              `[Tracing] Did not create ${t.op} transaction because _getCurrentHub is invalid.`,
            )
          return
        }
        let n = this._getCurrentHub(),
          {
            beforeNavigate: r,
            idleTimeout: s,
            finalTimeout: o,
            heartbeatInterval: i,
          } = this.options,
          c = t.op === 'pageload',
          a = c ? rv('sentry-trace') : '',
          u = c ? rv('baggage') : '',
          {
            traceparentData: d,
            dynamicSamplingContext: p,
            propagationContext: f,
          } = ir.tracingContextFromHeaders(a, u),
          _ = {
            ...t,
            ...d,
            metadata: {
              ...t.metadata,
              dynamicSamplingContext: d && !p ? {} : p,
            },
            trimEnd: !0,
          },
          h = typeof r == 'function' ? r(_) : _,
          g = h === void 0 ? { ..._, sampled: !1 } : h
        ;(g.metadata =
          g.name !== _.name ? { ...g.metadata, source: 'custom' } : g.metadata),
          (this._latestRouteName = g.name),
          (this._latestRouteSource = g.metadata && g.metadata.source),
          g.sampled === !1 &&
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            ir.logger.log(
              `[Tracing] Will not send ${g.op} transaction because of beforeNavigate.`,
            ),
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            ir.logger.log(`[Tracing] Starting ${g.op} transaction on scope`)
        let { location: E } = jN.WINDOW,
          P = wd.startIdleTransaction(n, g, s, o, !0, { location: E }, i),
          z = n.getScope()
        return (
          c && d
            ? z.setPropagationContext(f)
            : z.setPropagationContext({
                traceId: P.traceId,
                spanId: P.spanId,
                parentSpanId: P.parentSpanId,
                sampled: !!P.sampled,
              }),
          P.registerBeforeFinishCallback((ye) => {
            this._collectWebVitals(), Em.addPerformanceEntries(ye)
          }),
          P
        )
      }
      _registerInteractionListener() {
        let t,
          n = () => {
            let {
                idleTimeout: r,
                finalTimeout: s,
                heartbeatInterval: o,
              } = this.options,
              i = 'ui.action.click',
              c = wd.getActiveTransaction()
            if (c && c.op && ['navigation', 'pageload'].includes(c.op)) {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                ir.logger.warn(
                  `[Tracing] Did not create ${i} transaction because a pageload or navigation transaction is in progress.`,
                )
              return
            }
            if (
              (t &&
                (t.setFinishReason('interactionInterrupted'),
                t.finish(),
                (t = void 0)),
              !this._getCurrentHub)
            ) {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                ir.logger.warn(
                  `[Tracing] Did not create ${i} transaction because _getCurrentHub is invalid.`,
                )
              return
            }
            if (!this._latestRouteName) {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                ir.logger.warn(
                  `[Tracing] Did not create ${i} transaction because _latestRouteName is missing.`,
                )
              return
            }
            let a = this._getCurrentHub(),
              { location: u } = jN.WINDOW,
              d = {
                name: this._latestRouteName,
                op: i,
                trimEnd: !0,
                metadata: { source: this._latestRouteSource || 'url' },
              }
            t = wd.startIdleTransaction(a, d, r, s, !0, { location: u }, o)
          }
        ;['click'].forEach((r) => {
          addEventListener(r, n, { once: !1, capture: !0 })
        })
      }
    }
  function rv(e) {
    let t = ir.getDomElement(`meta[name=${e}]`)
    return t ? t.getAttribute('content') : void 0
  }
  Td.BROWSER_TRACING_INTEGRATION_ID = $N
  Td.BrowserTracing = nv
  Td.getMetaContent = rv
})
var WN = l((sv, xd) => {
  Object.defineProperty(sv, '__esModule', { value: !0 })
  var HN = be(),
    ri = A()
  function BZ() {
    let e = HN.getMainCarrier()
    if (!e.__SENTRY__) return
    let t = {
        mongodb() {
          let r = ri.dynamicRequire(xd, './node/integrations/mongo')
          return new r.Mongo()
        },
        mongoose() {
          let r = ri.dynamicRequire(xd, './node/integrations/mongo')
          return new r.Mongo()
        },
        mysql() {
          let r = ri.dynamicRequire(xd, './node/integrations/mysql')
          return new r.Mysql()
        },
        pg() {
          let r = ri.dynamicRequire(xd, './node/integrations/postgres')
          return new r.Postgres()
        },
      },
      n = Object.keys(t)
        .filter((r) => !!ri.loadModule(r))
        .map((r) => {
          try {
            return t[r]()
          } catch {
            return
          }
        })
        .filter((r) => r)
    n.length > 0 &&
      (e.__SENTRY__.integrations = [...(e.__SENTRY__.integrations || []), ...n])
  }
  function jZ() {
    HN.addTracingExtensions(), ri.isNodeEnv() && BZ()
  }
  sv.addExtensionMethods = jZ
})
var iv = l((he) => {
  Object.defineProperty(he, '__esModule', { value: !0 })
  var ar = be(),
    VN = A(),
    GZ = iN(),
    $Z = aN(),
    zZ = cN(),
    HZ = dN(),
    WZ = mN(),
    VZ = pN(),
    YZ = _N(),
    KZ = hN(),
    YN = zN(),
    ov = ev(),
    JZ = WN()
  he.IdleTransaction = ar.IdleTransaction
  he.Span = ar.Span
  he.SpanStatus = ar.SpanStatus
  he.Transaction = ar.Transaction
  he.extractTraceparentData = ar.extractTraceparentData
  he.getActiveTransaction = ar.getActiveTransaction
  he.hasTracingEnabled = ar.hasTracingEnabled
  he.spanStatusfromHttpCode = ar.spanStatusfromHttpCode
  he.startIdleTransaction = ar.startIdleTransaction
  he.TRACEPARENT_REGEXP = VN.TRACEPARENT_REGEXP
  he.stripUrlQueryAndFragment = VN.stripUrlQueryAndFragment
  he.Express = GZ.Express
  he.Postgres = $Z.Postgres
  he.Mysql = zZ.Mysql
  he.Mongo = HZ.Mongo
  he.Prisma = WZ.Prisma
  he.GraphQL = VZ.GraphQL
  he.Apollo = YZ.Apollo
  he.lazyLoadedNodePerformanceMonitoringIntegrations =
    KZ.lazyLoadedNodePerformanceMonitoringIntegrations
  he.BROWSER_TRACING_INTEGRATION_ID = YN.BROWSER_TRACING_INTEGRATION_ID
  he.BrowserTracing = YN.BrowserTracing
  he.addTracingHeadersToFetchRequest = ov.addTracingHeadersToFetchRequest
  he.defaultRequestInstrumentationOptions =
    ov.defaultRequestInstrumentationOptions
  he.instrumentOutgoingRequests = ov.instrumentOutgoingRequests
  he.addExtensionMethods = JZ.addExtensionMethods
})
var KN = l((av) => {
  Object.defineProperty(av, '__esModule', { value: !0 })
  var XZ = iv(),
    QZ = A()
  function ZZ() {
    let e = XZ.lazyLoadedNodePerformanceMonitoringIntegrations
      .map((t) => {
        try {
          return t()
        } catch {
          return
        }
      })
      .filter((t) => !!t)
    return (
      e.length === 0 &&
        QZ.logger.warn(
          'Performance monitoring integrations could not be automatically loaded.',
        ),
      e.filter((t) => !!t.loadDependency())
    )
  }
  av.autoDiscoverNodePerformanceMonitoringIntegrations = ZZ
})
var dv = l((oi) => {
  Object.defineProperty(oi, '__esModule', { value: !0 })
  var eee = be(),
    si = A()
  function cv(e, t) {
    return e(t.stack || '', 1)
  }
  function JN(e, t) {
    let n = { type: t.name || t.constructor.name, value: t.message },
      r = cv(e, t)
    return r.length && (n.stacktrace = { frames: r }), n
  }
  function tee(e, t, n) {
    let r = t,
      o = (n && n.data && n.data.mechanism) || { handled: !0, type: 'generic' }
    if (!si.isError(t)) {
      if (si.isPlainObject(t)) {
        let c = `Non-Error exception captured with keys: ${si.extractExceptionKeysForMessage(
            t,
          )}`,
          a = eee.getCurrentHub(),
          u = a.getClient(),
          d = u && u.getOptions().normalizeDepth
        a.configureScope((p) => {
          p.setExtra('__serialized__', si.normalizeToSize(t, d))
        }),
          (r = (n && n.syntheticException) || new Error(c)),
          (r.message = c)
      } else (r = (n && n.syntheticException) || new Error(t)), (r.message = t)
      o.synthetic = !0
    }
    let i = { exception: { values: [JN(e, r)] } }
    return (
      si.addExceptionTypeValue(i, void 0, void 0),
      si.addExceptionMechanism(i, o),
      { ...i, event_id: n && n.event_id }
    )
  }
  function nee(e, t, n = 'info', r, s) {
    let o = { event_id: r && r.event_id, level: n, message: t }
    if (s && r && r.syntheticException) {
      let i = cv(e, r.syntheticException)
      i.length &&
        (o.exception = { values: [{ value: t, stacktrace: { frames: i } }] })
    }
    return o
  }
  oi.eventFromMessage = nee
  oi.eventFromUnknownInput = tee
  oi.exceptionFromError = JN
  oi.parseStackFrames = cv
})
var mv = l((lv) => {
  var { _optionalChain: Sm } = ge()
  Object.defineProperty(lv, '__esModule', { value: !0 })
  var Js = be(),
    Xs = A(),
    ree = require('os'),
    see = require('util'),
    XN = dv(),
    uv = class extends Js.BaseClient {
      constructor(t) {
        ;(t._metadata = t._metadata || {}),
          (t._metadata.sdk = t._metadata.sdk || {
            name: 'sentry.javascript.node',
            packages: [{ name: 'npm:@sentry/node', version: Js.SDK_VERSION }],
            version: Js.SDK_VERSION,
          }),
          (t.transportOptions = {
            textEncoder: new see.TextEncoder(),
            ...t.transportOptions,
          }),
          Js.addTracingExtensions(),
          super(t)
      }
      captureException(t, n, r) {
        if (this._options.autoSessionTracking && this._sessionFlusher && r) {
          let s = r.getRequestSession()
          s && s.status === 'ok' && (s.status = 'errored')
        }
        return super.captureException(t, n, r)
      }
      captureEvent(t, n, r) {
        if (
          this._options.autoSessionTracking &&
          this._sessionFlusher &&
          r &&
          (t.type || 'exception') === 'exception' &&
          t.exception &&
          t.exception.values &&
          t.exception.values.length > 0
        ) {
          let i = r.getRequestSession()
          i && i.status === 'ok' && (i.status = 'errored')
        }
        return super.captureEvent(t, n, r)
      }
      close(t) {
        return (
          Sm([
            this,
            'access',
            (n) => n._sessionFlusher,
            'optionalAccess',
            (n) => n.close,
            'call',
            (n) => n(),
          ]),
          super.close(t)
        )
      }
      initSessionFlusher() {
        let { release: t, environment: n } = this._options
        t
          ? (this._sessionFlusher = new Js.SessionFlusher(this, {
              release: t,
              environment: n,
            }))
          : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Xs.logger.warn(
              'Cannot initialise an instance of SessionFlusher if no release is provided!',
            )
      }
      eventFromException(t, n) {
        return Xs.resolvedSyncPromise(
          XN.eventFromUnknownInput(this._options.stackParser, t, n),
        )
      }
      eventFromMessage(t, n = 'info', r) {
        return Xs.resolvedSyncPromise(
          XN.eventFromMessage(
            this._options.stackParser,
            t,
            n,
            r,
            this._options.attachStacktrace,
          ),
        )
      }
      captureCheckIn(t, n, r) {
        let s =
          t.status !== 'in_progress' && t.checkInId ? t.checkInId : Xs.uuid4()
        if (!this._isEnabled())
          return (
            (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              Xs.logger.warn('SDK not enabled, will not capture checkin.'),
            s
          )
        let o = this.getOptions(),
          { release: i, environment: c, tunnel: a } = o,
          u = {
            check_in_id: s,
            monitor_slug: t.monitorSlug,
            status: t.status,
            release: i,
            environment: c,
          }
        t.status !== 'in_progress' && (u.duration = t.duration),
          n &&
            (u.monitor_config = {
              schedule: n.schedule,
              checkin_margin: n.checkinMargin,
              max_runtime: n.maxRuntime,
              timezone: n.timezone,
            })
        let [d, p] = this._getTraceInfoFromScope(r)
        p && (u.contexts = { trace: p })
        let f = Js.createCheckInEnvelope(
          u,
          d,
          this.getSdkMetadata(),
          a,
          this.getDsn(),
        )
        return (
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Xs.logger.info('Sending checkin:', t.monitorSlug, t.status),
          this._sendEnvelope(f),
          s
        )
      }
      _prepareEvent(t, n, r) {
        return (
          (t.platform = t.platform || 'node'),
          (t.contexts = {
            ...t.contexts,
            runtime: Sm([
              t,
              'access',
              (s) => s.contexts,
              'optionalAccess',
              (s) => s.runtime,
            ]) || { name: 'node', version: global.process.version },
          }),
          (t.server_name =
            t.server_name ||
            this.getOptions().serverName ||
            global.process.env.SENTRY_NAME ||
            ree.hostname()),
          super._prepareEvent(t, n, r)
        )
      }
      _captureRequestSession() {
        this._sessionFlusher
          ? this._sessionFlusher.incrementSessionStatusCount()
          : (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Xs.logger.warn(
              'Discarded request mode session because autoSessionTracking option was disabled',
            )
      }
      _getTraceInfoFromScope(t) {
        if (!t) return [void 0, void 0]
        let n = t.getSpan()
        if (n)
          return [
            Sm([
              n,
              'optionalAccess',
              (a) => a.transaction,
              'optionalAccess',
              (a) => a.getDynamicSamplingContext,
              'call',
              (a) => a(),
            ]),
            Sm([
              n,
              'optionalAccess',
              (a) => a.getTraceContext,
              'call',
              (a) => a(),
            ]),
          ]
        let {
            traceId: r,
            spanId: s,
            parentSpanId: o,
            dsc: i,
          } = t.getPropagationContext(),
          c = { trace_id: r, span_id: s, parent_span_id: o }
        return i
          ? [i, c]
          : [Js.getDynamicSamplingContextFromClient(r, this, t), c]
      }
    }
  lv.NodeClient = uv
})
var ZN = l((RMe, QN) => {
  var ii = 1e3,
    ai = ii * 60,
    ci = ai * 60,
    Qs = ci * 24,
    oee = Qs * 7,
    iee = Qs * 365.25
  QN.exports = function (e, t) {
    t = t || {}
    var n = typeof e
    if (n === 'string' && e.length > 0) return aee(e)
    if (n === 'number' && isFinite(e)) return t.long ? dee(e) : cee(e)
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(e),
    )
  }
  function aee(e) {
    if (((e = String(e)), !(e.length > 100))) {
      var t =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          e,
        )
      if (t) {
        var n = parseFloat(t[1]),
          r = (t[2] || 'ms').toLowerCase()
        switch (r) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * iee
          case 'weeks':
          case 'week':
          case 'w':
            return n * oee
          case 'days':
          case 'day':
          case 'd':
            return n * Qs
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * ci
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * ai
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * ii
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n
          default:
            return
        }
      }
    }
  }
  function cee(e) {
    var t = Math.abs(e)
    return t >= Qs
      ? Math.round(e / Qs) + 'd'
      : t >= ci
      ? Math.round(e / ci) + 'h'
      : t >= ai
      ? Math.round(e / ai) + 'm'
      : t >= ii
      ? Math.round(e / ii) + 's'
      : e + 'ms'
  }
  function dee(e) {
    var t = Math.abs(e)
    return t >= Qs
      ? bm(e, t, Qs, 'day')
      : t >= ci
      ? bm(e, t, ci, 'hour')
      : t >= ai
      ? bm(e, t, ai, 'minute')
      : t >= ii
      ? bm(e, t, ii, 'second')
      : e + ' ms'
  }
  function bm(e, t, n, r) {
    var s = t >= n * 1.5
    return Math.round(e / n) + ' ' + r + (s ? 's' : '')
  }
})
var pv = l((DMe, eq) => {
  function uee(e) {
    ;(n.debug = n),
      (n.default = n),
      (n.coerce = a),
      (n.disable = o),
      (n.enable = s),
      (n.enabled = i),
      (n.humanize = ZN()),
      (n.destroy = u),
      Object.keys(e).forEach((d) => {
        n[d] = e[d]
      }),
      (n.names = []),
      (n.skips = []),
      (n.formatters = {})
    function t(d) {
      let p = 0
      for (let f = 0; f < d.length; f++)
        (p = (p << 5) - p + d.charCodeAt(f)), (p |= 0)
      return n.colors[Math.abs(p) % n.colors.length]
    }
    n.selectColor = t
    function n(d) {
      let p,
        f = null,
        _,
        h
      function g(...E) {
        if (!g.enabled) return
        let P = g,
          z = Number(new Date()),
          ye = z - (p || z)
        ;(P.diff = ye),
          (P.prev = p),
          (P.curr = z),
          (p = z),
          (E[0] = n.coerce(E[0])),
          typeof E[0] != 'string' && E.unshift('%O')
        let fe = 0
        ;(E[0] = E[0].replace(/%([a-zA-Z%])/g, (Q, De) => {
          if (Q === '%%') return '%'
          fe++
          let bt = n.formatters[De]
          if (typeof bt == 'function') {
            let Ls = E[fe]
            ;(Q = bt.call(P, Ls)), E.splice(fe, 1), fe--
          }
          return Q
        })),
          n.formatArgs.call(P, E),
          (P.log || n.log).apply(P, E)
      }
      return (
        (g.namespace = d),
        (g.useColors = n.useColors()),
        (g.color = n.selectColor(d)),
        (g.extend = r),
        (g.destroy = n.destroy),
        Object.defineProperty(g, 'enabled', {
          enumerable: !0,
          configurable: !1,
          get: () =>
            f !== null
              ? f
              : (_ !== n.namespaces && ((_ = n.namespaces), (h = n.enabled(d))),
                h),
          set: (E) => {
            f = E
          },
        }),
        typeof n.init == 'function' && n.init(g),
        g
      )
    }
    function r(d, p) {
      let f = n(this.namespace + (typeof p > 'u' ? ':' : p) + d)
      return (f.log = this.log), f
    }
    function s(d) {
      n.save(d), (n.namespaces = d), (n.names = []), (n.skips = [])
      let p,
        f = (typeof d == 'string' ? d : '').split(/[\s,]+/),
        _ = f.length
      for (p = 0; p < _; p++)
        f[p] &&
          ((d = f[p].replace(/\*/g, '.*?')),
          d[0] === '-'
            ? n.skips.push(new RegExp('^' + d.slice(1) + '$'))
            : n.names.push(new RegExp('^' + d + '$')))
    }
    function o() {
      let d = [...n.names.map(c), ...n.skips.map(c).map((p) => '-' + p)].join(
        ',',
      )
      return n.enable(''), d
    }
    function i(d) {
      if (d[d.length - 1] === '*') return !0
      let p, f
      for (p = 0, f = n.skips.length; p < f; p++)
        if (n.skips[p].test(d)) return !1
      for (p = 0, f = n.names.length; p < f; p++)
        if (n.names[p].test(d)) return !0
      return !1
    }
    function c(d) {
      return d
        .toString()
        .substring(2, d.toString().length - 2)
        .replace(/\.\*\?$/, '*')
    }
    function a(d) {
      return d instanceof Error ? d.stack || d.message : d
    }
    function u() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
      )
    }
    return n.enable(n.load()), n
  }
  eq.exports = uee
})
var tq = l((wt, vm) => {
  wt.formatArgs = mee
  wt.save = pee
  wt.load = fee
  wt.useColors = lee
  wt.storage = _ee()
  wt.destroy = (() => {
    let e = !1
    return () => {
      e ||
        ((e = !0),
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
        ))
    }
  })()
  wt.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33',
  ]
  function lee() {
    return typeof window < 'u' &&
      window.process &&
      (window.process.type === 'renderer' || window.process.__nwjs)
      ? !0
      : typeof navigator < 'u' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ? !1
      : (typeof document < 'u' &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        (typeof window < 'u' &&
          window.console &&
          (window.console.firebug ||
            (window.console.exception && window.console.table))) ||
        (typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
          parseInt(RegExp.$1, 10) >= 31) ||
        (typeof navigator < 'u' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
  }
  function mee(e) {
    if (
      ((e[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        e[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        vm.exports.humanize(this.diff)),
      !this.useColors)
    )
      return
    let t = 'color: ' + this.color
    e.splice(1, 0, t, 'color: inherit')
    let n = 0,
      r = 0
    e[0].replace(/%[a-zA-Z%]/g, (s) => {
      s !== '%%' && (n++, s === '%c' && (r = n))
    }),
      e.splice(r, 0, t)
  }
  wt.log = console.debug || console.log || (() => {})
  function pee(e) {
    try {
      e ? wt.storage.setItem('debug', e) : wt.storage.removeItem('debug')
    } catch {}
  }
  function fee() {
    let e
    try {
      e = wt.storage.getItem('debug')
    } catch {}
    return (
      !e && typeof process < 'u' && 'env' in process && (e = process.env.DEBUG),
      e
    )
  }
  function _ee() {
    try {
      return localStorage
    } catch {}
  }
  vm.exports = pv()(wt)
  var { formatters: hee } = vm.exports
  hee.j = function (e) {
    try {
      return JSON.stringify(e)
    } catch (t) {
      return '[UnexpectedJSONParseError]: ' + t.message
    }
  }
})
var rq = l((AMe, nq) => {
  'use strict'
  nq.exports = (e, t = process.argv) => {
    let n = e.startsWith('-') ? '' : e.length === 1 ? '-' : '--',
      r = t.indexOf(n + e),
      s = t.indexOf('--')
    return r !== -1 && (s === -1 || r < s)
  }
})
var iq = l((OMe, oq) => {
  'use strict'
  var yee = require('os'),
    sq = require('tty'),
    jt = rq(),
    { env: Be } = process,
    Gr
  jt('no-color') || jt('no-colors') || jt('color=false') || jt('color=never')
    ? (Gr = 0)
    : (jt('color') || jt('colors') || jt('color=true') || jt('color=always')) &&
      (Gr = 1)
  'FORCE_COLOR' in Be &&
    (Be.FORCE_COLOR === 'true'
      ? (Gr = 1)
      : Be.FORCE_COLOR === 'false'
      ? (Gr = 0)
      : (Gr =
          Be.FORCE_COLOR.length === 0
            ? 1
            : Math.min(parseInt(Be.FORCE_COLOR, 10), 3)))
  function fv(e) {
    return e === 0
      ? !1
      : { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }
  }
  function _v(e, t) {
    if (Gr === 0) return 0
    if (jt('color=16m') || jt('color=full') || jt('color=truecolor')) return 3
    if (jt('color=256')) return 2
    if (e && !t && Gr === void 0) return 0
    let n = Gr || 0
    if (Be.TERM === 'dumb') return n
    if (process.platform === 'win32') {
      let r = yee.release().split('.')
      return Number(r[0]) >= 10 && Number(r[2]) >= 10586
        ? Number(r[2]) >= 14931
          ? 3
          : 2
        : 1
    }
    if ('CI' in Be)
      return [
        'TRAVIS',
        'CIRCLECI',
        'APPVEYOR',
        'GITLAB_CI',
        'GITHUB_ACTIONS',
        'BUILDKITE',
      ].some((r) => r in Be) || Be.CI_NAME === 'codeship'
        ? 1
        : n
    if ('TEAMCITY_VERSION' in Be)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Be.TEAMCITY_VERSION) ? 1 : 0
    if (Be.COLORTERM === 'truecolor') return 3
    if ('TERM_PROGRAM' in Be) {
      let r = parseInt((Be.TERM_PROGRAM_VERSION || '').split('.')[0], 10)
      switch (Be.TERM_PROGRAM) {
        case 'iTerm.app':
          return r >= 3 ? 3 : 2
        case 'Apple_Terminal':
          return 2
      }
    }
    return /-256(color)?$/i.test(Be.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
          Be.TERM,
        ) || 'COLORTERM' in Be
      ? 1
      : n
  }
  function gee(e) {
    let t = _v(e, e && e.isTTY)
    return fv(t)
  }
  oq.exports = {
    supportsColor: gee,
    stdout: fv(_v(!0, sq.isatty(1))),
    stderr: fv(_v(!0, sq.isatty(2))),
  }
})
var cq = l((We, wm) => {
  var Eee = require('tty'),
    Cm = require('util')
  We.init = xee
  We.log = Cee
  We.formatArgs = bee
  We.save = wee
  We.load = Tee
  We.useColors = See
  We.destroy = Cm.deprecate(
    () => {},
    'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
  )
  We.colors = [6, 2, 3, 4, 5, 1]
  try {
    let e = iq()
    e &&
      (e.stderr || e).level >= 2 &&
      (We.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,
        68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,
        129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
      ])
  } catch {}
  We.inspectOpts = Object.keys(process.env)
    .filter((e) => /^debug_/i.test(e))
    .reduce((e, t) => {
      let n = t
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (s, o) => o.toUpperCase()),
        r = process.env[t]
      return (
        /^(yes|on|true|enabled)$/i.test(r)
          ? (r = !0)
          : /^(no|off|false|disabled)$/i.test(r)
          ? (r = !1)
          : r === 'null'
          ? (r = null)
          : (r = Number(r)),
        (e[n] = r),
        e
      )
    }, {})
  function See() {
    return 'colors' in We.inspectOpts
      ? !!We.inspectOpts.colors
      : Eee.isatty(process.stderr.fd)
  }
  function bee(e) {
    let { namespace: t, useColors: n } = this
    if (n) {
      let r = this.color,
        s = '\x1B[3' + (r < 8 ? r : '8;5;' + r),
        o = `  ${s};1m${t} \x1B[0m`
      ;(e[0] =
        o +
        e[0]
          .split(
            `
`,
          )
          .join(
            `
` + o,
          )),
        e.push(s + 'm+' + wm.exports.humanize(this.diff) + '\x1B[0m')
    } else e[0] = vee() + t + ' ' + e[0]
  }
  function vee() {
    return We.inspectOpts.hideDate ? '' : new Date().toISOString() + ' '
  }
  function Cee(...e) {
    return process.stderr.write(
      Cm.format(...e) +
        `
`,
    )
  }
  function wee(e) {
    e ? (process.env.DEBUG = e) : delete process.env.DEBUG
  }
  function Tee() {
    return process.env.DEBUG
  }
  function xee(e) {
    e.inspectOpts = {}
    let t = Object.keys(We.inspectOpts)
    for (let n = 0; n < t.length; n++)
      e.inspectOpts[t[n]] = We.inspectOpts[t[n]]
  }
  wm.exports = pv()(We)
  var { formatters: aq } = wm.exports
  aq.o = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      Cm.inspect(e, this.inspectOpts)
        .split(
          `
`,
        )
        .map((t) => t.trim())
        .join(' ')
    )
  }
  aq.O = function (e) {
    return (
      (this.inspectOpts.colors = this.useColors),
      Cm.inspect(e, this.inspectOpts)
    )
  }
})
var Tm = l((NMe, hv) => {
  typeof process > 'u' ||
  process.type === 'renderer' ||
  process.browser === !0 ||
  process.__nwjs
    ? (hv.exports = tq())
    : (hv.exports = cq())
})
var dq = l((yv) => {
  'use strict'
  Object.defineProperty(yv, '__esModule', { value: !0 })
  function Iee(e) {
    return function (t, n) {
      return new Promise((r, s) => {
        e.call(this, t, n, (o, i) => {
          o ? s(o) : r(i)
        })
      })
    }
  }
  yv.default = Iee
})
var mq = l((Ev, lq) => {
  'use strict'
  var uq =
      (Ev && Ev.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e }
      },
    Pee = require('events'),
    Ree = uq(Tm()),
    Dee = uq(dq()),
    Id = Ree.default('agent-base')
  function Aee(e) {
    return !!e && typeof e.addRequest == 'function'
  }
  function gv() {
    let { stack: e } = new Error()
    return typeof e != 'string'
      ? !1
      : e
          .split(
            `
`,
          )
          .some(
            (t) =>
              t.indexOf('(https.js:') !== -1 || t.indexOf('node:https:') !== -1,
          )
  }
  function xm(e, t) {
    return new xm.Agent(e, t)
  }
  ;(function (e) {
    class t extends Pee.EventEmitter {
      constructor(r, s) {
        super()
        let o = s
        typeof r == 'function' ? (this.callback = r) : r && (o = r),
          (this.timeout = null),
          o && typeof o.timeout == 'number' && (this.timeout = o.timeout),
          (this.maxFreeSockets = 1),
          (this.maxSockets = 1),
          (this.maxTotalSockets = 1 / 0),
          (this.sockets = {}),
          (this.freeSockets = {}),
          (this.requests = {}),
          (this.options = {})
      }
      get defaultPort() {
        return typeof this.explicitDefaultPort == 'number'
          ? this.explicitDefaultPort
          : gv()
          ? 443
          : 80
      }
      set defaultPort(r) {
        this.explicitDefaultPort = r
      }
      get protocol() {
        return typeof this.explicitProtocol == 'string'
          ? this.explicitProtocol
          : gv()
          ? 'https:'
          : 'http:'
      }
      set protocol(r) {
        this.explicitProtocol = r
      }
      callback(r, s, o) {
        throw new Error(
          '"agent-base" has no default implementation, you must subclass and override `callback()`',
        )
      }
      addRequest(r, s) {
        let o = Object.assign({}, s)
        typeof o.secureEndpoint != 'boolean' && (o.secureEndpoint = gv()),
          o.host == null && (o.host = 'localhost'),
          o.port == null && (o.port = o.secureEndpoint ? 443 : 80),
          o.protocol == null &&
            (o.protocol = o.secureEndpoint ? 'https:' : 'http:'),
          o.host && o.path && delete o.path,
          delete o.agent,
          delete o.hostname,
          delete o._defaultAgent,
          delete o.defaultPort,
          delete o.createConnection,
          (r._last = !0),
          (r.shouldKeepAlive = !1)
        let i = !1,
          c = null,
          a = o.timeout || this.timeout,
          u = (_) => {
            r._hadError || (r.emit('error', _), (r._hadError = !0))
          },
          d = () => {
            ;(c = null), (i = !0)
            let _ = new Error(
              `A "socket" was not created for HTTP request before ${a}ms`,
            )
            ;(_.code = 'ETIMEOUT'), u(_)
          },
          p = (_) => {
            i || (c !== null && (clearTimeout(c), (c = null)), u(_))
          },
          f = (_) => {
            if (i) return
            if ((c != null && (clearTimeout(c), (c = null)), Aee(_))) {
              Id(
                'Callback returned another Agent instance %o',
                _.constructor.name,
              ),
                _.addRequest(r, o)
              return
            }
            if (_) {
              _.once('free', () => {
                this.freeSocket(_, o)
              }),
                r.onSocket(_)
              return
            }
            let h = new Error(
              `no Duplex stream was returned to agent-base for \`${r.method} ${r.path}\``,
            )
            u(h)
          }
        if (typeof this.callback != 'function') {
          u(new Error('`callback` is not defined'))
          return
        }
        this.promisifiedCallback ||
          (this.callback.length >= 3
            ? (Id('Converting legacy callback function to promise'),
              (this.promisifiedCallback = Dee.default(this.callback)))
            : (this.promisifiedCallback = this.callback)),
          typeof a == 'number' && a > 0 && (c = setTimeout(d, a)),
          'port' in o && typeof o.port != 'number' && (o.port = Number(o.port))
        try {
          Id(
            'Resolving socket for %o request: %o',
            o.protocol,
            `${r.method} ${r.path}`,
          ),
            Promise.resolve(this.promisifiedCallback(r, o)).then(f, p)
        } catch (_) {
          Promise.reject(_).catch(p)
        }
      }
      freeSocket(r, s) {
        Id('Freeing socket %o %o', r.constructor.name, s), r.destroy()
      }
      destroy() {
        Id('Destroying agent %o', this.constructor.name)
      }
    }
    ;(e.Agent = t), (e.prototype = e.Agent.prototype)
  })(xm || (xm = {}))
  lq.exports = xm
})
var pq = l((Rd) => {
  'use strict'
  var Oee =
    (Rd && Rd.__importDefault) ||
    function (e) {
      return e && e.__esModule ? e : { default: e }
    }
  Object.defineProperty(Rd, '__esModule', { value: !0 })
  var Nee = Oee(Tm()),
    Pd = Nee.default('https-proxy-agent:parse-proxy-response')
  function qee(e) {
    return new Promise((t, n) => {
      let r = 0,
        s = []
      function o() {
        let p = e.read()
        p ? d(p) : e.once('readable', o)
      }
      function i() {
        e.removeListener('end', a),
          e.removeListener('error', u),
          e.removeListener('close', c),
          e.removeListener('readable', o)
      }
      function c(p) {
        Pd('onclose had error %o', p)
      }
      function a() {
        Pd('onend')
      }
      function u(p) {
        i(), Pd('onerror %o', p), n(p)
      }
      function d(p) {
        s.push(p), (r += p.length)
        let f = Buffer.concat(s, r)
        if (
          f.indexOf(`\r
\r
`) === -1
        ) {
          Pd('have not received end of HTTP headers yet...'), o()
          return
        }
        let h = f.toString(
            'ascii',
            0,
            f.indexOf(`\r
`),
          ),
          g = +h.split(' ')[1]
        Pd('got proxy server response: %o', h),
          t({ statusCode: g, buffered: f })
      }
      e.on('error', u), e.on('close', c), e.on('end', a), o()
    })
  }
  Rd.default = qee
})
var hq = l((Zs) => {
  'use strict'
  var kee =
      (Zs && Zs.__awaiter) ||
      function (e, t, n, r) {
        function s(o) {
          return o instanceof n
            ? o
            : new n(function (i) {
                i(o)
              })
        }
        return new (n || (n = Promise))(function (o, i) {
          function c(d) {
            try {
              u(r.next(d))
            } catch (p) {
              i(p)
            }
          }
          function a(d) {
            try {
              u(r.throw(d))
            } catch (p) {
              i(p)
            }
          }
          function u(d) {
            d.done ? o(d.value) : s(d.value).then(c, a)
          }
          u((r = r.apply(e, t || [])).next())
        })
      },
    di =
      (Zs && Zs.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e }
      }
  Object.defineProperty(Zs, '__esModule', { value: !0 })
  var fq = di(require('net')),
    _q = di(require('tls')),
    Mee = di(require('url')),
    Fee = di(require('assert')),
    Uee = di(Tm()),
    Lee = mq(),
    Bee = di(pq()),
    Dd = Uee.default('https-proxy-agent:agent'),
    Sv = class extends Lee.Agent {
      constructor(t) {
        let n
        if ((typeof t == 'string' ? (n = Mee.default.parse(t)) : (n = t), !n))
          throw new Error(
            'an HTTP(S) proxy server `host` and `port` must be specified!',
          )
        Dd('creating new HttpsProxyAgent instance: %o', n), super(n)
        let r = Object.assign({}, n)
        ;(this.secureProxy = n.secureProxy || $ee(r.protocol)),
          (r.host = r.hostname || r.host),
          typeof r.port == 'string' && (r.port = parseInt(r.port, 10)),
          !r.port && r.host && (r.port = this.secureProxy ? 443 : 80),
          this.secureProxy &&
            !('ALPNProtocols' in r) &&
            (r.ALPNProtocols = ['http 1.1']),
          r.host && r.path && (delete r.path, delete r.pathname),
          (this.proxy = r)
      }
      callback(t, n) {
        return kee(this, void 0, void 0, function* () {
          let { proxy: r, secureProxy: s } = this,
            o
          s
            ? (Dd('Creating `tls.Socket`: %o', r), (o = _q.default.connect(r)))
            : (Dd('Creating `net.Socket`: %o', r), (o = fq.default.connect(r)))
          let i = Object.assign({}, r.headers),
            a = `CONNECT ${`${n.host}:${n.port}`} HTTP/1.1\r
`
          r.auth &&
            (i['Proxy-Authorization'] = `Basic ${Buffer.from(r.auth).toString(
              'base64',
            )}`)
          let { host: u, port: d, secureEndpoint: p } = n
          Gee(d, p) || (u += `:${d}`), (i.Host = u), (i.Connection = 'close')
          for (let E of Object.keys(i))
            a += `${E}: ${i[E]}\r
`
          let f = Bee.default(o)
          o.write(`${a}\r
`)
          let { statusCode: _, buffered: h } = yield f
          if (_ === 200) {
            if ((t.once('socket', jee), n.secureEndpoint)) {
              Dd('Upgrading socket connection to TLS')
              let E = n.servername || n.host
              return _q.default.connect(
                Object.assign(
                  Object.assign({}, zee(n, 'host', 'hostname', 'path', 'port')),
                  { socket: o, servername: E },
                ),
              )
            }
            return o
          }
          o.destroy()
          let g = new fq.default.Socket({ writable: !1 })
          return (
            (g.readable = !0),
            t.once('socket', (E) => {
              Dd('replaying proxy buffer for failed request'),
                Fee.default(E.listenerCount('data') > 0),
                E.push(h),
                E.push(null)
            }),
            g
          )
        })
      }
    }
  Zs.default = Sv
  function jee(e) {
    e.resume()
  }
  function Gee(e, t) {
    return !!((!t && e === 80) || (t && e === 443))
  }
  function $ee(e) {
    return typeof e == 'string' ? /^https:?$/i.test(e) : !1
  }
  function zee(e, ...t) {
    let n = {},
      r
    for (r in e) t.includes(r) || (n[r] = e[r])
    return n
  }
})
var gq = l((Cv, yq) => {
  'use strict'
  var Hee =
      (Cv && Cv.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e }
      },
    bv = Hee(hq())
  function vv(e) {
    return new bv.default(e)
  }
  ;(function (e) {
    ;(e.HttpsProxyAgent = bv.default), (e.prototype = bv.default.prototype)
  })(vv || (vv = {}))
  yq.exports = vv
})
var xv = l((Tv) => {
  var { _nullishCoalesce: wv } = ge()
  Object.defineProperty(Tv, '__esModule', { value: !0 })
  var Eq = be(),
    Wee = require('http'),
    Vee = require('https'),
    Yee = gq(),
    Kee = require('stream'),
    Sq = require('url'),
    Jee = require('zlib'),
    Xee = 1024 * 32
  function Qee(e) {
    return new Kee.Readable({
      read() {
        this.push(e), this.push(null)
      },
    })
  }
  function Zee(e) {
    let t
    try {
      t = new Sq.URL(e.url)
    } catch {
      return (
        console.warn(
          '[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.',
        ),
        Eq.createTransport(e, () => Promise.resolve({}))
      )
    }
    let n = t.protocol === 'https:',
      r = ete(
        t,
        e.proxy ||
          (n ? process.env.https_proxy : void 0) ||
          process.env.http_proxy,
      ),
      s = n ? Vee : Wee,
      o = e.keepAlive === void 0 ? !1 : e.keepAlive,
      i = r
        ? new Yee.HttpsProxyAgent(r)
        : new s.Agent({ keepAlive: o, maxSockets: 30, timeout: 2e3 }),
      c = tte(
        e,
        wv(e.httpModule, () => s),
        i,
      )
    return Eq.createTransport(e, c)
  }
  function ete(e, t) {
    let { no_proxy: n } = process.env
    if (
      !(
        n &&
        n.split(',').some((s) => e.host.endsWith(s) || e.hostname.endsWith(s))
      )
    )
      return t
  }
  function tte(e, t, n) {
    let {
      hostname: r,
      pathname: s,
      port: o,
      protocol: i,
      search: c,
    } = new Sq.URL(e.url)
    return function (u) {
      return new Promise((d, p) => {
        let f = Qee(u.body),
          _ = { ...e.headers }
        u.body.length > Xee &&
          ((_['content-encoding'] = 'gzip'), (f = f.pipe(Jee.createGzip())))
        let h = t.request(
          {
            method: 'POST',
            agent: n,
            headers: _,
            hostname: r,
            path: `${s}${c}`,
            port: o,
            protocol: i,
            ca: e.caCerts,
          },
          (g) => {
            g.on('data', () => {}), g.on('end', () => {}), g.setEncoding('utf8')
            let E = wv(g.headers['retry-after'], () => null),
              P = wv(g.headers['x-sentry-rate-limits'], () => null)
            d({
              statusCode: g.statusCode,
              headers: {
                'retry-after': E,
                'x-sentry-rate-limits': Array.isArray(P) ? P[0] : P,
              },
            })
          },
        )
        h.on('error', p), f.pipe(h)
      })
    }
  }
  Tv.makeNodeTransport = Zee
})
var ui = l((Iv) => {
  Object.defineProperty(Iv, '__esModule', { value: !0 })
  var nte = A(),
    rte = nte.parseSemver(process.versions.node)
  Iv.NODE_VERSION = rte
})
var Cq = l((Pv) => {
  var { _optionalChain: ste } = ge()
  Object.defineProperty(Pv, '__esModule', { value: !0 })
  var eo = be(),
    bq = require('domain')
  function vq() {
    return bq.active
  }
  function ote() {
    let e = vq()
    if (e) return eo.ensureHubOnCarrier(e), eo.getHubFromCarrier(e)
  }
  function ite(e) {
    let t = {}
    return eo.ensureHubOnCarrier(t, e), eo.getHubFromCarrier(t)
  }
  function ate(e, t) {
    let n = vq()
    if (n && ste([t, 'optionalAccess', (i) => i.reuseExisting])) return e()
    let r = bq.create(),
      s = n ? eo.getHubFromCarrier(n) : void 0,
      o = ite(s)
    return eo.setHubOnCarrier(r, o), r.bind(() => e())()
  }
  function cte() {
    eo.setAsyncContextStrategy({ getCurrentHub: ote, runWithAsyncContext: ate })
  }
  Pv.setDomainAsyncContextStrategy = cte
})
var wq = l((Dv) => {
  var { _optionalChain: dte } = ge()
  Object.defineProperty(Dv, '__esModule', { value: !0 })
  var Rv = be(),
    ute = require('async_hooks')
  function lte() {
    let e = new ute.AsyncLocalStorage()
    function t() {
      return e.getStore()
    }
    function n(s) {
      let o = {}
      return Rv.ensureHubOnCarrier(o, s), Rv.getHubFromCarrier(o)
    }
    function r(s, o) {
      let i = t()
      if (i && dte([o, 'optionalAccess', (a) => a.reuseExisting])) return s()
      let c = n(i)
      return e.run(c, () => s())
    }
    Rv.setAsyncContextStrategy({ getCurrentHub: t, runWithAsyncContext: r })
  }
  Dv.setHooksAsyncContextStrategy = lte
})
var xq = l((Av) => {
  Object.defineProperty(Av, '__esModule', { value: !0 })
  var Tq = ui(),
    mte = Cq(),
    pte = wq()
  function fte() {
    Tq.NODE_VERSION.major && Tq.NODE_VERSION.major >= 14
      ? pte.setHooksAsyncContextStrategy()
      : mte.setDomainAsyncContextStrategy()
  }
  Av.setNodeAsyncContextStrategy = fte
})
var Nv = l((Ov) => {
  Object.defineProperty(Ov, '__esModule', { value: !0 })
  var Iq = be(),
    Pq = A(),
    _te = require('util'),
    Ad = class e {
      constructor() {
        e.prototype.__init.call(this)
      }
      static __initStatic() {
        this.id = 'Console'
      }
      __init() {
        this.name = e.id
      }
      setupOnce() {
        for (let t of ['debug', 'info', 'warn', 'error', 'log'])
          Pq.fill(console, t, hte(t))
      }
    }
  Ad.__initStatic()
  function hte(e) {
    return function (n) {
      let r = Pq.severityLevelFromString(e)
      return function () {
        Iq.getCurrentHub().getIntegration(Ad) &&
          Iq.getCurrentHub().addBreadcrumb(
            {
              category: 'console',
              level: r,
              message: _te.format.apply(void 0, arguments),
            },
            { input: [...arguments], level: e },
          ),
          n.apply(this, arguments)
      }
    }
  }
  Ov.Console = Ad
})
var Od = l((Im) => {
  ;(function (e, t) {
    let n = typeof Im == 'object' ? Im : typeof e == 'object' ? e : {}
    t(n), typeof define == 'function' && define.amd && define('lru', n)
  })(Im, function (e) {
    let t = Symbol('newer'),
      n = Symbol('older')
    function r(a, u) {
      typeof a != 'number' && ((u = a), (a = 0)),
        (this.size = 0),
        (this.limit = a),
        (this.oldest = this.newest = void 0),
        (this._keymap = new Map()),
        u && (this.assign(u), a < 1 && (this.limit = this.size))
    }
    e.LRUMap = r
    function s(a, u) {
      ;(this.key = a), (this.value = u), (this[t] = void 0), (this[n] = void 0)
    }
    ;(r.prototype._markEntryAsUsed = function (a) {
      a !== this.newest &&
        (a[t] && (a === this.oldest && (this.oldest = a[t]), (a[t][n] = a[n])),
        a[n] && (a[n][t] = a[t]),
        (a[t] = void 0),
        (a[n] = this.newest),
        this.newest && (this.newest[t] = a),
        (this.newest = a))
    }),
      (r.prototype.assign = function (a) {
        let u,
          d = this.limit || Number.MAX_VALUE
        this._keymap.clear()
        let p = a[Symbol.iterator]()
        for (let f = p.next(); !f.done; f = p.next()) {
          let _ = new s(f.value[0], f.value[1])
          if (
            (this._keymap.set(_.key, _),
            u ? ((u[t] = _), (_[n] = u)) : (this.oldest = _),
            (u = _),
            d-- == 0)
          )
            throw new Error('overflow')
        }
        ;(this.newest = u), (this.size = this._keymap.size)
      }),
      (r.prototype.get = function (a) {
        var u = this._keymap.get(a)
        if (u) return this._markEntryAsUsed(u), u.value
      }),
      (r.prototype.set = function (a, u) {
        var d = this._keymap.get(a)
        return d
          ? ((d.value = u), this._markEntryAsUsed(d), this)
          : (this._keymap.set(a, (d = new s(a, u))),
            this.newest
              ? ((this.newest[t] = d), (d[n] = this.newest))
              : (this.oldest = d),
            (this.newest = d),
            ++this.size,
            this.size > this.limit && this.shift(),
            this)
      }),
      (r.prototype.shift = function () {
        var a = this.oldest
        if (a)
          return (
            this.oldest[t]
              ? ((this.oldest = this.oldest[t]), (this.oldest[n] = void 0))
              : ((this.oldest = void 0), (this.newest = void 0)),
            (a[t] = a[n] = void 0),
            this._keymap.delete(a.key),
            --this.size,
            [a.key, a.value]
          )
      }),
      (r.prototype.find = function (a) {
        let u = this._keymap.get(a)
        return u ? u.value : void 0
      }),
      (r.prototype.has = function (a) {
        return this._keymap.has(a)
      }),
      (r.prototype.delete = function (a) {
        var u = this._keymap.get(a)
        if (u)
          return (
            this._keymap.delete(u.key),
            u[t] && u[n]
              ? ((u[n][t] = u[t]), (u[t][n] = u[n]))
              : u[t]
              ? ((u[t][n] = void 0), (this.oldest = u[t]))
              : u[n]
              ? ((u[n][t] = void 0), (this.newest = u[n]))
              : (this.oldest = this.newest = void 0),
            this.size--,
            u.value
          )
      }),
      (r.prototype.clear = function () {
        ;(this.oldest = this.newest = void 0),
          (this.size = 0),
          this._keymap.clear()
      })
    function o(a) {
      this.entry = a
    }
    ;(o.prototype[Symbol.iterator] = function () {
      return this
    }),
      (o.prototype.next = function () {
        let a = this.entry
        return a
          ? ((this.entry = a[t]), { done: !1, value: [a.key, a.value] })
          : { done: !0, value: void 0 }
      })
    function i(a) {
      this.entry = a
    }
    ;(i.prototype[Symbol.iterator] = function () {
      return this
    }),
      (i.prototype.next = function () {
        let a = this.entry
        return a
          ? ((this.entry = a[t]), { done: !1, value: a.key })
          : { done: !0, value: void 0 }
      })
    function c(a) {
      this.entry = a
    }
    ;(c.prototype[Symbol.iterator] = function () {
      return this
    }),
      (c.prototype.next = function () {
        let a = this.entry
        return a
          ? ((this.entry = a[t]), { done: !1, value: a.value })
          : { done: !0, value: void 0 }
      }),
      (r.prototype.keys = function () {
        return new i(this.oldest)
      }),
      (r.prototype.values = function () {
        return new c(this.oldest)
      }),
      (r.prototype.entries = function () {
        return this
      }),
      (r.prototype[Symbol.iterator] = function () {
        return new o(this.oldest)
      }),
      (r.prototype.forEach = function (a, u) {
        typeof u != 'object' && (u = this)
        let d = this.oldest
        for (; d; ) a.call(u, d.value, d.key, this), (d = d[t])
      }),
      (r.prototype.toJSON = function () {
        for (var a = new Array(this.size), u = 0, d = this.oldest; d; )
          (a[u++] = { key: d.key, value: d.value }), (d = d[t])
        return a
      }),
      (r.prototype.toString = function () {
        for (var a = '', u = this.oldest; u; )
          (a += String(u.key) + ':' + u.value), (u = u[t]), u && (a += ' < ')
        return a
      })
  })
})
var kv = l(($r) => {
  var { _optionalChain: on } = ge()
  Object.defineProperty($r, '__esModule', { value: !0 })
  var yte = be(),
    Rq = require('url'),
    Dq = ui()
  function gte(e) {
    let t = on([
      yte.getCurrentHub,
      'call',
      (n) => n(),
      'access',
      (n) => n.getClient,
      'call',
      (n) => n(),
      'optionalAccess',
      (n) => n.getDsn,
      'call',
      (n) => n(),
    ])
    return t ? e.includes(t.host) : !1
  }
  function Ete(e) {
    let t = e.protocol || '',
      n = e.hostname || e.host || '',
      r = !e.port || e.port === 80 || e.port === 443 ? '' : `:${e.port}`,
      s = e.path ? e.path : '/'
    return `${t}//${n}${r}${s}`
  }
  function Aq(e) {
    let t = e.protocol || '',
      n = e.hostname || e.host || '',
      r = !e.port || e.port === 80 || e.port === 443 ? '' : `:${e.port}`,
      s = e.pathname || '/',
      o = e.auth ? Ste(e.auth) : ''
    return `${t}//${o}${n}${r}${s}`
  }
  function Ste(e) {
    let [t, n] = e.split(':')
    return `${t ? '[Filtered]' : ''}:${n ? '[Filtered]' : ''}@`
  }
  function bte(e, t, n) {
    if (!e) return e
    let [r, s] = e.split(' ')
    return (
      t.host &&
        !t.protocol &&
        ((t.protocol = on([
          n,
          'optionalAccess',
          (o) => o.agent,
          'optionalAccess',
          (o) => o.protocol,
        ])),
        (s = Aq(t))),
      on([s, 'optionalAccess', (o) => o.startsWith, 'call', (o) => o('///')]) &&
        (s = s.slice(2)),
      `${r} ${s}`
    )
  }
  function qv(e) {
    let t = {
      protocol: e.protocol,
      hostname:
        typeof e.hostname == 'string' && e.hostname.startsWith('[')
          ? e.hostname.slice(1, -1)
          : e.hostname,
      hash: e.hash,
      search: e.search,
      pathname: e.pathname,
      path: `${e.pathname || ''}${e.search || ''}`,
      href: e.href,
    }
    return (
      e.port !== '' && (t.port = Number(e.port)),
      (e.username || e.password) && (t.auth = `${e.username}:${e.password}`),
      t
    )
  }
  function vte(e, t) {
    let n, r
    return (
      typeof t[t.length - 1] == 'function' && (n = t.pop()),
      typeof t[0] == 'string'
        ? (r = qv(new Rq.URL(t[0])))
        : t[0] instanceof Rq.URL
        ? (r = qv(t[0]))
        : (r = t[0]),
      t.length === 2 && (r = { ...r, ...t[1] }),
      r.protocol === void 0 &&
        (Dq.NODE_VERSION.major && Dq.NODE_VERSION.major > 8
          ? (r.protocol =
              on([
                on([e, 'optionalAccess', (s) => s.globalAgent]),
                'optionalAccess',
                (s) => s.protocol,
              ]) ||
              on([r.agent, 'optionalAccess', (s) => s.protocol]) ||
              on([r._defaultAgent, 'optionalAccess', (s) => s.protocol]))
          : (r.protocol =
              on([r.agent, 'optionalAccess', (s) => s.protocol]) ||
              on([r._defaultAgent, 'optionalAccess', (s) => s.protocol]) ||
              on([
                on([e, 'optionalAccess', (s) => s.globalAgent]),
                'optionalAccess',
                (s) => s.protocol,
              ]))),
      n ? [r, n] : [r]
    )
  }
  $r.cleanSpanDescription = bte
  $r.extractRawUrl = Ete
  $r.extractUrl = Aq
  $r.isSentryRequest = gte
  $r.normalizeRequestArgs = vte
  $r.urlToOptions = qv
})
var Fv = l((Mv) => {
  var { _optionalChain: to } = ge()
  Object.defineProperty(Mv, '__esModule', { value: !0 })
  var Pm = be(),
    Sn = A(),
    Oq = Od(),
    Nq = ui(),
    li = kv(),
    Nd = class e {
      static __initStatic() {
        this.id = 'Http'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          (this._breadcrumbs = typeof t.breadcrumbs > 'u' ? !0 : t.breadcrumbs),
          (this._tracing = t.tracing
            ? t.tracing === !0
              ? {}
              : t.tracing
            : void 0)
      }
      setupOnce(t, n) {
        if (!this._breadcrumbs && !this._tracing) return
        let r = to([
          n,
          'call',
          (a) => a(),
          'access',
          (a) => a.getClient,
          'call',
          (a) => a(),
          'optionalAccess',
          (a) => a.getOptions,
          'call',
          (a) => a(),
        ])
        if (r && r.instrumenter !== 'sentry') {
          ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Sn.logger.log(
              'HTTP Integration is skipped because of instrumenter configuration.',
            )
          return
        }
        let s =
            to([
              this,
              'access',
              (a) => a._tracing,
              'optionalAccess',
              (a) => a.shouldCreateSpanForRequest,
            ]) ||
            to([r, 'optionalAccess', (a) => a.shouldCreateSpanForRequest]),
          o =
            to([r, 'optionalAccess', (a) => a.tracePropagationTargets]) ||
            to([
              this,
              'access',
              (a) => a._tracing,
              'optionalAccess',
              (a) => a.tracePropagationTargets,
            ]),
          i = require('http'),
          c = qq(i, this._breadcrumbs, s, o)
        if (
          (Sn.fill(i, 'get', c),
          Sn.fill(i, 'request', c),
          Nq.NODE_VERSION.major && Nq.NODE_VERSION.major > 8)
        ) {
          let a = require('https'),
            u = qq(a, this._breadcrumbs, s, o)
          Sn.fill(a, 'get', u), Sn.fill(a, 'request', u)
        }
      }
    }
  Nd.__initStatic()
  function qq(e, t, n, r) {
    let s = new Oq.LRUMap(100),
      o = new Oq.LRUMap(100),
      i = (u) => {
        if (n === void 0) return !0
        let d = s.get(u)
        if (d !== void 0) return d
        let p = n(u)
        return s.set(u, p), p
      },
      c = (u) => {
        if (r === void 0) return !0
        let d = o.get(u)
        if (d !== void 0) return d
        let p = Sn.stringMatchesSomePattern(u, r)
        return o.set(u, p), p
      }
    function a(u, d, p, f) {
      Pm.getCurrentHub().getIntegration(Nd) &&
        Pm.getCurrentHub().addBreadcrumb(
          {
            category: 'http',
            data: { status_code: f && f.statusCode, ...d },
            type: 'http',
          },
          { event: u, request: p, response: f },
        )
    }
    return function (d) {
      return function (...f) {
        let _ = li.normalizeRequestArgs(e, f),
          h = _[0],
          g = li.extractRawUrl(h),
          E = li.extractUrl(h)
        if (li.isSentryRequest(E)) return d.apply(e, _)
        let P = Pm.getCurrentHub(),
          z = P.getScope(),
          ye = z.getSpan(),
          fe = Cte(E, h),
          xe = i(g)
            ? to([
                ye,
                'optionalAccess',
                (Q) => Q.startChild,
                'call',
                (Q) =>
                  Q({
                    op: 'http.client',
                    description: `${fe['http.method']} ${fe.url}`,
                    data: fe,
                  }),
              ])
            : void 0
        if (c(g))
          if (xe) {
            let Q = xe.toTraceparent(),
              De = to([
                xe,
                'optionalAccess',
                (bt) => bt.transaction,
                'optionalAccess',
                (bt) => bt.getDynamicSamplingContext,
                'call',
                (bt) => bt(),
              ])
            kq(h, E, Q, De)
          } else {
            let Q = P.getClient(),
              { traceId: De, sampled: bt, dsc: Ls } = z.getPropagationContext(),
              vt = Sn.generateSentryTraceHeader(De, void 0, bt),
              Ce =
                Ls ||
                (Q ? Pm.getDynamicSamplingContextFromClient(De, Q, z) : void 0)
            kq(h, E, vt, Ce)
          }
        else
          (typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Sn.logger.log(
              `[Tracing] Not adding sentry-trace header to outgoing request (${E}) due to mismatching tracePropagationTargets option.`,
            )
        return d
          .apply(e, _)
          .once('response', function (Q) {
            let De = this
            t && a('response', fe, De, Q),
              xe &&
                (Q.statusCode && xe.setHttpStatus(Q.statusCode),
                (xe.description = li.cleanSpanDescription(
                  xe.description,
                  h,
                  De,
                )),
                xe.finish())
          })
          .once('error', function () {
            let Q = this
            t && a('error', fe, Q),
              xe &&
                (xe.setHttpStatus(500),
                (xe.description = li.cleanSpanDescription(
                  xe.description,
                  h,
                  Q,
                )),
                xe.finish())
          })
      }
    }
  }
  function kq(e, t, n, r) {
    if ((e.headers || {})['sentry-trace']) return
    ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
      Sn.logger.log(
        `[Tracing] Adding sentry-trace header ${n} to outgoing request to "${t}": `,
      )
    let o = Sn.dynamicSamplingContextToSentryBaggageHeader(r),
      i = o && o.length > 0 ? wte(e, o) : void 0
    e.headers = { ...e.headers, 'sentry-trace': n, ...(i && { baggage: i }) }
  }
  function Cte(e, t) {
    let n = t.method || 'GET',
      r = { url: e, 'http.method': n }
    return (
      t.hash && (r['http.fragment'] = t.hash.substring(1)),
      t.search && (r['http.query'] = t.search.substring(1)),
      r
    )
  }
  function wte(e, t) {
    if (!e.headers || !e.headers.baggage) return t
    if (t) {
      if (Array.isArray(e.headers.baggage)) return [...e.headers.baggage, t]
    } else return e.headers.baggage
    return [e.headers.baggage, t]
  }
  Mv.Http = Nd
})
var Bv = l((Lv) => {
  Object.defineProperty(Lv, '__esModule', { value: !0 })
  var Tte = be(),
    Uv = A(),
    xte = 2e3
  function Ite(e) {
    console.error(e && e.stack ? e.stack : e)
    let t = Tte.getCurrentHub().getClient()
    t === void 0 &&
      ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        Uv.logger.warn(
          'No NodeClient was defined, we are exiting the process now.',
        ),
      global.process.exit(1))
    let n = t.getOptions(),
      r =
        (n &&
          n.shutdownTimeout &&
          n.shutdownTimeout > 0 &&
          n.shutdownTimeout) ||
        xte
    t.close(r).then(
      (s) => {
        s ||
          ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
            Uv.logger.warn(
              'We reached the timeout for emptying the request buffer, still exiting now!',
            )),
          global.process.exit(1)
      },
      (s) => {
        ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
          Uv.logger.error(s)
      },
    )
  }
  Lv.logAndExitProcess = Ite
})
var Gv = l((jv) => {
  Object.defineProperty(jv, '__esModule', { value: !0 })
  var Mq = be(),
    Pte = A(),
    Fq = Bv(),
    Rm = class e {
      static __initStatic() {
        this.id = 'OnUncaughtException'
      }
      __init() {
        this.name = e.id
      }
      __init2() {
        this.handler = this._makeErrorHandler()
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          e.prototype.__init2.call(this),
          (this._options = { exitEvenIfOtherHandlersAreRegistered: !0, ...t })
      }
      setupOnce() {
        global.process.on('uncaughtException', this.handler)
      }
      _makeErrorHandler() {
        let n = !1,
          r = !1,
          s = !1,
          o
        return (i) => {
          let c = Fq.logAndExitProcess,
            a = Mq.getCurrentHub().getClient()
          this._options.onFatalError
            ? (c = this._options.onFatalError)
            : a &&
              a.getOptions().onFatalError &&
              (c = a.getOptions().onFatalError)
          let d =
              global.process
                .listeners('uncaughtException')
                .reduce(
                  (f, _) =>
                    _.name === 'domainUncaughtExceptionClear' ||
                    (_.tag && _.tag === 'sentry_tracingErrorCallback') ||
                    _ === this.handler
                      ? f
                      : f + 1,
                  0,
                ) === 0,
            p = this._options.exitEvenIfOtherHandlersAreRegistered || d
          if (n)
            p &&
              (s
                ? ((typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                    Pte.logger.warn(
                      'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',
                    ),
                  Fq.logAndExitProcess(i))
                : r ||
                  ((r = !0),
                  setTimeout(() => {
                    s || ((s = !0), c(o, i))
                  }, 2e3)))
          else {
            let f = Mq.getCurrentHub()
            ;(o = i),
              (n = !0),
              f.getIntegration(e)
                ? f.withScope((_) => {
                    _.setLevel('fatal'),
                      f.captureException(i, {
                        originalException: i,
                        data: {
                          mechanism: {
                            handled: !1,
                            type: 'onuncaughtexception',
                          },
                        },
                      }),
                      !s && p && ((s = !0), c(i))
                  })
                : !s && p && ((s = !0), c(i))
          }
        }
      }
    }
  Rm.__initStatic()
  jv.OnUncaughtException = Rm
})
var zv = l(($v) => {
  Object.defineProperty($v, '__esModule', { value: !0 })
  var Rte = be(),
    Uq = A(),
    Dte = Bv(),
    Dm = class e {
      static __initStatic() {
        this.id = 'OnUnhandledRejection'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = { mode: 'warn' }) {
        ;(this._options = t), e.prototype.__init.call(this)
      }
      setupOnce() {
        global.process.on(
          'unhandledRejection',
          this.sendUnhandledPromise.bind(this),
        )
      }
      sendUnhandledPromise(t, n) {
        let r = Rte.getCurrentHub()
        r.getIntegration(e) &&
          r.withScope((s) => {
            s.setExtra('unhandledPromiseRejection', !0),
              r.captureException(t, {
                originalException: n,
                data: {
                  mechanism: { handled: !1, type: 'onunhandledrejection' },
                },
              })
          }),
          this._handleRejection(t)
      }
      _handleRejection(t) {
        let n =
          'This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:'
        this._options.mode === 'warn'
          ? Uq.consoleSandbox(() => {
              console.warn(n), console.error(t && t.stack ? t.stack : t)
            })
          : this._options.mode === 'strict' &&
            (Uq.consoleSandbox(() => {
              console.warn(n)
            }),
            Dte.logAndExitProcess(t))
      }
    }
  Dm.__initStatic()
  $v.OnUnhandledRejection = Dm
})
var Nm = l((Wv) => {
  var { _optionalChain: Hv } = ge()
  Object.defineProperty(Wv, '__esModule', { value: !0 })
  var Ate = A(),
    Ote = require('fs'),
    Nte = Od(),
    Am = new Nte.LRUMap(100),
    qte = 7
  function kte(e) {
    return new Promise((t, n) => {
      Ote.readFile(e, 'utf8', (r, s) => {
        r ? n(r) : t(s)
      })
    })
  }
  var Om = class e {
    static __initStatic() {
      this.id = 'ContextLines'
    }
    __init() {
      this.name = e.id
    }
    constructor(t = {}) {
      ;(this._options = t), e.prototype.__init.call(this)
    }
    get _contextLines() {
      return this._options.frameContextLines !== void 0
        ? this._options.frameContextLines
        : qte
    }
    setupOnce(t, n) {
      t((r) => (n().getIntegration(e) ? this.addSourceContext(r) : r))
    }
    async addSourceContext(t) {
      let n = {},
        r = []
      if (
        this._contextLines > 0 &&
        Hv([t, 'access', (s) => s.exception, 'optionalAccess', (s) => s.values])
      ) {
        for (let s of t.exception.values)
          if (
            Hv([
              s,
              'access',
              (o) => o.stacktrace,
              'optionalAccess',
              (o) => o.frames,
            ])
          )
            for (let o = s.stacktrace.frames.length - 1; o >= 0; o--) {
              let i = s.stacktrace.frames[o]
              i.filename &&
                !n[i.filename] &&
                !Am.get(i.filename) &&
                (r.push(Mte(i.filename)), (n[i.filename] = 1))
            }
      }
      if (
        (r.length > 0 && (await Promise.all(r)),
        this._contextLines > 0 &&
          Hv([
            t,
            'access',
            (s) => s.exception,
            'optionalAccess',
            (s) => s.values,
          ]))
      )
        for (let s of t.exception.values)
          s.stacktrace &&
            s.stacktrace.frames &&
            (await this.addSourceContextToFrames(s.stacktrace.frames))
      return t
    }
    addSourceContextToFrames(t) {
      for (let n of t)
        if (n.filename && n.context_line === void 0) {
          let r = Am.get(n.filename)
          if (r)
            try {
              Ate.addContextToFrame(r, n, this._contextLines)
            } catch {}
        }
    }
  }
  Om.__initStatic()
  async function Mte(e) {
    let t = Am.get(e)
    if (t === null) return null
    if (t !== void 0) return t
    let n = null
    try {
      n = (await kte(e)).split(`
`)
    } catch {}
    return Am.set(e, n), n
  }
  Wv.ContextLines = Om
})
var Yv = l((Vv) => {
  Object.defineProperty(Vv, '__esModule', { value: !0 })
  var Fte = A(),
    Ute = dv(),
    Lte = Nm(),
    Bte = 'cause',
    jte = 5,
    qm = class e {
      static __initStatic() {
        this.id = 'LinkedErrors'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          (this._key = t.key || Bte),
          (this._limit = t.limit || jte)
      }
      setupOnce(t, n) {
        t(async (r, s) => {
          let o = n(),
            i = o.getClient(),
            c = o.getIntegration(e)
          if (!i || !c) return r
          let a = i.getOptions()
          Fte.applyAggregateErrorsToEvent(
            Ute.exceptionFromError,
            a.stackParser,
            a.maxValueLength,
            c._key,
            c._limit,
            r,
            s,
          )
          let u = n().getIntegration(Lte.ContextLines)
          return u && (await u.addSourceContext(r)), r
        })
      }
    }
  qm.__initStatic()
  Vv.LinkedErrors = qm
})
var Xv = l((Jv) => {
  Object.defineProperty(Jv, '__esModule', { value: !0 })
  var Lq = require('fs'),
    Bq = require('path'),
    Kv
  function Gte() {
    try {
      return require.cache ? Object.keys(require.cache) : []
    } catch {
      return []
    }
  }
  function $te() {
    let e = (require.main && require.main.paths) || [],
      t = Gte(),
      n = {},
      r = {}
    return (
      t.forEach((s) => {
        let o = s,
          i = () => {
            let c = o
            if (((o = Bq.dirname(c)), !o || c === o || r[c])) return
            if (e.indexOf(o) < 0) return i()
            let a = Bq.join(c, 'package.json')
            if (((r[c] = !0), !Lq.existsSync(a))) return i()
            try {
              let u = JSON.parse(Lq.readFileSync(a, 'utf8'))
              n[u.name] = u.version
            } catch {}
          }
        i()
      }),
      n
    )
  }
  var km = class e {
    constructor() {
      e.prototype.__init.call(this)
    }
    static __initStatic() {
      this.id = 'Modules'
    }
    __init() {
      this.name = e.id
    }
    setupOnce(t, n) {
      t((r) =>
        n().getIntegration(e)
          ? { ...r, modules: { ...r.modules, ...this._getModules() } }
          : r,
      )
    }
    _getModules() {
      return Kv || (Kv = $te()), Kv
    }
  }
  km.__initStatic()
  Jv.Modules = km
})
var Qv = l((mi) => {
  var { _optionalChain: no } = ge()
  Object.defineProperty(mi, '__esModule', { value: !0 })
  var zte = require('child_process'),
    Gq = require('fs'),
    Gt = require('os'),
    Hte = require('path'),
    $q = require('util'),
    zq = $q.promisify(Gq.readFile),
    Hq = $q.promisify(Gq.readdir),
    Mm = class e {
      static __initStatic() {
        this.id = 'Context'
      }
      __init() {
        this.name = e.id
      }
      constructor(
        t = { app: !0, os: !0, device: !0, culture: !0, cloudResource: !0 },
      ) {
        ;(this._options = t), e.prototype.__init.call(this)
      }
      setupOnce(t) {
        t((n) => this.addContext(n))
      }
      async addContext(t) {
        this._cachedContext === void 0 &&
          (this._cachedContext = this._getContexts())
        let n = this._updateContext(await this._cachedContext)
        return (
          (t.contexts = {
            ...t.contexts,
            app: {
              ...n.app,
              ...no([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.app,
              ]),
            },
            os: {
              ...n.os,
              ...no([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.os,
              ]),
            },
            device: {
              ...n.device,
              ...no([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.device,
              ]),
            },
            culture: {
              ...n.culture,
              ...no([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.culture,
              ]),
            },
            cloud_resource: {
              ...n.cloud_resource,
              ...no([
                t,
                'access',
                (r) => r.contexts,
                'optionalAccess',
                (r) => r.cloud_resource,
              ]),
            },
          }),
          t
        )
      }
      _updateContext(t) {
        return (
          no([
            t,
            'optionalAccess',
            (n) => n.app,
            'optionalAccess',
            (n) => n.app_memory,
          ]) && (t.app.app_memory = process.memoryUsage().rss),
          no([
            t,
            'optionalAccess',
            (n) => n.device,
            'optionalAccess',
            (n) => n.free_memory,
          ]) && (t.device.free_memory = Gt.freemem()),
          t
        )
      }
      async _getContexts() {
        let t = {}
        if (
          (this._options.os && (t.os = await Wte()),
          this._options.app && (t.app = Yte()),
          this._options.device && (t.device = Wq(this._options.device)),
          this._options.culture)
        ) {
          let n = Vte()
          n && (t.culture = n)
        }
        return this._options.cloudResource && (t.cloud_resource = ene()), t
      }
    }
  Mm.__initStatic()
  async function Wte() {
    let e = Gt.platform()
    switch (e) {
      case 'darwin':
        return Qte()
      case 'linux':
        return Zte()
      default:
        return { name: Kte[e] || e, version: Gt.release() }
    }
  }
  function Vte() {
    try {
      if (typeof process.versions.icu != 'string') return
      let e = new Date(9e8)
      if (
        new Intl.DateTimeFormat('es', { month: 'long' }).format(e) === 'enero'
      ) {
        let n = Intl.DateTimeFormat().resolvedOptions()
        return { locale: n.locale, timezone: n.timeZone }
      }
    } catch {}
  }
  function Yte() {
    let e = process.memoryUsage().rss
    return {
      app_start_time: new Date(
        Date.now() - process.uptime() * 1e3,
      ).toISOString(),
      app_memory: e,
    }
  }
  function Wq(e) {
    let t = {},
      n
    try {
      n = Gt.uptime && Gt.uptime()
    } catch {}
    if (
      (typeof n == 'number' &&
        (t.boot_time = new Date(Date.now() - n * 1e3).toISOString()),
      (t.arch = Gt.arch()),
      (e === !0 || e.memory) &&
        ((t.memory_size = Gt.totalmem()), (t.free_memory = Gt.freemem())),
      e === !0 || e.cpu)
    ) {
      let r = Gt.cpus()
      if (r && r.length) {
        let s = r[0]
        ;(t.processor_count = r.length),
          (t.cpu_description = s.model),
          (t.processor_frequency = s.speed)
      }
    }
    return t
  }
  var Kte = {
      aix: 'IBM AIX',
      freebsd: 'FreeBSD',
      openbsd: 'OpenBSD',
      sunos: 'SunOS',
      win32: 'Windows',
    },
    Jte = [
      { name: 'fedora-release', distros: ['Fedora'] },
      { name: 'redhat-release', distros: ['Red Hat Linux', 'Centos'] },
      { name: 'redhat_version', distros: ['Red Hat Linux'] },
      { name: 'SuSE-release', distros: ['SUSE Linux'] },
      { name: 'lsb-release', distros: ['Ubuntu Linux', 'Arch Linux'] },
      { name: 'debian_version', distros: ['Debian'] },
      { name: 'debian_release', distros: ['Debian'] },
      { name: 'arch-release', distros: ['Arch Linux'] },
      { name: 'gentoo-release', distros: ['Gentoo Linux'] },
      { name: 'novell-release', distros: ['SUSE Linux'] },
      { name: 'alpine-release', distros: ['Alpine Linux'] },
    ],
    Xte = {
      alpine: (e) => e,
      arch: (e) => bn(/distrib_release=(.*)/, e),
      centos: (e) => bn(/release ([^ ]+)/, e),
      debian: (e) => e,
      fedora: (e) => bn(/release (..)/, e),
      mint: (e) => bn(/distrib_release=(.*)/, e),
      red: (e) => bn(/release ([^ ]+)/, e),
      suse: (e) => bn(/VERSION = (.*)\n/, e),
      ubuntu: (e) => bn(/distrib_release=(.*)/, e),
    }
  function bn(e, t) {
    let n = e.exec(t)
    return n ? n[1] : void 0
  }
  async function Qte() {
    let e = {
      kernel_version: Gt.release(),
      name: 'Mac OS X',
      version: `10.${Number(Gt.release().split('.')[0]) - 4}`,
    }
    try {
      let t = await new Promise((n, r) => {
        zte.execFile('/usr/bin/sw_vers', (s, o) => {
          if (s) {
            r(s)
            return
          }
          n(o)
        })
      })
      ;(e.name = bn(/^ProductName:\s+(.*)$/m, t)),
        (e.version = bn(/^ProductVersion:\s+(.*)$/m, t)),
        (e.build = bn(/^BuildVersion:\s+(.*)$/m, t))
    } catch {}
    return e
  }
  function jq(e) {
    return e.split(' ')[0].toLowerCase()
  }
  async function Zte() {
    let e = { kernel_version: Gt.release(), name: 'Linux' }
    try {
      let t = await Hq('/etc'),
        n = Jte.find((c) => t.includes(c.name))
      if (!n) return e
      let r = Hte.join('/etc', n.name),
        s = (await zq(r, { encoding: 'utf-8' })).toLowerCase(),
        { distros: o } = n
      e.name = o.find((c) => s.indexOf(jq(c)) >= 0) || o[0]
      let i = jq(e.name)
      e.version = Xte[i](s)
    } catch {}
    return e
  }
  function ene() {
    return process.env.VERCEL
      ? {
          'cloud.provider': 'vercel',
          'cloud.region': process.env.VERCEL_REGION,
        }
      : process.env.AWS_REGION
      ? {
          'cloud.provider': 'aws',
          'cloud.region': process.env.AWS_REGION,
          'cloud.platform': process.env.AWS_EXECUTION_ENV,
        }
      : process.env.GCP_PROJECT
      ? { 'cloud.provider': 'gcp' }
      : process.env.ALIYUN_REGION_ID
      ? {
          'cloud.provider': 'alibaba_cloud',
          'cloud.region': process.env.ALIYUN_REGION_ID,
        }
      : process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME
      ? { 'cloud.provider': 'azure', 'cloud.region': process.env.REGION_NAME }
      : process.env.IBM_CLOUD_REGION
      ? {
          'cloud.provider': 'ibm_cloud',
          'cloud.region': process.env.IBM_CLOUD_REGION,
        }
      : process.env.TENCENTCLOUD_REGION
      ? {
          'cloud.provider': 'tencent_cloud',
          'cloud.region': process.env.TENCENTCLOUD_REGION,
          'cloud.account.id': process.env.TENCENTCLOUD_APPID,
          'cloud.availability_zone': process.env.TENCENTCLOUD_ZONE,
        }
      : process.env.NETLIFY
      ? { 'cloud.provider': 'netlify' }
      : process.env.FLY_REGION
      ? { 'cloud.provider': 'fly.io', 'cloud.region': process.env.FLY_REGION }
      : process.env.DYNO
      ? { 'cloud.provider': 'heroku' }
      : void 0
  }
  mi.Context = Mm
  mi.getDeviceContext = Wq
  mi.readDirAsync = Hq
  mi.readFileAsync = zq
})
var Vq = l((Zv) => {
  'use strict'
  Zv.parse = rne
  Zv.serialize = sne
  var tne = decodeURIComponent,
    nne = encodeURIComponent,
    Fm = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/
  function rne(e, t) {
    if (typeof e != 'string')
      throw new TypeError('argument str must be a string')
    for (
      var n = {}, r = t || {}, s = e.split(';'), o = r.decode || tne, i = 0;
      i < s.length;
      i++
    ) {
      var c = s[i],
        a = c.indexOf('=')
      if (!(a < 0)) {
        var u = c.substring(0, a).trim()
        if (n[u] == null) {
          var d = c.substring(a + 1, c.length).trim()
          d[0] === '"' && (d = d.slice(1, -1)), (n[u] = one(d, o))
        }
      }
    }
    return n
  }
  function sne(e, t, n) {
    var r = n || {},
      s = r.encode || nne
    if (typeof s != 'function') throw new TypeError('option encode is invalid')
    if (!Fm.test(e)) throw new TypeError('argument name is invalid')
    var o = s(t)
    if (o && !Fm.test(o)) throw new TypeError('argument val is invalid')
    var i = e + '=' + o
    if (r.maxAge != null) {
      var c = r.maxAge - 0
      if (isNaN(c) || !isFinite(c))
        throw new TypeError('option maxAge is invalid')
      i += '; Max-Age=' + Math.floor(c)
    }
    if (r.domain) {
      if (!Fm.test(r.domain)) throw new TypeError('option domain is invalid')
      i += '; Domain=' + r.domain
    }
    if (r.path) {
      if (!Fm.test(r.path)) throw new TypeError('option path is invalid')
      i += '; Path=' + r.path
    }
    if (r.expires) {
      if (typeof r.expires.toUTCString != 'function')
        throw new TypeError('option expires is invalid')
      i += '; Expires=' + r.expires.toUTCString()
    }
    if (
      (r.httpOnly && (i += '; HttpOnly'),
      r.secure && (i += '; Secure'),
      r.sameSite)
    ) {
      var a =
        typeof r.sameSite == 'string' ? r.sameSite.toLowerCase() : r.sameSite
      switch (a) {
        case !0:
          i += '; SameSite=Strict'
          break
        case 'lax':
          i += '; SameSite=Lax'
          break
        case 'strict':
          i += '; SameSite=Strict'
          break
        case 'none':
          i += '; SameSite=None'
          break
        default:
          throw new TypeError('option sameSite is invalid')
      }
    }
    return i
  }
  function one(e, t) {
    try {
      return t(e)
    } catch {
      return e
    }
  }
})
var qd = l((pi) => {
  var { _optionalChain: ine } = ge()
  Object.defineProperty(pi, '__esModule', { value: !0 })
  var Um = A(),
    ane = Vq(),
    cne = require('url'),
    dne = { ip: !1, request: !0, transaction: !0, user: !0 },
    une = ['cookies', 'data', 'headers', 'method', 'query_string', 'url'],
    Yq = ['id', 'username', 'email']
  function eC(e, t = {}) {
    let n = e.method && e.method.toUpperCase(),
      r = '',
      s = 'url'
    t.customRoute || e.route
      ? ((r = t.customRoute || `${e.baseUrl || ''}${e.route && e.route.path}`),
        (s = 'route'))
      : (e.originalUrl || e.url) &&
        (r = Um.stripUrlQueryAndFragment(e.originalUrl || e.url || ''))
    let o = ''
    return (
      t.method && n && (o += n),
      t.method && t.path && (o += ' '),
      t.path && r && (o += r),
      [o, s]
    )
  }
  function lne(e, t) {
    switch (t) {
      case 'path':
        return eC(e, { path: !0 })[0]
      case 'handler':
        return (
          (e.route &&
            e.route.stack &&
            e.route.stack[0] &&
            e.route.stack[0].name) ||
          '<anonymous>'
        )
      case 'methodPath':
      default:
        return eC(e, { path: !0, method: !0 })[0]
    }
  }
  function mne(e, t) {
    let n = {}
    return (
      (Array.isArray(t) ? t : Yq).forEach((s) => {
        e && s in e && (n[s] = e[s])
      }),
      n
    )
  }
  function tC(e, t) {
    let { include: n = une } = t || {},
      r = {},
      s = e.headers || {},
      o = e.method,
      i = e.hostname || e.host || s.host || '<no host>',
      c =
        e.protocol === 'https' || (e.socket && e.socket.encrypted)
          ? 'https'
          : 'http',
      a = e.originalUrl || e.url || '',
      u = a.startsWith(c) ? a : `${c}://${i}${a}`
    return (
      n.forEach((d) => {
        switch (d) {
          case 'headers': {
            ;(r.headers = s), n.includes('cookies') || delete r.headers.cookie
            break
          }
          case 'method': {
            r.method = o
            break
          }
          case 'url': {
            r.url = u
            break
          }
          case 'cookies': {
            r.cookies = e.cookies || (s.cookie && ane.parse(s.cookie)) || {}
            break
          }
          case 'query_string': {
            r.query_string = fne(e)
            break
          }
          case 'data': {
            if (o === 'GET' || o === 'HEAD') break
            e.body !== void 0 &&
              (r.data = Um.isString(e.body)
                ? e.body
                : JSON.stringify(Um.normalize(e.body)))
            break
          }
          default:
            ;({}).hasOwnProperty.call(e, d) && (r[d] = e[d])
        }
      }),
      r
    )
  }
  function pne(e, t, n) {
    let r = { ...dne, ...ine([n, 'optionalAccess', (s) => s.include]) }
    if (r.request) {
      let s = Array.isArray(r.request) ? tC(t, { include: r.request }) : tC(t)
      e.request = { ...e.request, ...s }
    }
    if (r.user) {
      let s = t.user && Um.isPlainObject(t.user) ? mne(t.user, r.user) : {}
      Object.keys(s).length && (e.user = { ...e.user, ...s })
    }
    if (r.ip) {
      let s = t.ip || (t.socket && t.socket.remoteAddress)
      s && (e.user = { ...e.user, ip_address: s })
    }
    return (
      r.transaction &&
        !e.transaction &&
        (e.transaction = lne(t, r.transaction)),
      e
    )
  }
  function fne(e) {
    let t = e.originalUrl || e.url || ''
    if (t)
      return (
        t.startsWith('/') && (t = `http://dogs.are.great${t}`),
        e.query ||
          (typeof URL !== void 0 && new URL(t).search.replace('?', '')) ||
          cne.parse(t).query ||
          void 0
      )
  }
  pi.DEFAULT_USER_INCLUDES = Yq
  pi.addRequestDataToEvent = pne
  pi.extractPathForTransaction = eC
  pi.extractRequestData = tC
})
var sC = l((rC) => {
  Object.defineProperty(rC, '__esModule', { value: !0 })
  var _ne = A(),
    hne = qd(),
    nC = {
      include: {
        cookies: !0,
        data: !0,
        headers: !0,
        ip: !1,
        query_string: !0,
        url: !0,
        user: { id: !0, username: !0, email: !0 },
      },
      transactionNamingScheme: 'methodPath',
    },
    Lm = class e {
      static __initStatic() {
        this.id = 'RequestData'
      }
      __init() {
        this.name = e.id
      }
      constructor(t = {}) {
        e.prototype.__init.call(this),
          (this._addRequestData = hne.addRequestDataToEvent),
          (this._options = {
            ...nC,
            ...t,
            include: {
              method: !0,
              ...nC.include,
              ...t.include,
              user:
                t.include && typeof t.include.user == 'boolean'
                  ? t.include.user
                  : { ...nC.include.user, ...(t.include || {}).user },
            },
          })
      }
      setupOnce(t, n) {
        let { transactionNamingScheme: r } = this._options
        t((s) => {
          let o = n(),
            i = o.getIntegration(e),
            { sdkProcessingMetadata: c = {} } = s,
            a = c.request
          if (!i || !a) return s
          let u =
              c.requestDataOptionsFromExpressHandler ||
              c.requestDataOptionsFromGCPWrapper ||
              yne(this._options),
            d = this._addRequestData(s, a, u)
          if (s.type === 'transaction' || r === 'handler') return d
          let f = a._sentryTransaction
          if (f) {
            let _ =
                gne(o) === 'sentry.javascript.nextjs'
                  ? f.name.startsWith('/api')
                  : r !== 'path',
              [h] = _ne.extractPathForTransaction(a, {
                path: !0,
                method: _,
                customRoute: f.name,
              })
            d.transaction = h
          }
          return d
        })
      }
    }
  Lm.__initStatic()
  function yne(e) {
    let {
        transactionNamingScheme: t,
        include: { ip: n, user: r, ...s },
      } = e,
      o = []
    for (let [c, a] of Object.entries(s)) a && o.push(c)
    let i
    if (r === void 0) i = !0
    else if (typeof r == 'boolean') i = r
    else {
      let c = []
      for (let [a, u] of Object.entries(r)) u && c.push(a)
      i = c
    }
    return {
      include: {
        ip: n,
        user: i,
        request: o.length !== 0 ? o : void 0,
        transaction: t,
      },
    }
  }
  function gne(e) {
    try {
      return e.getClient().getOptions()._metadata.sdk.name
    } catch {
      return
    }
  }
  rC.RequestData = Lm
})
var aC = l((jm) => {
  var { _optionalChain: Ae } = ge()
  Object.defineProperty(jm, '__esModule', { value: !0 })
  var Ene = A(),
    Sne = Od(),
    bne = ui()
  function iC(e) {
    let t = [],
      n = !1
    function r(i) {
      ;(t = []), !n && ((n = !0), e(i))
    }
    t.push(r)
    function s(i) {
      t.push(i)
    }
    function o(i) {
      let c = t.pop() || r
      try {
        c(i)
      } catch {
        r(i)
      }
    }
    return { add: s, next: o }
  }
  var oC = class {
    constructor() {
      let { Session: t } = require('inspector')
      this._session = new t()
    }
    configureAndConnect(t, n) {
      this._session.connect(),
        this._session.on('Debugger.paused', (r) => {
          t(r, () => {
            this._session.post('Debugger.resume')
          })
        }),
        this._session.post('Debugger.enable'),
        this._session.post('Debugger.setPauseOnExceptions', {
          state: n ? 'all' : 'uncaught',
        })
    }
    getLocalVariables(t, n) {
      this._getProperties(t, (r) => {
        let { add: s, next: o } = iC(n)
        for (let i of r)
          if (
            Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'optionalAccess',
              (c) => c.objectId,
            ]) &&
            Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'access',
              (c) => c.className,
            ]) === 'Array'
          ) {
            let c = i.value.objectId
            s((a) => this._unrollArray(c, i.name, a, o))
          } else if (
            Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'optionalAccess',
              (c) => c.objectId,
            ]) &&
            Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'optionalAccess',
              (c) => c.className,
            ]) === 'Object'
          ) {
            let c = i.value.objectId
            s((a) => this._unrollObject(c, i.name, a, o))
          } else
            (Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'optionalAccess',
              (c) => c.value,
            ]) ||
              Ae([
                i,
                'optionalAccess',
                (c) => c.value,
                'optionalAccess',
                (c) => c.description,
              ])) &&
              s((c) => this._unrollOther(i, c, o))
        o({})
      })
    }
    _getProperties(t, n) {
      this._session.post(
        'Runtime.getProperties',
        { objectId: t, ownProperties: !0 },
        (r, s) => {
          n(r ? [] : s.result)
        },
      )
    }
    _unrollArray(t, n, r, s) {
      this._getProperties(t, (o) => {
        ;(r[n] = o
          .filter((i) => i.name !== 'length' && !isNaN(parseInt(i.name, 10)))
          .sort((i, c) => parseInt(i.name, 10) - parseInt(c.name, 10))
          .map((i) =>
            Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'optionalAccess',
              (c) => c.value,
            ]),
          )),
          s(r)
      })
    }
    _unrollObject(t, n, r, s) {
      this._getProperties(t, (o) => {
        ;(r[n] = o
          .map((i) => [
            i.name,
            Ae([
              i,
              'optionalAccess',
              (c) => c.value,
              'optionalAccess',
              (c) => c.value,
            ]),
          ])
          .reduce((i, [c, a]) => ((i[c] = a), i), {})),
          s(r)
      })
    }
    _unrollOther(t, n, r) {
      Ae([
        t,
        'optionalAccess',
        (s) => s.value,
        'optionalAccess',
        (s) => s.value,
      ])
        ? (n[t.name] = t.value.value)
        : Ae([
            t,
            'optionalAccess',
            (s) => s.value,
            'optionalAccess',
            (s) => s.description,
          ]) &&
          Ae([
            t,
            'optionalAccess',
            (s) => s.value,
            'optionalAccess',
            (s) => s.type,
          ]) !== 'function' &&
          (n[t.name] = `<${t.value.description}>`),
        r(n)
    }
  }
  function vne() {
    try {
      return new oC()
    } catch {
      return
    }
  }
  function Kq(e) {
    return e !== void 0 && ['', '?', '<anonymous>'].includes(e)
  }
  function Cne(e, t) {
    return e === t || (Kq(e) && Kq(t))
  }
  function Jq(e) {
    if (e !== void 0)
      return e
        .slice(-10)
        .reduce((t, n) => `${t},${n.function},${n.lineno},${n.colno}`, '')
  }
  function wne(e, t) {
    if (t !== void 0) return Jq(e(t, 1))
  }
  var Bm = class e {
    static __initStatic() {
      this.id = 'LocalVariables'
    }
    __init() {
      this.name = e.id
    }
    __init2() {
      this._cachedFrames = new Sne.LRUMap(20)
    }
    constructor(t = {}, n = vne()) {
      ;(this._options = t),
        (this._session = n),
        e.prototype.__init.call(this),
        e.prototype.__init2.call(this)
    }
    setupOnce(t, n) {
      this._setup(
        t,
        Ae([
          n,
          'call',
          (r) => r(),
          'access',
          (r) => r.getClient,
          'call',
          (r) => r(),
          'optionalAccess',
          (r) => r.getOptions,
          'call',
          (r) => r(),
        ]),
      )
    }
    _setup(t, n) {
      if (
        this._session &&
        Ae([n, 'optionalAccess', (r) => r.includeLocalVariables])
      ) {
        if ((bne.NODE_VERSION.major || 0) < 18) {
          Ene.logger.log(
            'The `LocalVariables` integration is only supported on Node >= v18.',
          )
          return
        }
        this._session.configureAndConnect(
          (s, o) => this._handlePaused(n.stackParser, s, o),
          !!this._options.captureAllExceptions,
        ),
          t(async (s) => this._addLocalVariables(s))
      }
    }
    _handlePaused(t, { params: { reason: n, data: r, callFrames: s } }, o) {
      if (n !== 'exception' && n !== 'promiseRejection') {
        o()
        return
      }
      let i = wne(t, Ae([r, 'optionalAccess', (u) => u.description]))
      if (i == null) {
        o()
        return
      }
      let { add: c, next: a } = iC((u) => {
        this._cachedFrames.set(i, u), o()
      })
      for (let u = 0; u < Math.min(s.length, 5); u++) {
        let { scopeChain: d, functionName: p, this: f } = s[u],
          _ = d.find((g) => g.type === 'local'),
          h =
            f.className === 'global' || !f.className ? p : `${f.className}.${p}`
        if (
          Ae([
            _,
            'optionalAccess',
            (g) => g.object,
            'access',
            (g) => g.objectId,
          ]) === void 0
        )
          c((g) => {
            ;(g[u] = { function: h }), a(g)
          })
        else {
          let g = _.object.objectId
          c((E) =>
            Ae([
              this,
              'access',
              (P) => P._session,
              'optionalAccess',
              (P) => P.getLocalVariables,
              'call',
              (P) =>
                P(g, (z) => {
                  ;(E[u] = { function: h, vars: z }), a(E)
                }),
            ]),
          )
        }
      }
      a([])
    }
    _addLocalVariables(t) {
      for (let n of Ae([
        t,
        'optionalAccess',
        (r) => r.exception,
        'optionalAccess',
        (r) => r.values,
      ]) || [])
        this._addLocalVariablesToException(n)
      return t
    }
    _addLocalVariablesToException(t) {
      let n = Jq(
        Ae([
          t,
          'optionalAccess',
          (o) => o.stacktrace,
          'optionalAccess',
          (o) => o.frames,
        ]),
      )
      if (n === void 0) return
      let r = this._cachedFrames.delete(n)
      if (r === void 0) return
      let s =
        Ae([
          t,
          'access',
          (o) => o.stacktrace,
          'optionalAccess',
          (o) => o.frames,
          'optionalAccess',
          (o) => o.length,
        ]) || 0
      for (let o = 0; o < s; o++) {
        let i = s - o - 1
        if (
          !Ae([
            t,
            'optionalAccess',
            (c) => c.stacktrace,
            'optionalAccess',
            (c) => c.frames,
            'optionalAccess',
            (c) => c[i],
          ]) ||
          !r[o]
        )
          break
        r[o].vars === void 0 ||
          t.stacktrace.frames[i].in_app === !1 ||
          !Cne(t.stacktrace.frames[i].function, r[o].function) ||
          (t.stacktrace.frames[i].vars = r[o].vars)
      }
    }
  }
  Bm.__initStatic()
  jm.LocalVariables = Bm
  jm.createCallbackList = iC
})
var dC = l((cr, tk) => {
  var { _optionalChain: ek } = ge()
  Object.defineProperty(cr, '__esModule', { value: !0 })
  var Gm = be(),
    ro = A(),
    Xq = Od(),
    Qq = ui(),
    cC = kv()
  cr.ChannelName = void 0
  ;(function (e) {
    let t = 'undici:request:create'
    e.RequestCreate = t
    let n = 'undici:request:headers'
    e.RequestEnd = n
    let r = 'undici:request:error'
    e.RequestError = r
  })(cr.ChannelName || (cr.ChannelName = {}))
  var $m = class e {
    static __initStatic() {
      this.id = 'Undici'
    }
    __init() {
      this.name = e.id
    }
    __init2() {
      this._createSpanUrlMap = new Xq.LRUMap(100)
    }
    __init3() {
      this._headersUrlMap = new Xq.LRUMap(100)
    }
    constructor(t = {}) {
      e.prototype.__init.call(this),
        e.prototype.__init2.call(this),
        e.prototype.__init3.call(this),
        e.prototype.__init4.call(this),
        e.prototype.__init5.call(this),
        e.prototype.__init6.call(this),
        (this._options = {
          breadcrumbs: t.breadcrumbs === void 0 ? !0 : t.breadcrumbs,
          shouldCreateSpanForRequest: t.shouldCreateSpanForRequest,
        })
    }
    setupOnce(t) {
      if (Qq.NODE_VERSION.major && Qq.NODE_VERSION.major < 16) return
      let n
      try {
        n = ro.dynamicRequire(tk, 'diagnostics_channel')
      } catch {}
      !n ||
        !n.subscribe ||
        (n.subscribe(cr.ChannelName.RequestCreate, this._onRequestCreate),
        n.subscribe(cr.ChannelName.RequestEnd, this._onRequestEnd),
        n.subscribe(cr.ChannelName.RequestError, this._onRequestError))
    }
    _shouldCreateSpan(t) {
      if (this._options.shouldCreateSpanForRequest === void 0) return !0
      let n = this._createSpanUrlMap.get(t)
      if (n !== void 0) return n
      let r = this._options.shouldCreateSpanForRequest(t)
      return this._createSpanUrlMap.set(t, r), r
    }
    __init4() {
      this._onRequestCreate = (t) => {
        let n = Gm.getCurrentHub()
        if (!n.getIntegration(e)) return
        let { request: r } = t,
          s = r.origin ? r.origin.toString() + r.path : r.path
        if (cC.isSentryRequest(s) || r.__sentry_span__ !== void 0) return
        let o = n.getClient()
        if (!o) return
        let i = o.getOptions(),
          c = n.getScope(),
          a = c.getSpan(),
          u = this._shouldCreateSpan(s) ? Tne(a, r, s) : void 0
        if (
          (u && (r.__sentry_span__ = u),
          ((p) => {
            if (i.tracePropagationTargets === void 0) return !0
            let f = this._headersUrlMap.get(p)
            if (f !== void 0) return f
            let _ = ro.stringMatchesSomePattern(p, i.tracePropagationTargets)
            return this._headersUrlMap.set(p, _), _
          })(s))
        )
          if (u) {
            let p = ek([
                u,
                'optionalAccess',
                (_) => _.transaction,
                'optionalAccess',
                (_) => _.getDynamicSamplingContext,
                'call',
                (_) => _(),
              ]),
              f = ro.dynamicSamplingContextToSentryBaggageHeader(p)
            Zq(r, u.toTraceparent(), f)
          } else {
            let { traceId: p, sampled: f, dsc: _ } = c.getPropagationContext(),
              h = ro.generateSentryTraceHeader(p, void 0, f),
              g = _ || Gm.getDynamicSamplingContextFromClient(p, o, c),
              E = ro.dynamicSamplingContextToSentryBaggageHeader(g)
            Zq(r, h, E)
          }
      }
    }
    __init5() {
      this._onRequestEnd = (t) => {
        let n = Gm.getCurrentHub()
        if (!n.getIntegration(e)) return
        let { request: r, response: s } = t,
          o = r.origin ? r.origin.toString() + r.path : r.path
        if (cC.isSentryRequest(o)) return
        let i = r.__sentry_span__
        i && (i.setHttpStatus(s.statusCode), i.finish()),
          this._options.breadcrumbs &&
            n.addBreadcrumb(
              {
                category: 'http',
                data: { method: r.method, status_code: s.statusCode, url: o },
                type: 'http',
              },
              { event: 'response', request: r, response: s },
            )
      }
    }
    __init6() {
      this._onRequestError = (t) => {
        let n = Gm.getCurrentHub()
        if (!n.getIntegration(e)) return
        let { request: r } = t,
          s = r.origin ? r.origin.toString() + r.path : r.path
        if (cC.isSentryRequest(s)) return
        let o = r.__sentry_span__
        o && (o.setStatus('internal_error'), o.finish()),
          this._options.breadcrumbs &&
            n.addBreadcrumb(
              {
                category: 'http',
                data: { method: r.method, url: s },
                level: 'error',
                type: 'http',
              },
              { event: 'error', request: r },
            )
      }
    }
  }
  $m.__initStatic()
  function Zq(e, t, n) {
    e.__sentry_has_headers__ ||
      (e.addHeader('sentry-trace', t),
      n && e.addHeader('baggage', n),
      (e.__sentry_has_headers__ = !0))
  }
  function Tne(e, t, n) {
    let r = ro.parseUrl(n),
      s = t.method || 'GET',
      o = { 'http.method': s }
    return (
      r.search && (o['http.query'] = r.search),
      r.hash && (o['http.fragment'] = r.hash),
      ek([
        e,
        'optionalAccess',
        (i) => i.startChild,
        'call',
        (i) =>
          i({
            op: 'http.client',
            description: `${s} ${ro.getSanitizedUrlString(r)}`,
            data: o,
          }),
      ])
    )
  }
  cr.Undici = $m
})
var lC = l((uC) => {
  Object.defineProperty(uC, '__esModule', { value: !0 })
  var nk = require('path'),
    xne = nk.sep === '\\'
  function Ine(e) {
    return e.replace(/^[A-Z]:/, '').replace(/\\/g, '/')
  }
  function Pne(e, t = xne) {
    if (!e) return
    let n = t ? Ine(e) : e,
      { root: r, dir: s, base: o, ext: i } = nk.posix.parse(n),
      a = `${
        (require && require.main && require.main.filename && s) ||
        global.process.cwd()
      }/`,
      u = o
    i === '.js' && (u = u.slice(0, u.length - 3)), !r && !s && (s = '.')
    let d = s.lastIndexOf('/node_modules/')
    if (d > -1) return `${s.slice(d + 14).replace(/\//g, '.')}:${u}`
    if (((d = `${s}/`.lastIndexOf(a, 0)), d === 0)) {
      let p = s.slice(a.length).replace(/\//g, '.')
      return p && (p += ':'), (p += u), p
    }
    return u
  }
  uC.getModuleFromFilename = Pne
})
var mC = l((io) => {
  var { _optionalChain: Rne } = ge()
  Object.defineProperty(io, '__esModule', { value: !0 })
  var so = be(),
    oo = A(),
    Dne = xq(),
    Ane = mv(),
    One = Nv(),
    Nne = Fv(),
    qne = Gv(),
    kne = zv(),
    Mne = Yv(),
    Fne = Xv(),
    Une = Nm(),
    Lne = Qv(),
    Bne = sC(),
    jne = aC(),
    Gne = dC(),
    $ne = lC(),
    zne = xv(),
    rk = [
      new so.Integrations.InboundFilters(),
      new so.Integrations.FunctionToString(),
      new One.Console(),
      new Nne.Http(),
      new Gne.Undici(),
      new qne.OnUncaughtException(),
      new kne.OnUnhandledRejection(),
      new Une.ContextLines(),
      new jne.LocalVariables(),
      new Lne.Context(),
      new Fne.Modules(),
      new Bne.RequestData(),
      new Mne.LinkedErrors(),
    ]
  function Hne(e = {}) {
    let t = so.getMainCarrier()
    Dne.setNodeAsyncContextStrategy()
    let n =
      Rne([
        t,
        'access',
        (o) => o.__SENTRY__,
        'optionalAccess',
        (o) => o.integrations,
      ]) || []
    ;(e.defaultIntegrations =
      e.defaultIntegrations === !1
        ? []
        : [
            ...(Array.isArray(e.defaultIntegrations)
              ? e.defaultIntegrations
              : rk),
            ...n,
          ]),
      e.dsn === void 0 &&
        process.env.SENTRY_DSN &&
        (e.dsn = process.env.SENTRY_DSN)
    let r = process.env.SENTRY_TRACES_SAMPLE_RATE
    if (e.tracesSampleRate === void 0 && r) {
      let o = parseFloat(r)
      isFinite(o) && (e.tracesSampleRate = o)
    }
    if (e.release === void 0) {
      let o = sk()
      o !== void 0 ? (e.release = o) : (e.autoSessionTracking = !1)
    }
    e.environment === void 0 &&
      process.env.SENTRY_ENVIRONMENT &&
      (e.environment = process.env.SENTRY_ENVIRONMENT),
      e.autoSessionTracking === void 0 &&
        e.dsn !== void 0 &&
        (e.autoSessionTracking = !0),
      e.instrumenter === void 0 && (e.instrumenter = 'sentry')
    let s = {
      ...e,
      stackParser: oo.stackParserFromStackParserOptions(e.stackParser || ok),
      integrations: so.getIntegrationsToSetup(e),
      transport: e.transport || zne.makeNodeTransport,
    }
    so.initAndBind(e.clientClass || Ane.NodeClient, s),
      e.autoSessionTracking && Vne(),
      Yne()
  }
  function Wne(e) {
    if (e === void 0) return !1
    let t = e && e.getOptions()
    return t && t.autoSessionTracking !== void 0 ? t.autoSessionTracking : !1
  }
  function sk(e) {
    return process.env.SENTRY_RELEASE
      ? process.env.SENTRY_RELEASE
      : oo.GLOBAL_OBJ.SENTRY_RELEASE && oo.GLOBAL_OBJ.SENTRY_RELEASE.id
      ? oo.GLOBAL_OBJ.SENTRY_RELEASE.id
      : process.env.GITHUB_SHA ||
        process.env.COMMIT_REF ||
        process.env.VERCEL_GIT_COMMIT_SHA ||
        process.env.VERCEL_GITHUB_COMMIT_SHA ||
        process.env.VERCEL_GITLAB_COMMIT_SHA ||
        process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
        process.env.ZEIT_GITHUB_COMMIT_SHA ||
        process.env.ZEIT_GITLAB_COMMIT_SHA ||
        process.env.ZEIT_BITBUCKET_COMMIT_SHA ||
        e
  }
  var ok = oo.createStackParser(
    oo.nodeStackLineParser($ne.getModuleFromFilename),
  )
  function Vne() {
    let e = so.getCurrentHub()
    e.startSession(),
      process.on('beforeExit', () => {
        let t = e.getScope().getSession()
        t && !['exited', 'crashed'].includes(t.status) && e.endSession()
      })
  }
  function Yne() {
    let e = (process.env.SENTRY_USE_ENVIRONMENT || '').toLowerCase()
    if (!['false', 'n', 'no', 'off', '0'].includes(e)) {
      let t = process.env.SENTRY_TRACE,
        n = process.env.SENTRY_BAGGAGE,
        { propagationContext: r } = oo.tracingContextFromHeaders(t, n)
      so.getCurrentHub().getScope().setPropagationContext(r)
    }
  }
  io.defaultIntegrations = rk
  io.defaultStackParser = ok
  io.getSentryRelease = sk
  io.init = Hne
  io.isAutoSessionTrackingEnabled = Wne
})
var ik = l((fC) => {
  Object.defineProperty(fC, '__esModule', { value: !0 })
  var zm = require('fs'),
    pC = require('path')
  function Kne(e) {
    let t = pC.resolve(e)
    if (!zm.existsSync(t))
      throw new Error(`Cannot read contents of ${t}. Directory does not exist.`)
    if (!zm.statSync(t).isDirectory())
      throw new Error(
        `Cannot read contents of ${t}, because it is not a directory.`,
      )
    let n = (r) =>
      zm.readdirSync(r).reduce((s, o) => {
        let i = pC.join(r, o)
        return zm.statSync(i).isDirectory() ? s.concat(n(i)) : (s.push(i), s)
      }, [])
    return n(t).map((r) => pC.relative(t, r))
  }
  fC.deepReadDirSync = Kne
})
var ck = l((Hm) => {
  Object.defineProperty(Hm, '__esModule', { value: !0 })
  var ak = qd()
  function Jne(e, t) {
    return ak.extractRequestData(e, { include: t })
  }
  function Xne(e, t, n = {}) {
    return ak.addRequestDataToEvent(e, t, { include: n })
  }
  Hm.extractRequestData = Jne
  Hm.parseRequest = Xne
})
var uk = l((Hr) => {
  var { _optionalChain: fi } = ge()
  Object.defineProperty(Hr, '__esModule', { value: !0 })
  var an = be(),
    zr = A(),
    Qne = qd(),
    Wm = mC(),
    dk = ck()
  function Zne() {
    return function (t, n, r) {
      let s = an.getCurrentHub(),
        o = fi([
          s,
          'access',
          (h) => h.getClient,
          'call',
          (h) => h(),
          'optionalAccess',
          (h) => h.getOptions,
          'call',
          (h) => h(),
        ])
      if (
        !o ||
        o.instrumenter !== 'sentry' ||
        fi([
          t,
          'access',
          (h) => h.method,
          'optionalAccess',
          (h) => h.toUpperCase,
          'call',
          (h) => h(),
        ]) === 'OPTIONS' ||
        fi([
          t,
          'access',
          (h) => h.method,
          'optionalAccess',
          (h) => h.toUpperCase,
          'call',
          (h) => h(),
        ]) === 'HEAD'
      )
        return r()
      let i =
          t.headers && zr.isString(t.headers['sentry-trace'])
            ? t.headers['sentry-trace']
            : void 0,
        c = fi([
          t,
          'access',
          (h) => h.headers,
          'optionalAccess',
          (h) => h.baggage,
        ]),
        {
          traceparentData: a,
          dynamicSamplingContext: u,
          propagationContext: d,
        } = zr.tracingContextFromHeaders(i, c)
      if ((s.getScope().setPropagationContext(d), !an.hasTracingEnabled(o)))
        return r()
      let [p, f] = zr.extractPathForTransaction(t, { path: !0, method: !0 }),
        _ = an.startTransaction(
          {
            name: p,
            op: 'http.server',
            ...a,
            metadata: {
              dynamicSamplingContext: a && !u ? {} : u,
              request: t,
              source: f,
            },
          },
          { request: Qne.extractRequestData(t) },
        )
      s.configureScope((h) => {
        h.setSpan(_)
      }),
        (n.__sentry_transaction = _),
        n.once('finish', () => {
          setImmediate(() => {
            zr.addRequestDataToTransaction(_, t),
              _.setHttpStatus(n.statusCode),
              _.finish()
          })
        }),
        r()
    }
  }
  function ere(e = {}) {
    let t
    if ('include' in e) t = { include: e.include }
    else {
      let { ip: n, request: r, transaction: s, user: o } = e
      ;(n || r || s || o) &&
        (t = {
          include: zr.dropUndefinedKeys({
            ip: n,
            request: r,
            transaction: s,
            user: o,
          }),
        })
    }
    return t
  }
  function tre(e) {
    let t = ere(e),
      n = an.getCurrentHub(),
      r = n.getClient()
    if (r && Wm.isAutoSessionTrackingEnabled(r)) {
      r.initSessionFlusher()
      let s = n.getScope()
      s.getSession() && s.setSession()
    }
    return function (o, i, c) {
      if (e && e.flushTimeout && e.flushTimeout > 0) {
        let a = i.end
        i.end = function (u, d, p) {
          an.flush(e.flushTimeout)
            .then(() => {
              a.call(this, u, d, p)
            })
            .then(null, (f) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                zr.logger.error(f),
                a.call(this, u, d, p)
            })
        }
      }
      an.runWithAsyncContext(() => {
        let a = an.getCurrentHub()
        a.configureScope((u) => {
          u.setSDKProcessingMetadata({
            request: o,
            requestDataOptionsFromExpressHandler: t,
          })
          let d = a.getClient()
          if (Wm.isAutoSessionTrackingEnabled(d)) {
            let p = a.getScope()
            p && p.setRequestSession({ status: 'ok' })
          }
        }),
          i.once('finish', () => {
            let u = a.getClient()
            Wm.isAutoSessionTrackingEnabled(u) &&
              setImmediate(() => {
                u && u._captureRequestSession && u._captureRequestSession()
              })
          }),
          c()
      })
    }
  }
  function nre(e) {
    let t =
      e.status ||
      e.statusCode ||
      e.status_code ||
      (e.output && e.output.statusCode)
    return t ? parseInt(t, 10) : 500
  }
  function rre(e) {
    return nre(e) >= 500
  }
  function sre(e) {
    return function (n, r, s, o) {
      if (((e && e.shouldHandleError) || rre)(n)) {
        an.withScope((c) => {
          c.setSDKProcessingMetadata({ request: r })
          let a = s.__sentry_transaction
          a && c.getSpan() === void 0 && c.setSpan(a)
          let u = an.getCurrentHub().getClient()
          if (
            u &&
            Wm.isAutoSessionTrackingEnabled(u) &&
            u._sessionFlusher !== void 0
          ) {
            let f = c.getRequestSession()
            f && f.status !== void 0 && (f.status = 'crashed')
          }
          c.addEventProcessor(
            (p) => (
              zr.addExceptionMechanism(p, { type: 'middleware', handled: !1 }),
              p
            ),
          )
          let d = an.captureException(n)
          ;(s.sentry = d), o(n)
        })
        return
      }
      o(n)
    }
  }
  function ore(e = {}) {
    return function ({ path: t, type: n, next: r, rawInput: s }) {
      let o = an.getCurrentHub(),
        i = fi([
          o,
          'access',
          (a) => a.getClient,
          'call',
          (a) => a(),
          'optionalAccess',
          (a) => a.getOptions,
          'call',
          (a) => a(),
        ]),
        c = o.getScope().getTransaction()
      if (c) {
        c.setName(`trpc/${t}`, 'route'), (c.op = 'rpc.server')
        let a = { procedure_type: n }
        ;(e.attachRpcInput !== void 0
          ? e.attachRpcInput
          : fi([i, 'optionalAccess', (u) => u.sendDefaultPii])) &&
          (a.input = zr.normalize(s)),
          c.setContext('trpc', a)
      }
      return r()
    }
  }
  Hr.extractRequestData = dk.extractRequestData
  Hr.parseRequest = dk.parseRequest
  Hr.errorHandler = sre
  Hr.requestHandler = tre
  Hr.tracingHandler = Zne
  Hr.trpcMiddleware = ore
})
var lk = l((Tt) => {
  Object.defineProperty(Tt, '__esModule', { value: !0 })
  var ire = Nv(),
    are = Fv(),
    cre = Gv(),
    dre = zv(),
    ure = Yv(),
    lre = Xv(),
    mre = Nm(),
    pre = Qv(),
    fre = sC(),
    _re = aC(),
    hre = dC()
  Tt.Console = ire.Console
  Tt.Http = are.Http
  Tt.OnUncaughtException = cre.OnUncaughtException
  Tt.OnUnhandledRejection = dre.OnUnhandledRejection
  Tt.LinkedErrors = ure.LinkedErrors
  Tt.Modules = lre.Modules
  Tt.ContextLines = mre.ContextLines
  Tt.Context = pre.Context
  Tt.RequestData = fre.RequestData
  Tt.LocalVariables = _re.LocalVariables
  Tt.Undici = hre.Undici
})
var mk = l((dr) => {
  Object.defineProperty(dr, '__esModule', { value: !0 })
  var ao = iv()
  dr.Apollo = ao.Apollo
  dr.Express = ao.Express
  dr.GraphQL = ao.GraphQL
  dr.Mongo = ao.Mongo
  dr.Mysql = ao.Mysql
  dr.Postgres = ao.Postgres
  dr.Prisma = ao.Prisma
})
var vn = l((V) => {
  Object.defineProperty(V, '__esModule', { value: !0 })
  var de = be(),
    yre = KN(),
    gre = mv(),
    Ere = xv(),
    Vm = mC(),
    _C = qd(),
    Sre = ik(),
    bre = lC(),
    vre = uk(),
    Cre = lk(),
    wre = mk(),
    Tre = { ...de.Integrations, ...Cre, ...wre }
  V.Hub = de.Hub
  V.SDK_VERSION = de.SDK_VERSION
  V.Scope = de.Scope
  V.addBreadcrumb = de.addBreadcrumb
  V.addGlobalEventProcessor = de.addGlobalEventProcessor
  V.captureCheckIn = de.captureCheckIn
  V.captureEvent = de.captureEvent
  V.captureException = de.captureException
  V.captureMessage = de.captureMessage
  V.close = de.close
  V.configureScope = de.configureScope
  V.createTransport = de.createTransport
  V.extractTraceparentData = de.extractTraceparentData
  V.flush = de.flush
  V.getActiveTransaction = de.getActiveTransaction
  V.getCurrentHub = de.getCurrentHub
  V.getHubFromCarrier = de.getHubFromCarrier
  V.lastEventId = de.lastEventId
  V.makeMain = de.makeMain
  V.runWithAsyncContext = de.runWithAsyncContext
  V.setContext = de.setContext
  V.setExtra = de.setExtra
  V.setExtras = de.setExtras
  V.setMeasurement = de.setMeasurement
  V.setTag = de.setTag
  V.setTags = de.setTags
  V.setUser = de.setUser
  V.spanStatusfromHttpCode = de.spanStatusfromHttpCode
  V.startTransaction = de.startTransaction
  V.trace = de.trace
  V.withScope = de.withScope
  V.autoDiscoverNodePerformanceMonitoringIntegrations =
    yre.autoDiscoverNodePerformanceMonitoringIntegrations
  V.NodeClient = gre.NodeClient
  V.makeNodeTransport = Ere.makeNodeTransport
  V.defaultIntegrations = Vm.defaultIntegrations
  V.defaultStackParser = Vm.defaultStackParser
  V.getSentryRelease = Vm.getSentryRelease
  V.init = Vm.init
  V.DEFAULT_USER_INCLUDES = _C.DEFAULT_USER_INCLUDES
  V.addRequestDataToEvent = _C.addRequestDataToEvent
  V.extractRequestData = _C.extractRequestData
  V.deepReadDirSync = Sre.deepReadDirSync
  V.getModuleFromFilename = bre.getModuleFromFilename
  V.Handlers = vre
  V.Integrations = Tre
})
var yC = l((hC) => {
  Object.defineProperty(hC, '__esModule', { value: !0 })
  var xre = vn(),
    Ire = A(),
    Ym = class e {
      static __initStatic() {
        this.id = 'AWSServices'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._optional = t.optional || !1)
      }
      setupOnce() {
        try {
          let t = require('aws-sdk/global')
          Ire.fill(t.Service.prototype, 'makeRequest', Pre)
        } catch (t) {
          if (!this._optional) throw t
        }
      }
    }
  Ym.__initStatic()
  function Pre(e) {
    return function (t, n, r) {
      let s,
        o,
        i = xre.getCurrentHub().getScope()
      i && (s = i.getTransaction())
      let c = e.call(this, t, n)
      return (
        c.on('afterBuild', () => {
          s &&
            (o = s.startChild({
              description: Rre(this, t, n),
              op: 'http.client',
            }))
        }),
        c.on('complete', () => {
          o && o.finish()
        }),
        r && c.send(r),
        c
      )
    }
  }
  function Rre(e, t, n) {
    let r = `aws.${e.serviceIdentifier}.${t}`
    if (n === void 0) return r
    switch (e.serviceIdentifier) {
      case 's3':
        r += Are(t, n)
        break
      case 'lambda':
        r += Dre(t, n)
        break
    }
    return r
  }
  function Dre(e, t) {
    let n = ''
    return 'FunctionName' in t && (n += ` ${t.FunctionName}`), n
  }
  function Are(e, t) {
    let n = ''
    return 'Bucket' in t && (n += ` ${t.Bucket}`), n
  }
  hC.AWSServices = Ym
})
var _i = l((kd) => {
  Object.defineProperty(kd, '__esModule', { value: !0 })
  var Ore = be(),
    Nre = A()
  function qre(e) {
    return Nre.addExceptionMechanism(e, { handled: !1 }), e
  }
  function kre(e) {
    return (...t) =>
      Ore.runWithAsyncContext(() => e(...t), { reuseExisting: !0 })
  }
  function Mre(e, t, n) {
    let r = t(e),
      s = { apply: (o, i, c) => r.apply(i, c) }
    return (
      n &&
        (s.get = (o, i) =>
          Object.prototype.hasOwnProperty.call(n, i) ? n[i] : o[i]),
      new Proxy(e, s)
    )
  }
  kd.domainify = kre
  kd.proxyFunction = Mre
  kd.serverlessEventProcessor = qre
})
var Ek = l((Wr) => {
  var { _optionalChain: pk } = ge()
  Object.defineProperty(Wr, '__esModule', { value: !0 })
  var xt = vn(),
    co = A(),
    fk = require('fs'),
    Fre = require('os'),
    _k = require('path'),
    hk = require('perf_hooks'),
    Ure = require('util'),
    Lre = yC(),
    Bre = _i(),
    { isPromise: jre } = Ure.types,
    yk = [...xt.defaultIntegrations, new Lre.AWSServices({ optional: !0 })]
  function Gre(e = {}) {
    e.defaultIntegrations === void 0 && (e.defaultIntegrations = yk),
      (e._metadata = e._metadata || {}),
      (e._metadata.sdk = {
        name: 'sentry.javascript.serverless',
        integrations: ['AWSLambda'],
        packages: [{ name: 'npm:@sentry/serverless', version: xt.SDK_VERSION }],
        version: xt.SDK_VERSION,
      }),
      xt.init(e),
      xt.addGlobalEventProcessor(Bre.serverlessEventProcessor)
  }
  function $re(e, t, n) {
    let r = _k.resolve(e, t, n)
    return fk.existsSync(r) || fk.existsSync(`${r}.js`)
      ? require(r)
      : require(require.resolve(n, { paths: [e, t] }))
  }
  function zre(e) {
    return e.every(
      (t) =>
        Object.prototype.hasOwnProperty.call(t, 'status') &&
        (Object.prototype.hasOwnProperty.call(t, 'value') ||
          Object.prototype.hasOwnProperty.call(t, 'reason')),
    )
  }
  function Hre(e) {
    return e.reduce(
      (t, n) => (n.status === 'rejected' && n.reason && t.push(n.reason), t),
      [],
    )
  }
  function Wre(e, t) {
    let n = _k.basename(t),
      r = n.match(/^([^.]*)\.(.*)$/)
    if (!r) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        co.logger.error(`Bad handler ${n}`)
      return
    }
    let [, s, o] = r,
      i
    try {
      let u = t.substring(0, t.indexOf(n))
      i = $re(e, u, s)
    } catch (u) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        co.logger.error(`Cannot require ${t} in ${e}`, u)
      return
    }
    let c, a
    if (
      (o.split('.').forEach((u) => {
        ;(c = i), (i = i && i[u]), (a = u)
      }),
      !i)
    ) {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        co.logger.error(`${t} is undefined or not exported`)
      return
    }
    if (typeof i != 'function') {
      ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
        co.logger.error(`${t} is not a function`)
      return
    }
    c[a] = gk(i)
  }
  function gC(e) {
    return typeof e.getRemainingTimeInMillis == 'function'
      ? e.getRemainingTimeInMillis()
      : 0
  }
  function Vre(e, t, n) {
    e.setTransactionName(t.functionName),
      e.setTag(
        'server_name',
        process.env._AWS_XRAY_DAEMON_ADDRESS ||
          process.env.SENTRY_NAME ||
          Fre.hostname(),
      ),
      e.setTag('url', `awslambda:///${t.functionName}`),
      e.setContext('aws.lambda', {
        aws_request_id: t.awsRequestId,
        function_name: t.functionName,
        function_version: t.functionVersion,
        invoked_function_arn: t.invokedFunctionArn,
        execution_duration_in_millis: hk.performance.now() - n,
        remaining_time_in_millis: gC(t),
        'sys.argv': process.argv,
      }),
      e.setContext('aws.cloudwatch.logs', {
        log_group: t.logGroupName,
        log_stream: t.logStreamName,
        url: `https://console.aws.amazon.com/cloudwatch/home?region=${
          process.env.AWS_REGION
        }#logsV2:log-groups/log-group/${encodeURIComponent(
          t.logGroupName,
        )}/log-events/${encodeURIComponent(t.logStreamName)}?filterPattern="${
          t.awsRequestId
        }"`,
      })
  }
  function gk(e, t = {}) {
    let n = hk.performance.now(),
      r = {
        flushTimeout: 2e3,
        callbackWaitsForEmptyEventLoop: !1,
        captureTimeoutWarning: !0,
        timeoutWarningLimit: 500,
        captureAllSettledReasons: !1,
        ...t,
      },
      s,
      o =
        e.length > 2
          ? (i, c) =>
              new Promise((a, u) => {
                let d = e(i, c, (p, f) => {
                  p == null ? a(f) : u(p)
                })
                jre(d) && d.then(a, u)
              })
          : e
    return async (i, c) => {
      c.callbackWaitsForEmptyEventLoop = r.callbackWaitsForEmptyEventLoop
      let a = Math.ceil(gC(c) / 1e3),
        u = Math.floor(a / 60),
        d = a % 60,
        p = u > 0 ? `${u}m${d}s` : `${d}s`
      if (r.captureTimeoutWarning) {
        let Q = gC(c) - r.timeoutWarningLimit
        s = setTimeout(() => {
          xt.withScope((De) => {
            De.setTag('timeout', p),
              xt.captureMessage(
                `Possible function timeout: ${c.functionName}`,
                'warning',
              )
          })
        }, Q)
      }
      let f = xt.getCurrentHub(),
        _ = i,
        h =
          _.headers && co.isString(_.headers['sentry-trace'])
            ? _.headers['sentry-trace']
            : void 0,
        g = pk([
          _,
          'access',
          (Q) => Q.headers,
          'optionalAccess',
          (Q) => Q.baggage,
        ]),
        {
          traceparentData: E,
          dynamicSamplingContext: P,
          propagationContext: z,
        } = co.tracingContextFromHeaders(h, g)
      f.getScope().setPropagationContext(z)
      let ye = f.startTransaction({
          name: c.functionName,
          op: 'function.aws.lambda',
          ...E,
          metadata: {
            dynamicSamplingContext: E && !P ? {} : P,
            source: 'component',
          },
        }),
        fe = f.pushScope(),
        xe
      try {
        Vre(fe, c, n),
          fe.setSpan(ye),
          (xe = await o(i, c)),
          r.captureAllSettledReasons &&
            Array.isArray(xe) &&
            zre(xe) &&
            Hre(xe).forEach((De) => {
              xt.captureException(De)
            })
      } catch (Q) {
        throw (xt.captureException(Q), Q)
      } finally {
        clearTimeout(s),
          pk([ye, 'optionalAccess', (Q) => Q.finish, 'call', (Q) => Q()]),
          f.popScope(),
          await xt.flush(r.flushTimeout).catch((Q) => {
            ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
              co.logger.error(Q)
          })
      }
      return xe
    }
  }
  Wr.defaultIntegrations = yk
  Wr.init = Gre
  Wr.tryPatchHandler = Wre
  Wr.wrapHandler = gk
  for (let e in xt) e !== 'default' && !Wr.hasOwnProperty(e) && (Wr[e] = xt[e])
})
var vk = l((EC) => {
  var { _optionalChain: Sk } = ge()
  Object.defineProperty(EC, '__esModule', { value: !0 })
  var Yre = vn(),
    bk = A(),
    Km = class e {
      static __initStatic() {
        this.id = 'GoogleCloudGrpc'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._optional = t.optional || !1)
      }
      setupOnce() {
        try {
          let t = require('google-gax')
          bk.fill(t.GrpcClient.prototype, 'createStub', Kre)
        } catch (t) {
          if (!this._optional) throw t
        }
      }
    }
  Km.__initStatic()
  function Kre(e) {
    return async function (...t) {
      let n = Sk([
        t,
        'access',
        (o) => o[1],
        'optionalAccess',
        (o) => o.servicePath,
      ])
      if (n == null || n == null) return e.apply(this, t)
      let r = Xre(n),
        s = await e.apply(this, t)
      for (let o of Object.keys(Object.getPrototypeOf(s))) Jre(s, r, o)
      return s
    }
  }
  function Jre(e, t, n) {
    let r = e[n]
    if (typeof r != 'function') return
    let s =
      !r.requestStream && !r.responseStream
        ? 'unary call'
        : r.requestStream && !r.responseStream
        ? 'client stream'
        : !r.requestStream && r.responseStream
        ? 'server stream'
        : 'bidi stream'
    s == 'unary call' &&
      bk.fill(e, n, (o) => (...i) => {
        let c = o.apply(e, i)
        if (typeof Sk([c, 'optionalAccess', (p) => p.on]) != 'function')
          return c
        let a,
          u,
          d = Yre.getCurrentHub().getScope()
        return (
          d && (a = d.getTransaction()),
          a &&
            (u = a.startChild({ description: `${s} ${n}`, op: `grpc.${t}` })),
          c.on('status', () => {
            u && u.finish()
          }),
          c
        )
      })
  }
  function Xre(e) {
    let t = e.match(/^(\w+)\.googleapis.com$/)
    return t ? t[1] : e
  }
  EC.GoogleCloudGrpc = Km
})
var Ck = l((SC) => {
  Object.defineProperty(SC, '__esModule', { value: !0 })
  var Qre = vn(),
    Zre = A(),
    Jm = class e {
      static __initStatic() {
        this.id = 'GoogleCloudHttp'
      }
      constructor(t = {}) {
        ;(this.name = e.id), (this._optional = t.optional || !1)
      }
      setupOnce() {
        try {
          let t = require('@google-cloud/common')
          Zre.fill(t.Service.prototype, 'request', ese)
        } catch (t) {
          if (!this._optional) throw t
        }
      }
    }
  Jm.__initStatic()
  function ese(e) {
    return function (t, n) {
      let r,
        s,
        o = Qre.getCurrentHub().getScope()
      if ((o && (r = o.getTransaction()), r)) {
        let i = t.method || 'GET'
        s = r.startChild({
          description: `${i} ${t.uri}`,
          op: `http.client.${tse(this.apiEndpoint)}`,
        })
      }
      e.call(this, t, (...i) => {
        s && s.finish(), n(...i)
      })
    }
  }
  function tse(e) {
    let t = e.match(/^https:\/\/(\w+)\.googleapis.com$/)
    return t ? t[1] : e.replace(/^(http|https)?:\/\//, '')
  }
  SC.GoogleCloudHttp = Jm
})
var wk = l((CC) => {
  var { _optionalChain: bC } = ge()
  Object.defineProperty(CC, '__esModule', { value: !0 })
  var Xm = vn(),
    Md = A(),
    vC = _i()
  function nse(e, t = {}) {
    let n = (o) => vC.domainify(rse(o, t)),
      r,
      s = e.__emulator_func
    return (
      s && (r = { __emulator_func: vC.proxyFunction(s, n) }),
      vC.proxyFunction(e, n, r)
    )
  }
  function rse(e, t = {}) {
    let { parseRequestOptions: n } = t,
      r = {
        flushTimeout: 2e3,
        addRequestDataToEventOptions: n ? { include: n } : {},
        ...t,
      }
    return (s, o) => {
      let i = Xm.getCurrentHub(),
        c = (s.method || '').toUpperCase(),
        a = Md.stripUrlQueryAndFragment(s.originalUrl || s.url || ''),
        u =
          s.headers && Md.isString(s.headers['sentry-trace'])
            ? s.headers['sentry-trace']
            : void 0,
        d = bC([
          s,
          'access',
          (P) => P.headers,
          'optionalAccess',
          (P) => P.baggage,
        ]),
        {
          traceparentData: p,
          dynamicSamplingContext: f,
          propagationContext: _,
        } = Md.tracingContextFromHeaders(u, d)
      i.getScope().setPropagationContext(_)
      let h = i.startTransaction({
        name: `${c} ${a}`,
        op: 'function.gcp.http',
        ...p,
        metadata: { dynamicSamplingContext: p && !f ? {} : f, source: 'route' },
      })
      i.configureScope((P) => {
        P.setSDKProcessingMetadata({
          request: s,
          requestDataOptionsFromGCPWrapper: r.addRequestDataToEventOptions,
        }),
          P.setSpan(h)
      }),
        (o.__sentry_transaction = h)
      let g = o.end
      o.end = function (P, z, ye) {
        bC([
          h,
          'optionalAccess',
          (fe) => fe.setHttpStatus,
          'call',
          (fe) => fe(o.statusCode),
        ]),
          bC([h, 'optionalAccess', (fe) => fe.finish, 'call', (fe) => fe()]),
          Xm.flush(r.flushTimeout)
            .then(null, (fe) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Md.logger.error(fe)
            })
            .then(() => {
              g.call(this, P, z, ye)
            })
      }
      let E
      try {
        E = e(s, o)
      } catch (P) {
        throw (Xm.captureException(P), P)
      }
      return (
        Md.isThenable(E) &&
          E.then(null, (P) => {
            throw (Xm.captureException(P), P)
          }),
        E
      )
    }
  }
  CC.wrapHttpFunction = nse
})
var xk = l((TC) => {
  var { _optionalChain: sse } = ge()
  Object.defineProperty(TC, '__esModule', { value: !0 })
  var Fd = vn(),
    Tk = A(),
    wC = _i()
  function ose(e, t = {}) {
    return wC.proxyFunction(e, (n) => wC.domainify(ise(n, t)))
  }
  function ise(e, t = {}) {
    let n = { flushTimeout: 2e3, ...t }
    return (...r) => {
      let [s, o, i] = r,
        c = Fd.getCurrentHub(),
        a = c.startTransaction({
          name: o.eventType,
          op: 'function.gcp.event',
          metadata: { source: 'component' },
        })
      c.configureScope((d) => {
        d.setContext('gcp.function.context', { ...o }), d.setSpan(a)
      })
      let u = wC.domainify((...d) => {
        d[0] !== null && d[0] !== void 0 && Fd.captureException(d[0]),
          sse([a, 'optionalAccess', (p) => p.finish, 'call', (p) => p()]),
          Fd.flush(n.flushTimeout)
            .then(null, (p) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Tk.logger.error(p)
            })
            .then(() => {
              typeof i == 'function' && i(...d)
            })
      })
      if (e.length > 2) {
        let d
        try {
          d = e(s, o, u)
        } catch (p) {
          throw (Fd.captureException(p), p)
        }
        return (
          Tk.isThenable(d) &&
            d.then(null, (p) => {
              throw (Fd.captureException(p), p)
            }),
          d
        )
      }
      return Promise.resolve()
        .then(() => e(s, o))
        .then(
          (d) => u(null, d),
          (d) => u(d, void 0),
        )
    }
  }
  TC.wrapEventFunction = ose
})
var Pk = l((IC) => {
  var { _optionalChain: ase } = ge()
  Object.defineProperty(IC, '__esModule', { value: !0 })
  var Ud = vn(),
    Ik = A(),
    xC = _i()
  function cse(e, t = {}) {
    return xC.proxyFunction(e, (n) => xC.domainify(dse(n, t)))
  }
  function dse(e, t = {}) {
    let n = { flushTimeout: 2e3, ...t }
    return (r, s) => {
      let o = Ud.getCurrentHub(),
        i = o.startTransaction({
          name: r.type || '<unknown>',
          op: 'function.gcp.cloud_event',
          metadata: { source: 'component' },
        })
      o.configureScope((a) => {
        a.setContext('gcp.function.context', { ...r }), a.setSpan(i)
      })
      let c = xC.domainify((...a) => {
        a[0] !== null && a[0] !== void 0 && Ud.captureException(a[0]),
          ase([i, 'optionalAccess', (u) => u.finish, 'call', (u) => u()]),
          Ud.flush(n.flushTimeout)
            .then(null, (u) => {
              ;(typeof __SENTRY_DEBUG__ > 'u' || __SENTRY_DEBUG__) &&
                Ik.logger.error(u)
            })
            .then(() => {
              s(...a)
            })
      })
      if (e.length > 1) {
        let a
        try {
          a = e(r, c)
        } catch (u) {
          throw (Ud.captureException(u), u)
        }
        return (
          Ik.isThenable(a) &&
            a.then(null, (u) => {
              throw (Ud.captureException(u), u)
            }),
          a
        )
      }
      return Promise.resolve()
        .then(() => e(r))
        .then(
          (a) => c(null, a),
          (a) => c(a, void 0),
        )
    }
  }
  IC.wrapCloudEventFunction = cse
})
var Dk = l((uo) => {
  Object.defineProperty(uo, '__esModule', { value: !0 })
  var Ld = vn(),
    use = vk(),
    lse = Ck(),
    mse = _i(),
    pse = wk(),
    fse = xk(),
    _se = Pk(),
    Rk = [
      ...Ld.defaultIntegrations,
      new lse.GoogleCloudHttp({ optional: !0 }),
      new use.GoogleCloudGrpc({ optional: !0 }),
    ]
  function hse(e = {}) {
    e.defaultIntegrations === void 0 && (e.defaultIntegrations = Rk),
      (e._metadata = e._metadata || {}),
      (e._metadata.sdk = {
        name: 'sentry.javascript.serverless',
        integrations: ['GCPFunction'],
        packages: [{ name: 'npm:@sentry/serverless', version: Ld.SDK_VERSION }],
        version: Ld.SDK_VERSION,
      }),
      Ld.init(e),
      Ld.addGlobalEventProcessor(mse.serverlessEventProcessor)
  }
  uo.wrapHttpFunction = pse.wrapHttpFunction
  uo.wrapEventFunction = fse.wrapEventFunction
  uo.wrapCloudEventFunction = _se.wrapCloudEventFunction
  uo.defaultIntegrations = Rk
  uo.init = hse
})
var Ak = l((X) => {
  Object.defineProperty(X, '__esModule', { value: !0 })
  var yse = Ek(),
    gse = Dk(),
    Ese = yC(),
    Z = vn()
  X.AWSLambda = yse
  X.GCPFunction = gse
  X.AWSServices = Ese.AWSServices
  X.DEFAULT_USER_INCLUDES = Z.DEFAULT_USER_INCLUDES
  X.Handlers = Z.Handlers
  X.Hub = Z.Hub
  X.Integrations = Z.Integrations
  X.NodeClient = Z.NodeClient
  X.SDK_VERSION = Z.SDK_VERSION
  X.Scope = Z.Scope
  X.addBreadcrumb = Z.addBreadcrumb
  X.addGlobalEventProcessor = Z.addGlobalEventProcessor
  X.addRequestDataToEvent = Z.addRequestDataToEvent
  X.autoDiscoverNodePerformanceMonitoringIntegrations =
    Z.autoDiscoverNodePerformanceMonitoringIntegrations
  X.captureCheckIn = Z.captureCheckIn
  X.captureEvent = Z.captureEvent
  X.captureException = Z.captureException
  X.captureMessage = Z.captureMessage
  X.close = Z.close
  X.configureScope = Z.configureScope
  X.createTransport = Z.createTransport
  X.deepReadDirSync = Z.deepReadDirSync
  X.defaultIntegrations = Z.defaultIntegrations
  X.defaultStackParser = Z.defaultStackParser
  X.extractRequestData = Z.extractRequestData
  X.flush = Z.flush
  X.getActiveTransaction = Z.getActiveTransaction
  X.getCurrentHub = Z.getCurrentHub
  X.getHubFromCarrier = Z.getHubFromCarrier
  X.getSentryRelease = Z.getSentryRelease
  X.init = Z.init
  X.lastEventId = Z.lastEventId
  X.makeMain = Z.makeMain
  X.makeNodeTransport = Z.makeNodeTransport
  X.setContext = Z.setContext
  X.setExtra = Z.setExtra
  X.setExtras = Z.setExtras
  X.setMeasurement = Z.setMeasurement
  X.setTag = Z.setTag
  X.setTags = Z.setTags
  X.setUser = Z.setUser
  X.startTransaction = Z.startTransaction
  X.withScope = Z.withScope
})
var T = {}
Mc(T, {
  __addDisposableResource: () => t1,
  __assign: () => Qm,
  __asyncDelegator: () => Vk,
  __asyncGenerator: () => Wk,
  __asyncValues: () => Yk,
  __await: () => hi,
  __awaiter: () => Bk,
  __classPrivateFieldGet: () => Qk,
  __classPrivateFieldIn: () => e1,
  __classPrivateFieldSet: () => Zk,
  __createBinding: () => ep,
  __decorate: () => Fk,
  __disposeResources: () => n1,
  __esDecorate: () => Sse,
  __exportStar: () => Gk,
  __extends: () => kk,
  __generator: () => jk,
  __importDefault: () => Xk,
  __importStar: () => Jk,
  __makeTemplateObject: () => Kk,
  __metadata: () => Lk,
  __param: () => Uk,
  __propKey: () => vse,
  __read: () => RC,
  __rest: () => Mk,
  __runInitializers: () => bse,
  __setFunctionName: () => Cse,
  __spread: () => $k,
  __spreadArray: () => Hk,
  __spreadArrays: () => zk,
  __values: () => Zm,
  default: () => xse,
})
function kk(e, t) {
  if (typeof t != 'function' && t !== null)
    throw new TypeError(
      'Class extends value ' + String(t) + ' is not a constructor or null',
    )
  PC(e, t)
  function n() {
    this.constructor = e
  }
  e.prototype =
    t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
}
function Mk(e, t) {
  var n = {}
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++)
      t.indexOf(r[s]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[s]) &&
        (n[r[s]] = e[r[s]])
  return n
}
function Fk(e, t, n, r) {
  var s = arguments.length,
    o =
      s < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
    i
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    o = Reflect.decorate(e, t, n, r)
  else
    for (var c = e.length - 1; c >= 0; c--)
      (i = e[c]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o)
  return s > 3 && o && Object.defineProperty(t, n, o), o
}
function Uk(e, t) {
  return function (n, r) {
    t(n, r, e)
  }
}
function Sse(e, t, n, r, s, o) {
  function i(P) {
    if (P !== void 0 && typeof P != 'function')
      throw new TypeError('Function expected')
    return P
  }
  for (
    var c = r.kind,
      a = c === 'getter' ? 'get' : c === 'setter' ? 'set' : 'value',
      u = !t && e ? (r.static ? e : e.prototype) : null,
      d = t || (u ? Object.getOwnPropertyDescriptor(u, r.name) : {}),
      p,
      f = !1,
      _ = n.length - 1;
    _ >= 0;
    _--
  ) {
    var h = {}
    for (var g in r) h[g] = g === 'access' ? {} : r[g]
    for (var g in r.access) h.access[g] = r.access[g]
    h.addInitializer = function (P) {
      if (f)
        throw new TypeError(
          'Cannot add initializers after decoration has completed',
        )
      o.push(i(P || null))
    }
    var E = (0, n[_])(c === 'accessor' ? { get: d.get, set: d.set } : d[a], h)
    if (c === 'accessor') {
      if (E === void 0) continue
      if (E === null || typeof E != 'object')
        throw new TypeError('Object expected')
      ;(p = i(E.get)) && (d.get = p),
        (p = i(E.set)) && (d.set = p),
        (p = i(E.init)) && s.unshift(p)
    } else (p = i(E)) && (c === 'field' ? s.unshift(p) : (d[a] = p))
  }
  u && Object.defineProperty(u, r.name, d), (f = !0)
}
function bse(e, t, n) {
  for (var r = arguments.length > 2, s = 0; s < t.length; s++)
    n = r ? t[s].call(e, n) : t[s].call(e)
  return r ? n : void 0
}
function vse(e) {
  return typeof e == 'symbol' ? e : ''.concat(e)
}
function Cse(e, t, n) {
  return (
    typeof t == 'symbol' &&
      (t = t.description ? '['.concat(t.description, ']') : ''),
    Object.defineProperty(e, 'name', {
      configurable: !0,
      value: n ? ''.concat(n, ' ', t) : t,
    })
  )
}
function Lk(e, t) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(e, t)
}
function Bk(e, t, n, r) {
  function s(o) {
    return o instanceof n
      ? o
      : new n(function (i) {
          i(o)
        })
  }
  return new (n || (n = Promise))(function (o, i) {
    function c(d) {
      try {
        u(r.next(d))
      } catch (p) {
        i(p)
      }
    }
    function a(d) {
      try {
        u(r.throw(d))
      } catch (p) {
        i(p)
      }
    }
    function u(d) {
      d.done ? o(d.value) : s(d.value).then(c, a)
    }
    u((r = r.apply(e, t || [])).next())
  })
}
function jk(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1]
        return o[1]
      },
      trys: [],
      ops: [],
    },
    r,
    s,
    o,
    i
  return (
    (i = { next: c(0), throw: c(1), return: c(2) }),
    typeof Symbol == 'function' &&
      (i[Symbol.iterator] = function () {
        return this
      }),
    i
  )
  function c(u) {
    return function (d) {
      return a([u, d])
    }
  }
  function a(u) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; i && ((i = 0), u[0] && (n = 0)), n; )
      try {
        if (
          ((r = 1),
          s &&
            (o =
              u[0] & 2
                ? s.return
                : u[0]
                ? s.throw || ((o = s.return) && o.call(s), 0)
                : s.next) &&
            !(o = o.call(s, u[1])).done)
        )
          return o
        switch (((s = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
          case 0:
          case 1:
            o = u
            break
          case 4:
            return n.label++, { value: u[1], done: !1 }
          case 5:
            n.label++, (s = u[1]), (u = [0])
            continue
          case 7:
            ;(u = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((o = n.trys),
              !(o = o.length > 0 && o[o.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              n = 0
              continue
            }
            if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
              n.label = u[1]
              break
            }
            if (u[0] === 6 && n.label < o[1]) {
              ;(n.label = o[1]), (o = u)
              break
            }
            if (o && n.label < o[2]) {
              ;(n.label = o[2]), n.ops.push(u)
              break
            }
            o[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        u = t.call(e, n)
      } catch (d) {
        ;(u = [6, d]), (s = 0)
      } finally {
        r = o = 0
      }
    if (u[0] & 5) throw u[1]
    return { value: u[0] ? u[1] : void 0, done: !0 }
  }
}
function Gk(e, t) {
  for (var n in e)
    n !== 'default' &&
      !Object.prototype.hasOwnProperty.call(t, n) &&
      ep(t, e, n)
}
function Zm(e) {
  var t = typeof Symbol == 'function' && Symbol.iterator,
    n = t && e[t],
    r = 0
  if (n) return n.call(e)
  if (e && typeof e.length == 'number')
    return {
      next: function () {
        return (
          e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
        )
      },
    }
  throw new TypeError(
    t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
  )
}
function RC(e, t) {
  var n = typeof Symbol == 'function' && e[Symbol.iterator]
  if (!n) return e
  var r = n.call(e),
    s,
    o = [],
    i
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; ) o.push(s.value)
  } catch (c) {
    i = { error: c }
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r)
    } finally {
      if (i) throw i.error
    }
  }
  return o
}
function $k() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(RC(arguments[t]))
  return e
}
function zk() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++)
    e += arguments[t].length
  for (var r = Array(e), s = 0, t = 0; t < n; t++)
    for (var o = arguments[t], i = 0, c = o.length; i < c; i++, s++) r[s] = o[i]
  return r
}
function Hk(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = t.length, o; r < s; r++)
      (o || !(r in t)) &&
        (o || (o = Array.prototype.slice.call(t, 0, r)), (o[r] = t[r]))
  return e.concat(o || Array.prototype.slice.call(t))
}
function hi(e) {
  return this instanceof hi ? ((this.v = e), this) : new hi(e)
}
function Wk(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var r = n.apply(e, t || []),
    s,
    o = []
  return (
    (s = {}),
    i('next'),
    i('throw'),
    i('return'),
    (s[Symbol.asyncIterator] = function () {
      return this
    }),
    s
  )
  function i(f) {
    r[f] &&
      (s[f] = function (_) {
        return new Promise(function (h, g) {
          o.push([f, _, h, g]) > 1 || c(f, _)
        })
      })
  }
  function c(f, _) {
    try {
      a(r[f](_))
    } catch (h) {
      p(o[0][3], h)
    }
  }
  function a(f) {
    f.value instanceof hi
      ? Promise.resolve(f.value.v).then(u, d)
      : p(o[0][2], f)
  }
  function u(f) {
    c('next', f)
  }
  function d(f) {
    c('throw', f)
  }
  function p(f, _) {
    f(_), o.shift(), o.length && c(o[0][0], o[0][1])
  }
}
function Vk(e) {
  var t, n
  return (
    (t = {}),
    r('next'),
    r('throw', function (s) {
      throw s
    }),
    r('return'),
    (t[Symbol.iterator] = function () {
      return this
    }),
    t
  )
  function r(s, o) {
    t[s] = e[s]
      ? function (i) {
          return (n = !n) ? { value: hi(e[s](i)), done: !1 } : o ? o(i) : i
        }
      : o
  }
}
function Yk(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var t = e[Symbol.asyncIterator],
    n
  return t
    ? t.call(e)
    : ((e = typeof Zm == 'function' ? Zm(e) : e[Symbol.iterator]()),
      (n = {}),
      r('next'),
      r('throw'),
      r('return'),
      (n[Symbol.asyncIterator] = function () {
        return this
      }),
      n)
  function r(o) {
    n[o] =
      e[o] &&
      function (i) {
        return new Promise(function (c, a) {
          ;(i = e[o](i)), s(c, a, i.done, i.value)
        })
      }
  }
  function s(o, i, c, a) {
    Promise.resolve(a).then(function (u) {
      o({ value: u, done: c })
    }, i)
  }
}
function Kk(e, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(e, 'raw', { value: t })
      : (e.raw = t),
    e
  )
}
function Jk(e) {
  if (e && e.__esModule) return e
  var t = {}
  if (e != null)
    for (var n in e)
      n !== 'default' &&
        Object.prototype.hasOwnProperty.call(e, n) &&
        ep(t, e, n)
  return wse(t, e), t
}
function Xk(e) {
  return e && e.__esModule ? e : { default: e }
}
function Qk(e, t, n, r) {
  if (n === 'a' && !r)
    throw new TypeError('Private accessor was defined without a getter')
  if (typeof t == 'function' ? e !== t || !r : !t.has(e))
    throw new TypeError(
      'Cannot read private member from an object whose class did not declare it',
    )
  return n === 'm' ? r : n === 'a' ? r.call(e) : r ? r.value : t.get(e)
}
function Zk(e, t, n, r, s) {
  if (r === 'm') throw new TypeError('Private method is not writable')
  if (r === 'a' && !s)
    throw new TypeError('Private accessor was defined without a setter')
  if (typeof t == 'function' ? e !== t || !s : !t.has(e))
    throw new TypeError(
      'Cannot write private member to an object whose class did not declare it',
    )
  return r === 'a' ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n
}
function e1(e, t) {
  if (t === null || (typeof t != 'object' && typeof t != 'function'))
    throw new TypeError("Cannot use 'in' operator on non-object")
  return typeof e == 'function' ? t === e : e.has(t)
}
function t1(e, t, n) {
  if (t != null) {
    if (typeof t != 'object' && typeof t != 'function')
      throw new TypeError('Object expected.')
    var r
    if (n) {
      if (!Symbol.asyncDispose)
        throw new TypeError('Symbol.asyncDispose is not defined.')
      r = t[Symbol.asyncDispose]
    }
    if (r === void 0) {
      if (!Symbol.dispose) throw new TypeError('Symbol.dispose is not defined.')
      r = t[Symbol.dispose]
    }
    if (typeof r != 'function') throw new TypeError('Object not disposable.')
    e.stack.push({ value: t, dispose: r, async: n })
  } else n && e.stack.push({ async: !0 })
  return t
}
function n1(e) {
  function t(r) {
    ;(e.error = e.hasError
      ? new Tse(r, e.error, 'An error was suppressed during disposal.')
      : r),
      (e.hasError = !0)
  }
  function n() {
    for (; e.stack.length; ) {
      var r = e.stack.pop()
      try {
        var s = r.dispose && r.dispose.call(r.value)
        if (r.async)
          return Promise.resolve(s).then(n, function (o) {
            return t(o), n()
          })
      } catch (o) {
        t(o)
      }
    }
    if (e.hasError) throw e.error
  }
  return n()
}
var PC,
  Qm,
  ep,
  wse,
  Tse,
  xse,
  x = ce(() => {
    PC = function (e, t) {
      return (
        (PC =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (n, r) {
              n.__proto__ = r
            }) ||
          function (n, r) {
            for (var s in r)
              Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s])
          }),
        PC(e, t)
      )
    }
    Qm = function () {
      return (
        (Qm =
          Object.assign ||
          function (t) {
            for (var n, r = 1, s = arguments.length; r < s; r++) {
              n = arguments[r]
              for (var o in n)
                Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o])
            }
            return t
          }),
        Qm.apply(this, arguments)
      )
    }
    ep = Object.create
      ? function (e, t, n, r) {
          r === void 0 && (r = n)
          var s = Object.getOwnPropertyDescriptor(t, n)
          ;(!s ||
            ('get' in s ? !t.__esModule : s.writable || s.configurable)) &&
            (s = {
              enumerable: !0,
              get: function () {
                return t[n]
              },
            }),
            Object.defineProperty(e, r, s)
        }
      : function (e, t, n, r) {
          r === void 0 && (r = n), (e[r] = t[n])
        }
    wse = Object.create
      ? function (e, t) {
          Object.defineProperty(e, 'default', { enumerable: !0, value: t })
        }
      : function (e, t) {
          e.default = t
        }
    Tse =
      typeof SuppressedError == 'function'
        ? SuppressedError
        : function (e, t, n) {
            var r = new Error(n)
            return (
              (r.name = 'SuppressedError'), (r.error = e), (r.suppressed = t), r
            )
          }
    xse = {
      __extends: kk,
      __assign: Qm,
      __rest: Mk,
      __decorate: Fk,
      __param: Uk,
      __metadata: Lk,
      __awaiter: Bk,
      __generator: jk,
      __createBinding: ep,
      __exportStar: Gk,
      __values: Zm,
      __read: RC,
      __spread: $k,
      __spreadArrays: zk,
      __spreadArray: Hk,
      __await: hi,
      __asyncGenerator: Wk,
      __asyncDelegator: Vk,
      __asyncValues: Yk,
      __makeTemplateObject: Kk,
      __importStar: Jk,
      __importDefault: Xk,
      __classPrivateFieldGet: Qk,
      __classPrivateFieldSet: Zk,
      __classPrivateFieldIn: e1,
      __addDisposableResource: t1,
      __disposeResources: n1,
    }
  })
var o1 = l((tp) => {
  'use strict'
  Object.defineProperty(tp, '__esModule', { value: !0 })
  tp.NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = void 0
  var r1 = ['AWS_ENABLE_ENDPOINT_DISCOVERY', 'AWS_ENDPOINT_DISCOVERY_ENABLED'],
    DC = 'endpoint_discovery_enabled',
    s1 = (e) => ['false', '0'].indexOf(e) >= 0
  tp.NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => {
      for (let t = 0; t < r1.length; t++) {
        let n = r1[t]
        if (n in e) {
          let r = e[n]
          if (r === '')
            throw Error(
              `Environment variable ${n} can't be empty of undefined, got "${r}"`,
            )
          return !s1(r)
        }
      }
    },
    configFileSelector: (e) => {
      if (DC in e) {
        let t = e[DC]
        if (t === void 0)
          throw Error(
            `Shared config entry ${DC} can't be undefined, got "${t}"`,
          )
        return !s1(t)
      }
    },
    default: void 0,
  }
})
var a1 = l((i1) => {
  'use strict'
  Object.defineProperty(i1, '__esModule', { value: !0 })
})
var c1 = l((Bd) => {
  'use strict'
  Object.defineProperty(Bd, '__esModule', { value: !0 })
  Bd.HttpAuthLocation = void 0
  var Ise
  ;(function (e) {
    ;(e.HEADER = 'header'), (e.QUERY = 'query')
  })((Ise = Bd.HttpAuthLocation || (Bd.HttpAuthLocation = {})))
})
var u1 = l((d1) => {
  'use strict'
  Object.defineProperty(d1, '__esModule', { value: !0 })
})
var m1 = l((l1) => {
  'use strict'
  Object.defineProperty(l1, '__esModule', { value: !0 })
})
var f1 = l((p1) => {
  'use strict'
  Object.defineProperty(p1, '__esModule', { value: !0 })
})
var h1 = l((_1) => {
  'use strict'
  Object.defineProperty(_1, '__esModule', { value: !0 })
})
var g1 = l((y1) => {
  'use strict'
  Object.defineProperty(y1, '__esModule', { value: !0 })
})
var S1 = l((E1) => {
  'use strict'
  Object.defineProperty(E1, '__esModule', { value: !0 })
})
var v1 = l((b1) => {
  'use strict'
  Object.defineProperty(b1, '__esModule', { value: !0 })
})
var C1 = l((jd) => {
  'use strict'
  Object.defineProperty(jd, '__esModule', { value: !0 })
  var AC = (x(), w(T))
  AC.__exportStar(g1(), jd)
  AC.__exportStar(S1(), jd)
  AC.__exportStar(v1(), jd)
})
var T1 = l((w1) => {
  'use strict'
  Object.defineProperty(w1, '__esModule', { value: !0 })
})
var I1 = l((x1) => {
  'use strict'
  Object.defineProperty(x1, '__esModule', { value: !0 })
})
var P1 = l((Gd) => {
  'use strict'
  Object.defineProperty(Gd, '__esModule', { value: !0 })
  Gd.EndpointURLScheme = void 0
  var Pse
  ;(function (e) {
    ;(e.HTTP = 'http'), (e.HTTPS = 'https')
  })((Pse = Gd.EndpointURLScheme || (Gd.EndpointURLScheme = {})))
})
var D1 = l((R1) => {
  'use strict'
  Object.defineProperty(R1, '__esModule', { value: !0 })
})
var O1 = l((A1) => {
  'use strict'
  Object.defineProperty(A1, '__esModule', { value: !0 })
})
var q1 = l((N1) => {
  'use strict'
  Object.defineProperty(N1, '__esModule', { value: !0 })
})
var M1 = l((k1) => {
  'use strict'
  Object.defineProperty(k1, '__esModule', { value: !0 })
})
var U1 = l((F1) => {
  'use strict'
  Object.defineProperty(F1, '__esModule', { value: !0 })
})
var L1 = l((lo) => {
  'use strict'
  Object.defineProperty(lo, '__esModule', { value: !0 })
  var $d = (x(), w(T))
  $d.__exportStar(D1(), lo)
  $d.__exportStar(O1(), lo)
  $d.__exportStar(q1(), lo)
  $d.__exportStar(M1(), lo)
  $d.__exportStar(U1(), lo)
})
var j1 = l((B1) => {
  'use strict'
  Object.defineProperty(B1, '__esModule', { value: !0 })
})
var G1 = l((ur) => {
  'use strict'
  Object.defineProperty(ur, '__esModule', { value: !0 })
  ur.resolveChecksumRuntimeConfig =
    ur.getChecksumConfiguration =
    ur.AlgorithmId =
      void 0
  var OC
  ;(function (e) {
    ;(e.MD5 = 'md5'),
      (e.CRC32 = 'crc32'),
      (e.CRC32C = 'crc32c'),
      (e.SHA1 = 'sha1'),
      (e.SHA256 = 'sha256')
  })((OC = ur.AlgorithmId || (ur.AlgorithmId = {})))
  var Rse = (e) => {
    let t = []
    return (
      e.sha256 !== void 0 &&
        t.push({
          algorithmId: () => OC.SHA256,
          checksumConstructor: () => e.sha256,
        }),
      e.md5 != null &&
        t.push({ algorithmId: () => OC.MD5, checksumConstructor: () => e.md5 }),
      {
        _checksumAlgorithms: t,
        addChecksumAlgorithm(n) {
          this._checksumAlgorithms.push(n)
        },
        checksumAlgorithms() {
          return this._checksumAlgorithms
        },
      }
    )
  }
  ur.getChecksumConfiguration = Rse
  var Dse = (e) => {
    let t = {}
    return (
      e.checksumAlgorithms().forEach((n) => {
        t[n.algorithmId()] = n.checksumConstructor()
      }),
      t
    )
  }
  ur.resolveChecksumRuntimeConfig = Dse
})
var z1 = l((yi) => {
  'use strict'
  Object.defineProperty(yi, '__esModule', { value: !0 })
  yi.resolveDefaultRuntimeConfig = yi.getDefaultClientConfiguration = void 0
  var $1 = G1(),
    Ase = (e) => ({ ...(0, $1.getChecksumConfiguration)(e) })
  yi.getDefaultClientConfiguration = Ase
  var Ose = (e) => ({ ...(0, $1.resolveChecksumRuntimeConfig)(e) })
  yi.resolveDefaultRuntimeConfig = Ose
})
var H1 = l((NC) => {
  'use strict'
  Object.defineProperty(NC, '__esModule', { value: !0 })
  var Nse = (x(), w(T))
  Nse.__exportStar(z1(), NC)
})
var W1 = l((zd) => {
  'use strict'
  Object.defineProperty(zd, '__esModule', { value: !0 })
  zd.FieldPosition = void 0
  var qse
  ;(function (e) {
    ;(e[(e.HEADER = 0)] = 'HEADER'), (e[(e.TRAILER = 1)] = 'TRAILER')
  })((qse = zd.FieldPosition || (zd.FieldPosition = {})))
})
var Y1 = l((V1) => {
  'use strict'
  Object.defineProperty(V1, '__esModule', { value: !0 })
})
var J1 = l((K1) => {
  'use strict'
  Object.defineProperty(K1, '__esModule', { value: !0 })
})
var Q1 = l((np) => {
  'use strict'
  Object.defineProperty(np, '__esModule', { value: !0 })
  var X1 = (x(), w(T))
  X1.__exportStar(Y1(), np)
  X1.__exportStar(J1(), np)
})
var eM = l((Z1) => {
  'use strict'
  Object.defineProperty(Z1, '__esModule', { value: !0 })
})
var nM = l((tM) => {
  'use strict'
  Object.defineProperty(tM, '__esModule', { value: !0 })
})
var sM = l((rM) => {
  'use strict'
  Object.defineProperty(rM, '__esModule', { value: !0 })
})
var iM = l((oM) => {
  'use strict'
  Object.defineProperty(oM, '__esModule', { value: !0 })
})
var cM = l((aM) => {
  'use strict'
  Object.defineProperty(aM, '__esModule', { value: !0 })
})
var uM = l((dM) => {
  'use strict'
  Object.defineProperty(dM, '__esModule', { value: !0 })
})
var mM = l((lM) => {
  'use strict'
  Object.defineProperty(lM, '__esModule', { value: !0 })
})
var fM = l((pM) => {
  'use strict'
  Object.defineProperty(pM, '__esModule', { value: !0 })
})
var hM = l((_M) => {
  'use strict'
  Object.defineProperty(_M, '__esModule', { value: !0 })
})
var gM = l((yM) => {
  'use strict'
  Object.defineProperty(yM, '__esModule', { value: !0 })
})
var SM = l((EM) => {
  'use strict'
  Object.defineProperty(EM, '__esModule', { value: !0 })
})
var vM = l((bM) => {
  'use strict'
  Object.defineProperty(bM, '__esModule', { value: !0 })
})
var wM = l((CM) => {
  'use strict'
  Object.defineProperty(CM, '__esModule', { value: !0 })
})
var TM = l((Hd) => {
  'use strict'
  Object.defineProperty(Hd, '__esModule', { value: !0 })
  Hd.RequestHandlerProtocol = void 0
  var kse
  ;(function (e) {
    ;(e.HTTP_0_9 = 'http/0.9'),
      (e.HTTP_1_0 = 'http/1.0'),
      (e.TDS_8_0 = 'tds/8.0')
  })((kse = Hd.RequestHandlerProtocol || (Hd.RequestHandlerProtocol = {})))
})
var IM = l((xM) => {
  'use strict'
  Object.defineProperty(xM, '__esModule', { value: !0 })
})
var RM = l((PM) => {
  'use strict'
  Object.defineProperty(PM, '__esModule', { value: !0 })
})
var AM = l((DM) => {
  'use strict'
  Object.defineProperty(DM, '__esModule', { value: !0 })
})
var NM = l((OM) => {
  'use strict'
  Object.defineProperty(OM, '__esModule', { value: !0 })
})
var kM = l((qM) => {
  'use strict'
  Object.defineProperty(qM, '__esModule', { value: !0 })
})
var Vr = l((ne) => {
  'use strict'
  Object.defineProperty(ne, '__esModule', { value: !0 })
  var re = (x(), w(T))
  re.__exportStar(a1(), ne)
  re.__exportStar(c1(), ne)
  re.__exportStar(u1(), ne)
  re.__exportStar(m1(), ne)
  re.__exportStar(f1(), ne)
  re.__exportStar(h1(), ne)
  re.__exportStar(C1(), ne)
  re.__exportStar(T1(), ne)
  re.__exportStar(I1(), ne)
  re.__exportStar(P1(), ne)
  re.__exportStar(L1(), ne)
  re.__exportStar(j1(), ne)
  re.__exportStar(H1(), ne)
  re.__exportStar(W1(), ne)
  re.__exportStar(Q1(), ne)
  re.__exportStar(eM(), ne)
  re.__exportStar(nM(), ne)
  re.__exportStar(sM(), ne)
  re.__exportStar(iM(), ne)
  re.__exportStar(cM(), ne)
  re.__exportStar(uM(), ne)
  re.__exportStar(mM(), ne)
  re.__exportStar(fM(), ne)
  re.__exportStar(hM(), ne)
  re.__exportStar(gM(), ne)
  re.__exportStar(SM(), ne)
  re.__exportStar(vM(), ne)
  re.__exportStar(wM(), ne)
  re.__exportStar(TM(), ne)
  re.__exportStar(IM(), ne)
  re.__exportStar(RM(), ne)
  re.__exportStar(AM(), ne)
  re.__exportStar(NM(), ne)
  re.__exportStar(kM(), ne)
})
var MM = l((rp) => {
  'use strict'
  Object.defineProperty(rp, '__esModule', { value: !0 })
  rp.Field = void 0
  var Mse = Vr(),
    qC = class {
      constructor({
        name: t,
        kind: n = Mse.FieldPosition.HEADER,
        values: r = [],
      }) {
        ;(this.name = t), (this.kind = n), (this.values = r)
      }
      add(t) {
        this.values.push(t)
      }
      set(t) {
        this.values = t
      }
      remove(t) {
        this.values = this.values.filter((n) => n !== t)
      }
      toString() {
        return this.values
          .map((t) => (t.includes(',') || t.includes(' ') ? `"${t}"` : t))
          .join(', ')
      }
      get() {
        return this.values
      }
    }
  rp.Field = qC
})
var FM = l((sp) => {
  'use strict'
  Object.defineProperty(sp, '__esModule', { value: !0 })
  sp.Fields = void 0
  var kC = class {
    constructor({ fields: t = [], encoding: n = 'utf-8' }) {
      ;(this.entries = {}),
        t.forEach(this.setField.bind(this)),
        (this.encoding = n)
    }
    setField(t) {
      this.entries[t.name.toLowerCase()] = t
    }
    getField(t) {
      return this.entries[t.toLowerCase()]
    }
    removeField(t) {
      delete this.entries[t.toLowerCase()]
    }
    getByType(t) {
      return Object.values(this.entries).filter((n) => n.kind === t)
    }
  }
  sp.Fields = kC
})
var LM = l((UM) => {
  'use strict'
  Object.defineProperty(UM, '__esModule', { value: !0 })
})
var BM = l((op) => {
  'use strict'
  Object.defineProperty(op, '__esModule', { value: !0 })
  op.HttpRequest = void 0
  var MC = class e {
    constructor(t) {
      ;(this.method = t.method || 'GET'),
        (this.hostname = t.hostname || 'localhost'),
        (this.port = t.port),
        (this.query = t.query || {}),
        (this.headers = t.headers || {}),
        (this.body = t.body),
        (this.protocol = t.protocol
          ? t.protocol.slice(-1) !== ':'
            ? `${t.protocol}:`
            : t.protocol
          : 'https:'),
        (this.path = t.path
          ? t.path.charAt(0) !== '/'
            ? `/${t.path}`
            : t.path
          : '/'),
        (this.username = t.username),
        (this.password = t.password),
        (this.fragment = t.fragment)
    }
    static isInstance(t) {
      if (!t) return !1
      let n = t
      return (
        'method' in n &&
        'protocol' in n &&
        'hostname' in n &&
        'path' in n &&
        typeof n.query == 'object' &&
        typeof n.headers == 'object'
      )
    }
    clone() {
      let t = new e({ ...this, headers: { ...this.headers } })
      return t.query && (t.query = Fse(t.query)), t
    }
  }
  op.HttpRequest = MC
  function Fse(e) {
    return Object.keys(e).reduce((t, n) => {
      let r = e[n]
      return { ...t, [n]: Array.isArray(r) ? [...r] : r }
    }, {})
  }
})
var jM = l((ip) => {
  'use strict'
  Object.defineProperty(ip, '__esModule', { value: !0 })
  ip.HttpResponse = void 0
  var FC = class {
    constructor(t) {
      ;(this.statusCode = t.statusCode),
        (this.reason = t.reason),
        (this.headers = t.headers || {}),
        (this.body = t.body)
    }
    static isInstance(t) {
      if (!t) return !1
      let n = t
      return typeof n.statusCode == 'number' && typeof n.headers == 'object'
    }
  }
  ip.HttpResponse = FC
})
var GM = l((ap) => {
  'use strict'
  Object.defineProperty(ap, '__esModule', { value: !0 })
  ap.isValidHostname = void 0
  function Use(e) {
    return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(e)
  }
  ap.isValidHostname = Use
})
var zM = l(($M) => {
  'use strict'
  Object.defineProperty($M, '__esModule', { value: !0 })
})
var tt = l((lr) => {
  'use strict'
  Object.defineProperty(lr, '__esModule', { value: !0 })
  var mo = (x(), w(T))
  mo.__exportStar(MM(), lr)
  mo.__exportStar(FM(), lr)
  mo.__exportStar(LM(), lr)
  mo.__exportStar(BM(), lr)
  mo.__exportStar(jM(), lr)
  mo.__exportStar(GM(), lr)
  mo.__exportStar(zM(), lr)
})
var HM = l((cp) => {
  'use strict'
  Object.defineProperty(cp, '__esModule', { value: !0 })
  cp.getCacheKey = void 0
  var Lse = async (e, t, n) => {
    let { accessKeyId: r } = await t.credentials(),
      { identifiers: s } = n
    return JSON.stringify({
      ...(r && { accessKeyId: r }),
      ...(s && {
        commandName: e,
        identifiers: Object.entries(s)
          .sort()
          .reduce((o, [i, c]) => ({ ...o, [i]: c }), {}),
      }),
    })
  }
  cp.getCacheKey = Lse
})
var WM = l((dp) => {
  'use strict'
  Object.defineProperty(dp, '__esModule', { value: !0 })
  dp.updateDiscoveredEndpointInCache = void 0
  var mr = {},
    Bse = async (e, t) =>
      new Promise((n, r) => {
        let { endpointCache: s } = e,
          { cacheKey: o, commandName: i, identifiers: c } = t,
          a = s.get(o)
        if (a && a.length === 1 && a[0].Address === '')
          t.isDiscoveredEndpointRequired
            ? (mr[o] || (mr[o] = []), mr[o].push({ resolve: n, reject: r }))
            : n()
        else if (a && a.length > 0) n()
        else {
          let u = [{ Address: '', CachePeriodInMinutes: 1 }]
          s.set(o, u)
          let d = new t.endpointDiscoveryCommandCtor({
            Operation: i.slice(0, -7),
            Identifiers: c,
          })
          d.resolveMiddleware(
            t.clientStack,
            e,
            t.options,
          )(d)
            .then((f) => {
              s.set(o, f.output.Endpoints),
                mr[o] &&
                  (mr[o].forEach(({ resolve: _ }) => {
                    _()
                  }),
                  delete mr[o]),
                n()
            })
            .catch((f) => {
              s.delete(o)
              let _ = Object.assign(
                new Error(
                  'The operation to discover endpoint failed. Please retry, or provide a custom endpoint and disable endpoint discovery to proceed.',
                ),
                { reason: f },
              )
              mr[o] &&
                (mr[o].forEach(({ reject: h }) => {
                  h(_)
                }),
                delete mr[o]),
                t.isDiscoveredEndpointRequired ? r(_) : (s.set(o, u), n())
            })
        }
      })
  dp.updateDiscoveredEndpointInCache = Bse
})
var YM = l((up) => {
  'use strict'
  Object.defineProperty(up, '__esModule', { value: !0 })
  up.endpointDiscoveryMiddleware = void 0
  var jse = tt(),
    Gse = HM(),
    VM = WM(),
    $se = (e, t) => (n, r) => async (s) => {
      if (e.isCustomEndpoint) {
        if (e.isClientEndpointDiscoveryEnabled)
          throw new Error(
            'Custom endpoint is supplied; endpointDiscoveryEnabled must not be true.',
          )
        return n(s)
      }
      let { endpointDiscoveryCommandCtor: o } = e,
        { isDiscoveredEndpointRequired: i, identifiers: c } = t,
        { clientName: a, commandName: u } = r,
        d = await e.endpointDiscoveryEnabled(),
        p = await (0, Gse.getCacheKey)(u, e, { identifiers: c })
      if (i) {
        if (d === !1)
          throw new Error(
            `Endpoint Discovery is disabled but ${u} on ${a} requires it. Please check your configurations.`,
          )
        await (0, VM.updateDiscoveredEndpointInCache)(e, {
          ...t,
          commandName: u,
          cacheKey: p,
          endpointDiscoveryCommandCtor: o,
        })
      } else
        d &&
          (0, VM.updateDiscoveredEndpointInCache)(e, {
            ...t,
            commandName: u,
            cacheKey: p,
            endpointDiscoveryCommandCtor: o,
          })
      let { request: f } = s
      if (p && jse.HttpRequest.isInstance(f)) {
        let _ = e.endpointCache.getEndpoint(p)
        _ && (f.hostname = _)
      }
      return n(s)
    }
  up.endpointDiscoveryMiddleware = $se
})
var KM = l((It) => {
  'use strict'
  Object.defineProperty(It, '__esModule', { value: !0 })
  It.getEndpointDiscoveryOptionalPlugin =
    It.getEndpointDiscoveryRequiredPlugin =
    It.getEndpointDiscoveryPlugin =
    It.endpointDiscoveryMiddlewareOptions =
      void 0
  var UC = YM()
  It.endpointDiscoveryMiddlewareOptions = {
    name: 'endpointDiscoveryMiddleware',
    step: 'build',
    tags: ['ENDPOINT_DISCOVERY'],
    override: !0,
  }
  var zse = (e, t) => ({
    applyToStack: (n) => {
      n.add(
        (0, UC.endpointDiscoveryMiddleware)(e, t),
        It.endpointDiscoveryMiddlewareOptions,
      )
    },
  })
  It.getEndpointDiscoveryPlugin = zse
  var Hse = (e, t) => ({
    applyToStack: (n) => {
      n.add(
        (0, UC.endpointDiscoveryMiddleware)(e, {
          ...t,
          isDiscoveredEndpointRequired: !0,
        }),
        It.endpointDiscoveryMiddlewareOptions,
      )
    },
  })
  It.getEndpointDiscoveryRequiredPlugin = Hse
  var Wse = (e, t) => ({
    applyToStack: (n) => {
      n.add(
        (0, UC.endpointDiscoveryMiddleware)(e, {
          ...t,
          isDiscoveredEndpointRequired: !1,
        }),
        It.endpointDiscoveryMiddlewareOptions,
      )
    },
  })
  It.getEndpointDiscoveryOptionalPlugin = Wse
})
var XM = l((JM) => {
  'use strict'
  Object.defineProperty(JM, '__esModule', { value: !0 })
})
var ZM = l((AUe, QM) => {
  function pr(e) {
    Object.defineProperty(this, '_next', {
      writable: !1,
      enumerable: !1,
      value: e,
    }),
      (this.done = !1)
  }
  pr.prototype.next = function () {
    if (this.done) return { done: !0 }
    var e = this._next()
    return e.done && (this.done = !0), e
  }
  typeof Symbol < 'u' &&
    (pr.prototype[Symbol.iterator] = function () {
      return this
    })
  pr.of = function () {
    var e = arguments,
      t = e.length,
      n = 0
    return new pr(function () {
      return n >= t ? { done: !0 } : { done: !1, value: e[n++] }
    })
  }
  pr.empty = function () {
    var e = new pr(null)
    return (e.done = !0), e
  }
  pr.is = function (e) {
    return e instanceof pr
      ? !0
      : typeof e == 'object' && e !== null && typeof e.next == 'function'
  }
  QM.exports = pr
})
var LC = l((OUe, rF) => {
  var eF = typeof ArrayBuffer < 'u',
    tF = typeof Symbol < 'u'
  function nF(e, t) {
    var n, r, s, o, i
    if (!e) throw new Error('obliterator/forEach: invalid iterable.')
    if (typeof t != 'function')
      throw new Error('obliterator/forEach: expecting a callback.')
    if (
      Array.isArray(e) ||
      (eF && ArrayBuffer.isView(e)) ||
      typeof e == 'string' ||
      e.toString() === '[object Arguments]'
    ) {
      for (s = 0, o = e.length; s < o; s++) t(e[s], s)
      return
    }
    if (typeof e.forEach == 'function') {
      e.forEach(t)
      return
    }
    if (
      (tF &&
        Symbol.iterator in e &&
        typeof e.next != 'function' &&
        (e = e[Symbol.iterator]()),
      typeof e.next == 'function')
    ) {
      for (n = e, s = 0; (i = n.next()), i.done !== !0; ) t(i.value, s), s++
      return
    }
    for (r in e) e.hasOwnProperty(r) && t(e[r], r)
  }
  nF.forEachWithNullKeys = function (e, t) {
    var n, r, s, o, i
    if (!e)
      throw new Error('obliterator/forEachWithNullKeys: invalid iterable.')
    if (typeof t != 'function')
      throw new Error('obliterator/forEachWithNullKeys: expecting a callback.')
    if (
      Array.isArray(e) ||
      (eF && ArrayBuffer.isView(e)) ||
      typeof e == 'string' ||
      e.toString() === '[object Arguments]'
    ) {
      for (s = 0, o = e.length; s < o; s++) t(e[s], null)
      return
    }
    if (e instanceof Set) {
      e.forEach(function (c) {
        t(c, null)
      })
      return
    }
    if (typeof e.forEach == 'function') {
      e.forEach(t)
      return
    }
    if (
      (tF &&
        Symbol.iterator in e &&
        typeof e.next != 'function' &&
        (e = e[Symbol.iterator]()),
      typeof e.next == 'function')
    ) {
      for (n = e, s = 0; (i = n.next()), i.done !== !0; ) t(i.value, null), s++
      return
    }
    for (r in e) e.hasOwnProperty(r) && t(e[r], r)
  }
  rF.exports = nF
})
var BC = l((Cn) => {
  var Vse = Math.pow(2, 8) - 1,
    Yse = Math.pow(2, 16) - 1,
    Kse = Math.pow(2, 32) - 1,
    Jse = Math.pow(2, 7) - 1,
    Xse = Math.pow(2, 15) - 1,
    Qse = Math.pow(2, 31) - 1
  Cn.getPointerArray = function (e) {
    var t = e - 1
    return t <= Vse
      ? Uint8Array
      : t <= Yse
      ? Uint16Array
      : t <= Kse
      ? Uint32Array
      : Float64Array
  }
  Cn.getSignedPointerArray = function (e) {
    var t = e - 1
    return t <= Jse
      ? Int8Array
      : t <= Xse
      ? Int16Array
      : t <= Qse
      ? Int32Array
      : Float64Array
  }
  Cn.getNumberType = function (e) {
    return e === (e | 0)
      ? Math.sign(e) === -1
        ? e <= 127 && e >= -128
          ? Int8Array
          : e <= 32767 && e >= -32768
          ? Int16Array
          : Int32Array
        : e <= 255
        ? Uint8Array
        : e <= 65535
        ? Uint16Array
        : Uint32Array
      : Float64Array
  }
  var Zse = {
    Uint8Array: 1,
    Int8Array: 2,
    Uint16Array: 3,
    Int16Array: 4,
    Uint32Array: 5,
    Int32Array: 6,
    Float32Array: 7,
    Float64Array: 8,
  }
  Cn.getMinimalRepresentation = function (e, t) {
    var n = null,
      r = 0,
      s,
      o,
      i,
      c,
      a
    for (c = 0, a = e.length; c < a; c++)
      (i = t ? t(e[c]) : e[c]),
        (o = Cn.getNumberType(i)),
        (s = Zse[o.name]),
        s > r && ((r = s), (n = o))
    return n
  }
  Cn.isTypedArray = function (e) {
    return typeof ArrayBuffer < 'u' && ArrayBuffer.isView(e)
  }
  Cn.concat = function () {
    var e = 0,
      t,
      n,
      r
    for (t = 0, r = arguments.length; t < r; t++) e += arguments[t].length
    var s = new arguments[0].constructor(e)
    for (t = 0, n = 0; t < r; t++)
      s.set(arguments[t], n), (n += arguments[t].length)
    return s
  }
  Cn.indices = function (e) {
    for (var t = Cn.getPointerArray(e), n = new t(e), r = 0; r < e; r++)
      n[r] = r
    return n
  }
})
var iF = l((Wd) => {
  var sF = LC(),
    oF = BC()
  function eoe(e) {
    return Array.isArray(e) || oF.isTypedArray(e)
  }
  function jC(e) {
    if (typeof e.length == 'number') return e.length
    if (typeof e.size == 'number') return e.size
  }
  function toe(e) {
    var t = jC(e),
      n = typeof t == 'number' ? new Array(t) : [],
      r = 0
    return (
      sF(e, function (s) {
        n[r++] = s
      }),
      n
    )
  }
  function noe(e) {
    var t = jC(e),
      n = typeof t == 'number' ? oF.getPointerArray(t) : Array,
      r = typeof t == 'number' ? new Array(t) : [],
      s = typeof t == 'number' ? new n(t) : [],
      o = 0
    return (
      sF(e, function (i) {
        ;(r[o] = i), (s[o] = o++)
      }),
      [r, s]
    )
  }
  Wd.isArrayLike = eoe
  Wd.guessLength = jC
  Wd.toArray = toe
  Wd.toArrayWithIndices = noe
})
var cF = l((kUe, aF) => {
  var GC = ZM(),
    roe = LC(),
    soe = BC(),
    ooe = iF()
  function Oe(e, t, n) {
    if (
      (arguments.length < 2 && ((n = e), (e = null), (t = null)),
      (this.capacity = n),
      typeof this.capacity != 'number' || this.capacity <= 0)
    )
      throw new Error(
        'mnemonist/lru-cache: capacity should be positive number.',
      )
    var r = soe.getPointerArray(n)
    ;(this.forward = new r(n)),
      (this.backward = new r(n)),
      (this.K = typeof e == 'function' ? new e(n) : new Array(n)),
      (this.V = typeof t == 'function' ? new t(n) : new Array(n)),
      (this.size = 0),
      (this.head = 0),
      (this.tail = 0),
      (this.items = {})
  }
  Oe.prototype.clear = function () {
    ;(this.size = 0), (this.head = 0), (this.tail = 0), (this.items = {})
  }
  Oe.prototype.splayOnTop = function (e) {
    var t = this.head
    if (this.head === e) return this
    var n = this.backward[e],
      r = this.forward[e]
    return (
      this.tail === e ? (this.tail = n) : (this.backward[r] = n),
      (this.forward[n] = r),
      (this.backward[t] = e),
      (this.head = e),
      (this.forward[e] = t),
      this
    )
  }
  Oe.prototype.set = function (e, t) {
    var n = this.items[e]
    if (typeof n < 'u') {
      this.splayOnTop(n), (this.V[n] = t)
      return
    }
    this.size < this.capacity
      ? (n = this.size++)
      : ((n = this.tail),
        (this.tail = this.backward[n]),
        delete this.items[this.K[n]]),
      (this.items[e] = n),
      (this.K[n] = e),
      (this.V[n] = t),
      (this.forward[n] = this.head),
      (this.backward[this.head] = n),
      (this.head = n)
  }
  Oe.prototype.setpop = function (e, t) {
    var n = null,
      r = null,
      s = this.items[e]
    return typeof s < 'u'
      ? (this.splayOnTop(s),
        (n = this.V[s]),
        (this.V[s] = t),
        { evicted: !1, key: e, value: n })
      : (this.size < this.capacity
          ? (s = this.size++)
          : ((s = this.tail),
            (this.tail = this.backward[s]),
            (n = this.V[s]),
            (r = this.K[s]),
            delete this.items[this.K[s]]),
        (this.items[e] = s),
        (this.K[s] = e),
        (this.V[s] = t),
        (this.forward[s] = this.head),
        (this.backward[this.head] = s),
        (this.head = s),
        r ? { evicted: !0, key: r, value: n } : null)
  }
  Oe.prototype.has = function (e) {
    return e in this.items
  }
  Oe.prototype.get = function (e) {
    var t = this.items[e]
    if (!(typeof t > 'u')) return this.splayOnTop(t), this.V[t]
  }
  Oe.prototype.peek = function (e) {
    var t = this.items[e]
    if (!(typeof t > 'u')) return this.V[t]
  }
  Oe.prototype.forEach = function (e, t) {
    t = arguments.length > 1 ? t : this
    for (
      var n = 0,
        r = this.size,
        s = this.head,
        o = this.K,
        i = this.V,
        c = this.forward;
      n < r;

    )
      e.call(t, i[s], o[s], this), (s = c[s]), n++
  }
  Oe.prototype.keys = function () {
    var e = 0,
      t = this.size,
      n = this.head,
      r = this.K,
      s = this.forward
    return new GC(function () {
      if (e >= t) return { done: !0 }
      var o = r[n]
      return e++, e < t && (n = s[n]), { done: !1, value: o }
    })
  }
  Oe.prototype.values = function () {
    var e = 0,
      t = this.size,
      n = this.head,
      r = this.V,
      s = this.forward
    return new GC(function () {
      if (e >= t) return { done: !0 }
      var o = r[n]
      return e++, e < t && (n = s[n]), { done: !1, value: o }
    })
  }
  Oe.prototype.entries = function () {
    var e = 0,
      t = this.size,
      n = this.head,
      r = this.K,
      s = this.V,
      o = this.forward
    return new GC(function () {
      if (e >= t) return { done: !0 }
      var i = r[n],
        c = s[n]
      return e++, e < t && (n = o[n]), { done: !1, value: [i, c] }
    })
  }
  typeof Symbol < 'u' && (Oe.prototype[Symbol.iterator] = Oe.prototype.entries)
  Oe.prototype.inspect = function () {
    for (var e = new Map(), t = this.entries(), n; (n = t.next()), !n.done; )
      e.set(n.value[0], n.value[1])
    return (
      Object.defineProperty(e, 'constructor', { value: Oe, enumerable: !1 }), e
    )
  }
  typeof Symbol < 'u' &&
    (Oe.prototype[Symbol.for('nodejs.util.inspect.custom')] =
      Oe.prototype.inspect)
  Oe.from = function (e, t, n, r) {
    if (arguments.length < 2) {
      if (((r = ooe.guessLength(e)), typeof r != 'number'))
        throw new Error(
          'mnemonist/lru-cache.from: could not guess iterable length. Please provide desired capacity as last argument.',
        )
    } else arguments.length === 2 && ((r = t), (t = null), (n = null))
    var s = new Oe(t, n, r)
    return (
      roe(e, function (o, i) {
        s.set(i, o)
      }),
      s
    )
  }
  aF.exports = Oe
})
var dF = l((lp) => {
  'use strict'
  Object.defineProperty(lp, '__esModule', { value: !0 })
  lp.EndpointCache = void 0
  var ioe = (x(), w(T)),
    aoe = ioe.__importDefault(cF()),
    $C = class {
      constructor(t) {
        this.cache = new aoe.default(t)
      }
      getEndpoint(t) {
        let n = this.get(t)
        if (!n || n.length === 0) return
        let r = n.map((s) => s.Address)
        return r[Math.floor(Math.random() * r.length)]
      }
      get(t) {
        if (!this.has(t)) return
        let n = this.cache.get(t)
        if (!n) return
        let r = Date.now(),
          s = n.filter((o) => r < o.Expires)
        if (s.length === 0) {
          this.delete(t)
          return
        }
        return s
      }
      set(t, n) {
        let r = Date.now()
        this.cache.set(
          t,
          n.map(({ Address: s, CachePeriodInMinutes: o }) => ({
            Address: s,
            Expires: r + o * 60 * 1e3,
          })),
        )
      }
      delete(t) {
        this.cache.set(t, [])
      }
      has(t) {
        if (!this.cache.has(t)) return !1
        let n = this.cache.peek(t)
        return n ? n.length > 0 : !1
      }
      clear() {
        this.cache.clear()
      }
    }
  lp.EndpointCache = $C
})
var lF = l((mp) => {
  'use strict'
  Object.defineProperty(mp, '__esModule', { value: !0 })
  var uF = (x(), w(T))
  uF.__exportStar(XM(), mp)
  uF.__exportStar(dF(), mp)
})
var mF = l((pp) => {
  'use strict'
  Object.defineProperty(pp, '__esModule', { value: !0 })
  pp.resolveEndpointDiscoveryConfig = void 0
  var coe = lF(),
    doe = (e, { endpointDiscoveryCommandCtor: t }) => {
      var n
      return {
        ...e,
        endpointDiscoveryCommandCtor: t,
        endpointCache: new coe.EndpointCache(
          (n = e.endpointCacheSize) !== null && n !== void 0 ? n : 1e3,
        ),
        endpointDiscoveryEnabled:
          e.endpointDiscoveryEnabled !== void 0
            ? () => Promise.resolve(e.endpointDiscoveryEnabled)
            : e.endpointDiscoveryEnabledProvider,
        isClientEndpointDiscoveryEnabled: e.endpointDiscoveryEnabled !== void 0,
      }
    }
  pp.resolveEndpointDiscoveryConfig = doe
})
var HC = l((Vd) => {
  'use strict'
  Object.defineProperty(Vd, '__esModule', { value: !0 })
  var zC = (x(), w(T))
  zC.__exportStar(o1(), Vd)
  zC.__exportStar(KM(), Vd)
  zC.__exportStar(mF(), Vd)
})
var Yd = l(($t) => {
  'use strict'
  Object.defineProperty($t, '__esModule', { value: !0 })
  $t.getHostHeaderPlugin =
    $t.hostHeaderMiddlewareOptions =
    $t.hostHeaderMiddleware =
    $t.resolveHostHeaderConfig =
      void 0
  var uoe = tt()
  function loe(e) {
    return e
  }
  $t.resolveHostHeaderConfig = loe
  var moe = (e) => (t) => async (n) => {
    if (!uoe.HttpRequest.isInstance(n.request)) return t(n)
    let { request: r } = n,
      { handlerProtocol: s = '' } = e.requestHandler.metadata || {}
    if (s.indexOf('h2') >= 0 && !r.headers[':authority'])
      delete r.headers.host, (r.headers[':authority'] = '')
    else if (!r.headers.host) {
      let o = r.hostname
      r.port != null && (o += `:${r.port}`), (r.headers.host = o)
    }
    return t(n)
  }
  $t.hostHeaderMiddleware = moe
  $t.hostHeaderMiddlewareOptions = {
    name: 'hostHeaderMiddleware',
    step: 'build',
    priority: 'low',
    tags: ['HOST'],
    override: !0,
  }
  var poe = (e) => ({
    applyToStack: (t) => {
      t.add((0, $t.hostHeaderMiddleware)(e), $t.hostHeaderMiddlewareOptions)
    },
  })
  $t.getHostHeaderPlugin = poe
})
var pF = l((wn) => {
  'use strict'
  Object.defineProperty(wn, '__esModule', { value: !0 })
  wn.getLoggerPlugin = wn.loggerMiddlewareOptions = wn.loggerMiddleware = void 0
  var foe = () => (e, t) => async (n) => {
    var r, s
    try {
      let o = await e(n),
        {
          clientName: i,
          commandName: c,
          logger: a,
          dynamoDbDocumentClientOptions: u = {},
        } = t,
        {
          overrideInputFilterSensitiveLog: d,
          overrideOutputFilterSensitiveLog: p,
        } = u,
        f = d ?? t.inputFilterSensitiveLog,
        _ = p ?? t.outputFilterSensitiveLog,
        { $metadata: h, ...g } = o.output
      return (
        (r = a?.info) === null ||
          r === void 0 ||
          r.call(a, {
            clientName: i,
            commandName: c,
            input: f(n.input),
            output: _(g),
            metadata: h,
          }),
        o
      )
    } catch (o) {
      let {
          clientName: i,
          commandName: c,
          logger: a,
          dynamoDbDocumentClientOptions: u = {},
        } = t,
        { overrideInputFilterSensitiveLog: d } = u,
        p = d ?? t.inputFilterSensitiveLog
      throw (
        ((s = a?.error) === null ||
          s === void 0 ||
          s.call(a, {
            clientName: i,
            commandName: c,
            input: p(n.input),
            error: o,
            metadata: o.$metadata,
          }),
        o)
      )
    }
  }
  wn.loggerMiddleware = foe
  wn.loggerMiddlewareOptions = {
    name: 'loggerMiddleware',
    tags: ['LOGGER'],
    step: 'initialize',
    override: !0,
  }
  var _oe = (e) => ({
    applyToStack: (t) => {
      t.add((0, wn.loggerMiddleware)(), wn.loggerMiddlewareOptions)
    },
  })
  wn.getLoggerPlugin = _oe
})
var Kd = l((WC) => {
  'use strict'
  Object.defineProperty(WC, '__esModule', { value: !0 })
  var hoe = (x(), w(T))
  hoe.__exportStar(pF(), WC)
})
var Jd = l((Tn) => {
  'use strict'
  Object.defineProperty(Tn, '__esModule', { value: !0 })
  Tn.getRecursionDetectionPlugin =
    Tn.addRecursionDetectionMiddlewareOptions =
    Tn.recursionDetectionMiddleware =
      void 0
  var yoe = tt(),
    fF = 'X-Amzn-Trace-Id',
    goe = 'AWS_LAMBDA_FUNCTION_NAME',
    Eoe = '_X_AMZN_TRACE_ID',
    Soe = (e) => (t) => async (n) => {
      let { request: r } = n
      if (
        !yoe.HttpRequest.isInstance(r) ||
        e.runtime !== 'node' ||
        r.headers.hasOwnProperty(fF)
      )
        return t(n)
      let s = process.env[goe],
        o = process.env[Eoe],
        i = (c) => typeof c == 'string' && c.length > 0
      return i(s) && i(o) && (r.headers[fF] = o), t({ ...n, request: r })
    }
  Tn.recursionDetectionMiddleware = Soe
  Tn.addRecursionDetectionMiddlewareOptions = {
    step: 'build',
    tags: ['RECURSION_DETECTION'],
    name: 'recursionDetectionMiddleware',
    override: !0,
    priority: 'low',
  }
  var boe = (e) => ({
    applyToStack: (t) => {
      t.add(
        (0, Tn.recursionDetectionMiddleware)(e),
        Tn.addRecursionDetectionMiddlewareOptions,
      )
    },
  })
  Tn.getRecursionDetectionPlugin = boe
})
var Xd = l((fp) => {
  'use strict'
  Object.defineProperty(fp, '__esModule', { value: !0 })
  fp.ProviderError = void 0
  var VC = class e extends Error {
    constructor(t, n = !0) {
      super(t),
        (this.tryNextLink = n),
        (this.name = 'ProviderError'),
        Object.setPrototypeOf(this, e.prototype)
    }
    static from(t, n = !0) {
      return Object.assign(new this(t.message, n), t)
    }
  }
  fp.ProviderError = VC
})
var _F = l((_p) => {
  'use strict'
  Object.defineProperty(_p, '__esModule', { value: !0 })
  _p.CredentialsProviderError = void 0
  var voe = Xd(),
    YC = class e extends voe.ProviderError {
      constructor(t, n = !0) {
        super(t, n),
          (this.tryNextLink = n),
          (this.name = 'CredentialsProviderError'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  _p.CredentialsProviderError = YC
})
var hF = l((hp) => {
  'use strict'
  Object.defineProperty(hp, '__esModule', { value: !0 })
  hp.TokenProviderError = void 0
  var Coe = Xd(),
    KC = class e extends Coe.ProviderError {
      constructor(t, n = !0) {
        super(t, n),
          (this.tryNextLink = n),
          (this.name = 'TokenProviderError'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  hp.TokenProviderError = KC
})
var yF = l((yp) => {
  'use strict'
  Object.defineProperty(yp, '__esModule', { value: !0 })
  yp.chain = void 0
  var woe = Xd()
  function Toe(...e) {
    return () => {
      let t = Promise.reject(new woe.ProviderError('No providers in chain'))
      for (let n of e)
        t = t.catch((r) => {
          if (r?.tryNextLink) return n()
          throw r
        })
      return t
    }
  }
  yp.chain = Toe
})
var gF = l((gp) => {
  'use strict'
  Object.defineProperty(gp, '__esModule', { value: !0 })
  gp.fromStatic = void 0
  var xoe = (e) => () => Promise.resolve(e)
  gp.fromStatic = xoe
})
var EF = l((Ep) => {
  'use strict'
  Object.defineProperty(Ep, '__esModule', { value: !0 })
  Ep.memoize = void 0
  var Ioe = (e, t, n) => {
    let r,
      s,
      o,
      i = !1,
      c = async () => {
        s || (s = e())
        try {
          ;(r = await s), (o = !0), (i = !1)
        } finally {
          s = void 0
        }
        return r
      }
    return t === void 0
      ? async (a) => ((!o || a?.forceRefresh) && (r = await c()), r)
      : async (a) => (
          (!o || a?.forceRefresh) && (r = await c()),
          i ? r : n && !n(r) ? ((i = !0), r) : (t(r) && (await c()), r)
        )
  }
  Ep.memoize = Ioe
})
var Y = l((Yr) => {
  'use strict'
  Object.defineProperty(Yr, '__esModule', { value: !0 })
  var gi = (x(), w(T))
  gi.__exportStar(_F(), Yr)
  gi.__exportStar(Xd(), Yr)
  gi.__exportStar(hF(), Yr)
  gi.__exportStar(yF(), Yr)
  gi.__exportStar(gF(), Yr)
  gi.__exportStar(EF(), Yr)
})
var ZC = {}
Mc(ZC, {
  __assign: () => XC,
  __asyncDelegator: () => Boe,
  __asyncGenerator: () => Loe,
  __asyncValues: () => joe,
  __await: () => Qd,
  __awaiter: () => Noe,
  __classPrivateFieldGet: () => Hoe,
  __classPrivateFieldSet: () => Woe,
  __createBinding: () => koe,
  __decorate: () => Doe,
  __exportStar: () => Moe,
  __extends: () => Poe,
  __generator: () => qoe,
  __importDefault: () => zoe,
  __importStar: () => $oe,
  __makeTemplateObject: () => Goe,
  __metadata: () => Ooe,
  __param: () => Aoe,
  __read: () => SF,
  __rest: () => Roe,
  __spread: () => Foe,
  __spreadArrays: () => Uoe,
  __values: () => QC,
})
function Poe(e, t) {
  JC(e, t)
  function n() {
    this.constructor = e
  }
  e.prototype =
    t === null ? Object.create(t) : ((n.prototype = t.prototype), new n())
}
function Roe(e, t) {
  var n = {}
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r])
  if (e != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var s = 0, r = Object.getOwnPropertySymbols(e); s < r.length; s++)
      t.indexOf(r[s]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[s]) &&
        (n[r[s]] = e[r[s]])
  return n
}
function Doe(e, t, n, r) {
  var s = arguments.length,
    o =
      s < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
    i
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    o = Reflect.decorate(e, t, n, r)
  else
    for (var c = e.length - 1; c >= 0; c--)
      (i = e[c]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o)
  return s > 3 && o && Object.defineProperty(t, n, o), o
}
function Aoe(e, t) {
  return function (n, r) {
    t(n, r, e)
  }
}
function Ooe(e, t) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(e, t)
}
function Noe(e, t, n, r) {
  function s(o) {
    return o instanceof n
      ? o
      : new n(function (i) {
          i(o)
        })
  }
  return new (n || (n = Promise))(function (o, i) {
    function c(d) {
      try {
        u(r.next(d))
      } catch (p) {
        i(p)
      }
    }
    function a(d) {
      try {
        u(r.throw(d))
      } catch (p) {
        i(p)
      }
    }
    function u(d) {
      d.done ? o(d.value) : s(d.value).then(c, a)
    }
    u((r = r.apply(e, t || [])).next())
  })
}
function qoe(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (o[0] & 1) throw o[1]
        return o[1]
      },
      trys: [],
      ops: [],
    },
    r,
    s,
    o,
    i
  return (
    (i = { next: c(0), throw: c(1), return: c(2) }),
    typeof Symbol == 'function' &&
      (i[Symbol.iterator] = function () {
        return this
      }),
    i
  )
  function c(u) {
    return function (d) {
      return a([u, d])
    }
  }
  function a(u) {
    if (r) throw new TypeError('Generator is already executing.')
    for (; n; )
      try {
        if (
          ((r = 1),
          s &&
            (o =
              u[0] & 2
                ? s.return
                : u[0]
                ? s.throw || ((o = s.return) && o.call(s), 0)
                : s.next) &&
            !(o = o.call(s, u[1])).done)
        )
          return o
        switch (((s = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
          case 0:
          case 1:
            o = u
            break
          case 4:
            return n.label++, { value: u[1], done: !1 }
          case 5:
            n.label++, (s = u[1]), (u = [0])
            continue
          case 7:
            ;(u = n.ops.pop()), n.trys.pop()
            continue
          default:
            if (
              ((o = n.trys),
              !(o = o.length > 0 && o[o.length - 1]) &&
                (u[0] === 6 || u[0] === 2))
            ) {
              n = 0
              continue
            }
            if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
              n.label = u[1]
              break
            }
            if (u[0] === 6 && n.label < o[1]) {
              ;(n.label = o[1]), (o = u)
              break
            }
            if (o && n.label < o[2]) {
              ;(n.label = o[2]), n.ops.push(u)
              break
            }
            o[2] && n.ops.pop(), n.trys.pop()
            continue
        }
        u = t.call(e, n)
      } catch (d) {
        ;(u = [6, d]), (s = 0)
      } finally {
        r = o = 0
      }
    if (u[0] & 5) throw u[1]
    return { value: u[0] ? u[1] : void 0, done: !0 }
  }
}
function koe(e, t, n, r) {
  r === void 0 && (r = n), (e[r] = t[n])
}
function Moe(e, t) {
  for (var n in e) n !== 'default' && !t.hasOwnProperty(n) && (t[n] = e[n])
}
function QC(e) {
  var t = typeof Symbol == 'function' && Symbol.iterator,
    n = t && e[t],
    r = 0
  if (n) return n.call(e)
  if (e && typeof e.length == 'number')
    return {
      next: function () {
        return (
          e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
        )
      },
    }
  throw new TypeError(
    t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.',
  )
}
function SF(e, t) {
  var n = typeof Symbol == 'function' && e[Symbol.iterator]
  if (!n) return e
  var r = n.call(e),
    s,
    o = [],
    i
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; ) o.push(s.value)
  } catch (c) {
    i = { error: c }
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r)
    } finally {
      if (i) throw i.error
    }
  }
  return o
}
function Foe() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(SF(arguments[t]))
  return e
}
function Uoe() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++)
    e += arguments[t].length
  for (var r = Array(e), s = 0, t = 0; t < n; t++)
    for (var o = arguments[t], i = 0, c = o.length; i < c; i++, s++) r[s] = o[i]
  return r
}
function Qd(e) {
  return this instanceof Qd ? ((this.v = e), this) : new Qd(e)
}
function Loe(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var r = n.apply(e, t || []),
    s,
    o = []
  return (
    (s = {}),
    i('next'),
    i('throw'),
    i('return'),
    (s[Symbol.asyncIterator] = function () {
      return this
    }),
    s
  )
  function i(f) {
    r[f] &&
      (s[f] = function (_) {
        return new Promise(function (h, g) {
          o.push([f, _, h, g]) > 1 || c(f, _)
        })
      })
  }
  function c(f, _) {
    try {
      a(r[f](_))
    } catch (h) {
      p(o[0][3], h)
    }
  }
  function a(f) {
    f.value instanceof Qd
      ? Promise.resolve(f.value.v).then(u, d)
      : p(o[0][2], f)
  }
  function u(f) {
    c('next', f)
  }
  function d(f) {
    c('throw', f)
  }
  function p(f, _) {
    f(_), o.shift(), o.length && c(o[0][0], o[0][1])
  }
}
function Boe(e) {
  var t, n
  return (
    (t = {}),
    r('next'),
    r('throw', function (s) {
      throw s
    }),
    r('return'),
    (t[Symbol.iterator] = function () {
      return this
    }),
    t
  )
  function r(s, o) {
    t[s] = e[s]
      ? function (i) {
          return (n = !n)
            ? { value: Qd(e[s](i)), done: s === 'return' }
            : o
            ? o(i)
            : i
        }
      : o
  }
}
function joe(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var t = e[Symbol.asyncIterator],
    n
  return t
    ? t.call(e)
    : ((e = typeof QC == 'function' ? QC(e) : e[Symbol.iterator]()),
      (n = {}),
      r('next'),
      r('throw'),
      r('return'),
      (n[Symbol.asyncIterator] = function () {
        return this
      }),
      n)
  function r(o) {
    n[o] =
      e[o] &&
      function (i) {
        return new Promise(function (c, a) {
          ;(i = e[o](i)), s(c, a, i.done, i.value)
        })
      }
  }
  function s(o, i, c, a) {
    Promise.resolve(a).then(function (u) {
      o({ value: u, done: c })
    }, i)
  }
}
function Goe(e, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(e, 'raw', { value: t })
      : (e.raw = t),
    e
  )
}
function $oe(e) {
  if (e && e.__esModule) return e
  var t = {}
  if (e != null)
    for (var n in e) Object.hasOwnProperty.call(e, n) && (t[n] = e[n])
  return (t.default = e), t
}
function zoe(e) {
  return e && e.__esModule ? e : { default: e }
}
function Hoe(e, t) {
  if (!t.has(e))
    throw new TypeError('attempted to get private field on non-instance')
  return t.get(e)
}
function Woe(e, t, n) {
  if (!t.has(e))
    throw new TypeError('attempted to set private field on non-instance')
  return t.set(e, n), n
}
var JC,
  XC,
  e0 = ce(() => {
    JC = function (e, t) {
      return (
        (JC =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (n, r) {
              n.__proto__ = r
            }) ||
          function (n, r) {
            for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s])
          }),
        JC(e, t)
      )
    }
    XC = function () {
      return (
        (XC =
          Object.assign ||
          function (t) {
            for (var n, r = 1, s = arguments.length; r < s; r++) {
              n = arguments[r]
              for (var o in n)
                Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o])
            }
            return t
          }),
        XC.apply(this, arguments)
      )
    }
  })
var bF = l((Ei) => {
  'use strict'
  Object.defineProperty(Ei, '__esModule', { value: !0 })
  Ei.toUtf8 = Ei.fromUtf8 = void 0
  var Voe = (e) => {
    let t = []
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e.charCodeAt(n)
      if (s < 128) t.push(s)
      else if (s < 2048) t.push((s >> 6) | 192, (s & 63) | 128)
      else if (
        n + 1 < e.length &&
        (s & 64512) === 55296 &&
        (e.charCodeAt(n + 1) & 64512) === 56320
      ) {
        let o = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++n) & 1023)
        t.push(
          (o >> 18) | 240,
          ((o >> 12) & 63) | 128,
          ((o >> 6) & 63) | 128,
          (o & 63) | 128,
        )
      } else t.push((s >> 12) | 224, ((s >> 6) & 63) | 128, (s & 63) | 128)
    }
    return Uint8Array.from(t)
  }
  Ei.fromUtf8 = Voe
  var Yoe = (e) => {
    let t = ''
    for (let n = 0, r = e.length; n < r; n++) {
      let s = e[n]
      if (s < 128) t += String.fromCharCode(s)
      else if (192 <= s && s < 224) {
        let o = e[++n]
        t += String.fromCharCode(((s & 31) << 6) | (o & 63))
      } else if (240 <= s && s < 365) {
        let i =
          '%' + [s, e[++n], e[++n], e[++n]].map((c) => c.toString(16)).join('%')
        t += decodeURIComponent(i)
      } else
        t += String.fromCharCode(
          ((s & 15) << 12) | ((e[++n] & 63) << 6) | (e[++n] & 63),
        )
    }
    return t
  }
  Ei.toUtf8 = Yoe
})
var vF = l((Si) => {
  'use strict'
  Object.defineProperty(Si, '__esModule', { value: !0 })
  Si.toUtf8 = Si.fromUtf8 = void 0
  function Koe(e) {
    return new TextEncoder().encode(e)
  }
  Si.fromUtf8 = Koe
  function Joe(e) {
    return new TextDecoder('utf-8').decode(e)
  }
  Si.toUtf8 = Joe
})
var TF = l((bi) => {
  'use strict'
  Object.defineProperty(bi, '__esModule', { value: !0 })
  bi.toUtf8 = bi.fromUtf8 = void 0
  var CF = bF(),
    wF = vF(),
    Xoe = (e) =>
      typeof TextEncoder == 'function'
        ? (0, wF.fromUtf8)(e)
        : (0, CF.fromUtf8)(e)
  bi.fromUtf8 = Xoe
  var Qoe = (e) =>
    typeof TextDecoder == 'function' ? (0, wF.toUtf8)(e) : (0, CF.toUtf8)(e)
  bi.toUtf8 = Qoe
})
var xF = l((Sp) => {
  'use strict'
  Object.defineProperty(Sp, '__esModule', { value: !0 })
  Sp.convertToBuffer = void 0
  var Zoe = TF(),
    eie =
      typeof Buffer < 'u' && Buffer.from
        ? function (e) {
            return Buffer.from(e, 'utf8')
          }
        : Zoe.fromUtf8
  function tie(e) {
    return e instanceof Uint8Array
      ? e
      : typeof e == 'string'
      ? eie(e)
      : ArrayBuffer.isView(e)
      ? new Uint8Array(
          e.buffer,
          e.byteOffset,
          e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
        )
      : new Uint8Array(e)
  }
  Sp.convertToBuffer = tie
})
var IF = l((bp) => {
  'use strict'
  Object.defineProperty(bp, '__esModule', { value: !0 })
  bp.isEmptyData = void 0
  function nie(e) {
    return typeof e == 'string' ? e.length === 0 : e.byteLength === 0
  }
  bp.isEmptyData = nie
})
var PF = l((vp) => {
  'use strict'
  Object.defineProperty(vp, '__esModule', { value: !0 })
  vp.numToUint8 = void 0
  function rie(e) {
    return new Uint8Array([
      (e & 4278190080) >> 24,
      (e & 16711680) >> 16,
      (e & 65280) >> 8,
      e & 255,
    ])
  }
  vp.numToUint8 = rie
})
var RF = l((Cp) => {
  'use strict'
  Object.defineProperty(Cp, '__esModule', { value: !0 })
  Cp.uint32ArrayFrom = void 0
  function sie(e) {
    if (!Uint32Array.from) {
      for (var t = new Uint32Array(e.length), n = 0; n < e.length; )
        (t[n] = e[n]), (n += 1)
      return t
    }
    return Uint32Array.from(e)
  }
  Cp.uint32ArrayFrom = sie
})
var t0 = l((xn) => {
  'use strict'
  Object.defineProperty(xn, '__esModule', { value: !0 })
  xn.uint32ArrayFrom =
    xn.numToUint8 =
    xn.isEmptyData =
    xn.convertToBuffer =
      void 0
  var oie = xF()
  Object.defineProperty(xn, 'convertToBuffer', {
    enumerable: !0,
    get: function () {
      return oie.convertToBuffer
    },
  })
  var iie = IF()
  Object.defineProperty(xn, 'isEmptyData', {
    enumerable: !0,
    get: function () {
      return iie.isEmptyData
    },
  })
  var aie = PF()
  Object.defineProperty(xn, 'numToUint8', {
    enumerable: !0,
    get: function () {
      return aie.numToUint8
    },
  })
  var cie = RF()
  Object.defineProperty(xn, 'uint32ArrayFrom', {
    enumerable: !0,
    get: function () {
      return cie.uint32ArrayFrom
    },
  })
})
var OF = l((wp) => {
  'use strict'
  Object.defineProperty(wp, '__esModule', { value: !0 })
  wp.AwsCrc32 = void 0
  var DF = (e0(), w(ZC)),
    n0 = t0(),
    AF = Tp(),
    die = (function () {
      function e() {
        this.crc32 = new AF.Crc32()
      }
      return (
        (e.prototype.update = function (t) {
          ;(0, n0.isEmptyData)(t) ||
            this.crc32.update((0, n0.convertToBuffer)(t))
        }),
        (e.prototype.digest = function () {
          return DF.__awaiter(this, void 0, void 0, function () {
            return DF.__generator(this, function (t) {
              return [2, (0, n0.numToUint8)(this.crc32.digest())]
            })
          })
        }),
        (e.prototype.reset = function () {
          this.crc32 = new AF.Crc32()
        }),
        e
      )
    })()
  wp.AwsCrc32 = die
})
var Tp = l((Kr) => {
  'use strict'
  Object.defineProperty(Kr, '__esModule', { value: !0 })
  Kr.AwsCrc32 = Kr.Crc32 = Kr.crc32 = void 0
  var uie = (e0(), w(ZC)),
    lie = t0()
  function mie(e) {
    return new NF().update(e).digest()
  }
  Kr.crc32 = mie
  var NF = (function () {
    function e() {
      this.checksum = 4294967295
    }
    return (
      (e.prototype.update = function (t) {
        var n, r
        try {
          for (var s = uie.__values(t), o = s.next(); !o.done; o = s.next()) {
            var i = o.value
            this.checksum =
              (this.checksum >>> 8) ^ fie[(this.checksum ^ i) & 255]
          }
        } catch (c) {
          n = { error: c }
        } finally {
          try {
            o && !o.done && (r = s.return) && r.call(s)
          } finally {
            if (n) throw n.error
          }
        }
        return this
      }),
      (e.prototype.digest = function () {
        return (this.checksum ^ 4294967295) >>> 0
      }),
      e
    )
  })()
  Kr.Crc32 = NF
  var pie = [
      0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685,
      2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995,
      2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648,
      2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990,
      1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755,
      2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145,
      1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206,
      2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980,
      1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705,
      3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527,
      1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772,
      4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
      251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719,
      3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925,
      453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202,
      4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960,
      984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733,
      3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467,
      855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048,
      3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054,
      702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443,
      3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945,
      2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430,
      2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
      2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225,
      1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
      2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732,
      1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850,
      2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135,
      1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109,
      3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954,
      1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920,
      3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877,
      83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603,
      3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992,
      534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
      4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795,
      376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105,
      3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270,
      936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108,
      3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449,
      601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471,
      3272380065, 1510334235, 755167117,
    ],
    fie = (0, lie.uint32ArrayFrom)(pie),
    _ie = OF()
  Object.defineProperty(Kr, 'AwsCrc32', {
    enumerable: !0,
    get: function () {
      return _ie.AwsCrc32
    },
  })
})
var Ci = l((vi) => {
  'use strict'
  Object.defineProperty(vi, '__esModule', { value: !0 })
  vi.toHex = vi.fromHex = void 0
  var qF = {},
    r0 = {}
  for (let e = 0; e < 256; e++) {
    let t = e.toString(16).toLowerCase()
    t.length === 1 && (t = `0${t}`), (qF[e] = t), (r0[t] = e)
  }
  function hie(e) {
    if (e.length % 2 !== 0)
      throw new Error('Hex encoded strings must have an even number length')
    let t = new Uint8Array(e.length / 2)
    for (let n = 0; n < e.length; n += 2) {
      let r = e.slice(n, n + 2).toLowerCase()
      if (r in r0) t[n / 2] = r0[r]
      else
        throw new Error(
          `Cannot decode unrecognized sequence ${r} as hexadecimal`,
        )
    }
    return t
  }
  vi.fromHex = hie
  function yie(e) {
    let t = ''
    for (let n = 0; n < e.byteLength; n++) t += qF[e[n]]
    return t
  }
  vi.toHex = yie
})
var o0 = l((xp) => {
  'use strict'
  Object.defineProperty(xp, '__esModule', { value: !0 })
  xp.Int64 = void 0
  var gie = Ci(),
    s0 = class e {
      constructor(t) {
        if (((this.bytes = t), t.byteLength !== 8))
          throw new Error('Int64 buffers must be exactly 8 bytes')
      }
      static fromNumber(t) {
        if (t > 9223372036854776e3 || t < -9223372036854776e3)
          throw new Error(
            `${t} is too large (or, if negative, too small) to represent as an Int64`,
          )
        let n = new Uint8Array(8)
        for (
          let r = 7, s = Math.abs(Math.round(t));
          r > -1 && s > 0;
          r--, s /= 256
        )
          n[r] = s
        return t < 0 && kF(n), new e(n)
      }
      valueOf() {
        let t = this.bytes.slice(0),
          n = t[0] & 128
        return n && kF(t), parseInt((0, gie.toHex)(t), 16) * (n ? -1 : 1)
      }
      toString() {
        return String(this.valueOf())
      }
    }
  xp.Int64 = s0
  function kF(e) {
    for (let t = 0; t < 8; t++) e[t] ^= 255
    for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--);
  }
})
var c0 = l((Ip) => {
  'use strict'
  Object.defineProperty(Ip, '__esModule', { value: !0 })
  Ip.HeaderMarshaller = void 0
  var wi = Ci(),
    i0 = o0(),
    a0 = class {
      constructor(t, n) {
        ;(this.toUtf8 = t), (this.fromUtf8 = n)
      }
      format(t) {
        let n = []
        for (let o of Object.keys(t)) {
          let i = this.fromUtf8(o)
          n.push(
            Uint8Array.from([i.byteLength]),
            i,
            this.formatHeaderValue(t[o]),
          )
        }
        let r = new Uint8Array(n.reduce((o, i) => o + i.byteLength, 0)),
          s = 0
        for (let o of n) r.set(o, s), (s += o.byteLength)
        return r
      }
      formatHeaderValue(t) {
        switch (t.type) {
          case 'boolean':
            return Uint8Array.from([t.value ? 0 : 1])
          case 'byte':
            return Uint8Array.from([2, t.value])
          case 'short':
            let n = new DataView(new ArrayBuffer(3))
            return (
              n.setUint8(0, 3),
              n.setInt16(1, t.value, !1),
              new Uint8Array(n.buffer)
            )
          case 'integer':
            let r = new DataView(new ArrayBuffer(5))
            return (
              r.setUint8(0, 4),
              r.setInt32(1, t.value, !1),
              new Uint8Array(r.buffer)
            )
          case 'long':
            let s = new Uint8Array(9)
            return (s[0] = 5), s.set(t.value.bytes, 1), s
          case 'binary':
            let o = new DataView(new ArrayBuffer(3 + t.value.byteLength))
            o.setUint8(0, 6), o.setUint16(1, t.value.byteLength, !1)
            let i = new Uint8Array(o.buffer)
            return i.set(t.value, 3), i
          case 'string':
            let c = this.fromUtf8(t.value),
              a = new DataView(new ArrayBuffer(3 + c.byteLength))
            a.setUint8(0, 7), a.setUint16(1, c.byteLength, !1)
            let u = new Uint8Array(a.buffer)
            return u.set(c, 3), u
          case 'timestamp':
            let d = new Uint8Array(9)
            return (
              (d[0] = 8),
              d.set(i0.Int64.fromNumber(t.value.valueOf()).bytes, 1),
              d
            )
          case 'uuid':
            if (!Iie.test(t.value))
              throw new Error(`Invalid UUID received: ${t.value}`)
            let p = new Uint8Array(17)
            return (
              (p[0] = 9),
              p.set((0, wi.fromHex)(t.value.replace(/\-/g, '')), 1),
              p
            )
        }
      }
      parse(t) {
        let n = {},
          r = 0
        for (; r < t.byteLength; ) {
          let s = t.getUint8(r++),
            o = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + r, s))
          switch (((r += s), t.getUint8(r++))) {
            case 0:
              n[o] = { type: FF, value: !0 }
              break
            case 1:
              n[o] = { type: FF, value: !1 }
              break
            case 2:
              n[o] = { type: Eie, value: t.getInt8(r++) }
              break
            case 3:
              ;(n[o] = { type: Sie, value: t.getInt16(r, !1) }), (r += 2)
              break
            case 4:
              ;(n[o] = { type: bie, value: t.getInt32(r, !1) }), (r += 4)
              break
            case 5:
              ;(n[o] = {
                type: vie,
                value: new i0.Int64(
                  new Uint8Array(t.buffer, t.byteOffset + r, 8),
                ),
              }),
                (r += 8)
              break
            case 6:
              let i = t.getUint16(r, !1)
              ;(r += 2),
                (n[o] = {
                  type: Cie,
                  value: new Uint8Array(t.buffer, t.byteOffset + r, i),
                }),
                (r += i)
              break
            case 7:
              let c = t.getUint16(r, !1)
              ;(r += 2),
                (n[o] = {
                  type: wie,
                  value: this.toUtf8(
                    new Uint8Array(t.buffer, t.byteOffset + r, c),
                  ),
                }),
                (r += c)
              break
            case 8:
              ;(n[o] = {
                type: Tie,
                value: new Date(
                  new i0.Int64(
                    new Uint8Array(t.buffer, t.byteOffset + r, 8),
                  ).valueOf(),
                ),
              }),
                (r += 8)
              break
            case 9:
              let a = new Uint8Array(t.buffer, t.byteOffset + r, 16)
              ;(r += 16),
                (n[o] = {
                  type: xie,
                  value: `${(0, wi.toHex)(a.subarray(0, 4))}-${(0, wi.toHex)(
                    a.subarray(4, 6),
                  )}-${(0, wi.toHex)(a.subarray(6, 8))}-${(0, wi.toHex)(
                    a.subarray(8, 10),
                  )}-${(0, wi.toHex)(a.subarray(10))}`,
                })
              break
            default:
              throw new Error('Unrecognized header type tag')
          }
        }
        return n
      }
    }
  Ip.HeaderMarshaller = a0
  var MF
  ;(function (e) {
    ;(e[(e.boolTrue = 0)] = 'boolTrue'),
      (e[(e.boolFalse = 1)] = 'boolFalse'),
      (e[(e.byte = 2)] = 'byte'),
      (e[(e.short = 3)] = 'short'),
      (e[(e.integer = 4)] = 'integer'),
      (e[(e.long = 5)] = 'long'),
      (e[(e.byteArray = 6)] = 'byteArray'),
      (e[(e.string = 7)] = 'string'),
      (e[(e.timestamp = 8)] = 'timestamp'),
      (e[(e.uuid = 9)] = 'uuid')
  })(MF || (MF = {}))
  var FF = 'boolean',
    Eie = 'byte',
    Sie = 'short',
    bie = 'integer',
    vie = 'long',
    Cie = 'binary',
    wie = 'string',
    Tie = 'timestamp',
    xie = 'uuid',
    Iie = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/
})
var LF = l((Pp) => {
  'use strict'
  Object.defineProperty(Pp, '__esModule', { value: !0 })
  Pp.splitMessage = void 0
  var Pie = Tp(),
    UF = 4,
    Jr = UF * 2,
    po = 4,
    Rie = Jr + po * 2
  function Die({ byteLength: e, byteOffset: t, buffer: n }) {
    if (e < Rie)
      throw new Error(
        'Provided message too short to accommodate event stream message overhead',
      )
    let r = new DataView(n, t, e),
      s = r.getUint32(0, !1)
    if (e !== s)
      throw new Error(
        'Reported message length does not match received message length',
      )
    let o = r.getUint32(UF, !1),
      i = r.getUint32(Jr, !1),
      c = r.getUint32(e - po, !1),
      a = new Pie.Crc32().update(new Uint8Array(n, t, Jr))
    if (i !== a.digest())
      throw new Error(
        `The prelude checksum specified in the message (${i}) does not match the calculated CRC32 checksum (${a.digest()})`,
      )
    if ((a.update(new Uint8Array(n, t + Jr, e - (Jr + po))), c !== a.digest()))
      throw new Error(
        `The message checksum (${a.digest()}) did not match the expected value of ${c}`,
      )
    return {
      headers: new DataView(n, t + Jr + po, o),
      body: new Uint8Array(n, t + Jr + po + o, s - o - (Jr + po + po)),
    }
  }
  Pp.splitMessage = Die
})
var BF = l((Rp) => {
  'use strict'
  Object.defineProperty(Rp, '__esModule', { value: !0 })
  Rp.EventStreamCodec = void 0
  var Aie = Tp(),
    Oie = c0(),
    Nie = LF(),
    d0 = class {
      constructor(t, n) {
        ;(this.headerMarshaller = new Oie.HeaderMarshaller(t, n)),
          (this.messageBuffer = []),
          (this.isEndOfStream = !1)
      }
      feed(t) {
        this.messageBuffer.push(this.decode(t))
      }
      endOfStream() {
        this.isEndOfStream = !0
      }
      getMessage() {
        let t = this.messageBuffer.pop(),
          n = this.isEndOfStream
        return {
          getMessage() {
            return t
          },
          isEndOfStream() {
            return n
          },
        }
      }
      getAvailableMessages() {
        let t = this.messageBuffer
        this.messageBuffer = []
        let n = this.isEndOfStream
        return {
          getMessages() {
            return t
          },
          isEndOfStream() {
            return n
          },
        }
      }
      encode({ headers: t, body: n }) {
        let r = this.headerMarshaller.format(t),
          s = r.byteLength + n.byteLength + 16,
          o = new Uint8Array(s),
          i = new DataView(o.buffer, o.byteOffset, o.byteLength),
          c = new Aie.Crc32()
        return (
          i.setUint32(0, s, !1),
          i.setUint32(4, r.byteLength, !1),
          i.setUint32(8, c.update(o.subarray(0, 8)).digest(), !1),
          o.set(r, 12),
          o.set(n, r.byteLength + 12),
          i.setUint32(s - 4, c.update(o.subarray(8, s - 4)).digest(), !1),
          o
        )
      }
      decode(t) {
        let { headers: n, body: r } = (0, Nie.splitMessage)(t)
        return { headers: this.headerMarshaller.parse(n), body: r }
      }
      formatHeaders(t) {
        return this.headerMarshaller.format(t)
      }
    }
  Rp.EventStreamCodec = d0
})
var GF = l((jF) => {
  'use strict'
  Object.defineProperty(jF, '__esModule', { value: !0 })
})
var $F = l((Dp) => {
  'use strict'
  Object.defineProperty(Dp, '__esModule', { value: !0 })
  Dp.MessageDecoderStream = void 0
  var u0 = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.inputStream)
        yield this.options.decoder.decode(t)
    }
  }
  Dp.MessageDecoderStream = u0
})
var zF = l((Ap) => {
  'use strict'
  Object.defineProperty(Ap, '__esModule', { value: !0 })
  Ap.MessageEncoderStream = void 0
  var l0 = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.messageStream)
        yield this.options.encoder.encode(t)
      this.options.includeEndFrame && (yield new Uint8Array(0))
    }
  }
  Ap.MessageEncoderStream = l0
})
var HF = l((Op) => {
  'use strict'
  Object.defineProperty(Op, '__esModule', { value: !0 })
  Op.SmithyMessageDecoderStream = void 0
  var m0 = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.messageStream) {
        let n = await this.options.deserializer(t)
        n !== void 0 && (yield n)
      }
    }
  }
  Op.SmithyMessageDecoderStream = m0
})
var WF = l((Np) => {
  'use strict'
  Object.defineProperty(Np, '__esModule', { value: !0 })
  Np.SmithyMessageEncoderStream = void 0
  var p0 = class {
    constructor(t) {
      this.options = t
    }
    [Symbol.asyncIterator]() {
      return this.asyncIterator()
    }
    async *asyncIterator() {
      for await (let t of this.options.inputStream)
        yield this.options.serializer(t)
    }
  }
  Np.SmithyMessageEncoderStream = p0
})
var VF = l((In) => {
  'use strict'
  Object.defineProperty(In, '__esModule', { value: !0 })
  var Xr = (x(), w(T))
  Xr.__exportStar(BF(), In)
  Xr.__exportStar(c0(), In)
  Xr.__exportStar(o0(), In)
  Xr.__exportStar(GF(), In)
  Xr.__exportStar($F(), In)
  Xr.__exportStar(zF(), In)
  Xr.__exportStar(HF(), In)
  Xr.__exportStar(WF(), In)
})
var YF = l((qp) => {
  'use strict'
  Object.defineProperty(qp, '__esModule', { value: !0 })
  qp.normalizeProvider = void 0
  var qie = (e) => {
    if (typeof e == 'function') return e
    let t = Promise.resolve(e)
    return () => t
  }
  qp.normalizeProvider = qie
})
var fo = l((f0) => {
  'use strict'
  Object.defineProperty(f0, '__esModule', { value: !0 })
  var kie = (x(), w(T))
  kie.__exportStar(YF(), f0)
})
var _0 = l((kp) => {
  'use strict'
  Object.defineProperty(kp, '__esModule', { value: !0 })
  kp.isArrayBuffer = void 0
  var Mie = (e) =>
    (typeof ArrayBuffer == 'function' && e instanceof ArrayBuffer) ||
    Object.prototype.toString.call(e) === '[object ArrayBuffer]'
  kp.isArrayBuffer = Mie
})
var _o = l((Ti) => {
  'use strict'
  Object.defineProperty(Ti, '__esModule', { value: !0 })
  Ti.fromString = Ti.fromArrayBuffer = void 0
  var Fie = _0(),
    h0 = require('buffer'),
    Uie = (e, t = 0, n = e.byteLength - t) => {
      if (!(0, Fie.isArrayBuffer)(e))
        throw new TypeError(
          `The "input" argument must be ArrayBuffer. Received type ${typeof e} (${e})`,
        )
      return h0.Buffer.from(e, t, n)
    }
  Ti.fromArrayBuffer = Uie
  var Lie = (e, t) => {
    if (typeof e != 'string')
      throw new TypeError(
        `The "input" argument must be of type string. Received type ${typeof e} (${e})`,
      )
    return t ? h0.Buffer.from(e, t) : h0.Buffer.from(e)
  }
  Ti.fromString = Lie
})
var y0 = l((Mp) => {
  'use strict'
  Object.defineProperty(Mp, '__esModule', { value: !0 })
  Mp.fromUtf8 = void 0
  var Bie = _o(),
    jie = (e) => {
      let t = (0, Bie.fromString)(e, 'utf8')
      return new Uint8Array(
        t.buffer,
        t.byteOffset,
        t.byteLength / Uint8Array.BYTES_PER_ELEMENT,
      )
    }
  Mp.fromUtf8 = jie
})
var KF = l((Fp) => {
  'use strict'
  Object.defineProperty(Fp, '__esModule', { value: !0 })
  Fp.toUint8Array = void 0
  var Gie = y0(),
    $ie = (e) =>
      typeof e == 'string'
        ? (0, Gie.fromUtf8)(e)
        : ArrayBuffer.isView(e)
        ? new Uint8Array(
            e.buffer,
            e.byteOffset,
            e.byteLength / Uint8Array.BYTES_PER_ELEMENT,
          )
        : new Uint8Array(e)
  Fp.toUint8Array = $ie
})
var JF = l((Up) => {
  'use strict'
  Object.defineProperty(Up, '__esModule', { value: !0 })
  Up.toUtf8 = void 0
  var zie = _o(),
    Hie = (e) =>
      (0, zie.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength).toString(
        'utf8',
      )
  Up.toUtf8 = Hie
})
var Pn = l((Zd) => {
  'use strict'
  Object.defineProperty(Zd, '__esModule', { value: !0 })
  var g0 = (x(), w(T))
  g0.__exportStar(y0(), Zd)
  g0.__exportStar(KF(), Zd)
  g0.__exportStar(JF(), Zd)
})
var ho = l((q) => {
  'use strict'
  Object.defineProperty(q, '__esModule', { value: !0 })
  q.MAX_PRESIGNED_TTL =
    q.KEY_TYPE_IDENTIFIER =
    q.MAX_CACHE_SIZE =
    q.UNSIGNED_PAYLOAD =
    q.EVENT_ALGORITHM_IDENTIFIER =
    q.ALGORITHM_IDENTIFIER_V4A =
    q.ALGORITHM_IDENTIFIER =
    q.UNSIGNABLE_PATTERNS =
    q.SEC_HEADER_PATTERN =
    q.PROXY_HEADER_PATTERN =
    q.ALWAYS_UNSIGNABLE_HEADERS =
    q.HOST_HEADER =
    q.TOKEN_HEADER =
    q.SHA256_HEADER =
    q.SIGNATURE_HEADER =
    q.GENERATED_HEADERS =
    q.DATE_HEADER =
    q.AMZ_DATE_HEADER =
    q.AUTH_HEADER =
    q.REGION_SET_PARAM =
    q.TOKEN_QUERY_PARAM =
    q.SIGNATURE_QUERY_PARAM =
    q.EXPIRES_QUERY_PARAM =
    q.SIGNED_HEADERS_QUERY_PARAM =
    q.AMZ_DATE_QUERY_PARAM =
    q.CREDENTIAL_QUERY_PARAM =
    q.ALGORITHM_QUERY_PARAM =
      void 0
  q.ALGORITHM_QUERY_PARAM = 'X-Amz-Algorithm'
  q.CREDENTIAL_QUERY_PARAM = 'X-Amz-Credential'
  q.AMZ_DATE_QUERY_PARAM = 'X-Amz-Date'
  q.SIGNED_HEADERS_QUERY_PARAM = 'X-Amz-SignedHeaders'
  q.EXPIRES_QUERY_PARAM = 'X-Amz-Expires'
  q.SIGNATURE_QUERY_PARAM = 'X-Amz-Signature'
  q.TOKEN_QUERY_PARAM = 'X-Amz-Security-Token'
  q.REGION_SET_PARAM = 'X-Amz-Region-Set'
  q.AUTH_HEADER = 'authorization'
  q.AMZ_DATE_HEADER = q.AMZ_DATE_QUERY_PARAM.toLowerCase()
  q.DATE_HEADER = 'date'
  q.GENERATED_HEADERS = [q.AUTH_HEADER, q.AMZ_DATE_HEADER, q.DATE_HEADER]
  q.SIGNATURE_HEADER = q.SIGNATURE_QUERY_PARAM.toLowerCase()
  q.SHA256_HEADER = 'x-amz-content-sha256'
  q.TOKEN_HEADER = q.TOKEN_QUERY_PARAM.toLowerCase()
  q.HOST_HEADER = 'host'
  q.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: !0,
    'cache-control': !0,
    connection: !0,
    expect: !0,
    from: !0,
    'keep-alive': !0,
    'max-forwards': !0,
    pragma: !0,
    referer: !0,
    te: !0,
    trailer: !0,
    'transfer-encoding': !0,
    upgrade: !0,
    'user-agent': !0,
    'x-amzn-trace-id': !0,
  }
  q.PROXY_HEADER_PATTERN = /^proxy-/
  q.SEC_HEADER_PATTERN = /^sec-/
  q.UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i]
  q.ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256'
  q.ALGORITHM_IDENTIFIER_V4A = 'AWS4-ECDSA-P256-SHA256'
  q.EVENT_ALGORITHM_IDENTIFIER = 'AWS4-HMAC-SHA256-PAYLOAD'
  q.UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD'
  q.MAX_CACHE_SIZE = 50
  q.KEY_TYPE_IDENTIFIER = 'aws4_request'
  q.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7
})
var S0 = l((Qr) => {
  'use strict'
  Object.defineProperty(Qr, '__esModule', { value: !0 })
  Qr.clearCredentialCache = Qr.getSigningKey = Qr.createScope = void 0
  var Wie = Ci(),
    Vie = Pn(),
    E0 = ho(),
    xi = {},
    Lp = [],
    Yie = (e, t, n) => `${e}/${t}/${n}/${E0.KEY_TYPE_IDENTIFIER}`
  Qr.createScope = Yie
  var Kie = async (e, t, n, r, s) => {
    let o = await XF(e, t.secretAccessKey, t.accessKeyId),
      i = `${n}:${r}:${s}:${(0, Wie.toHex)(o)}:${t.sessionToken}`
    if (i in xi) return xi[i]
    for (Lp.push(i); Lp.length > E0.MAX_CACHE_SIZE; ) delete xi[Lp.shift()]
    let c = `AWS4${t.secretAccessKey}`
    for (let a of [n, r, s, E0.KEY_TYPE_IDENTIFIER]) c = await XF(e, c, a)
    return (xi[i] = c)
  }
  Qr.getSigningKey = Kie
  var Jie = () => {
    ;(Lp.length = 0),
      Object.keys(xi).forEach((e) => {
        delete xi[e]
      })
  }
  Qr.clearCredentialCache = Jie
  var XF = (e, t, n) => {
    let r = new e(t)
    return r.update((0, Vie.toUint8Array)(n)), r.digest()
  }
})
var v0 = l((Bp) => {
  'use strict'
  Object.defineProperty(Bp, '__esModule', { value: !0 })
  Bp.getCanonicalHeaders = void 0
  var b0 = ho(),
    Xie = ({ headers: e }, t, n) => {
      let r = {}
      for (let s of Object.keys(e).sort()) {
        if (e[s] == null) continue
        let o = s.toLowerCase()
        ;((o in b0.ALWAYS_UNSIGNABLE_HEADERS ||
          t?.has(o) ||
          b0.PROXY_HEADER_PATTERN.test(o) ||
          b0.SEC_HEADER_PATTERN.test(o)) &&
          (!n || (n && !n.has(o)))) ||
          (r[o] = e[s].trim().replace(/\s+/g, ' '))
      }
      return r
    }
  Bp.getCanonicalHeaders = Xie
})
var C0 = l((jp) => {
  'use strict'
  Object.defineProperty(jp, '__esModule', { value: !0 })
  jp.escapeUri = void 0
  var Qie = (e) => encodeURIComponent(e).replace(/[!'()*]/g, Zie)
  jp.escapeUri = Qie
  var Zie = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
})
var QF = l((Gp) => {
  'use strict'
  Object.defineProperty(Gp, '__esModule', { value: !0 })
  Gp.escapeUriPath = void 0
  var eae = C0(),
    tae = (e) => e.split('/').map(eae.escapeUri).join('/')
  Gp.escapeUriPath = tae
})
var w0 = l(($p) => {
  'use strict'
  Object.defineProperty($p, '__esModule', { value: !0 })
  var ZF = (x(), w(T))
  ZF.__exportStar(C0(), $p)
  ZF.__exportStar(QF(), $p)
})
var T0 = l((Hp) => {
  'use strict'
  Object.defineProperty(Hp, '__esModule', { value: !0 })
  Hp.getCanonicalQuery = void 0
  var zp = w0(),
    nae = ho(),
    rae = ({ query: e = {} }) => {
      let t = [],
        n = {}
      for (let r of Object.keys(e).sort()) {
        if (r.toLowerCase() === nae.SIGNATURE_HEADER) continue
        t.push(r)
        let s = e[r]
        typeof s == 'string'
          ? (n[r] = `${(0, zp.escapeUri)(r)}=${(0, zp.escapeUri)(s)}`)
          : Array.isArray(s) &&
            (n[r] = s
              .slice(0)
              .reduce(
                (o, i) =>
                  o.concat([`${(0, zp.escapeUri)(r)}=${(0, zp.escapeUri)(i)}`]),
                [],
              )
              .sort()
              .join('&'))
      }
      return t
        .map((r) => n[r])
        .filter((r) => r)
        .join('&')
    }
  Hp.getCanonicalQuery = rae
})
var x0 = l((Wp) => {
  'use strict'
  Object.defineProperty(Wp, '__esModule', { value: !0 })
  Wp.getPayloadHash = void 0
  var sae = _0(),
    oae = Ci(),
    iae = Pn(),
    eU = ho(),
    aae = async ({ headers: e, body: t }, n) => {
      for (let r of Object.keys(e))
        if (r.toLowerCase() === eU.SHA256_HEADER) return e[r]
      if (t == null)
        return 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'
      if (
        typeof t == 'string' ||
        ArrayBuffer.isView(t) ||
        (0, sae.isArrayBuffer)(t)
      ) {
        let r = new n()
        return (
          r.update((0, iae.toUint8Array)(t)), (0, oae.toHex)(await r.digest())
        )
      }
      return eU.UNSIGNED_PAYLOAD
    }
  Wp.getPayloadHash = aae
})
var tU = l((Zr) => {
  'use strict'
  Object.defineProperty(Zr, '__esModule', { value: !0 })
  Zr.deleteHeader = Zr.getHeaderValue = Zr.hasHeader = void 0
  var cae = (e, t) => {
    e = e.toLowerCase()
    for (let n of Object.keys(t)) if (e === n.toLowerCase()) return !0
    return !1
  }
  Zr.hasHeader = cae
  var dae = (e, t) => {
    e = e.toLowerCase()
    for (let n of Object.keys(t)) if (e === n.toLowerCase()) return t[n]
  }
  Zr.getHeaderValue = dae
  var uae = (e, t) => {
    e = e.toLowerCase()
    for (let n of Object.keys(t)) e === n.toLowerCase() && delete t[n]
  }
  Zr.deleteHeader = uae
})
var I0 = l((yo) => {
  'use strict'
  Object.defineProperty(yo, '__esModule', { value: !0 })
  yo.cloneQuery = yo.cloneRequest = void 0
  var lae = ({ headers: e, query: t, ...n }) => ({
    ...n,
    headers: { ...e },
    query: t ? (0, yo.cloneQuery)(t) : void 0,
  })
  yo.cloneRequest = lae
  var mae = (e) =>
    Object.keys(e).reduce((t, n) => {
      let r = e[n]
      return { ...t, [n]: Array.isArray(r) ? [...r] : r }
    }, {})
  yo.cloneQuery = mae
})
var P0 = l((Vp) => {
  'use strict'
  Object.defineProperty(Vp, '__esModule', { value: !0 })
  Vp.moveHeadersToQuery = void 0
  var pae = I0(),
    fae = (e, t = {}) => {
      var n
      let { headers: r, query: s = {} } =
        typeof e.clone == 'function' ? e.clone() : (0, pae.cloneRequest)(e)
      for (let o of Object.keys(r)) {
        let i = o.toLowerCase()
        i.slice(0, 6) === 'x-amz-' &&
          !(
            !((n = t.unhoistableHeaders) === null || n === void 0) && n.has(i)
          ) &&
          ((s[o] = r[o]), delete r[o])
      }
      return { ...e, headers: r, query: s }
    }
  Vp.moveHeadersToQuery = fae
})
var R0 = l((Yp) => {
  'use strict'
  Object.defineProperty(Yp, '__esModule', { value: !0 })
  Yp.prepareRequest = void 0
  var _ae = I0(),
    hae = ho(),
    yae = (e) => {
      e = typeof e.clone == 'function' ? e.clone() : (0, _ae.cloneRequest)(e)
      for (let t of Object.keys(e.headers))
        hae.GENERATED_HEADERS.indexOf(t.toLowerCase()) > -1 &&
          delete e.headers[t]
      return e
    }
  Yp.prepareRequest = yae
})
var nU = l((go) => {
  'use strict'
  Object.defineProperty(go, '__esModule', { value: !0 })
  go.toDate = go.iso8601 = void 0
  var gae = (e) =>
    (0, go.toDate)(e)
      .toISOString()
      .replace(/\.\d{3}Z$/, 'Z')
  go.iso8601 = gae
  var Eae = (e) =>
    typeof e == 'number'
      ? new Date(e * 1e3)
      : typeof e == 'string'
      ? Number(e)
        ? new Date(Number(e) * 1e3)
        : new Date(e)
      : e
  go.toDate = Eae
})
var aU = l((Qp) => {
  'use strict'
  Object.defineProperty(Qp, '__esModule', { value: !0 })
  Qp.SignatureV4 = void 0
  var Sae = VF(),
    Kp = Ci(),
    rU = fo(),
    eu = Pn(),
    Ve = ho(),
    Jp = S0(),
    sU = v0(),
    bae = T0(),
    D0 = x0(),
    vae = tU(),
    Cae = P0(),
    oU = R0(),
    wae = nU(),
    A0 = class {
      constructor({
        applyChecksum: t,
        credentials: n,
        region: r,
        service: s,
        sha256: o,
        uriEscapePath: i = !0,
      }) {
        ;(this.headerMarshaller = new Sae.HeaderMarshaller(
          eu.toUtf8,
          eu.fromUtf8,
        )),
          (this.service = s),
          (this.sha256 = o),
          (this.uriEscapePath = i),
          (this.applyChecksum = typeof t == 'boolean' ? t : !0),
          (this.regionProvider = (0, rU.normalizeProvider)(r)),
          (this.credentialProvider = (0, rU.normalizeProvider)(n))
      }
      async presign(t, n = {}) {
        let {
            signingDate: r = new Date(),
            expiresIn: s = 3600,
            unsignableHeaders: o,
            unhoistableHeaders: i,
            signableHeaders: c,
            signingRegion: a,
            signingService: u,
          } = n,
          d = await this.credentialProvider()
        this.validateResolvedCredentials(d)
        let p = a ?? (await this.regionProvider()),
          { longDate: f, shortDate: _ } = Xp(r)
        if (s > Ve.MAX_PRESIGNED_TTL)
          return Promise.reject(
            'Signature version 4 presigned URLs must have an expiration date less than one week in the future',
          )
        let h = (0, Jp.createScope)(_, p, u ?? this.service),
          g = (0, Cae.moveHeadersToQuery)((0, oU.prepareRequest)(t), {
            unhoistableHeaders: i,
          })
        d.sessionToken && (g.query[Ve.TOKEN_QUERY_PARAM] = d.sessionToken),
          (g.query[Ve.ALGORITHM_QUERY_PARAM] = Ve.ALGORITHM_IDENTIFIER),
          (g.query[Ve.CREDENTIAL_QUERY_PARAM] = `${d.accessKeyId}/${h}`),
          (g.query[Ve.AMZ_DATE_QUERY_PARAM] = f),
          (g.query[Ve.EXPIRES_QUERY_PARAM] = s.toString(10))
        let E = (0, sU.getCanonicalHeaders)(g, o, c)
        return (
          (g.query[Ve.SIGNED_HEADERS_QUERY_PARAM] = iU(E)),
          (g.query[Ve.SIGNATURE_QUERY_PARAM] = await this.getSignature(
            f,
            h,
            this.getSigningKey(d, p, _, u),
            this.createCanonicalRequest(
              g,
              E,
              await (0, D0.getPayloadHash)(t, this.sha256),
            ),
          )),
          g
        )
      }
      async sign(t, n) {
        return typeof t == 'string'
          ? this.signString(t, n)
          : t.headers && t.payload
          ? this.signEvent(t, n)
          : t.message
          ? this.signMessage(t, n)
          : this.signRequest(t, n)
      }
      async signEvent(
        { headers: t, payload: n },
        {
          signingDate: r = new Date(),
          priorSignature: s,
          signingRegion: o,
          signingService: i,
        },
      ) {
        let c = o ?? (await this.regionProvider()),
          { shortDate: a, longDate: u } = Xp(r),
          d = (0, Jp.createScope)(a, c, i ?? this.service),
          p = await (0, D0.getPayloadHash)(
            { headers: {}, body: n },
            this.sha256,
          ),
          f = new this.sha256()
        f.update(t)
        let _ = (0, Kp.toHex)(await f.digest()),
          h = [Ve.EVENT_ALGORITHM_IDENTIFIER, u, d, s, _, p].join(`
`)
        return this.signString(h, {
          signingDate: r,
          signingRegion: c,
          signingService: i,
        })
      }
      async signMessage(
        t,
        { signingDate: n = new Date(), signingRegion: r, signingService: s },
      ) {
        return this.signEvent(
          {
            headers: this.headerMarshaller.format(t.message.headers),
            payload: t.message.body,
          },
          {
            signingDate: n,
            signingRegion: r,
            signingService: s,
            priorSignature: t.priorSignature,
          },
        ).then((i) => ({ message: t.message, signature: i }))
      }
      async signString(
        t,
        {
          signingDate: n = new Date(),
          signingRegion: r,
          signingService: s,
        } = {},
      ) {
        let o = await this.credentialProvider()
        this.validateResolvedCredentials(o)
        let i = r ?? (await this.regionProvider()),
          { shortDate: c } = Xp(n),
          a = new this.sha256(await this.getSigningKey(o, i, c, s))
        return (
          a.update((0, eu.toUint8Array)(t)), (0, Kp.toHex)(await a.digest())
        )
      }
      async signRequest(
        t,
        {
          signingDate: n = new Date(),
          signableHeaders: r,
          unsignableHeaders: s,
          signingRegion: o,
          signingService: i,
        } = {},
      ) {
        let c = await this.credentialProvider()
        this.validateResolvedCredentials(c)
        let a = o ?? (await this.regionProvider()),
          u = (0, oU.prepareRequest)(t),
          { longDate: d, shortDate: p } = Xp(n),
          f = (0, Jp.createScope)(p, a, i ?? this.service)
        ;(u.headers[Ve.AMZ_DATE_HEADER] = d),
          c.sessionToken && (u.headers[Ve.TOKEN_HEADER] = c.sessionToken)
        let _ = await (0, D0.getPayloadHash)(u, this.sha256)
        !(0, vae.hasHeader)(Ve.SHA256_HEADER, u.headers) &&
          this.applyChecksum &&
          (u.headers[Ve.SHA256_HEADER] = _)
        let h = (0, sU.getCanonicalHeaders)(u, s, r),
          g = await this.getSignature(
            d,
            f,
            this.getSigningKey(c, a, p, i),
            this.createCanonicalRequest(u, h, _),
          )
        return (
          (u.headers[Ve.AUTH_HEADER] = `${Ve.ALGORITHM_IDENTIFIER} Credential=${
            c.accessKeyId
          }/${f}, SignedHeaders=${iU(h)}, Signature=${g}`),
          u
        )
      }
      createCanonicalRequest(t, n, r) {
        let s = Object.keys(n).sort()
        return `${t.method}
${this.getCanonicalPath(t)}
${(0, bae.getCanonicalQuery)(t)}
${s.map((o) => `${o}:${n[o]}`).join(`
`)}

${s.join(';')}
${r}`
      }
      async createStringToSign(t, n, r) {
        let s = new this.sha256()
        s.update((0, eu.toUint8Array)(r))
        let o = await s.digest()
        return `${Ve.ALGORITHM_IDENTIFIER}
${t}
${n}
${(0, Kp.toHex)(o)}`
      }
      getCanonicalPath({ path: t }) {
        if (this.uriEscapePath) {
          let n = []
          for (let o of t.split('/'))
            o?.length !== 0 && o !== '.' && (o === '..' ? n.pop() : n.push(o))
          let r = `${t?.startsWith('/') ? '/' : ''}${n.join('/')}${
            n.length > 0 && t?.endsWith('/') ? '/' : ''
          }`
          return encodeURIComponent(r).replace(/%2F/g, '/')
        }
        return t
      }
      async getSignature(t, n, r, s) {
        let o = await this.createStringToSign(t, n, s),
          i = new this.sha256(await r)
        return (
          i.update((0, eu.toUint8Array)(o)), (0, Kp.toHex)(await i.digest())
        )
      }
      getSigningKey(t, n, r, s) {
        return (0, Jp.getSigningKey)(this.sha256, t, r, n, s || this.service)
      }
      validateResolvedCredentials(t) {
        if (
          typeof t != 'object' ||
          typeof t.accessKeyId != 'string' ||
          typeof t.secretAccessKey != 'string'
        )
          throw new Error('Resolved credential object is not valid')
      }
    }
  Qp.SignatureV4 = A0
  var Xp = (e) => {
      let t = (0, wae.iso8601)(e).replace(/[\-:]/g, '')
      return { longDate: t, shortDate: t.slice(0, 8) }
    },
    iU = (e) => Object.keys(e).sort().join(';')
})
var dU = l((_t) => {
  'use strict'
  Object.defineProperty(_t, '__esModule', { value: !0 })
  _t.prepareRequest =
    _t.moveHeadersToQuery =
    _t.getPayloadHash =
    _t.getCanonicalQuery =
    _t.getCanonicalHeaders =
      void 0
  var cU = (x(), w(T))
  cU.__exportStar(aU(), _t)
  var Tae = v0()
  Object.defineProperty(_t, 'getCanonicalHeaders', {
    enumerable: !0,
    get: function () {
      return Tae.getCanonicalHeaders
    },
  })
  var xae = T0()
  Object.defineProperty(_t, 'getCanonicalQuery', {
    enumerable: !0,
    get: function () {
      return xae.getCanonicalQuery
    },
  })
  var Iae = x0()
  Object.defineProperty(_t, 'getPayloadHash', {
    enumerable: !0,
    get: function () {
      return Iae.getPayloadHash
    },
  })
  var Pae = P0()
  Object.defineProperty(_t, 'moveHeadersToQuery', {
    enumerable: !0,
    get: function () {
      return Pae.moveHeadersToQuery
    },
  })
  var Rae = R0()
  Object.defineProperty(_t, 'prepareRequest', {
    enumerable: !0,
    get: function () {
      return Rae.prepareRequest
    },
  })
  cU.__exportStar(S0(), _t)
})
var lU = l((Pi) => {
  'use strict'
  Object.defineProperty(Pi, '__esModule', { value: !0 })
  Pi.resolveSigV4AuthConfig = Pi.resolveAwsAuthConfig = void 0
  var Dae = Y(),
    O0 = dU(),
    Ii = fo(),
    Aae = 3e5,
    Oae = (e) => {
      let t = e.credentials
          ? uU(e.credentials)
          : e.credentialDefaultProvider(e),
        {
          signingEscapePath: n = !0,
          systemClockOffset: r = e.systemClockOffset || 0,
          sha256: s,
        } = e,
        o
      return (
        e.signer
          ? (o = (0, Ii.normalizeProvider)(e.signer))
          : e.regionInfoProvider
          ? (o = () =>
              (0, Ii.normalizeProvider)(e.region)()
                .then(async (i) => [
                  (await e.regionInfoProvider(i, {
                    useFipsEndpoint: await e.useFipsEndpoint(),
                    useDualstackEndpoint: await e.useDualstackEndpoint(),
                  })) || {},
                  i,
                ])
                .then(([i, c]) => {
                  let { signingRegion: a, signingService: u } = i
                  ;(e.signingRegion = e.signingRegion || a || c),
                    (e.signingName = e.signingName || u || e.serviceId)
                  let d = {
                      ...e,
                      credentials: t,
                      region: e.signingRegion,
                      service: e.signingName,
                      sha256: s,
                      uriEscapePath: n,
                    },
                    p = e.signerConstructor || O0.SignatureV4
                  return new p(d)
                }))
          : (o = async (i) => {
              i = Object.assign(
                {},
                {
                  name: 'sigv4',
                  signingName: e.signingName || e.defaultSigningName,
                  signingRegion: await (0, Ii.normalizeProvider)(e.region)(),
                  properties: {},
                },
                i,
              )
              let c = i.signingRegion,
                a = i.signingName
              ;(e.signingRegion = e.signingRegion || c),
                (e.signingName = e.signingName || a || e.serviceId)
              let u = {
                  ...e,
                  credentials: t,
                  region: e.signingRegion,
                  service: e.signingName,
                  sha256: s,
                  uriEscapePath: n,
                },
                d = e.signerConstructor || O0.SignatureV4
              return new d(u)
            }),
        {
          ...e,
          systemClockOffset: r,
          signingEscapePath: n,
          credentials: t,
          signer: o,
        }
      )
    }
  Pi.resolveAwsAuthConfig = Oae
  var Nae = (e) => {
    let t = e.credentials ? uU(e.credentials) : e.credentialDefaultProvider(e),
      {
        signingEscapePath: n = !0,
        systemClockOffset: r = e.systemClockOffset || 0,
        sha256: s,
      } = e,
      o
    return (
      e.signer
        ? (o = (0, Ii.normalizeProvider)(e.signer))
        : (o = (0, Ii.normalizeProvider)(
            new O0.SignatureV4({
              credentials: t,
              region: e.region,
              service: e.signingName,
              sha256: s,
              uriEscapePath: n,
            }),
          )),
      {
        ...e,
        systemClockOffset: r,
        signingEscapePath: n,
        credentials: t,
        signer: o,
      }
    )
  }
  Pi.resolveSigV4AuthConfig = Nae
  var uU = (e) =>
    typeof e == 'function'
      ? (0, Dae.memoize)(
          e,
          (t) =>
            t.expiration !== void 0 &&
            t.expiration.getTime() - Date.now() < Aae,
          (t) => t.expiration !== void 0,
        )
      : (0, Ii.normalizeProvider)(e)
})
var N0 = l((Zp) => {
  'use strict'
  Object.defineProperty(Zp, '__esModule', { value: !0 })
  Zp.getSkewCorrectedDate = void 0
  var qae = (e) => new Date(Date.now() + e)
  Zp.getSkewCorrectedDate = qae
})
var mU = l((ef) => {
  'use strict'
  Object.defineProperty(ef, '__esModule', { value: !0 })
  ef.isClockSkewed = void 0
  var kae = N0(),
    Mae = (e, t) =>
      Math.abs((0, kae.getSkewCorrectedDate)(t).getTime() - e) >= 3e5
  ef.isClockSkewed = Mae
})
var pU = l((tf) => {
  'use strict'
  Object.defineProperty(tf, '__esModule', { value: !0 })
  tf.getUpdatedSystemClockOffset = void 0
  var Fae = mU(),
    Uae = (e, t) => {
      let n = Date.parse(e)
      return (0, Fae.isClockSkewed)(n, t) ? n - Date.now() : t
    }
  tf.getUpdatedSystemClockOffset = Uae
})
var yU = l((Pt) => {
  'use strict'
  Object.defineProperty(Pt, '__esModule', { value: !0 })
  Pt.getSigV4AuthPlugin =
    Pt.getAwsAuthPlugin =
    Pt.awsAuthMiddlewareOptions =
    Pt.awsAuthMiddleware =
      void 0
  var hU = tt(),
    Lae = N0(),
    fU = pU(),
    Bae = (e) => (t, n) =>
      async function (r) {
        var s, o, i, c
        if (!hU.HttpRequest.isInstance(r.request)) return t(r)
        let a =
            (i =
              (o =
                (s = n.endpointV2) === null || s === void 0
                  ? void 0
                  : s.properties) === null || o === void 0
                ? void 0
                : o.authSchemes) === null || i === void 0
              ? void 0
              : i[0],
          u =
            a?.name === 'sigv4a'
              ? (c = a?.signingRegionSet) === null || c === void 0
                ? void 0
                : c.join(',')
              : void 0,
          d = await e.signer(a),
          p = await t({
            ...r,
            request: await d.sign(r.request, {
              signingDate: (0, Lae.getSkewCorrectedDate)(e.systemClockOffset),
              signingRegion: u || n.signing_region,
              signingService: n.signing_service,
            }),
          }).catch((_) => {
            var h
            let g =
              (h = _.ServerTime) !== null && h !== void 0 ? h : _U(_.$response)
            throw (
              (g &&
                (e.systemClockOffset = (0, fU.getUpdatedSystemClockOffset)(
                  g,
                  e.systemClockOffset,
                )),
              _)
            )
          }),
          f = _U(p.response)
        return (
          f &&
            (e.systemClockOffset = (0, fU.getUpdatedSystemClockOffset)(
              f,
              e.systemClockOffset,
            )),
          p
        )
      }
  Pt.awsAuthMiddleware = Bae
  var _U = (e) => {
    var t, n, r
    return hU.HttpResponse.isInstance(e)
      ? (n = (t = e.headers) === null || t === void 0 ? void 0 : t.date) !==
          null && n !== void 0
        ? n
        : (r = e.headers) === null || r === void 0
        ? void 0
        : r.Date
      : void 0
  }
  Pt.awsAuthMiddlewareOptions = {
    name: 'awsAuthMiddleware',
    tags: ['SIGNATURE', 'AWSAUTH'],
    relation: 'after',
    toMiddleware: 'retryMiddleware',
    override: !0,
  }
  var jae = (e) => ({
    applyToStack: (t) => {
      t.addRelativeTo((0, Pt.awsAuthMiddleware)(e), Pt.awsAuthMiddlewareOptions)
    },
  })
  Pt.getAwsAuthPlugin = jae
  Pt.getSigV4AuthPlugin = Pt.getAwsAuthPlugin
})
var fr = l((nf) => {
  'use strict'
  Object.defineProperty(nf, '__esModule', { value: !0 })
  var gU = (x(), w(T))
  gU.__exportStar(lU(), nf)
  gU.__exportStar(yU(), nf)
})
var EU = l((rf) => {
  'use strict'
  Object.defineProperty(rf, '__esModule', { value: !0 })
  rf.resolveUserAgentConfig = void 0
  function Gae(e) {
    return {
      ...e,
      customUserAgent:
        typeof e.customUserAgent == 'string'
          ? [[e.customUserAgent]]
          : e.customUserAgent,
    }
  }
  rf.resolveUserAgentConfig = Gae
})
var SU = l((YLe, $ae) => {
  $ae.exports = {
    partitions: [
      {
        id: 'aws',
        outputs: {
          dnsSuffix: 'amazonaws.com',
          dualStackDnsSuffix: 'api.aws',
          name: 'aws',
          supportsDualStack: !0,
          supportsFIPS: !0,
        },
        regionRegex: '^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$',
        regions: {
          'af-south-1': { description: 'Africa (Cape Town)' },
          'ap-east-1': { description: 'Asia Pacific (Hong Kong)' },
          'ap-northeast-1': { description: 'Asia Pacific (Tokyo)' },
          'ap-northeast-2': { description: 'Asia Pacific (Seoul)' },
          'ap-northeast-3': { description: 'Asia Pacific (Osaka)' },
          'ap-south-1': { description: 'Asia Pacific (Mumbai)' },
          'ap-south-2': { description: 'Asia Pacific (Hyderabad)' },
          'ap-southeast-1': { description: 'Asia Pacific (Singapore)' },
          'ap-southeast-2': { description: 'Asia Pacific (Sydney)' },
          'ap-southeast-3': { description: 'Asia Pacific (Jakarta)' },
          'ap-southeast-4': { description: 'Asia Pacific (Melbourne)' },
          'aws-global': { description: 'AWS Standard global region' },
          'ca-central-1': { description: 'Canada (Central)' },
          'eu-central-1': { description: 'Europe (Frankfurt)' },
          'eu-central-2': { description: 'Europe (Zurich)' },
          'eu-north-1': { description: 'Europe (Stockholm)' },
          'eu-south-1': { description: 'Europe (Milan)' },
          'eu-south-2': { description: 'Europe (Spain)' },
          'eu-west-1': { description: 'Europe (Ireland)' },
          'eu-west-2': { description: 'Europe (London)' },
          'eu-west-3': { description: 'Europe (Paris)' },
          'il-central-1': { description: 'Israel (Tel Aviv)' },
          'me-central-1': { description: 'Middle East (UAE)' },
          'me-south-1': { description: 'Middle East (Bahrain)' },
          'sa-east-1': { description: 'South America (Sao Paulo)' },
          'us-east-1': { description: 'US East (N. Virginia)' },
          'us-east-2': { description: 'US East (Ohio)' },
          'us-west-1': { description: 'US West (N. California)' },
          'us-west-2': { description: 'US West (Oregon)' },
        },
      },
      {
        id: 'aws-cn',
        outputs: {
          dnsSuffix: 'amazonaws.com.cn',
          dualStackDnsSuffix: 'api.amazonwebservices.com.cn',
          name: 'aws-cn',
          supportsDualStack: !0,
          supportsFIPS: !0,
        },
        regionRegex: '^cn\\-\\w+\\-\\d+$',
        regions: {
          'aws-cn-global': { description: 'AWS China global region' },
          'cn-north-1': { description: 'China (Beijing)' },
          'cn-northwest-1': { description: 'China (Ningxia)' },
        },
      },
      {
        id: 'aws-us-gov',
        outputs: {
          dnsSuffix: 'amazonaws.com',
          dualStackDnsSuffix: 'api.aws',
          name: 'aws-us-gov',
          supportsDualStack: !0,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-gov\\-\\w+\\-\\d+$',
        regions: {
          'aws-us-gov-global': {
            description: 'AWS GovCloud (US) global region',
          },
          'us-gov-east-1': { description: 'AWS GovCloud (US-East)' },
          'us-gov-west-1': { description: 'AWS GovCloud (US-West)' },
        },
      },
      {
        id: 'aws-iso',
        outputs: {
          dnsSuffix: 'c2s.ic.gov',
          dualStackDnsSuffix: 'c2s.ic.gov',
          name: 'aws-iso',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-iso\\-\\w+\\-\\d+$',
        regions: {
          'aws-iso-global': { description: 'AWS ISO (US) global region' },
          'us-iso-east-1': { description: 'US ISO East' },
          'us-iso-west-1': { description: 'US ISO WEST' },
        },
      },
      {
        id: 'aws-iso-b',
        outputs: {
          dnsSuffix: 'sc2s.sgov.gov',
          dualStackDnsSuffix: 'sc2s.sgov.gov',
          name: 'aws-iso-b',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-isob\\-\\w+\\-\\d+$',
        regions: {
          'aws-iso-b-global': { description: 'AWS ISOB (US) global region' },
          'us-isob-east-1': { description: 'US ISOB East (Ohio)' },
        },
      },
      {
        id: 'aws-iso-e',
        outputs: {
          dnsSuffix: 'cloud.adc-e.uk',
          dualStackDnsSuffix: 'cloud.adc-e.uk',
          name: 'aws-iso-e',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^eu\\-isoe\\-\\w+\\-\\d+$',
        regions: {},
      },
      {
        id: 'aws-iso-f',
        outputs: {
          dnsSuffix: 'csp.hci.ic.gov',
          dualStackDnsSuffix: 'csp.hci.ic.gov',
          name: 'aws-iso-f',
          supportsDualStack: !1,
          supportsFIPS: !0,
        },
        regionRegex: '^us\\-isof\\-\\w+\\-\\d+$',
        regions: {},
      },
    ],
    version: '1.1',
  }
})
var q0 = l((cn) => {
  'use strict'
  Object.defineProperty(cn, '__esModule', { value: !0 })
  cn.getUserAgentPrefix =
    cn.useDefaultPartitionInfo =
    cn.setPartitionInfo =
    cn.partition =
      void 0
  var zae = (x(), w(T)),
    bU = zae.__importDefault(SU()),
    vU = bU.default,
    CU = '',
    Hae = (e) => {
      let { partitions: t } = vU
      for (let r of t) {
        let { regions: s, outputs: o } = r
        for (let [i, c] of Object.entries(s)) if (i === e) return { ...o, ...c }
      }
      for (let r of t) {
        let { regionRegex: s, outputs: o } = r
        if (new RegExp(s).test(e)) return { ...o }
      }
      let n = t.find((r) => r.id === 'aws')
      if (!n)
        throw new Error(
          "Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.",
        )
      return { ...n.outputs }
    }
  cn.partition = Hae
  var Wae = (e, t = '') => {
    ;(vU = e), (CU = t)
  }
  cn.setPartitionInfo = Wae
  var Vae = () => {
    ;(0, cn.setPartitionInfo)(bU.default, '')
  }
  cn.useDefaultPartitionInfo = Vae
  var Yae = () => CU
  cn.getUserAgentPrefix = Yae
})
var of = l((sf) => {
  'use strict'
  Object.defineProperty(sf, '__esModule', { value: !0 })
  sf.isIpAddress = void 0
  var Kae = new RegExp(
      '^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$',
    ),
    Jae = (e) => Kae.test(e) || (e.startsWith('[') && e.endsWith(']'))
  sf.isIpAddress = Jae
})
var wU = l((af) => {
  'use strict'
  Object.defineProperty(af, '__esModule', { value: !0 })
  af.debugId = void 0
  af.debugId = 'endpoints'
})
var TU = l((cf) => {
  'use strict'
  Object.defineProperty(cf, '__esModule', { value: !0 })
  cf.toDebugString = void 0
  function k0(e) {
    return typeof e != 'object' || e == null
      ? e
      : 'ref' in e
      ? `$${k0(e.ref)}`
      : 'fn' in e
      ? `${e.fn}(${(e.argv || []).map(k0).join(', ')})`
      : JSON.stringify(e, null, 2)
  }
  cf.toDebugString = k0
})
var tu = l((df) => {
  'use strict'
  Object.defineProperty(df, '__esModule', { value: !0 })
  var xU = (x(), w(T))
  xU.__exportStar(wU(), df)
  xU.__exportStar(TU(), df)
})
var IU = l((uf) => {
  'use strict'
  Object.defineProperty(uf, '__esModule', { value: !0 })
  uf.EndpointError = void 0
  var M0 = class extends Error {
    constructor(t) {
      super(t), (this.name = 'EndpointError')
    }
  }
  uf.EndpointError = M0
})
var RU = l((PU) => {
  'use strict'
  Object.defineProperty(PU, '__esModule', { value: !0 })
})
var AU = l((DU) => {
  'use strict'
  Object.defineProperty(DU, '__esModule', { value: !0 })
})
var NU = l((OU) => {
  'use strict'
  Object.defineProperty(OU, '__esModule', { value: !0 })
})
var kU = l((qU) => {
  'use strict'
  Object.defineProperty(qU, '__esModule', { value: !0 })
})
var FU = l((MU) => {
  'use strict'
  Object.defineProperty(MU, '__esModule', { value: !0 })
})
var zt = l((es) => {
  'use strict'
  Object.defineProperty(es, '__esModule', { value: !0 })
  var Ri = (x(), w(T))
  Ri.__exportStar(IU(), es)
  Ri.__exportStar(RU(), es)
  Ri.__exportStar(AU(), es)
  Ri.__exportStar(NU(), es)
  Ri.__exportStar(kU(), es)
  Ri.__exportStar(FU(), es)
})
var F0 = l((nu) => {
  'use strict'
  Object.defineProperty(nu, '__esModule', { value: !0 })
  nu.isValidHostLabel = void 0
  var Xae = new RegExp('^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$'),
    Qae = (e, t = !1) => {
      if (!t) return Xae.test(e)
      let n = e.split('.')
      for (let r of n) if (!(0, nu.isValidHostLabel)(r)) return !1
      return !0
    }
  nu.isValidHostLabel = Qae
})
var UU = l((ru) => {
  'use strict'
  Object.defineProperty(ru, '__esModule', { value: !0 })
  ru.isVirtualHostableS3Bucket = void 0
  var Zae = of(),
    ece = F0(),
    tce = (e, t = !1) => {
      if (t) {
        for (let n of e.split('.'))
          if (!(0, ru.isVirtualHostableS3Bucket)(n)) return !1
        return !0
      }
      return !(
        !(0, ece.isValidHostLabel)(e) ||
        e.length < 3 ||
        e.length > 63 ||
        e !== e.toLowerCase() ||
        (0, Zae.isIpAddress)(e)
      )
    }
  ru.isVirtualHostableS3Bucket = tce
})
var LU = l((lf) => {
  'use strict'
  Object.defineProperty(lf, '__esModule', { value: !0 })
  lf.parseArn = void 0
  var nce = (e) => {
    let t = e.split(':')
    if (t.length < 6) return null
    let [n, r, s, o, i, ...c] = t
    return n !== 'arn' || r === '' || s === '' || c[0] === ''
      ? null
      : {
          partition: r,
          service: s,
          region: o,
          accountId: i,
          resourceId: c[0].includes('/') ? c[0].split('/') : c,
        }
  }
  lf.parseArn = nce
})
var BU = l((su) => {
  'use strict'
  Object.defineProperty(su, '__esModule', { value: !0 })
  var U0 = (x(), w(T))
  U0.__exportStar(UU(), su)
  U0.__exportStar(LU(), su)
  U0.__exportStar(q0(), su)
})
var jU = l((mf) => {
  'use strict'
  Object.defineProperty(mf, '__esModule', { value: !0 })
  mf.booleanEquals = void 0
  var rce = (e, t) => e === t
  mf.booleanEquals = rce
})
var $U = l((pf) => {
  'use strict'
  Object.defineProperty(pf, '__esModule', { value: !0 })
  pf.getAttrPathList = void 0
  var GU = zt(),
    sce = (e) => {
      let t = e.split('.'),
        n = []
      for (let r of t) {
        let s = r.indexOf('[')
        if (s !== -1) {
          if (r.indexOf(']') !== r.length - 1)
            throw new GU.EndpointError(`Path: '${e}' does not end with ']'`)
          let o = r.slice(s + 1, -1)
          if (Number.isNaN(parseInt(o)))
            throw new GU.EndpointError(
              `Invalid array index: '${o}' in path: '${e}'`,
            )
          s !== 0 && n.push(r.slice(0, s)), n.push(o)
        } else n.push(r)
      }
      return n
    }
  pf.getAttrPathList = sce
})
var zU = l((ff) => {
  'use strict'
  Object.defineProperty(ff, '__esModule', { value: !0 })
  ff.getAttr = void 0
  var oce = zt(),
    ice = $U(),
    ace = (e, t) =>
      (0, ice.getAttrPathList)(t).reduce((n, r) => {
        if (typeof n != 'object')
          throw new oce.EndpointError(
            `Index '${r}' in '${t}' not found in '${JSON.stringify(e)}'`,
          )
        return Array.isArray(n) ? n[parseInt(r)] : n[r]
      }, e)
  ff.getAttr = ace
})
var HU = l((_f) => {
  'use strict'
  Object.defineProperty(_f, '__esModule', { value: !0 })
  _f.isSet = void 0
  var cce = (e) => e != null
  _f.isSet = cce
})
var WU = l((hf) => {
  'use strict'
  Object.defineProperty(hf, '__esModule', { value: !0 })
  hf.not = void 0
  var dce = (e) => !e
  hf.not = dce
})
var YU = l((VU) => {
  'use strict'
  Object.defineProperty(VU, '__esModule', { value: !0 })
})
var KU = l((yf) => {
  'use strict'
  Object.defineProperty(yf, '__esModule', { value: !0 })
  yf.HttpAuthLocation = void 0
  var uce = Vr()
  Object.defineProperty(yf, 'HttpAuthLocation', {
    enumerable: !0,
    get: function () {
      return uce.HttpAuthLocation
    },
  })
})
var XU = l((JU) => {
  'use strict'
  Object.defineProperty(JU, '__esModule', { value: !0 })
})
var ZU = l((QU) => {
  'use strict'
  Object.defineProperty(QU, '__esModule', { value: !0 })
})
var tL = l((eL) => {
  'use strict'
  Object.defineProperty(eL, '__esModule', { value: !0 })
})
var rL = l((nL) => {
  'use strict'
  Object.defineProperty(nL, '__esModule', { value: !0 })
})
var oL = l((sL) => {
  'use strict'
  Object.defineProperty(sL, '__esModule', { value: !0 })
})
var aL = l((iL) => {
  'use strict'
  Object.defineProperty(iL, '__esModule', { value: !0 })
})
var dL = l((cL) => {
  'use strict'
  Object.defineProperty(cL, '__esModule', { value: !0 })
})
var uL = l((ou) => {
  'use strict'
  Object.defineProperty(ou, '__esModule', { value: !0 })
  ou.HostAddressType = void 0
  var lce
  ;(function (e) {
    ;(e.AAAA = 'AAAA'), (e.A = 'A')
  })((lce = ou.HostAddressType || (ou.HostAddressType = {})))
})
var mL = l((lL) => {
  'use strict'
  Object.defineProperty(lL, '__esModule', { value: !0 })
})
var pL = l((gf) => {
  'use strict'
  Object.defineProperty(gf, '__esModule', { value: !0 })
  gf.EndpointURLScheme = void 0
  var mce = Vr()
  Object.defineProperty(gf, 'EndpointURLScheme', {
    enumerable: !0,
    get: function () {
      return mce.EndpointURLScheme
    },
  })
})
var _L = l((fL) => {
  'use strict'
  Object.defineProperty(fL, '__esModule', { value: !0 })
})
var yL = l((hL) => {
  'use strict'
  Object.defineProperty(hL, '__esModule', { value: !0 })
})
var EL = l((gL) => {
  'use strict'
  Object.defineProperty(gL, '__esModule', { value: !0 })
})
var bL = l((SL) => {
  'use strict'
  Object.defineProperty(SL, '__esModule', { value: !0 })
})
var CL = l((vL) => {
  'use strict'
  Object.defineProperty(vL, '__esModule', { value: !0 })
})
var TL = l((wL) => {
  'use strict'
  Object.defineProperty(wL, '__esModule', { value: !0 })
})
var IL = l((xL) => {
  'use strict'
  Object.defineProperty(xL, '__esModule', { value: !0 })
})
var PL = l((Eo) => {
  'use strict'
  Object.defineProperty(Eo, '__esModule', { value: !0 })
  var iu = (x(), w(T))
  iu.__exportStar(EL(), Eo)
  iu.__exportStar(bL(), Eo)
  iu.__exportStar(CL(), Eo)
  iu.__exportStar(TL(), Eo)
  iu.__exportStar(IL(), Eo)
})
var DL = l((RL) => {
  'use strict'
  Object.defineProperty(RL, '__esModule', { value: !0 })
})
var OL = l((AL) => {
  'use strict'
  Object.defineProperty(AL, '__esModule', { value: !0 })
})
var qL = l((NL) => {
  'use strict'
  Object.defineProperty(NL, '__esModule', { value: !0 })
})
var ML = l((kL) => {
  'use strict'
  Object.defineProperty(kL, '__esModule', { value: !0 })
})
var UL = l((FL) => {
  'use strict'
  Object.defineProperty(FL, '__esModule', { value: !0 })
})
var BL = l((LL) => {
  'use strict'
  Object.defineProperty(LL, '__esModule', { value: !0 })
})
var GL = l((jL) => {
  'use strict'
  Object.defineProperty(jL, '__esModule', { value: !0 })
})
var zL = l(($L) => {
  'use strict'
  Object.defineProperty($L, '__esModule', { value: !0 })
})
var WL = l((HL) => {
  'use strict'
  Object.defineProperty(HL, '__esModule', { value: !0 })
})
var YL = l((VL) => {
  'use strict'
  Object.defineProperty(VL, '__esModule', { value: !0 })
})
var JL = l((KL) => {
  'use strict'
  Object.defineProperty(KL, '__esModule', { value: !0 })
})
var QL = l((XL) => {
  'use strict'
  Object.defineProperty(XL, '__esModule', { value: !0 })
})
var ZL = l((Ef) => {
  'use strict'
  Object.defineProperty(Ef, '__esModule', { value: !0 })
  Ef.RequestHandlerProtocol = void 0
  var pce = Vr()
  Object.defineProperty(Ef, 'RequestHandlerProtocol', {
    enumerable: !0,
    get: function () {
      return pce.RequestHandlerProtocol
    },
  })
})
var tB = l((eB) => {
  'use strict'
  Object.defineProperty(eB, '__esModule', { value: !0 })
})
var rB = l((nB) => {
  'use strict'
  Object.defineProperty(nB, '__esModule', { value: !0 })
})
var oB = l((sB) => {
  'use strict'
  Object.defineProperty(sB, '__esModule', { value: !0 })
})
var iB = l((ie) => {
  'use strict'
  Object.defineProperty(ie, '__esModule', { value: !0 })
  var le = (x(), w(T))
  le.__exportStar(YU(), ie)
  le.__exportStar(KU(), ie)
  le.__exportStar(XU(), ie)
  le.__exportStar(ZU(), ie)
  le.__exportStar(tL(), ie)
  le.__exportStar(rL(), ie)
  le.__exportStar(oL(), ie)
  le.__exportStar(aL(), ie)
  le.__exportStar(dL(), ie)
  le.__exportStar(uL(), ie)
  le.__exportStar(mL(), ie)
  le.__exportStar(pL(), ie)
  le.__exportStar(_L(), ie)
  le.__exportStar(yL(), ie)
  le.__exportStar(PL(), ie)
  le.__exportStar(DL(), ie)
  le.__exportStar(OL(), ie)
  le.__exportStar(qL(), ie)
  le.__exportStar(ML(), ie)
  le.__exportStar(UL(), ie)
  le.__exportStar(BL(), ie)
  le.__exportStar(GL(), ie)
  le.__exportStar(zL(), ie)
  le.__exportStar(WL(), ie)
  le.__exportStar(YL(), ie)
  le.__exportStar(JL(), ie)
  le.__exportStar(QL(), ie)
  le.__exportStar(ZL(), ie)
  le.__exportStar(tB(), ie)
  le.__exportStar(rB(), ie)
  le.__exportStar(oB(), ie)
})
var aB = l((Sf) => {
  'use strict'
  Object.defineProperty(Sf, '__esModule', { value: !0 })
  Sf.parseURL = void 0
  var B0 = iB(),
    fce = of(),
    L0 = { [B0.EndpointURLScheme.HTTP]: 80, [B0.EndpointURLScheme.HTTPS]: 443 },
    _ce = (e) => {
      let t = (() => {
        try {
          if (e instanceof URL) return e
          if (typeof e == 'object' && 'hostname' in e) {
            let {
                hostname: f,
                port: _,
                protocol: h = '',
                path: g = '',
                query: E = {},
              } = e,
              P = new URL(`${h}//${f}${_ ? `:${_}` : ''}${g}`)
            return (
              (P.search = Object.entries(E)
                .map(([z, ye]) => `${z}=${ye}`)
                .join('&')),
              P
            )
          }
          return new URL(e)
        } catch {
          return null
        }
      })()
      if (!t)
        return (
          console.error(
            `Unable to parse ${JSON.stringify(e)} as a whatwg URL.`,
          ),
          null
        )
      let n = t.href,
        { host: r, hostname: s, pathname: o, protocol: i, search: c } = t
      if (c) return null
      let a = i.slice(0, -1)
      if (!Object.values(B0.EndpointURLScheme).includes(a)) return null
      let u = (0, fce.isIpAddress)(s),
        d =
          n.includes(`${r}:${L0[a]}`) ||
          (typeof e == 'string' && e.includes(`${r}:${L0[a]}`)),
        p = `${r}${d ? `:${L0[a]}` : ''}`
      return {
        scheme: a,
        authority: p,
        path: o,
        normalizedPath: o.endsWith('/') ? o : `${o}/`,
        isIp: u,
      }
    }
  Sf.parseURL = _ce
})
var cB = l((bf) => {
  'use strict'
  Object.defineProperty(bf, '__esModule', { value: !0 })
  bf.stringEquals = void 0
  var hce = (e, t) => e === t
  bf.stringEquals = hce
})
var dB = l((vf) => {
  'use strict'
  Object.defineProperty(vf, '__esModule', { value: !0 })
  vf.substring = void 0
  var yce = (e, t, n, r) =>
    t >= n || e.length < n
      ? null
      : r
      ? e.substring(e.length - n, e.length - t)
      : e.substring(t, n)
  vf.substring = yce
})
var uB = l((Cf) => {
  'use strict'
  Object.defineProperty(Cf, '__esModule', { value: !0 })
  Cf.uriEncode = void 0
  var gce = (e) =>
    encodeURIComponent(e).replace(
      /[!*'()]/g,
      (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`,
    )
  Cf.uriEncode = gce
})
var j0 = l((Rt) => {
  'use strict'
  Object.defineProperty(Rt, '__esModule', { value: !0 })
  Rt.aws = void 0
  var Rn = (x(), w(T))
  Rt.aws = Rn.__importStar(BU())
  Rn.__exportStar(jU(), Rt)
  Rn.__exportStar(zU(), Rt)
  Rn.__exportStar(HU(), Rt)
  Rn.__exportStar(F0(), Rt)
  Rn.__exportStar(WU(), Rt)
  Rn.__exportStar(aB(), Rt)
  Rn.__exportStar(cB(), Rt)
  Rn.__exportStar(dB(), Rt)
  Rn.__exportStar(uB(), Rt)
})
var G0 = l((wf) => {
  'use strict'
  Object.defineProperty(wf, '__esModule', { value: !0 })
  wf.evaluateTemplate = void 0
  var Ece = j0(),
    Sce = (e, t) => {
      let n = [],
        r = { ...t.endpointParams, ...t.referenceRecord },
        s = 0
      for (; s < e.length; ) {
        let o = e.indexOf('{', s)
        if (o === -1) {
          n.push(e.slice(s))
          break
        }
        n.push(e.slice(s, o))
        let i = e.indexOf('}', o)
        if (i === -1) {
          n.push(e.slice(o))
          break
        }
        e[o + 1] === '{' &&
          e[i + 1] === '}' &&
          (n.push(e.slice(o + 1, i)), (s = i + 2))
        let c = e.substring(o + 1, i)
        if (c.includes('#')) {
          let [a, u] = c.split('#')
          n.push((0, Ece.getAttr)(r[a], u))
        } else n.push(r[c])
        s = i + 1
      }
      return n.join('')
    }
  wf.evaluateTemplate = Sce
})
var lB = l((Tf) => {
  'use strict'
  Object.defineProperty(Tf, '__esModule', { value: !0 })
  Tf.getReferenceValue = void 0
  var bce = ({ ref: e }, t) =>
    ({ ...t.endpointParams, ...t.referenceRecord })[e]
  Tf.getReferenceValue = bce
})
var au = l((xf) => {
  'use strict'
  Object.defineProperty(xf, '__esModule', { value: !0 })
  xf.evaluateExpression = void 0
  var vce = zt(),
    Cce = $0(),
    wce = G0(),
    Tce = lB(),
    xce = (e, t, n) => {
      if (typeof e == 'string') return (0, wce.evaluateTemplate)(e, n)
      if (e.fn) return (0, Cce.callFunction)(e, n)
      if (e.ref) return (0, Tce.getReferenceValue)(e, n)
      throw new vce.EndpointError(
        `'${t}': ${String(e)} is not a string, function or reference.`,
      )
    }
  xf.evaluateExpression = xce
})
var $0 = l((If) => {
  'use strict'
  Object.defineProperty(If, '__esModule', { value: !0 })
  If.callFunction = void 0
  var Ice = (x(), w(T)),
    Pce = Ice.__importStar(j0()),
    Rce = au(),
    Dce = ({ fn: e, argv: t }, n) => {
      let r = t.map((s) =>
        ['boolean', 'number'].includes(typeof s)
          ? s
          : (0, Rce.evaluateExpression)(s, 'arg', n),
      )
      return e.split('.').reduce((s, o) => s[o], Pce)(...r)
    }
  If.callFunction = Dce
})
var mB = l((Pf) => {
  'use strict'
  Object.defineProperty(Pf, '__esModule', { value: !0 })
  Pf.evaluateCondition = void 0
  var z0 = tu(),
    Ace = zt(),
    Oce = $0(),
    Nce = ({ assign: e, ...t }, n) => {
      var r, s
      if (e && e in n.referenceRecord)
        throw new Ace.EndpointError(
          `'${e}' is already defined in Reference Record.`,
        )
      let o = (0, Oce.callFunction)(t, n)
      return (
        (s = (r = n.logger) === null || r === void 0 ? void 0 : r.debug) ===
          null ||
          s === void 0 ||
          s.call(
            r,
            z0.debugId,
            `evaluateCondition: ${(0, z0.toDebugString)(t)} = ${(0,
            z0.toDebugString)(o)}`,
          ),
        {
          result: o === '' ? !0 : !!o,
          ...(e != null && { toAssign: { name: e, value: o } }),
        }
      )
    }
  Pf.evaluateCondition = Nce
})
var Df = l((Rf) => {
  'use strict'
  Object.defineProperty(Rf, '__esModule', { value: !0 })
  Rf.evaluateConditions = void 0
  var pB = tu(),
    qce = mB(),
    kce = (e = [], t) => {
      var n, r
      let s = {}
      for (let o of e) {
        let { result: i, toAssign: c } = (0, qce.evaluateCondition)(o, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...s },
        })
        if (!i) return { result: i }
        c &&
          ((s[c.name] = c.value),
          (r = (n = t.logger) === null || n === void 0 ? void 0 : n.debug) ===
            null ||
            r === void 0 ||
            r.call(
              n,
              pB.debugId,
              `assign: ${c.name} := ${(0, pB.toDebugString)(c.value)}`,
            ))
      }
      return { result: !0, referenceRecord: s }
    }
  Rf.evaluateConditions = kce
})
var fB = l((Af) => {
  'use strict'
  Object.defineProperty(Af, '__esModule', { value: !0 })
  Af.getEndpointHeaders = void 0
  var Mce = zt(),
    Fce = au(),
    Uce = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => ({
          ...n,
          [r]: s.map((o) => {
            let i = (0, Fce.evaluateExpression)(o, 'Header value entry', t)
            if (typeof i != 'string')
              throw new Mce.EndpointError(
                `Header '${r}' value '${i}' is not a string`,
              )
            return i
          }),
        }),
        {},
      )
  Af.getEndpointHeaders = Uce
})
var hB = l((cu) => {
  'use strict'
  Object.defineProperty(cu, '__esModule', { value: !0 })
  cu.getEndpointProperty = void 0
  var _B = zt(),
    Lce = G0(),
    Bce = H0(),
    jce = (e, t) => {
      if (Array.isArray(e))
        return e.map((n) => (0, cu.getEndpointProperty)(n, t))
      switch (typeof e) {
        case 'string':
          return (0, Lce.evaluateTemplate)(e, t)
        case 'object':
          if (e === null)
            throw new _B.EndpointError(`Unexpected endpoint property: ${e}`)
          return (0, Bce.getEndpointProperties)(e, t)
        case 'boolean':
          return e
        default:
          throw new _B.EndpointError(
            `Unexpected endpoint property type: ${typeof e}`,
          )
      }
    }
  cu.getEndpointProperty = jce
})
var H0 = l((Of) => {
  'use strict'
  Object.defineProperty(Of, '__esModule', { value: !0 })
  Of.getEndpointProperties = void 0
  var Gce = hB(),
    $ce = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => ({ ...n, [r]: (0, Gce.getEndpointProperty)(s, t) }),
        {},
      )
  Of.getEndpointProperties = $ce
})
var yB = l((Nf) => {
  'use strict'
  Object.defineProperty(Nf, '__esModule', { value: !0 })
  Nf.getEndpointUrl = void 0
  var zce = zt(),
    Hce = au(),
    Wce = (e, t) => {
      let n = (0, Hce.evaluateExpression)(e, 'Endpoint URL', t)
      if (typeof n == 'string')
        try {
          return new URL(n)
        } catch (r) {
          throw (console.error(`Failed to construct URL with ${n}`, r), r)
        }
      throw new zce.EndpointError(
        `Endpoint URL must be a string, got ${typeof n}`,
      )
    }
  Nf.getEndpointUrl = Wce
})
var EB = l((qf) => {
  'use strict'
  Object.defineProperty(qf, '__esModule', { value: !0 })
  qf.evaluateEndpointRule = void 0
  var gB = tu(),
    Vce = Df(),
    Yce = fB(),
    Kce = H0(),
    Jce = yB(),
    Xce = (e, t) => {
      var n, r
      let { conditions: s, endpoint: o } = e,
        { result: i, referenceRecord: c } = (0, Vce.evaluateConditions)(s, t)
      if (!i) return
      let a = { ...t, referenceRecord: { ...t.referenceRecord, ...c } },
        { url: u, properties: d, headers: p } = o
      return (
        (r = (n = t.logger) === null || n === void 0 ? void 0 : n.debug) ===
          null ||
          r === void 0 ||
          r.call(
            n,
            gB.debugId,
            `Resolving endpoint from template: ${(0, gB.toDebugString)(o)}`,
          ),
        {
          ...(p != null && { headers: (0, Yce.getEndpointHeaders)(p, a) }),
          ...(d != null && {
            properties: (0, Kce.getEndpointProperties)(d, a),
          }),
          url: (0, Jce.getEndpointUrl)(u, a),
        }
      )
    }
  qf.evaluateEndpointRule = Xce
})
var SB = l((kf) => {
  'use strict'
  Object.defineProperty(kf, '__esModule', { value: !0 })
  kf.evaluateErrorRule = void 0
  var Qce = zt(),
    Zce = Df(),
    ede = au(),
    tde = (e, t) => {
      let { conditions: n, error: r } = e,
        { result: s, referenceRecord: o } = (0, Zce.evaluateConditions)(n, t)
      if (s)
        throw new Qce.EndpointError(
          (0, ede.evaluateExpression)(r, 'Error', {
            ...t,
            referenceRecord: { ...t.referenceRecord, ...o },
          }),
        )
    }
  kf.evaluateErrorRule = tde
})
var bB = l((Mf) => {
  'use strict'
  Object.defineProperty(Mf, '__esModule', { value: !0 })
  Mf.evaluateTreeRule = void 0
  var nde = Df(),
    rde = W0(),
    sde = (e, t) => {
      let { conditions: n, rules: r } = e,
        { result: s, referenceRecord: o } = (0, nde.evaluateConditions)(n, t)
      if (s)
        return (0, rde.evaluateRules)(r, {
          ...t,
          referenceRecord: { ...t.referenceRecord, ...o },
        })
    }
  Mf.evaluateTreeRule = sde
})
var W0 = l((Ff) => {
  'use strict'
  Object.defineProperty(Ff, '__esModule', { value: !0 })
  Ff.evaluateRules = void 0
  var vB = zt(),
    ode = EB(),
    ide = SB(),
    ade = bB(),
    cde = (e, t) => {
      for (let n of e)
        if (n.type === 'endpoint') {
          let r = (0, ode.evaluateEndpointRule)(n, t)
          if (r) return r
        } else if (n.type === 'error') (0, ide.evaluateErrorRule)(n, t)
        else if (n.type === 'tree') {
          let r = (0, ade.evaluateTreeRule)(n, t)
          if (r) return r
        } else throw new vB.EndpointError(`Unknown endpoint rule: ${n}`)
      throw new vB.EndpointError('Rules evaluation failed')
    }
  Ff.evaluateRules = cde
})
var CB = l((V0) => {
  'use strict'
  Object.defineProperty(V0, '__esModule', { value: !0 })
  var dde = (x(), w(T))
  dde.__exportStar(W0(), V0)
})
var wB = l((Lf) => {
  'use strict'
  Object.defineProperty(Lf, '__esModule', { value: !0 })
  Lf.resolveEndpoint = void 0
  var Uf = tu(),
    ude = zt(),
    lde = CB(),
    mde = (e, t) => {
      var n, r, s, o, i, c
      let { endpointParams: a, logger: u } = t,
        { parameters: d, rules: p } = e
      ;(r = (n = t.logger) === null || n === void 0 ? void 0 : n.debug) ===
        null ||
        r === void 0 ||
        r.call(
          n,
          `${Uf.debugId} Initial EndpointParams: ${(0, Uf.toDebugString)(a)}`,
        )
      let f = Object.entries(d)
        .filter(([, g]) => g.default != null)
        .map(([g, E]) => [g, E.default])
      if (f.length > 0)
        for (let [g, E] of f) a[g] = (s = a[g]) !== null && s !== void 0 ? s : E
      let _ = Object.entries(d)
        .filter(([, g]) => g.required)
        .map(([g]) => g)
      for (let g of _)
        if (a[g] == null)
          throw new ude.EndpointError(`Missing required parameter: '${g}'`)
      let h = (0, lde.evaluateRules)(p, {
        endpointParams: a,
        logger: u,
        referenceRecord: {},
      })
      if (!((o = t.endpointParams) === null || o === void 0) && o.Endpoint)
        try {
          let g = new URL(t.endpointParams.Endpoint),
            { protocol: E, port: P } = g
          ;(h.url.protocol = E), (h.url.port = P)
        } catch {}
      return (
        (c = (i = t.logger) === null || i === void 0 ? void 0 : i.debug) ===
          null ||
          c === void 0 ||
          c.call(
            i,
            `${Uf.debugId} Resolved endpoint: ${(0, Uf.toDebugString)(h)}`,
          ),
        h
      )
    }
  Lf.resolveEndpoint = mde
})
var Ai = l((Di) => {
  'use strict'
  Object.defineProperty(Di, '__esModule', { value: !0 })
  var Bf = (x(), w(T))
  Bf.__exportStar(q0(), Di)
  Bf.__exportStar(of(), Di)
  Bf.__exportStar(wB(), Di)
  Bf.__exportStar(zt(), Di)
})
var TB = l((nt) => {
  'use strict'
  Object.defineProperty(nt, '__esModule', { value: !0 })
  nt.UA_ESCAPE_CHAR =
    nt.UA_VALUE_ESCAPE_REGEX =
    nt.UA_NAME_ESCAPE_REGEX =
    nt.UA_NAME_SEPARATOR =
    nt.SPACE =
    nt.X_AMZ_USER_AGENT =
    nt.USER_AGENT =
      void 0
  nt.USER_AGENT = 'user-agent'
  nt.X_AMZ_USER_AGENT = 'x-amz-user-agent'
  nt.SPACE = ' '
  nt.UA_NAME_SEPARATOR = '/'
  nt.UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g
  nt.UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g
  nt.UA_ESCAPE_CHAR = '-'
})
var xB = l((Dn) => {
  'use strict'
  Object.defineProperty(Dn, '__esModule', { value: !0 })
  Dn.getUserAgentPlugin =
    Dn.getUserAgentMiddlewareOptions =
    Dn.userAgentMiddleware =
      void 0
  var pde = Ai(),
    fde = tt(),
    ht = TB(),
    _de = (e) => (t, n) => async (r) => {
      var s, o
      let { request: i } = r
      if (!fde.HttpRequest.isInstance(i)) return t(r)
      let { headers: c } = i,
        a =
          ((s = n?.userAgent) === null || s === void 0 ? void 0 : s.map(Y0)) ||
          [],
        u = (await e.defaultUserAgentProvider()).map(Y0),
        d =
          ((o = e?.customUserAgent) === null || o === void 0
            ? void 0
            : o.map(Y0)) || [],
        p = (0, pde.getUserAgentPrefix)(),
        f = (p ? [p] : []).concat([...u, ...a, ...d]).join(ht.SPACE),
        _ = [...u.filter((h) => h.startsWith('aws-sdk-')), ...d].join(ht.SPACE)
      return (
        e.runtime !== 'browser'
          ? (_ &&
              (c[ht.X_AMZ_USER_AGENT] = c[ht.X_AMZ_USER_AGENT]
                ? `${c[ht.USER_AGENT]} ${_}`
                : _),
            (c[ht.USER_AGENT] = f))
          : (c[ht.X_AMZ_USER_AGENT] = f),
        t({ ...r, request: i })
      )
    }
  Dn.userAgentMiddleware = _de
  var Y0 = (e) => {
    var t
    let n = e[0]
        .split(ht.UA_NAME_SEPARATOR)
        .map((c) => c.replace(ht.UA_NAME_ESCAPE_REGEX, ht.UA_ESCAPE_CHAR))
        .join(ht.UA_NAME_SEPARATOR),
      r =
        (t = e[1]) === null || t === void 0
          ? void 0
          : t.replace(ht.UA_VALUE_ESCAPE_REGEX, ht.UA_ESCAPE_CHAR),
      s = n.indexOf(ht.UA_NAME_SEPARATOR),
      o = n.substring(0, s),
      i = n.substring(s + 1)
    return (
      o === 'api' && (i = i.toLowerCase()),
      [o, i, r]
        .filter((c) => c && c.length > 0)
        .reduce((c, a, u) => {
          switch (u) {
            case 0:
              return a
            case 1:
              return `${c}/${a}`
            default:
              return `${c}#${a}`
          }
        }, '')
    )
  }
  Dn.getUserAgentMiddlewareOptions = {
    name: 'getUserAgentMiddleware',
    step: 'build',
    priority: 'low',
    tags: ['SET_USER_AGENT', 'USER_AGENT'],
    override: !0,
  }
  var hde = (e) => ({
    applyToStack: (t) => {
      t.add((0, Dn.userAgentMiddleware)(e), Dn.getUserAgentMiddlewareOptions)
    },
  })
  Dn.getUserAgentPlugin = hde
})
var du = l((jf) => {
  'use strict'
  Object.defineProperty(jf, '__esModule', { value: !0 })
  var IB = (x(), w(T))
  IB.__exportStar(EU(), jf)
  IB.__exportStar(xB(), jf)
})
var PB = l((So) => {
  'use strict'
  Object.defineProperty(So, '__esModule', { value: !0 })
  So.booleanSelector = So.SelectorType = void 0
  var yde
  ;(function (e) {
    ;(e.ENV = 'env'), (e.CONFIG = 'shared config entry')
  })((yde = So.SelectorType || (So.SelectorType = {})))
  var gde = (e, t, n) => {
    if (t in e) {
      if (e[t] === 'true') return !0
      if (e[t] === 'false') return !1
      throw new Error(
        `Cannot load ${n} "${t}". Expected "true" or "false", got ${e[t]}.`,
      )
    }
  }
  So.booleanSelector = gde
})
var J0 = l((K0) => {
  'use strict'
  Object.defineProperty(K0, '__esModule', { value: !0 })
  var Ede = (x(), w(T))
  Ede.__exportStar(PB(), K0)
})
var RB = l((Ht) => {
  'use strict'
  Object.defineProperty(Ht, '__esModule', { value: !0 })
  Ht.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS =
    Ht.DEFAULT_USE_DUALSTACK_ENDPOINT =
    Ht.CONFIG_USE_DUALSTACK_ENDPOINT =
    Ht.ENV_USE_DUALSTACK_ENDPOINT =
      void 0
  var Gf = J0()
  Ht.ENV_USE_DUALSTACK_ENDPOINT = 'AWS_USE_DUALSTACK_ENDPOINT'
  Ht.CONFIG_USE_DUALSTACK_ENDPOINT = 'use_dualstack_endpoint'
  Ht.DEFAULT_USE_DUALSTACK_ENDPOINT = !1
  Ht.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) =>
      (0, Gf.booleanSelector)(
        e,
        Ht.ENV_USE_DUALSTACK_ENDPOINT,
        Gf.SelectorType.ENV,
      ),
    configFileSelector: (e) =>
      (0, Gf.booleanSelector)(
        e,
        Ht.CONFIG_USE_DUALSTACK_ENDPOINT,
        Gf.SelectorType.CONFIG,
      ),
    default: !1,
  }
})
var DB = l((Wt) => {
  'use strict'
  Object.defineProperty(Wt, '__esModule', { value: !0 })
  Wt.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS =
    Wt.DEFAULT_USE_FIPS_ENDPOINT =
    Wt.CONFIG_USE_FIPS_ENDPOINT =
    Wt.ENV_USE_FIPS_ENDPOINT =
      void 0
  var $f = J0()
  Wt.ENV_USE_FIPS_ENDPOINT = 'AWS_USE_FIPS_ENDPOINT'
  Wt.CONFIG_USE_FIPS_ENDPOINT = 'use_fips_endpoint'
  Wt.DEFAULT_USE_FIPS_ENDPOINT = !1
  Wt.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) =>
      (0, $f.booleanSelector)(e, Wt.ENV_USE_FIPS_ENDPOINT, $f.SelectorType.ENV),
    configFileSelector: (e) =>
      (0, $f.booleanSelector)(
        e,
        Wt.CONFIG_USE_FIPS_ENDPOINT,
        $f.SelectorType.CONFIG,
      ),
    default: !1,
  }
})
var OB = l((zf) => {
  'use strict'
  Object.defineProperty(zf, '__esModule', { value: !0 })
  zf.resolveCustomEndpointsConfig = void 0
  var AB = fo(),
    Sde = (e) => {
      var t, n
      let { endpoint: r, urlParser: s } = e
      return {
        ...e,
        tls: (t = e.tls) !== null && t !== void 0 ? t : !0,
        endpoint: (0, AB.normalizeProvider)(typeof r == 'string' ? s(r) : r),
        isCustomEndpoint: !0,
        useDualstackEndpoint: (0, AB.normalizeProvider)(
          (n = e.useDualstackEndpoint) !== null && n !== void 0 ? n : !1,
        ),
      }
    }
  zf.resolveCustomEndpointsConfig = Sde
})
var NB = l((Hf) => {
  'use strict'
  Object.defineProperty(Hf, '__esModule', { value: !0 })
  Hf.getEndpointFromRegion = void 0
  var bde = async (e) => {
    var t
    let { tls: n = !0 } = e,
      r = await e.region()
    if (
      !new RegExp(
        /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/,
      ).test(r)
    )
      throw new Error('Invalid region in client config')
    let o = await e.useDualstackEndpoint(),
      i = await e.useFipsEndpoint(),
      { hostname: c } =
        (t = await e.regionInfoProvider(r, {
          useDualstackEndpoint: o,
          useFipsEndpoint: i,
        })) !== null && t !== void 0
          ? t
          : {}
    if (!c) throw new Error('Cannot resolve hostname from client config')
    return e.urlParser(`${n ? 'https:' : 'http:'}//${c}`)
  }
  Hf.getEndpointFromRegion = bde
})
var kB = l((Wf) => {
  'use strict'
  Object.defineProperty(Wf, '__esModule', { value: !0 })
  Wf.resolveEndpointsConfig = void 0
  var qB = fo(),
    vde = NB(),
    Cde = (e) => {
      var t, n
      let r = (0, qB.normalizeProvider)(
          (t = e.useDualstackEndpoint) !== null && t !== void 0 ? t : !1,
        ),
        { endpoint: s, useFipsEndpoint: o, urlParser: i } = e
      return {
        ...e,
        tls: (n = e.tls) !== null && n !== void 0 ? n : !0,
        endpoint: s
          ? (0, qB.normalizeProvider)(typeof s == 'string' ? i(s) : s)
          : () =>
              (0, vde.getEndpointFromRegion)({
                ...e,
                useDualstackEndpoint: r,
                useFipsEndpoint: o,
              }),
        isCustomEndpoint: !!s,
        useDualstackEndpoint: r,
      }
    }
  Wf.resolveEndpointsConfig = Cde
})
var MB = l((Oi) => {
  'use strict'
  Object.defineProperty(Oi, '__esModule', { value: !0 })
  var Vf = (x(), w(T))
  Vf.__exportStar(RB(), Oi)
  Vf.__exportStar(DB(), Oi)
  Vf.__exportStar(OB(), Oi)
  Vf.__exportStar(kB(), Oi)
})
var FB = l((Vt) => {
  'use strict'
  Object.defineProperty(Vt, '__esModule', { value: !0 })
  Vt.NODE_REGION_CONFIG_FILE_OPTIONS =
    Vt.NODE_REGION_CONFIG_OPTIONS =
    Vt.REGION_INI_NAME =
    Vt.REGION_ENV_NAME =
      void 0
  Vt.REGION_ENV_NAME = 'AWS_REGION'
  Vt.REGION_INI_NAME = 'region'
  Vt.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Vt.REGION_ENV_NAME],
    configFileSelector: (e) => e[Vt.REGION_INI_NAME],
    default: () => {
      throw new Error('Region is missing')
    },
  }
  Vt.NODE_REGION_CONFIG_FILE_OPTIONS = { preferredFile: 'credentials' }
})
var X0 = l((Yf) => {
  'use strict'
  Object.defineProperty(Yf, '__esModule', { value: !0 })
  Yf.isFipsRegion = void 0
  var wde = (e) =>
    typeof e == 'string' && (e.startsWith('fips-') || e.endsWith('-fips'))
  Yf.isFipsRegion = wde
})
var UB = l((Kf) => {
  'use strict'
  Object.defineProperty(Kf, '__esModule', { value: !0 })
  Kf.getRealRegion = void 0
  var Tde = X0(),
    xde = (e) =>
      (0, Tde.isFipsRegion)(e)
        ? ['fips-aws-global', 'aws-fips'].includes(e)
          ? 'us-east-1'
          : e.replace(/fips-(dkr-|prod-)?|-fips/, '')
        : e
  Kf.getRealRegion = xde
})
var BB = l((Jf) => {
  'use strict'
  Object.defineProperty(Jf, '__esModule', { value: !0 })
  Jf.resolveRegionConfig = void 0
  var LB = UB(),
    Ide = X0(),
    Pde = (e) => {
      let { region: t, useFipsEndpoint: n } = e
      if (!t) throw new Error('Region is missing')
      return {
        ...e,
        region: async () => {
          if (typeof t == 'string') return (0, LB.getRealRegion)(t)
          let r = await t()
          return (0, LB.getRealRegion)(r)
        },
        useFipsEndpoint: async () => {
          let r = typeof t == 'string' ? t : await t()
          return (0, Ide.isFipsRegion)(r)
            ? !0
            : typeof n != 'function'
            ? Promise.resolve(!!n)
            : n()
        },
      }
    }
  Jf.resolveRegionConfig = Pde
})
var GB = l((Xf) => {
  'use strict'
  Object.defineProperty(Xf, '__esModule', { value: !0 })
  var jB = (x(), w(T))
  jB.__exportStar(FB(), Xf)
  jB.__exportStar(BB(), Xf)
})
var zB = l(($B) => {
  'use strict'
  Object.defineProperty($B, '__esModule', { value: !0 })
})
var WB = l((HB) => {
  'use strict'
  Object.defineProperty(HB, '__esModule', { value: !0 })
})
var VB = l((Qf) => {
  'use strict'
  Object.defineProperty(Qf, '__esModule', { value: !0 })
  Qf.getHostnameFromVariants = void 0
  var Rde = (e = [], { useFipsEndpoint: t, useDualstackEndpoint: n }) => {
    var r
    return (r = e.find(
      ({ tags: s }) =>
        t === s.includes('fips') && n === s.includes('dualstack'),
    )) === null || r === void 0
      ? void 0
      : r.hostname
  }
  Qf.getHostnameFromVariants = Rde
})
var YB = l((Zf) => {
  'use strict'
  Object.defineProperty(Zf, '__esModule', { value: !0 })
  Zf.getResolvedHostname = void 0
  var Dde = (e, { regionHostname: t, partitionHostname: n }) =>
    t || (n ? n.replace('{region}', e) : void 0)
  Zf.getResolvedHostname = Dde
})
var KB = l((e_) => {
  'use strict'
  Object.defineProperty(e_, '__esModule', { value: !0 })
  e_.getResolvedPartition = void 0
  var Ade = (e, { partitionHash: t }) => {
    var n
    return (n = Object.keys(t || {}).find((r) => t[r].regions.includes(e))) !==
      null && n !== void 0
      ? n
      : 'aws'
  }
  e_.getResolvedPartition = Ade
})
var JB = l((t_) => {
  'use strict'
  Object.defineProperty(t_, '__esModule', { value: !0 })
  t_.getResolvedSigningRegion = void 0
  var Ode = (e, { signingRegion: t, regionRegex: n, useFipsEndpoint: r }) => {
    if (t) return t
    if (r) {
      let s = n
          .replace('\\\\', '\\')
          .replace(/^\^/g, '\\.')
          .replace(/\$$/g, '\\.'),
        o = e.match(s)
      if (o) return o[0].slice(1, -1)
    }
  }
  t_.getResolvedSigningRegion = Ode
})
var QB = l((n_) => {
  'use strict'
  Object.defineProperty(n_, '__esModule', { value: !0 })
  n_.getRegionInfo = void 0
  var XB = VB(),
    Nde = YB(),
    qde = KB(),
    kde = JB(),
    Mde = (
      e,
      {
        useFipsEndpoint: t = !1,
        useDualstackEndpoint: n = !1,
        signingService: r,
        regionHash: s,
        partitionHash: o,
      },
    ) => {
      var i, c, a, u, d, p
      let f = (0, qde.getResolvedPartition)(e, { partitionHash: o }),
        _ =
          e in s
            ? e
            : (c =
                (i = o[f]) === null || i === void 0 ? void 0 : i.endpoint) !==
                null && c !== void 0
            ? c
            : e,
        h = { useFipsEndpoint: t, useDualstackEndpoint: n },
        g = (0, XB.getHostnameFromVariants)(
          (a = s[_]) === null || a === void 0 ? void 0 : a.variants,
          h,
        ),
        E = (0, XB.getHostnameFromVariants)(
          (u = o[f]) === null || u === void 0 ? void 0 : u.variants,
          h,
        ),
        P = (0, Nde.getResolvedHostname)(_, {
          regionHostname: g,
          partitionHostname: E,
        })
      if (P === void 0)
        throw new Error(
          `Endpoint resolution failed for: ${{
            resolvedRegion: _,
            useFipsEndpoint: t,
            useDualstackEndpoint: n,
          }}`,
        )
      let z = (0, kde.getResolvedSigningRegion)(P, {
        signingRegion:
          (d = s[_]) === null || d === void 0 ? void 0 : d.signingRegion,
        regionRegex: o[f].regionRegex,
        useFipsEndpoint: t,
      })
      return {
        partition: f,
        signingService: r,
        hostname: P,
        ...(z && { signingRegion: z }),
        ...(((p = s[_]) === null || p === void 0
          ? void 0
          : p.signingService) && { signingService: s[_].signingService }),
      }
    }
  n_.getRegionInfo = Mde
})
var ZB = l((uu) => {
  'use strict'
  Object.defineProperty(uu, '__esModule', { value: !0 })
  var Q0 = (x(), w(T))
  Q0.__exportStar(zB(), uu)
  Q0.__exportStar(WB(), uu)
  Q0.__exportStar(QB(), uu)
})
var An = l((lu) => {
  'use strict'
  Object.defineProperty(lu, '__esModule', { value: !0 })
  var Z0 = (x(), w(T))
  Z0.__exportStar(MB(), lu)
  Z0.__exportStar(GB(), lu)
  Z0.__exportStar(ZB(), lu)
})
var mu = l((_r) => {
  'use strict'
  Object.defineProperty(_r, '__esModule', { value: !0 })
  _r.getContentLengthPlugin =
    _r.contentLengthMiddlewareOptions =
    _r.contentLengthMiddleware =
      void 0
  var Fde = tt(),
    ej = 'content-length'
  function tj(e) {
    return (t) => async (n) => {
      let r = n.request
      if (Fde.HttpRequest.isInstance(r)) {
        let { body: s, headers: o } = r
        if (
          s &&
          Object.keys(o)
            .map((i) => i.toLowerCase())
            .indexOf(ej) === -1
        )
          try {
            let i = e(s)
            r.headers = { ...r.headers, [ej]: String(i) }
          } catch {}
      }
      return t({ ...n, request: r })
    }
  }
  _r.contentLengthMiddleware = tj
  _r.contentLengthMiddlewareOptions = {
    step: 'build',
    tags: ['SET_CONTENT_LENGTH', 'CONTENT_LENGTH'],
    name: 'contentLengthMiddleware',
    override: !0,
  }
  var Ude = (e) => ({
    applyToStack: (t) => {
      t.add(tj(e.bodyLengthChecker), _r.contentLengthMiddlewareOptions)
    },
  })
  _r.getContentLengthPlugin = Ude
})
var nj = l((yt) => {
  'use strict'
  Object.defineProperty(yt, '__esModule', { value: !0 })
  yt.isArnBucketName =
    yt.isDnsCompatibleBucketName =
    yt.S3_HOSTNAME_PATTERN =
    yt.DOT_PATTERN =
    yt.resolveParamsForS3 =
      void 0
  var Lde = async (e) => {
    let t = e?.Bucket || ''
    if (
      (typeof e.Bucket == 'string' &&
        (e.Bucket = t
          .replace(/#/g, encodeURIComponent('#'))
          .replace(/\?/g, encodeURIComponent('?'))),
      (0, yt.isArnBucketName)(t))
    ) {
      if (e.ForcePathStyle === !0)
        throw new Error('Path-style addressing cannot be used with ARN buckets')
    } else
      (!(0, yt.isDnsCompatibleBucketName)(t) ||
        (t.indexOf('.') !== -1 && !String(e.Endpoint).startsWith('http:')) ||
        t.toLowerCase() !== t ||
        t.length < 3) &&
        (e.ForcePathStyle = !0)
    return (
      e.DisableMultiRegionAccessPoints &&
        ((e.disableMultiRegionAccessPoints = !0), (e.DisableMRAP = !0)),
      e
    )
  }
  yt.resolveParamsForS3 = Lde
  var Bde = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/,
    jde = /(\d+\.){3}\d+/,
    Gde = /\.\./
  yt.DOT_PATTERN = /\./
  yt.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./
  var $de = (e) => Bde.test(e) && !jde.test(e) && !Gde.test(e)
  yt.isDnsCompatibleBucketName = $de
  var zde = (e) => {
    let [t, n, r, s, o, i] = e.split(':'),
      c = t === 'arn' && e.split(':').length >= 6,
      a = [t, n, r, o, i].filter(Boolean).length === 5
    if (c && !a) throw new Error(`Invalid ARN: ${e} was an invalid ARN.`)
    return t === 'arn' && !!n && !!r && !!o && !!i
  }
  yt.isArnBucketName = zde
})
var rj = l((ew) => {
  'use strict'
  Object.defineProperty(ew, '__esModule', { value: !0 })
  var Hde = (x(), w(T))
  Hde.__exportStar(nj(), ew)
})
var sj = l((r_) => {
  'use strict'
  Object.defineProperty(r_, '__esModule', { value: !0 })
  r_.createConfigValueProvider = void 0
  var Wde = (e, t, n) => {
    let r = async () => {
      var s
      let o = (s = n[e]) !== null && s !== void 0 ? s : n[t]
      return typeof o == 'function' ? o() : o
    }
    return e === 'endpoint' || t === 'endpoint'
      ? async () => {
          let s = await r()
          if (s && typeof s == 'object') {
            if ('url' in s) return s.url.href
            if ('hostname' in s) {
              let { protocol: o, hostname: i, port: c, path: a } = s
              return `${o}//${i}${c ? ':' + c : ''}${a}`
            }
          }
          return s
        }
      : r
  }
  r_.createConfigValueProvider = Wde
})
var tw = l((bo) => {
  'use strict'
  Object.defineProperty(bo, '__esModule', { value: !0 })
  bo.resolveParams = bo.getEndpointFromInstructions = void 0
  var Vde = rj(),
    Yde = sj(),
    Kde = async (e, t, n, r) => {
      let s = await (0, bo.resolveParams)(e, t, n)
      if (typeof n.endpointProvider != 'function')
        throw new Error('config.endpointProvider is not set.')
      return n.endpointProvider(s, r)
    }
  bo.getEndpointFromInstructions = Kde
  var Jde = async (e, t, n) => {
    var r
    let s = {},
      o =
        ((r = t?.getEndpointParameterInstructions) === null || r === void 0
          ? void 0
          : r.call(t)) || {}
    for (let [i, c] of Object.entries(o))
      switch (c.type) {
        case 'staticContextParams':
          s[i] = c.value
          break
        case 'contextParams':
          s[i] = e[c.name]
          break
        case 'clientContextParams':
        case 'builtInParams':
          s[i] = await (0, Yde.createConfigValueProvider)(c.name, i, n)()
          break
        default:
          throw new Error(
            'Unrecognized endpoint parameter instruction: ' + JSON.stringify(c),
          )
      }
    return (
      Object.keys(o).length === 0 && Object.assign(s, n),
      String(n.serviceId).toLowerCase() === 's3' &&
        (await (0, Vde.resolveParamsForS3)(s)),
      s
    )
  }
  bo.resolveParams = Jde
})
var oj = l((s_) => {
  'use strict'
  Object.defineProperty(s_, '__esModule', { value: !0 })
  s_.parseQueryString = void 0
  function Xde(e) {
    let t = {}
    if (((e = e.replace(/^\?/, '')), e))
      for (let n of e.split('&')) {
        let [r, s = null] = n.split('=')
        ;(r = decodeURIComponent(r)),
          s && (s = decodeURIComponent(s)),
          r in t
            ? Array.isArray(t[r])
              ? t[r].push(s)
              : (t[r] = [t[r], s])
            : (t[r] = s)
      }
    return t
  }
  s_.parseQueryString = Xde
})
var vo = l((pu) => {
  'use strict'
  Object.defineProperty(pu, '__esModule', { value: !0 })
  pu.parseUrl = void 0
  var Qde = oj(),
    Zde = (e) => {
      if (typeof e == 'string') return (0, pu.parseUrl)(new URL(e))
      let { hostname: t, pathname: n, port: r, protocol: s, search: o } = e,
        i
      return (
        o && (i = (0, Qde.parseQueryString)(o)),
        {
          hostname: t,
          port: r ? parseInt(r) : void 0,
          protocol: s,
          path: n,
          query: i,
        }
      )
    }
  pu.parseUrl = Zde
})
var nw = l((o_) => {
  'use strict'
  Object.defineProperty(o_, '__esModule', { value: !0 })
  o_.toEndpointV1 = void 0
  var ij = vo(),
    eue = (e) =>
      typeof e == 'object'
        ? 'url' in e
          ? (0, ij.parseUrl)(e.url)
          : e
        : (0, ij.parseUrl)(e)
  o_.toEndpointV1 = eue
})
var cj = l((i_) => {
  'use strict'
  Object.defineProperty(i_, '__esModule', { value: !0 })
  var aj = (x(), w(T))
  aj.__exportStar(tw(), i_)
  aj.__exportStar(nw(), i_)
})
var rw = l((a_) => {
  'use strict'
  Object.defineProperty(a_, '__esModule', { value: !0 })
  a_.endpointMiddleware = void 0
  var tue = tw(),
    nue =
      ({ config: e, instructions: t }) =>
      (n, r) =>
      async (s) => {
        var o, i
        let c = await (0, tue.getEndpointFromInstructions)(
          s.input,
          {
            getEndpointParameterInstructions() {
              return t
            },
          },
          { ...e },
          r,
        )
        ;(r.endpointV2 = c),
          (r.authSchemes =
            (o = c.properties) === null || o === void 0
              ? void 0
              : o.authSchemes)
        let a = (i = r.authSchemes) === null || i === void 0 ? void 0 : i[0]
        return (
          a &&
            ((r.signing_region = a.signingRegion),
            (r.signing_service = a.signingName)),
          n({ ...s })
        )
      }
  a_.endpointMiddleware = nue
})
var sw = l((c_) => {
  'use strict'
  Object.defineProperty(c_, '__esModule', { value: !0 })
  c_.deserializerMiddleware = void 0
  var rue = (e, t) => (n, r) => async (s) => {
    let { response: o } = await n(s)
    try {
      let i = await t(o, e)
      return { response: o, output: i }
    } catch (i) {
      if (
        (Object.defineProperty(i, '$response', { value: o }),
        !('$metadata' in i))
      ) {
        let c =
          'Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.'
        i.message +=
          `
  ` + c
      }
      throw i
    }
  }
  c_.deserializerMiddleware = rue
})
var ow = l((d_) => {
  'use strict'
  Object.defineProperty(d_, '__esModule', { value: !0 })
  d_.serializerMiddleware = void 0
  var sue = (e, t) => (n, r) => async (s) => {
    var o
    let i =
      !((o = r.endpointV2) === null || o === void 0) && o.url && e.urlParser
        ? async () => e.urlParser(r.endpointV2.url)
        : e.endpoint
    if (!i) throw new Error('No valid endpoint provider available.')
    let c = await t(s.input, { ...e, endpoint: i })
    return n({ ...s, request: c })
  }
  d_.serializerMiddleware = sue
})
var dj = l((On) => {
  'use strict'
  Object.defineProperty(On, '__esModule', { value: !0 })
  On.getSerdePlugin =
    On.serializerMiddlewareOption =
    On.deserializerMiddlewareOption =
      void 0
  var oue = sw(),
    iue = ow()
  On.deserializerMiddlewareOption = {
    name: 'deserializerMiddleware',
    step: 'deserialize',
    tags: ['DESERIALIZER'],
    override: !0,
  }
  On.serializerMiddlewareOption = {
    name: 'serializerMiddleware',
    step: 'serialize',
    tags: ['SERIALIZER'],
    override: !0,
  }
  function aue(e, t, n) {
    return {
      applyToStack: (r) => {
        r.add(
          (0, oue.deserializerMiddleware)(e, n),
          On.deserializerMiddlewareOption,
        ),
          r.add(
            (0, iue.serializerMiddleware)(e, t),
            On.serializerMiddlewareOption,
          )
      },
    }
  }
  On.getSerdePlugin = aue
})
var O = l((fu) => {
  'use strict'
  Object.defineProperty(fu, '__esModule', { value: !0 })
  var iw = (x(), w(T))
  iw.__exportStar(sw(), fu)
  iw.__exportStar(dj(), fu)
  iw.__exportStar(ow(), fu)
})
var uj = l((Co) => {
  'use strict'
  Object.defineProperty(Co, '__esModule', { value: !0 })
  Co.getEndpointPlugin = Co.endpointMiddlewareOptions = void 0
  var cue = O(),
    due = rw()
  Co.endpointMiddlewareOptions = {
    step: 'serialize',
    tags: ['ENDPOINT_PARAMETERS', 'ENDPOINT_V2', 'ENDPOINT'],
    name: 'endpointV2Middleware',
    override: !0,
    relation: 'before',
    toMiddleware: cue.serializerMiddlewareOption.name,
  }
  var uue = (e, t) => ({
    applyToStack: (n) => {
      n.addRelativeTo(
        (0, due.endpointMiddleware)({ config: e, instructions: t }),
        Co.endpointMiddlewareOptions,
      )
    },
  })
  Co.getEndpointPlugin = uue
})
var lj = l((u_) => {
  'use strict'
  Object.defineProperty(u_, '__esModule', { value: !0 })
  u_.resolveEndpointConfig = void 0
  var aw = fo(),
    lue = nw(),
    mue = (e) => {
      var t, n, r
      let s = (t = e.tls) !== null && t !== void 0 ? t : !0,
        { endpoint: o } = e,
        i =
          o != null
            ? async () =>
                (0, lue.toEndpointV1)(await (0, aw.normalizeProvider)(o)())
            : void 0
      return {
        ...e,
        endpoint: i,
        tls: s,
        isCustomEndpoint: !!o,
        useDualstackEndpoint: (0, aw.normalizeProvider)(
          (n = e.useDualstackEndpoint) !== null && n !== void 0 ? n : !1,
        ),
        useFipsEndpoint: (0, aw.normalizeProvider)(
          (r = e.useFipsEndpoint) !== null && r !== void 0 ? r : !1,
        ),
      }
    }
  u_.resolveEndpointConfig = mue
})
var pj = l((mj) => {
  'use strict'
  Object.defineProperty(mj, '__esModule', { value: !0 })
})
var D = l((wo) => {
  'use strict'
  Object.defineProperty(wo, '__esModule', { value: !0 })
  var _u = (x(), w(T))
  _u.__exportStar(cj(), wo)
  _u.__exportStar(rw(), wo)
  _u.__exportStar(uj(), wo)
  _u.__exportStar(lj(), wo)
  _u.__exportStar(pj(), wo)
})
var l_ = l((hr) => {
  'use strict'
  Object.defineProperty(hr, '__esModule', { value: !0 })
  hr.DEFAULT_RETRY_MODE = hr.DEFAULT_MAX_ATTEMPTS = hr.RETRY_MODES = void 0
  var fj
  ;(function (e) {
    ;(e.STANDARD = 'standard'), (e.ADAPTIVE = 'adaptive')
  })((fj = hr.RETRY_MODES || (hr.RETRY_MODES = {})))
  hr.DEFAULT_MAX_ATTEMPTS = 3
  hr.DEFAULT_RETRY_MODE = fj.STANDARD
})
var _j = l((Yt) => {
  'use strict'
  Object.defineProperty(Yt, '__esModule', { value: !0 })
  Yt.NODEJS_TIMEOUT_ERROR_CODES =
    Yt.TRANSIENT_ERROR_STATUS_CODES =
    Yt.TRANSIENT_ERROR_CODES =
    Yt.THROTTLING_ERROR_CODES =
    Yt.CLOCK_SKEW_ERROR_CODES =
      void 0
  Yt.CLOCK_SKEW_ERROR_CODES = [
    'AuthFailure',
    'InvalidSignatureException',
    'RequestExpired',
    'RequestInTheFuture',
    'RequestTimeTooSkewed',
    'SignatureDoesNotMatch',
  ]
  Yt.THROTTLING_ERROR_CODES = [
    'BandwidthLimitExceeded',
    'EC2ThrottledException',
    'LimitExceededException',
    'PriorRequestNotComplete',
    'ProvisionedThroughputExceededException',
    'RequestLimitExceeded',
    'RequestThrottled',
    'RequestThrottledException',
    'SlowDown',
    'ThrottledException',
    'Throttling',
    'ThrottlingException',
    'TooManyRequestsException',
    'TransactionInProgressException',
  ]
  Yt.TRANSIENT_ERROR_CODES = [
    'TimeoutError',
    'RequestTimeout',
    'RequestTimeoutException',
  ]
  Yt.TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504]
  Yt.NODEJS_TIMEOUT_ERROR_CODES = [
    'ECONNRESET',
    'ECONNREFUSED',
    'EPIPE',
    'ETIMEDOUT',
  ]
})
var yu = l((Dt) => {
  'use strict'
  Object.defineProperty(Dt, '__esModule', { value: !0 })
  Dt.isServerError =
    Dt.isTransientError =
    Dt.isThrottlingError =
    Dt.isClockSkewError =
    Dt.isRetryableByTrait =
      void 0
  var hu = _j(),
    pue = (e) => e.$retryable !== void 0
  Dt.isRetryableByTrait = pue
  var fue = (e) => hu.CLOCK_SKEW_ERROR_CODES.includes(e.name)
  Dt.isClockSkewError = fue
  var _ue = (e) => {
    var t, n
    return (
      ((t = e.$metadata) === null || t === void 0
        ? void 0
        : t.httpStatusCode) === 429 ||
      hu.THROTTLING_ERROR_CODES.includes(e.name) ||
      ((n = e.$retryable) === null || n === void 0 ? void 0 : n.throttling) ==
        !0
    )
  }
  Dt.isThrottlingError = _ue
  var hue = (e) => {
    var t
    return (
      hu.TRANSIENT_ERROR_CODES.includes(e.name) ||
      hu.NODEJS_TIMEOUT_ERROR_CODES.includes(e?.code || '') ||
      hu.TRANSIENT_ERROR_STATUS_CODES.includes(
        ((t = e.$metadata) === null || t === void 0
          ? void 0
          : t.httpStatusCode) || 0,
      )
    )
  }
  Dt.isTransientError = hue
  var yue = (e) => {
    var t
    if (
      ((t = e.$metadata) === null || t === void 0
        ? void 0
        : t.httpStatusCode) !== void 0
    ) {
      let n = e.$metadata.httpStatusCode
      return 500 <= n && n <= 599 && !(0, Dt.isTransientError)(e)
    }
    return !1
  }
  Dt.isServerError = yue
})
var dw = l((m_) => {
  'use strict'
  Object.defineProperty(m_, '__esModule', { value: !0 })
  m_.DefaultRateLimiter = void 0
  var gue = yu(),
    cw = class {
      constructor(t) {
        var n, r, s, o, i
        ;(this.currentCapacity = 0),
          (this.enabled = !1),
          (this.lastMaxRate = 0),
          (this.measuredTxRate = 0),
          (this.requestCount = 0),
          (this.lastTimestamp = 0),
          (this.timeWindow = 0),
          (this.beta = (n = t?.beta) !== null && n !== void 0 ? n : 0.7),
          (this.minCapacity =
            (r = t?.minCapacity) !== null && r !== void 0 ? r : 1),
          (this.minFillRate =
            (s = t?.minFillRate) !== null && s !== void 0 ? s : 0.5),
          (this.scaleConstant =
            (o = t?.scaleConstant) !== null && o !== void 0 ? o : 0.4),
          (this.smooth = (i = t?.smooth) !== null && i !== void 0 ? i : 0.8)
        let c = this.getCurrentTimeInSeconds()
        ;(this.lastThrottleTime = c),
          (this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds())),
          (this.fillRate = this.minFillRate),
          (this.maxCapacity = this.minCapacity)
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3
      }
      async getSendToken() {
        return this.acquireTokenBucket(1)
      }
      async acquireTokenBucket(t) {
        if (this.enabled) {
          if ((this.refillTokenBucket(), t > this.currentCapacity)) {
            let n = ((t - this.currentCapacity) / this.fillRate) * 1e3
            await new Promise((r) => setTimeout(r, n))
          }
          this.currentCapacity = this.currentCapacity - t
        }
      }
      refillTokenBucket() {
        let t = this.getCurrentTimeInSeconds()
        if (!this.lastTimestamp) {
          this.lastTimestamp = t
          return
        }
        let n = (t - this.lastTimestamp) * this.fillRate
        ;(this.currentCapacity = Math.min(
          this.maxCapacity,
          this.currentCapacity + n,
        )),
          (this.lastTimestamp = t)
      }
      updateClientSendingRate(t) {
        let n
        if ((this.updateMeasuredRate(), (0, gue.isThrottlingError)(t))) {
          let s = this.enabled
            ? Math.min(this.measuredTxRate, this.fillRate)
            : this.measuredTxRate
          ;(this.lastMaxRate = s),
            this.calculateTimeWindow(),
            (this.lastThrottleTime = this.getCurrentTimeInSeconds()),
            (n = this.cubicThrottle(s)),
            this.enableTokenBucket()
        } else
          this.calculateTimeWindow(),
            (n = this.cubicSuccess(this.getCurrentTimeInSeconds()))
        let r = Math.min(n, 2 * this.measuredTxRate)
        this.updateTokenBucketRate(r)
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(
          Math.pow(
            (this.lastMaxRate * (1 - this.beta)) / this.scaleConstant,
            1 / 3,
          ),
        )
      }
      cubicThrottle(t) {
        return this.getPrecise(t * this.beta)
      }
      cubicSuccess(t) {
        return this.getPrecise(
          this.scaleConstant *
            Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) +
            this.lastMaxRate,
        )
      }
      enableTokenBucket() {
        this.enabled = !0
      }
      updateTokenBucketRate(t) {
        this.refillTokenBucket(),
          (this.fillRate = Math.max(t, this.minFillRate)),
          (this.maxCapacity = Math.max(t, this.minCapacity)),
          (this.currentCapacity = Math.min(
            this.currentCapacity,
            this.maxCapacity,
          ))
      }
      updateMeasuredRate() {
        let t = this.getCurrentTimeInSeconds(),
          n = Math.floor(t * 2) / 2
        if ((this.requestCount++, n > this.lastTxRateBucket)) {
          let r = this.requestCount / (n - this.lastTxRateBucket)
          ;(this.measuredTxRate = this.getPrecise(
            r * this.smooth + this.measuredTxRate * (1 - this.smooth),
          )),
            (this.requestCount = 0),
            (this.lastTxRateBucket = n)
        }
      }
      getPrecise(t) {
        return parseFloat(t.toFixed(8))
      }
    }
  m_.DefaultRateLimiter = cw
})
var Ni = l((Ne) => {
  'use strict'
  Object.defineProperty(Ne, '__esModule', { value: !0 })
  Ne.REQUEST_HEADER =
    Ne.INVOCATION_ID_HEADER =
    Ne.NO_RETRY_INCREMENT =
    Ne.TIMEOUT_RETRY_COST =
    Ne.RETRY_COST =
    Ne.INITIAL_RETRY_TOKENS =
    Ne.THROTTLING_RETRY_DELAY_BASE =
    Ne.MAXIMUM_RETRY_DELAY =
    Ne.DEFAULT_RETRY_DELAY_BASE =
      void 0
  Ne.DEFAULT_RETRY_DELAY_BASE = 100
  Ne.MAXIMUM_RETRY_DELAY = 20 * 1e3
  Ne.THROTTLING_RETRY_DELAY_BASE = 500
  Ne.INITIAL_RETRY_TOKENS = 500
  Ne.RETRY_COST = 5
  Ne.TIMEOUT_RETRY_COST = 10
  Ne.NO_RETRY_INCREMENT = 1
  Ne.INVOCATION_ID_HEADER = 'amz-sdk-invocation-id'
  Ne.REQUEST_HEADER = 'amz-sdk-request'
})
var yj = l((p_) => {
  'use strict'
  Object.defineProperty(p_, '__esModule', { value: !0 })
  p_.getDefaultRetryBackoffStrategy = void 0
  var hj = Ni(),
    Eue = () => {
      let e = hj.DEFAULT_RETRY_DELAY_BASE
      return {
        computeNextBackoffDelay: (r) =>
          Math.floor(
            Math.min(hj.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** r * e),
          ),
        setDelayBase: (r) => {
          e = r
        },
      }
    }
  p_.getDefaultRetryBackoffStrategy = Eue
})
var gj = l((f_) => {
  'use strict'
  Object.defineProperty(f_, '__esModule', { value: !0 })
  f_.createDefaultRetryToken = void 0
  var Sue = Ni(),
    bue = ({ retryDelay: e, retryCount: t, retryCost: n }) => ({
      getRetryCount: () => t,
      getRetryDelay: () => Math.min(Sue.MAXIMUM_RETRY_DELAY, e),
      getRetryCost: () => n,
    })
  f_.createDefaultRetryToken = bue
})
var h_ = l((__) => {
  'use strict'
  Object.defineProperty(__, '__esModule', { value: !0 })
  __.StandardRetryStrategy = void 0
  var uw = l_(),
    ts = Ni(),
    vue = yj(),
    Ej = gj(),
    lw = class {
      constructor(t) {
        ;(this.maxAttempts = t),
          (this.mode = uw.RETRY_MODES.STANDARD),
          (this.capacity = ts.INITIAL_RETRY_TOKENS),
          (this.retryBackoffStrategy = (0,
          vue.getDefaultRetryBackoffStrategy)()),
          (this.maxAttemptsProvider =
            typeof t == 'function' ? t : async () => t)
      }
      async acquireInitialRetryToken(t) {
        return (0, Ej.createDefaultRetryToken)({
          retryDelay: ts.DEFAULT_RETRY_DELAY_BASE,
          retryCount: 0,
        })
      }
      async refreshRetryTokenForRetry(t, n) {
        let r = await this.getMaxAttempts()
        if (this.shouldRetry(t, n, r)) {
          let s = n.errorType
          this.retryBackoffStrategy.setDelayBase(
            s === 'THROTTLING'
              ? ts.THROTTLING_RETRY_DELAY_BASE
              : ts.DEFAULT_RETRY_DELAY_BASE,
          )
          let o = this.retryBackoffStrategy.computeNextBackoffDelay(
              t.getRetryCount(),
            ),
            i = n.retryAfterHint
              ? Math.max(n.retryAfterHint.getTime() - Date.now() || 0, o)
              : o,
            c = this.getCapacityCost(s)
          return (
            (this.capacity -= c),
            (0, Ej.createDefaultRetryToken)({
              retryDelay: i,
              retryCount: t.getRetryCount() + 1,
              retryCost: c,
            })
          )
        }
        throw new Error('No retry token available')
      }
      recordSuccess(t) {
        var n
        this.capacity = Math.max(
          ts.INITIAL_RETRY_TOKENS,
          this.capacity +
            ((n = t.getRetryCost()) !== null && n !== void 0
              ? n
              : ts.NO_RETRY_INCREMENT),
        )
      }
      getCapacity() {
        return this.capacity
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider()
        } catch {
          return (
            console.warn(
              `Max attempts provider could not resolve. Using default of ${uw.DEFAULT_MAX_ATTEMPTS}`,
            ),
            uw.DEFAULT_MAX_ATTEMPTS
          )
        }
      }
      shouldRetry(t, n, r) {
        return (
          t.getRetryCount() + 1 < r &&
          this.capacity >= this.getCapacityCost(n.errorType) &&
          this.isRetryableError(n.errorType)
        )
      }
      getCapacityCost(t) {
        return t === 'TRANSIENT' ? ts.TIMEOUT_RETRY_COST : ts.RETRY_COST
      }
      isRetryableError(t) {
        return t === 'THROTTLING' || t === 'TRANSIENT'
      }
    }
  __.StandardRetryStrategy = lw
})
var Sj = l((y_) => {
  'use strict'
  Object.defineProperty(y_, '__esModule', { value: !0 })
  y_.AdaptiveRetryStrategy = void 0
  var Cue = l_(),
    wue = dw(),
    Tue = h_(),
    mw = class {
      constructor(t, n) {
        ;(this.maxAttemptsProvider = t), (this.mode = Cue.RETRY_MODES.ADAPTIVE)
        let { rateLimiter: r } = n ?? {}
        ;(this.rateLimiter = r ?? new wue.DefaultRateLimiter()),
          (this.standardRetryStrategy = new Tue.StandardRetryStrategy(t))
      }
      async acquireInitialRetryToken(t) {
        return (
          await this.rateLimiter.getSendToken(),
          this.standardRetryStrategy.acquireInitialRetryToken(t)
        )
      }
      async refreshRetryTokenForRetry(t, n) {
        return (
          this.rateLimiter.updateClientSendingRate(n),
          this.standardRetryStrategy.refreshRetryTokenForRetry(t, n)
        )
      }
      recordSuccess(t) {
        this.rateLimiter.updateClientSendingRate({}),
          this.standardRetryStrategy.recordSuccess(t)
      }
    }
  y_.AdaptiveRetryStrategy = mw
})
var bj = l((g_) => {
  'use strict'
  Object.defineProperty(g_, '__esModule', { value: !0 })
  g_.ConfiguredRetryStrategy = void 0
  var xue = Ni(),
    Iue = h_(),
    pw = class extends Iue.StandardRetryStrategy {
      constructor(t, n = xue.DEFAULT_RETRY_DELAY_BASE) {
        super(typeof t == 'function' ? t : async () => t),
          typeof n == 'number'
            ? (this.computeNextBackoffDelay = () => n)
            : (this.computeNextBackoffDelay = n)
      }
      async refreshRetryTokenForRetry(t, n) {
        let r = await super.refreshRetryTokenForRetry(t, n)
        return (
          (r.getRetryDelay = () =>
            this.computeNextBackoffDelay(r.getRetryCount())),
          r
        )
      }
    }
  g_.ConfiguredRetryStrategy = pw
})
var Cj = l((vj) => {
  'use strict'
  Object.defineProperty(vj, '__esModule', { value: !0 })
})
var Kt = l((yr) => {
  'use strict'
  Object.defineProperty(yr, '__esModule', { value: !0 })
  var To = (x(), w(T))
  To.__exportStar(Sj(), yr)
  To.__exportStar(bj(), yr)
  To.__exportStar(dw(), yr)
  To.__exportStar(h_(), yr)
  To.__exportStar(l_(), yr)
  To.__exportStar(Ni(), yr)
  To.__exportStar(Cj(), yr)
})
function gu() {
  return (
    E_ > S_.length - 16 && (wj.default.randomFillSync(S_), (E_ = 0)),
    S_.slice(E_, (E_ += 16))
  )
}
var wj,
  S_,
  E_,
  fw = ce(() => {
    ;(wj = ln(require('crypto'))), (S_ = new Uint8Array(256)), (E_ = S_.length)
  })
var Tj,
  xj = ce(() => {
    Tj =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  })
function Pue(e) {
  return typeof e == 'string' && Tj.test(e)
}
var ns,
  Eu = ce(() => {
    xj()
    ns = Pue
  })
function Rue(e, t = 0) {
  let n = (
    Ye[e[t + 0]] +
    Ye[e[t + 1]] +
    Ye[e[t + 2]] +
    Ye[e[t + 3]] +
    '-' +
    Ye[e[t + 4]] +
    Ye[e[t + 5]] +
    '-' +
    Ye[e[t + 6]] +
    Ye[e[t + 7]] +
    '-' +
    Ye[e[t + 8]] +
    Ye[e[t + 9]] +
    '-' +
    Ye[e[t + 10]] +
    Ye[e[t + 11]] +
    Ye[e[t + 12]] +
    Ye[e[t + 13]] +
    Ye[e[t + 14]] +
    Ye[e[t + 15]]
  ).toLowerCase()
  if (!ns(n)) throw TypeError('Stringified UUID is invalid')
  return n
}
var Ye,
  rs,
  Su = ce(() => {
    Eu()
    Ye = []
    for (let e = 0; e < 256; ++e) Ye.push((e + 256).toString(16).substr(1))
    rs = Rue
  })
function Due(e, t, n) {
  let r = (t && n) || 0,
    s = t || new Array(16)
  e = e || {}
  let o = e.node || Ij,
    i = e.clockseq !== void 0 ? e.clockseq : _w
  if (o == null || i == null) {
    let f = e.random || (e.rng || gu)()
    o == null && (o = Ij = [f[0] | 1, f[1], f[2], f[3], f[4], f[5]]),
      i == null && (i = _w = ((f[6] << 8) | f[7]) & 16383)
  }
  let c = e.msecs !== void 0 ? e.msecs : Date.now(),
    a = e.nsecs !== void 0 ? e.nsecs : yw + 1,
    u = c - hw + (a - yw) / 1e4
  if (
    (u < 0 && e.clockseq === void 0 && (i = (i + 1) & 16383),
    (u < 0 || c > hw) && e.nsecs === void 0 && (a = 0),
    a >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
  ;(hw = c), (yw = a), (_w = i), (c += 122192928e5)
  let d = ((c & 268435455) * 1e4 + a) % 4294967296
  ;(s[r++] = (d >>> 24) & 255),
    (s[r++] = (d >>> 16) & 255),
    (s[r++] = (d >>> 8) & 255),
    (s[r++] = d & 255)
  let p = ((c / 4294967296) * 1e4) & 268435455
  ;(s[r++] = (p >>> 8) & 255),
    (s[r++] = p & 255),
    (s[r++] = ((p >>> 24) & 15) | 16),
    (s[r++] = (p >>> 16) & 255),
    (s[r++] = (i >>> 8) | 128),
    (s[r++] = i & 255)
  for (let f = 0; f < 6; ++f) s[r + f] = o[f]
  return t || rs(s)
}
var Ij,
  _w,
  hw,
  yw,
  Pj,
  Rj = ce(() => {
    fw()
    Su()
    ;(hw = 0), (yw = 0)
    Pj = Due
  })
function Aue(e) {
  if (!ns(e)) throw TypeError('Invalid UUID')
  let t,
    n = new Uint8Array(16)
  return (
    (n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (n[1] = (t >>> 16) & 255),
    (n[2] = (t >>> 8) & 255),
    (n[3] = t & 255),
    (n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (n[5] = t & 255),
    (n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (n[7] = t & 255),
    (n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (n[9] = t & 255),
    (n[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (n[11] = (t / 4294967296) & 255),
    (n[12] = (t >>> 24) & 255),
    (n[13] = (t >>> 16) & 255),
    (n[14] = (t >>> 8) & 255),
    (n[15] = t & 255),
    n
  )
}
var b_,
  gw = ce(() => {
    Eu()
    b_ = Aue
  })
function Oue(e) {
  e = unescape(encodeURIComponent(e))
  let t = []
  for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n))
  return t
}
function v_(e, t, n) {
  function r(s, o, i, c) {
    if (
      (typeof s == 'string' && (s = Oue(s)),
      typeof o == 'string' && (o = b_(o)),
      o.length !== 16)
    )
      throw TypeError(
        'Namespace must be array-like (16 iterable integer values, 0-255)',
      )
    let a = new Uint8Array(16 + s.length)
    if (
      (a.set(o),
      a.set(s, o.length),
      (a = n(a)),
      (a[6] = (a[6] & 15) | t),
      (a[8] = (a[8] & 63) | 128),
      i)
    ) {
      c = c || 0
      for (let u = 0; u < 16; ++u) i[c + u] = a[u]
      return i
    }
    return rs(a)
  }
  try {
    r.name = e
  } catch {}
  return (r.DNS = Nue), (r.URL = que), r
}
var Nue,
  que,
  Ew = ce(() => {
    Su()
    gw()
    ;(Nue = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'),
      (que = '6ba7b811-9dad-11d1-80b4-00c04fd430c8')
  })
function kue(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    Dj.default.createHash('md5').update(e).digest()
  )
}
var Dj,
  Aj,
  Oj = ce(() => {
    Dj = ln(require('crypto'))
    Aj = kue
  })
var Mue,
  Nj,
  qj = ce(() => {
    Ew()
    Oj()
    ;(Mue = v_('v3', 48, Aj)), (Nj = Mue)
  })
function Fue(e, t, n) {
  e = e || {}
  let r = e.random || (e.rng || gu)()
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    n = n || 0
    for (let s = 0; s < 16; ++s) t[n + s] = r[s]
    return t
  }
  return rs(r)
}
var kj,
  Mj = ce(() => {
    fw()
    Su()
    kj = Fue
  })
function Uue(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    Fj.default.createHash('sha1').update(e).digest()
  )
}
var Fj,
  Uj,
  Lj = ce(() => {
    Fj = ln(require('crypto'))
    Uj = Uue
  })
var Lue,
  Bj,
  jj = ce(() => {
    Ew()
    Lj()
    ;(Lue = v_('v5', 80, Uj)), (Bj = Lue)
  })
var Gj,
  $j = ce(() => {
    Gj = '00000000-0000-0000-0000-000000000000'
  })
function Bue(e) {
  if (!ns(e)) throw TypeError('Invalid UUID')
  return parseInt(e.substr(14, 1), 16)
}
var zj,
  Hj = ce(() => {
    Eu()
    zj = Bue
  })
var Sw = {}
Mc(Sw, {
  NIL: () => Gj,
  parse: () => b_,
  stringify: () => rs,
  v1: () => Pj,
  v3: () => Nj,
  v4: () => kj,
  v5: () => Bj,
  validate: () => ns,
  version: () => zj,
})
var bw = ce(() => {
  Rj()
  qj()
  Mj()
  jj()
  $j()
  Hj()
  Eu()
  Su()
  gw()
})
var Wj = l((C_) => {
  'use strict'
  Object.defineProperty(C_, '__esModule', { value: !0 })
  C_.getDefaultRetryQuota = void 0
  var vw = Kt(),
    jue = (e, t) => {
      var n, r, s
      let o = e,
        i =
          (n = t?.noRetryIncrement) !== null && n !== void 0
            ? n
            : vw.NO_RETRY_INCREMENT,
        c = (r = t?.retryCost) !== null && r !== void 0 ? r : vw.RETRY_COST,
        a =
          (s = t?.timeoutRetryCost) !== null && s !== void 0
            ? s
            : vw.TIMEOUT_RETRY_COST,
        u = e,
        d = (h) => (h.name === 'TimeoutError' ? a : c),
        p = (h) => d(h) <= u
      return Object.freeze({
        hasRetryTokens: p,
        retrieveRetryTokens: (h) => {
          if (!p(h)) throw new Error('No retry token available')
          let g = d(h)
          return (u -= g), g
        },
        releaseRetryTokens: (h) => {
          ;(u += h ?? i), (u = Math.min(u, o))
        },
      })
    }
  C_.getDefaultRetryQuota = jue
})
var Cw = l((w_) => {
  'use strict'
  Object.defineProperty(w_, '__esModule', { value: !0 })
  w_.defaultDelayDecider = void 0
  var Gue = Kt(),
    $ue = (e, t) =>
      Math.floor(Math.min(Gue.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** t * e))
  w_.defaultDelayDecider = $ue
})
var ww = l((x_) => {
  'use strict'
  Object.defineProperty(x_, '__esModule', { value: !0 })
  x_.defaultRetryDecider = void 0
  var T_ = yu(),
    zue = (e) =>
      e
        ? (0, T_.isRetryableByTrait)(e) ||
          (0, T_.isClockSkewError)(e) ||
          (0, T_.isThrottlingError)(e) ||
          (0, T_.isTransientError)(e)
        : !1
  x_.defaultRetryDecider = zue
})
var Tw = l((I_) => {
  'use strict'
  Object.defineProperty(I_, '__esModule', { value: !0 })
  I_.asSdkError = void 0
  var Hue = (e) =>
    e instanceof Error
      ? e
      : e instanceof Object
      ? Object.assign(new Error(), e)
      : typeof e == 'string'
      ? new Error(e)
      : new Error(`AWS SDK error wrapper for ${e}`)
  I_.asSdkError = Hue
})
var Pw = l((P_) => {
  'use strict'
  Object.defineProperty(P_, '__esModule', { value: !0 })
  P_.StandardRetryStrategy = void 0
  var xw = tt(),
    Wue = yu(),
    xo = Kt(),
    Vue = (bw(), w(Sw)),
    Yue = Wj(),
    Kue = Cw(),
    Jue = ww(),
    Xue = Tw(),
    Iw = class {
      constructor(t, n) {
        var r, s, o
        ;(this.maxAttemptsProvider = t),
          (this.mode = xo.RETRY_MODES.STANDARD),
          (this.retryDecider =
            (r = n?.retryDecider) !== null && r !== void 0
              ? r
              : Jue.defaultRetryDecider),
          (this.delayDecider =
            (s = n?.delayDecider) !== null && s !== void 0
              ? s
              : Kue.defaultDelayDecider),
          (this.retryQuota =
            (o = n?.retryQuota) !== null && o !== void 0
              ? o
              : (0, Yue.getDefaultRetryQuota)(xo.INITIAL_RETRY_TOKENS))
      }
      shouldRetry(t, n, r) {
        return (
          n < r && this.retryDecider(t) && this.retryQuota.hasRetryTokens(t)
        )
      }
      async getMaxAttempts() {
        let t
        try {
          t = await this.maxAttemptsProvider()
        } catch {
          t = xo.DEFAULT_MAX_ATTEMPTS
        }
        return t
      }
      async retry(t, n, r) {
        let s,
          o = 0,
          i = 0,
          c = await this.getMaxAttempts(),
          { request: a } = n
        for (
          xw.HttpRequest.isInstance(a) &&
          (a.headers[xo.INVOCATION_ID_HEADER] = (0, Vue.v4)());
          ;

        )
          try {
            xw.HttpRequest.isInstance(a) &&
              (a.headers[xo.REQUEST_HEADER] = `attempt=${o + 1}; max=${c}`),
              r?.beforeRequest && (await r.beforeRequest())
            let { response: u, output: d } = await t(n)
            return (
              r?.afterRequest && r.afterRequest(u),
              this.retryQuota.releaseRetryTokens(s),
              (d.$metadata.attempts = o + 1),
              (d.$metadata.totalRetryDelay = i),
              { response: u, output: d }
            )
          } catch (u) {
            let d = (0, Xue.asSdkError)(u)
            if ((o++, this.shouldRetry(d, o, c))) {
              s = this.retryQuota.retrieveRetryTokens(d)
              let p = this.delayDecider(
                  (0, Wue.isThrottlingError)(d)
                    ? xo.THROTTLING_RETRY_DELAY_BASE
                    : xo.DEFAULT_RETRY_DELAY_BASE,
                  o,
                ),
                f = Que(d.$response),
                _ = Math.max(f || 0, p)
              ;(i += _), await new Promise((h) => setTimeout(h, _))
              continue
            }
            throw (
              (d.$metadata || (d.$metadata = {}),
              (d.$metadata.attempts = o),
              (d.$metadata.totalRetryDelay = i),
              d)
            )
          }
      }
    }
  P_.StandardRetryStrategy = Iw
  var Que = (e) => {
    if (!xw.HttpResponse.isInstance(e)) return
    let t = Object.keys(e.headers).find(
      (o) => o.toLowerCase() === 'retry-after',
    )
    if (!t) return
    let n = e.headers[t],
      r = Number(n)
    return Number.isNaN(r) ? new Date(n).getTime() - Date.now() : r * 1e3
  }
})
var Yj = l((R_) => {
  'use strict'
  Object.defineProperty(R_, '__esModule', { value: !0 })
  R_.AdaptiveRetryStrategy = void 0
  var Vj = Kt(),
    Zue = Pw(),
    Rw = class extends Zue.StandardRetryStrategy {
      constructor(t, n) {
        let { rateLimiter: r, ...s } = n ?? {}
        super(t, s),
          (this.rateLimiter = r ?? new Vj.DefaultRateLimiter()),
          (this.mode = Vj.RETRY_MODES.ADAPTIVE)
      }
      async retry(t, n) {
        return super.retry(t, n, {
          beforeRequest: async () => this.rateLimiter.getSendToken(),
          afterRequest: (r) => {
            this.rateLimiter.updateClientSendingRate(r)
          },
        })
      }
    }
  R_.AdaptiveRetryStrategy = Rw
})
var Jj = l((Pe) => {
  'use strict'
  Object.defineProperty(Pe, '__esModule', { value: !0 })
  Pe.NODE_RETRY_MODE_CONFIG_OPTIONS =
    Pe.CONFIG_RETRY_MODE =
    Pe.ENV_RETRY_MODE =
    Pe.resolveRetryConfig =
    Pe.NODE_MAX_ATTEMPT_CONFIG_OPTIONS =
    Pe.CONFIG_MAX_ATTEMPTS =
    Pe.ENV_MAX_ATTEMPTS =
      void 0
  var Kj = fo(),
    qi = Kt()
  Pe.ENV_MAX_ATTEMPTS = 'AWS_MAX_ATTEMPTS'
  Pe.CONFIG_MAX_ATTEMPTS = 'max_attempts'
  Pe.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => {
      let t = e[Pe.ENV_MAX_ATTEMPTS]
      if (!t) return
      let n = parseInt(t)
      if (Number.isNaN(n))
        throw new Error(
          `Environment variable ${Pe.ENV_MAX_ATTEMPTS} mast be a number, got "${t}"`,
        )
      return n
    },
    configFileSelector: (e) => {
      let t = e[Pe.CONFIG_MAX_ATTEMPTS]
      if (!t) return
      let n = parseInt(t)
      if (Number.isNaN(n))
        throw new Error(
          `Shared config file entry ${Pe.CONFIG_MAX_ATTEMPTS} mast be a number, got "${t}"`,
        )
      return n
    },
    default: qi.DEFAULT_MAX_ATTEMPTS,
  }
  var ele = (e) => {
    var t
    let { retryStrategy: n } = e,
      r = (0, Kj.normalizeProvider)(
        (t = e.maxAttempts) !== null && t !== void 0
          ? t
          : qi.DEFAULT_MAX_ATTEMPTS,
      )
    return {
      ...e,
      maxAttempts: r,
      retryStrategy: async () =>
        n ||
        ((await (0, Kj.normalizeProvider)(e.retryMode)()) ===
        qi.RETRY_MODES.ADAPTIVE
          ? new qi.AdaptiveRetryStrategy(r)
          : new qi.StandardRetryStrategy(r)),
    }
  }
  Pe.resolveRetryConfig = ele
  Pe.ENV_RETRY_MODE = 'AWS_RETRY_MODE'
  Pe.CONFIG_RETRY_MODE = 'retry_mode'
  Pe.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Pe.ENV_RETRY_MODE],
    configFileSelector: (e) => e[Pe.CONFIG_RETRY_MODE],
    default: qi.DEFAULT_RETRY_MODE,
  }
})
var Qj = l((Nn) => {
  'use strict'
  Object.defineProperty(Nn, '__esModule', { value: !0 })
  Nn.getOmitRetryHeadersPlugin =
    Nn.omitRetryHeadersMiddlewareOptions =
    Nn.omitRetryHeadersMiddleware =
      void 0
  var tle = tt(),
    Xj = Kt(),
    nle = () => (e) => async (t) => {
      let { request: n } = t
      return (
        tle.HttpRequest.isInstance(n) &&
          (delete n.headers[Xj.INVOCATION_ID_HEADER],
          delete n.headers[Xj.REQUEST_HEADER]),
        e(t)
      )
    }
  Nn.omitRetryHeadersMiddleware = nle
  Nn.omitRetryHeadersMiddlewareOptions = {
    name: 'omitRetryHeadersMiddleware',
    tags: ['RETRY', 'HEADERS', 'OMIT_RETRY_HEADERS'],
    relation: 'before',
    toMiddleware: 'awsAuthMiddleware',
    override: !0,
  }
  var rle = (e) => ({
    applyToStack: (t) => {
      t.addRelativeTo(
        (0, Nn.omitRetryHeadersMiddleware)(),
        Nn.omitRetryHeadersMiddlewareOptions,
      )
    },
  })
  Nn.getOmitRetryHeadersPlugin = rle
})
var eG = l((At) => {
  'use strict'
  Object.defineProperty(At, '__esModule', { value: !0 })
  At.getRetryAfterHint =
    At.getRetryPlugin =
    At.retryMiddlewareOptions =
    At.retryMiddleware =
      void 0
  var Aw = tt(),
    Dw = yu(),
    Zj = Kt(),
    sle = (bw(), w(Sw)),
    ole = Tw(),
    ile = (e) => (t, n) => async (r) => {
      let s = await e.retryStrategy(),
        o = await e.maxAttempts()
      if (ale(s)) {
        s = s
        let i = await s.acquireInitialRetryToken(n.partition_id),
          c = new Error(),
          a = 0,
          u = 0,
          { request: d } = r
        for (
          Aw.HttpRequest.isInstance(d) &&
          (d.headers[Zj.INVOCATION_ID_HEADER] = (0, sle.v4)());
          ;

        )
          try {
            Aw.HttpRequest.isInstance(d) &&
              (d.headers[Zj.REQUEST_HEADER] = `attempt=${a + 1}; max=${o}`)
            let { response: p, output: f } = await t(r)
            return (
              s.recordSuccess(i),
              (f.$metadata.attempts = a + 1),
              (f.$metadata.totalRetryDelay = u),
              { response: p, output: f }
            )
          } catch (p) {
            let f = cle(p)
            c = (0, ole.asSdkError)(p)
            try {
              i = await s.refreshRetryTokenForRetry(i, f)
            } catch {
              throw (
                (c.$metadata || (c.$metadata = {}),
                (c.$metadata.attempts = a + 1),
                (c.$metadata.totalRetryDelay = u),
                c)
              )
            }
            a = i.getRetryCount()
            let _ = i.getRetryDelay()
            ;(u += _), await new Promise((h) => setTimeout(h, _))
          }
      } else
        return (
          (s = s),
          s?.mode &&
            (n.userAgent = [
              ...(n.userAgent || []),
              ['cfg/retry-mode', s.mode],
            ]),
          s.retry(t, r)
        )
    }
  At.retryMiddleware = ile
  var ale = (e) =>
      typeof e.acquireInitialRetryToken < 'u' &&
      typeof e.refreshRetryTokenForRetry < 'u' &&
      typeof e.recordSuccess < 'u',
    cle = (e) => {
      let t = { errorType: dle(e) },
        n = (0, At.getRetryAfterHint)(e.$response)
      return n && (t.retryAfterHint = n), t
    },
    dle = (e) =>
      (0, Dw.isThrottlingError)(e)
        ? 'THROTTLING'
        : (0, Dw.isTransientError)(e)
        ? 'TRANSIENT'
        : (0, Dw.isServerError)(e)
        ? 'SERVER_ERROR'
        : 'CLIENT_ERROR'
  At.retryMiddlewareOptions = {
    name: 'retryMiddleware',
    tags: ['RETRY'],
    step: 'finalizeRequest',
    priority: 'high',
    override: !0,
  }
  var ule = (e) => ({
    applyToStack: (t) => {
      t.add((0, At.retryMiddleware)(e), At.retryMiddlewareOptions)
    },
  })
  At.getRetryPlugin = ule
  var lle = (e) => {
    if (!Aw.HttpResponse.isInstance(e)) return
    let t = Object.keys(e.headers).find(
      (o) => o.toLowerCase() === 'retry-after',
    )
    if (!t) return
    let n = e.headers[t],
      r = Number(n)
    return Number.isNaN(r) ? new Date(n) : new Date(r * 1e3)
  }
  At.getRetryAfterHint = lle
})
var Er = l((gr) => {
  'use strict'
  Object.defineProperty(gr, '__esModule', { value: !0 })
  var Io = (x(), w(T))
  Io.__exportStar(Yj(), gr)
  Io.__exportStar(Pw(), gr)
  Io.__exportStar(Jj(), gr)
  Io.__exportStar(Cw(), gr)
  Io.__exportStar(Qj(), gr)
  Io.__exportStar(ww(), gr)
  Io.__exportStar(eG(), gr)
})
var tG = l((D_) => {
  'use strict'
  Object.defineProperty(D_, '__esModule', { value: !0 })
  D_.NoOpLogger = void 0
  var Ow = class {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
  }
  D_.NoOpLogger = Ow
})
var sG = l((ki) => {
  'use strict'
  Object.defineProperty(ki, '__esModule', { value: !0 })
  ki.constructStack = void 0
  var mle = () => {
    let e = [],
      t = [],
      n = new Set(),
      r = (d) =>
        d.sort(
          (p, f) =>
            nG[f.step] - nG[p.step] ||
            rG[f.priority || 'normal'] - rG[p.priority || 'normal'],
        ),
      s = (d) => {
        let p = !1,
          f = (_) => (_.name && _.name === d ? ((p = !0), n.delete(d), !1) : !0)
        return (e = e.filter(f)), (t = t.filter(f)), p
      },
      o = (d) => {
        let p = !1,
          f = (_) =>
            _.middleware === d ? ((p = !0), _.name && n.delete(_.name), !1) : !0
        return (e = e.filter(f)), (t = t.filter(f)), p
      },
      i = (d) => (
        e.forEach((p) => {
          d.add(p.middleware, { ...p })
        }),
        t.forEach((p) => {
          d.addRelativeTo(p.middleware, { ...p })
        }),
        d
      ),
      c = (d) => {
        let p = []
        return (
          d.before.forEach((f) => {
            f.before.length === 0 && f.after.length === 0
              ? p.push(f)
              : p.push(...c(f))
          }),
          p.push(d),
          d.after.reverse().forEach((f) => {
            f.before.length === 0 && f.after.length === 0
              ? p.push(f)
              : p.push(...c(f))
          }),
          p
        )
      },
      a = (d = !1) => {
        let p = [],
          f = [],
          _ = {}
        return (
          e.forEach((g) => {
            let E = { ...g, before: [], after: [] }
            E.name && (_[E.name] = E), p.push(E)
          }),
          t.forEach((g) => {
            let E = { ...g, before: [], after: [] }
            E.name && (_[E.name] = E), f.push(E)
          }),
          f.forEach((g) => {
            if (g.toMiddleware) {
              let E = _[g.toMiddleware]
              if (E === void 0) {
                if (d) return
                throw new Error(
                  `${g.toMiddleware} is not found when adding ${
                    g.name || 'anonymous'
                  } middleware ${g.relation} ${g.toMiddleware}`,
                )
              }
              g.relation === 'after' && E.after.push(g),
                g.relation === 'before' && E.before.push(g)
            }
          }),
          r(p)
            .map(c)
            .reduce((g, E) => (g.push(...E), g), [])
        )
      },
      u = {
        add: (d, p = {}) => {
          let { name: f, override: _ } = p,
            h = { step: 'initialize', priority: 'normal', middleware: d, ...p }
          if (f) {
            if (n.has(f)) {
              if (!_) throw new Error(`Duplicate middleware name '${f}'`)
              let g = e.findIndex((P) => P.name === f),
                E = e[g]
              if (E.step !== h.step || E.priority !== h.priority)
                throw new Error(
                  `"${f}" middleware with ${E.priority} priority in ${E.step} step cannot be overridden by same-name middleware with ${h.priority} priority in ${h.step} step.`,
                )
              e.splice(g, 1)
            }
            n.add(f)
          }
          e.push(h)
        },
        addRelativeTo: (d, p) => {
          let { name: f, override: _ } = p,
            h = { middleware: d, ...p }
          if (f) {
            if (n.has(f)) {
              if (!_) throw new Error(`Duplicate middleware name '${f}'`)
              let g = t.findIndex((P) => P.name === f),
                E = t[g]
              if (
                E.toMiddleware !== h.toMiddleware ||
                E.relation !== h.relation
              )
                throw new Error(
                  `"${f}" middleware ${E.relation} "${E.toMiddleware}" middleware cannot be overridden by same-name middleware ${h.relation} "${h.toMiddleware}" middleware.`,
                )
              t.splice(g, 1)
            }
            n.add(f)
          }
          t.push(h)
        },
        clone: () => i((0, ki.constructStack)()),
        use: (d) => {
          d.applyToStack(u)
        },
        remove: (d) => (typeof d == 'string' ? s(d) : o(d)),
        removeByTag: (d) => {
          let p = !1,
            f = (_) => {
              let { tags: h, name: g } = _
              return h && h.includes(d) ? (g && n.delete(g), (p = !0), !1) : !0
            }
          return (e = e.filter(f)), (t = t.filter(f)), p
        },
        concat: (d) => {
          let p = i((0, ki.constructStack)())
          return p.use(d), p
        },
        applyToStack: i,
        identify: () =>
          a(!0).map((d) => d.name + ': ' + (d.tags || []).join(',')),
        resolve: (d, p) => {
          for (let f of a()
            .map((_) => _.middleware)
            .reverse())
            d = f(d, p)
          return d
        },
      }
    return u
  }
  ki.constructStack = mle
  var nG = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1,
    },
    rG = { high: 3, normal: 2, low: 1 }
})
var qw = l((Nw) => {
  'use strict'
  Object.defineProperty(Nw, '__esModule', { value: !0 })
  var ple = (x(), w(T))
  ple.__exportStar(sG(), Nw)
})
var oG = l((A_) => {
  'use strict'
  Object.defineProperty(A_, '__esModule', { value: !0 })
  A_.Client = void 0
  var fle = qw(),
    kw = class {
      constructor(t) {
        ;(this.middlewareStack = (0, fle.constructStack)()), (this.config = t)
      }
      send(t, n, r) {
        let s = typeof n != 'function' ? n : void 0,
          o = typeof n == 'function' ? n : r,
          i = t.resolveMiddleware(this.middlewareStack, this.config, s)
        if (o)
          i(t)
            .then(
              (c) => o(null, c.output),
              (c) => o(c),
            )
            .catch(() => {})
        else return i(t).then((c) => c.output)
      }
      destroy() {
        this.config.requestHandler.destroy &&
          this.config.requestHandler.destroy()
      }
    }
  A_.Client = kw
})
var iG = l((O_) => {
  'use strict'
  Object.defineProperty(O_, '__esModule', { value: !0 })
  O_.fromBase64 = void 0
  var _le = _o(),
    hle = /^[A-Za-z0-9+/]*={0,2}$/,
    yle = (e) => {
      if ((e.length * 3) % 4 !== 0)
        throw new TypeError('Incorrect padding on base64 string.')
      if (!hle.exec(e)) throw new TypeError('Invalid base64 string.')
      let t = (0, _le.fromString)(e, 'base64')
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
    }
  O_.fromBase64 = yle
})
var aG = l((N_) => {
  'use strict'
  Object.defineProperty(N_, '__esModule', { value: !0 })
  N_.toBase64 = void 0
  var gle = _o(),
    Ele = (e) =>
      (0, gle.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength).toString(
        'base64',
      )
  N_.toBase64 = Ele
})
var Mi = l((q_) => {
  'use strict'
  Object.defineProperty(q_, '__esModule', { value: !0 })
  var cG = (x(), w(T))
  cG.__exportStar(iG(), q_)
  cG.__exportStar(aG(), q_)
})
var mG = l((Fi) => {
  'use strict'
  Object.defineProperty(Fi, '__esModule', { value: !0 })
  Fi.transformFromString = Fi.transformToString = void 0
  var uG = Mi(),
    lG = Pn(),
    dG = Mw()
  function Sle(e, t = 'utf-8') {
    return t === 'base64' ? (0, uG.toBase64)(e) : (0, lG.toUtf8)(e)
  }
  Fi.transformToString = Sle
  function ble(e, t) {
    return t === 'base64'
      ? dG.Uint8ArrayBlobAdapter.mutate((0, uG.fromBase64)(e))
      : dG.Uint8ArrayBlobAdapter.mutate((0, lG.fromUtf8)(e))
  }
  Fi.transformFromString = ble
})
var Mw = l((k_) => {
  'use strict'
  Object.defineProperty(k_, '__esModule', { value: !0 })
  k_.Uint8ArrayBlobAdapter = void 0
  var pG = mG(),
    Fw = class e extends Uint8Array {
      static fromString(t, n = 'utf-8') {
        switch (typeof t) {
          case 'string':
            return (0, pG.transformFromString)(t, n)
          default:
            throw new Error(
              `Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`,
            )
        }
      }
      static mutate(t) {
        return Object.setPrototypeOf(t, e.prototype), t
      }
      transformToString(t = 'utf-8') {
        return (0, pG.transformToString)(this, t)
      }
    }
  k_.Uint8ArrayBlobAdapter = Fw
})
var fG = l((M_) => {
  'use strict'
  Object.defineProperty(M_, '__esModule', { value: !0 })
  M_.getAwsChunkedEncodingStream = void 0
  var vle = require('stream'),
    Cle = (e, t) => {
      let {
          base64Encoder: n,
          bodyLengthChecker: r,
          checksumAlgorithmFn: s,
          checksumLocationName: o,
          streamHasher: i,
        } = t,
        c = n !== void 0 && s !== void 0 && o !== void 0 && i !== void 0,
        a = c ? i(s, e) : void 0,
        u = new vle.Readable({ read: () => {} })
      return (
        e.on('data', (d) => {
          let p = r(d) || 0
          u.push(`${p.toString(16)}\r
`),
            u.push(d),
            u.push(`\r
`)
        }),
        e.on('end', async () => {
          if (
            (u.push(`0\r
`),
            c)
          ) {
            let d = n(await a)
            u.push(`${o}:${d}\r
`),
              u.push(`\r
`)
          }
          u.push(null)
        }),
        u
      )
    }
  M_.getAwsChunkedEncodingStream = Cle
})
var Lw = l((F_) => {
  'use strict'
  Object.defineProperty(F_, '__esModule', { value: !0 })
  F_.buildQueryString = void 0
  var Uw = w0()
  function wle(e) {
    let t = []
    for (let n of Object.keys(e).sort()) {
      let r = e[n]
      if (((n = (0, Uw.escapeUri)(n)), Array.isArray(r)))
        for (let s = 0, o = r.length; s < o; s++)
          t.push(`${n}=${(0, Uw.escapeUri)(r[s])}`)
      else {
        let s = n
        ;(r || typeof r == 'string') && (s += `=${(0, Uw.escapeUri)(r)}`),
          t.push(s)
      }
    }
    return t.join('&')
  }
  F_.buildQueryString = wle
})
var _G = l((U_) => {
  'use strict'
  Object.defineProperty(U_, '__esModule', { value: !0 })
  U_.NODEJS_TIMEOUT_ERROR_CODES = void 0
  U_.NODEJS_TIMEOUT_ERROR_CODES = ['ECONNRESET', 'EPIPE', 'ETIMEDOUT']
})
var Bw = l((L_) => {
  'use strict'
  Object.defineProperty(L_, '__esModule', { value: !0 })
  L_.getTransformedHeaders = void 0
  var Tle = (e) => {
    let t = {}
    for (let n of Object.keys(e)) {
      let r = e[n]
      t[n] = Array.isArray(r) ? r.join(',') : r
    }
    return t
  }
  L_.getTransformedHeaders = Tle
})
var hG = l((B_) => {
  'use strict'
  Object.defineProperty(B_, '__esModule', { value: !0 })
  B_.setConnectionTimeout = void 0
  var xle = (e, t, n = 0) => {
    if (!n) return
    let r = setTimeout(() => {
      e.destroy(),
        t(
          Object.assign(
            new Error(
              `Socket timed out without establishing a connection within ${n} ms`,
            ),
            { name: 'TimeoutError' },
          ),
        )
    }, n)
    e.on('socket', (s) => {
      s.connecting
        ? s.on('connect', () => {
            clearTimeout(r)
          })
        : clearTimeout(r)
    })
  }
  B_.setConnectionTimeout = xle
})
var yG = l((j_) => {
  'use strict'
  Object.defineProperty(j_, '__esModule', { value: !0 })
  j_.setSocketKeepAlive = void 0
  var Ile = (e, { keepAlive: t, keepAliveMsecs: n }) => {
    t === !0 &&
      e.on('socket', (r) => {
        r.setKeepAlive(t, n || 0)
      })
  }
  j_.setSocketKeepAlive = Ile
})
var gG = l((G_) => {
  'use strict'
  Object.defineProperty(G_, '__esModule', { value: !0 })
  G_.setSocketTimeout = void 0
  var Ple = (e, t, n = 0) => {
    e.setTimeout(n, () => {
      e.destroy(),
        t(
          Object.assign(new Error(`Connection timed out after ${n} ms`), {
            name: 'TimeoutError',
          }),
        )
    })
  }
  G_.setSocketTimeout = Ple
})
var jw = l(($_) => {
  'use strict'
  Object.defineProperty($_, '__esModule', { value: !0 })
  $_.writeRequestBody = void 0
  var Rle = require('stream'),
    EG = 1e3
  async function Dle(e, t, n = EG) {
    var r
    let s = (r = t.headers) !== null && r !== void 0 ? r : {},
      o = s.Expect || s.expect,
      i = -1,
      c = !1
    o === '100-continue' &&
      (await Promise.race([
        new Promise((a) => {
          i = Number(setTimeout(a, Math.max(EG, n)))
        }),
        new Promise((a) => {
          e.on('continue', () => {
            clearTimeout(i), a()
          }),
            e.on('error', () => {
              ;(c = !0), clearTimeout(i), a()
            })
        }),
      ])),
      c || Ale(e, t.body)
  }
  $_.writeRequestBody = Dle
  function Ale(e, t) {
    t instanceof Rle.Readable ? t.pipe(e) : t ? e.end(Buffer.from(t)) : e.end()
  }
})
var vG = l((Ui) => {
  'use strict'
  Object.defineProperty(Ui, '__esModule', { value: !0 })
  Ui.NodeHttpHandler = Ui.DEFAULT_REQUEST_TIMEOUT = void 0
  var Ole = tt(),
    Nle = Lw(),
    SG = require('http'),
    bG = require('https'),
    qle = _G(),
    kle = Bw(),
    Mle = hG(),
    Fle = yG(),
    Ule = gG(),
    Lle = jw()
  Ui.DEFAULT_REQUEST_TIMEOUT = 0
  var Gw = class {
    constructor(t) {
      ;(this.metadata = { handlerProtocol: 'http/1.1' }),
        (this.configProvider = new Promise((n, r) => {
          typeof t == 'function'
            ? t()
                .then((s) => {
                  n(this.resolveDefaultConfig(s))
                })
                .catch(r)
            : n(this.resolveDefaultConfig(t))
        }))
    }
    resolveDefaultConfig(t) {
      let {
          requestTimeout: n,
          connectionTimeout: r,
          socketTimeout: s,
          httpAgent: o,
          httpsAgent: i,
        } = t || {},
        c = !0,
        a = 50
      return {
        connectionTimeout: r,
        requestTimeout: n ?? s,
        httpAgent: o || new SG.Agent({ keepAlive: c, maxSockets: a }),
        httpsAgent: i || new bG.Agent({ keepAlive: c, maxSockets: a }),
      }
    }
    destroy() {
      var t, n, r, s
      ;(n =
        (t = this.config) === null || t === void 0 ? void 0 : t.httpAgent) ===
        null ||
        n === void 0 ||
        n.destroy(),
        (s =
          (r = this.config) === null || r === void 0
            ? void 0
            : r.httpsAgent) === null ||
          s === void 0 ||
          s.destroy()
    }
    async handle(t, { abortSignal: n } = {}) {
      return (
        this.config || (this.config = await this.configProvider),
        new Promise((r, s) => {
          var o, i
          let c,
            a = async (z) => {
              await c, r(z)
            },
            u = async (z) => {
              await c, s(z)
            }
          if (!this.config)
            throw new Error('Node HTTP request handler config is not resolved')
          if (n?.aborted) {
            let z = new Error('Request aborted')
            ;(z.name = 'AbortError'), u(z)
            return
          }
          let d = t.protocol === 'https:',
            p = (0, Nle.buildQueryString)(t.query || {}),
            f
          if (t.username != null || t.password != null) {
            let z = (o = t.username) !== null && o !== void 0 ? o : '',
              ye = (i = t.password) !== null && i !== void 0 ? i : ''
            f = `${z}:${ye}`
          }
          let _ = t.path
          p && (_ += `?${p}`), t.fragment && (_ += `#${t.fragment}`)
          let h = {
              headers: t.headers,
              host: t.hostname,
              method: t.method,
              path: _,
              port: t.port,
              agent: d ? this.config.httpsAgent : this.config.httpAgent,
              auth: f,
            },
            E = (d ? bG.request : SG.request)(h, (z) => {
              let ye = new Ole.HttpResponse({
                statusCode: z.statusCode || -1,
                reason: z.statusMessage,
                headers: (0, kle.getTransformedHeaders)(z.headers),
                body: z,
              })
              a({ response: ye })
            })
          E.on('error', (z) => {
            qle.NODEJS_TIMEOUT_ERROR_CODES.includes(z.code)
              ? u(Object.assign(z, { name: 'TimeoutError' }))
              : u(z)
          }),
            (0, Mle.setConnectionTimeout)(E, u, this.config.connectionTimeout),
            (0, Ule.setSocketTimeout)(E, u, this.config.requestTimeout),
            n &&
              (n.onabort = () => {
                E.abort()
                let z = new Error('Request aborted')
                ;(z.name = 'AbortError'), u(z)
              })
          let P = h.agent
          typeof P == 'object' &&
            'keepAlive' in P &&
            (0, Fle.setSocketKeepAlive)(E, {
              keepAlive: P.keepAlive,
              keepAliveMsecs: P.keepAliveMsecs,
            }),
            (c = (0, Lle.writeRequestBody)(
              E,
              t,
              this.config.requestTimeout,
            ).catch(s))
        })
      )
    }
  }
  Ui.NodeHttpHandler = Gw
})
var CG = l((z_) => {
  'use strict'
  Object.defineProperty(z_, '__esModule', { value: !0 })
  z_.NodeHttp2ConnectionPool = void 0
  var $w = class {
    constructor(t) {
      ;(this.sessions = []), (this.sessions = t ?? [])
    }
    poll() {
      if (this.sessions.length > 0) return this.sessions.shift()
    }
    offerLast(t) {
      this.sessions.push(t)
    }
    contains(t) {
      return this.sessions.includes(t)
    }
    remove(t) {
      this.sessions = this.sessions.filter((n) => n !== t)
    }
    [Symbol.iterator]() {
      return this.sessions[Symbol.iterator]()
    }
    destroy(t) {
      for (let n of this.sessions) n === t && (n.destroyed || n.destroy())
    }
  }
  z_.NodeHttp2ConnectionPool = $w
})
var wG = l((H_) => {
  'use strict'
  Object.defineProperty(H_, '__esModule', { value: !0 })
  H_.NodeHttp2ConnectionManager = void 0
  var Ble = (x(), w(T)),
    jle = Ble.__importDefault(require('http2')),
    Gle = CG(),
    zw = class {
      constructor(t) {
        if (
          ((this.sessionCache = new Map()),
          (this.config = t),
          this.config.maxConcurrency && this.config.maxConcurrency <= 0)
        )
          throw new RangeError('maxConcurrency must be greater than zero.')
      }
      lease(t, n) {
        let r = this.getUrlString(t),
          s = this.sessionCache.get(r)
        if (s) {
          let a = s.poll()
          if (a && !this.config.disableConcurrency) return a
        }
        let o = jle.default.connect(r)
        this.config.maxConcurrency &&
          o.settings(
            { maxConcurrentStreams: this.config.maxConcurrency },
            (a) => {
              if (a)
                throw new Error(
                  'Fail to set maxConcurrentStreams to ' +
                    this.config.maxConcurrency +
                    'when creating new session for ' +
                    t.destination.toString(),
                )
            },
          ),
          o.unref()
        let i = () => {
          o.destroy(), this.deleteSession(r, o)
        }
        o.on('goaway', i),
          o.on('error', i),
          o.on('frameError', i),
          o.on('close', () => this.deleteSession(r, o)),
          n.requestTimeout && o.setTimeout(n.requestTimeout, i)
        let c = this.sessionCache.get(r) || new Gle.NodeHttp2ConnectionPool()
        return c.offerLast(o), this.sessionCache.set(r, c), o
      }
      deleteSession(t, n) {
        let r = this.sessionCache.get(t)
        r && r.contains(n) && (r.remove(n), this.sessionCache.set(t, r))
      }
      release(t, n) {
        var r
        let s = this.getUrlString(t)
        ;(r = this.sessionCache.get(s)) === null ||
          r === void 0 ||
          r.offerLast(n)
      }
      destroy() {
        for (let [t, n] of this.sessionCache) {
          for (let r of n) r.destroyed || r.destroy(), n.remove(r)
          this.sessionCache.delete(t)
        }
      }
      setMaxConcurrentStreams(t) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0)
          throw new RangeError(
            'maxConcurrentStreams must be greater than zero.',
          )
        this.config.maxConcurrency = t
      }
      setDisableConcurrentStreams(t) {
        this.config.disableConcurrency = t
      }
      getUrlString(t) {
        return t.destination.toString()
      }
    }
  H_.NodeHttp2ConnectionManager = zw
})
var xG = l((W_) => {
  'use strict'
  Object.defineProperty(W_, '__esModule', { value: !0 })
  W_.NodeHttp2Handler = void 0
  var $le = tt(),
    zle = Lw(),
    TG = require('http2'),
    Hle = Bw(),
    Wle = wG(),
    Vle = jw(),
    Hw = class {
      constructor(t) {
        ;(this.metadata = { handlerProtocol: 'h2' }),
          (this.connectionManager = new Wle.NodeHttp2ConnectionManager({})),
          (this.configProvider = new Promise((n, r) => {
            typeof t == 'function'
              ? t()
                  .then((s) => {
                    n(s || {})
                  })
                  .catch(r)
              : n(t || {})
          }))
      }
      destroy() {
        this.connectionManager.destroy()
      }
      async handle(t, { abortSignal: n } = {}) {
        this.config ||
          ((this.config = await this.configProvider),
          this.connectionManager.setDisableConcurrentStreams(
            this.config.disableConcurrentStreams || !1,
          ),
          this.config.maxConcurrentStreams &&
            this.connectionManager.setMaxConcurrentStreams(
              this.config.maxConcurrentStreams,
            ))
        let { requestTimeout: r, disableConcurrentStreams: s } = this.config
        return new Promise((o, i) => {
          var c, a, u
          let d = !1,
            p,
            f = async (Ce) => {
              await p, o(Ce)
            },
            _ = async (Ce) => {
              await p, i(Ce)
            }
          if (n?.aborted) {
            d = !0
            let Ce = new Error('Request aborted')
            ;(Ce.name = 'AbortError'), _(Ce)
            return
          }
          let { hostname: h, method: g, port: E, protocol: P, query: z } = t,
            ye = ''
          if (t.username != null || t.password != null) {
            let Ce = (c = t.username) !== null && c !== void 0 ? c : '',
              kc = (a = t.password) !== null && a !== void 0 ? a : ''
            ye = `${Ce}:${kc}@`
          }
          let fe = `${P}//${ye}${h}${E ? `:${E}` : ''}`,
            xe = { destination: new URL(fe) },
            Q = this.connectionManager.lease(xe, {
              requestTimeout:
                (u = this.config) === null || u === void 0
                  ? void 0
                  : u.sessionTimeout,
              disableConcurrentStreams: s || !1,
            }),
            De = (Ce) => {
              s && this.destroySession(Q), (d = !0), _(Ce)
            },
            bt = (0, zle.buildQueryString)(z || {}),
            Ls = t.path
          bt && (Ls += `?${bt}`), t.fragment && (Ls += `#${t.fragment}`)
          let vt = Q.request({
            ...t.headers,
            [TG.constants.HTTP2_HEADER_PATH]: Ls,
            [TG.constants.HTTP2_HEADER_METHOD]: g,
          })
          Q.ref(),
            vt.on('response', (Ce) => {
              let kc = new $le.HttpResponse({
                statusCode: Ce[':status'] || -1,
                headers: (0, Hle.getTransformedHeaders)(Ce),
                body: vt,
              })
              ;(d = !0),
                f({ response: kc }),
                s && (Q.close(), this.connectionManager.deleteSession(fe, Q))
            }),
            r &&
              vt.setTimeout(r, () => {
                vt.close()
                let Ce = new Error(
                  `Stream timed out because of no activity for ${r} ms`,
                )
                ;(Ce.name = 'TimeoutError'), De(Ce)
              }),
            n &&
              (n.onabort = () => {
                vt.close()
                let Ce = new Error('Request aborted')
                ;(Ce.name = 'AbortError'), De(Ce)
              }),
            vt.on('frameError', (Ce, kc, K4) => {
              De(
                new Error(
                  `Frame type id ${Ce} in stream id ${K4} has failed with code ${kc}.`,
                ),
              )
            }),
            vt.on('error', De),
            vt.on('aborted', () => {
              De(
                new Error(
                  `HTTP/2 stream is abnormally aborted in mid-communication with result code ${vt.rstCode}.`,
                ),
              )
            }),
            vt.on('close', () => {
              Q.unref(),
                s && Q.destroy(),
                d ||
                  De(
                    new Error(
                      'Unexpected error: http2 request did not get a response',
                    ),
                  )
            }),
            (p = (0, Vle.writeRequestBody)(vt, t, r))
        })
      }
      destroySession(t) {
        t.destroyed || t.destroy()
      }
    }
  W_.NodeHttp2Handler = Hw
})
var IG = l((V_) => {
  'use strict'
  Object.defineProperty(V_, '__esModule', { value: !0 })
  V_.Collector = void 0
  var Yle = require('stream'),
    Ww = class extends Yle.Writable {
      constructor() {
        super(...arguments), (this.bufferedBytes = [])
      }
      _write(t, n, r) {
        this.bufferedBytes.push(t), r()
      }
    }
  V_.Collector = Ww
})
var PG = l((Y_) => {
  'use strict'
  Object.defineProperty(Y_, '__esModule', { value: !0 })
  Y_.streamCollector = void 0
  var Kle = IG(),
    Jle = (e) =>
      new Promise((t, n) => {
        let r = new Kle.Collector()
        e.pipe(r),
          e.on('error', (s) => {
            r.end(), n(s)
          }),
          r.on('error', n),
          r.on('finish', function () {
            let s = new Uint8Array(Buffer.concat(this.bufferedBytes))
            t(s)
          })
      })
  Y_.streamCollector = Jle
})
var Li = l((bu) => {
  'use strict'
  Object.defineProperty(bu, '__esModule', { value: !0 })
  var Vw = (x(), w(T))
  Vw.__exportStar(vG(), bu)
  Vw.__exportStar(xG(), bu)
  Vw.__exportStar(PG(), bu)
})
var DG = l((K_) => {
  'use strict'
  Object.defineProperty(K_, '__esModule', { value: !0 })
  K_.sdkStreamMixin = void 0
  var Xle = Li(),
    Qle = _o(),
    Yw = require('stream'),
    Zle = require('util'),
    RG = 'The stream has already been transformed.',
    eme = (e) => {
      var t, n
      if (!(e instanceof Yw.Readable)) {
        let o =
          ((n =
            (t = e?.__proto__) === null || t === void 0
              ? void 0
              : t.constructor) === null || n === void 0
            ? void 0
            : n.name) || e
        throw new Error(
          `Unexpected stream implementation, expect Stream.Readable instance, got ${o}`,
        )
      }
      let r = !1,
        s = async () => {
          if (r) throw new Error(RG)
          return (r = !0), await (0, Xle.streamCollector)(e)
        }
      return Object.assign(e, {
        transformToByteArray: s,
        transformToString: async (o) => {
          let i = await s()
          return o === void 0 || Buffer.isEncoding(o)
            ? (0, Qle.fromArrayBuffer)(
                i.buffer,
                i.byteOffset,
                i.byteLength,
              ).toString(o)
            : new Zle.TextDecoder(o).decode(i)
        },
        transformToWebStream: () => {
          if (r) throw new Error(RG)
          if (e.readableFlowing !== null)
            throw new Error('The stream has been consumed by other callbacks.')
          if (typeof Yw.Readable.toWeb != 'function')
            throw new Error(
              'Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.',
            )
          return (r = !0), Yw.Readable.toWeb(e)
        },
      })
    }
  K_.sdkStreamMixin = eme
})
var AG = l((vu) => {
  'use strict'
  Object.defineProperty(vu, '__esModule', { value: !0 })
  var Kw = (x(), w(T))
  Kw.__exportStar(Mw(), vu)
  Kw.__exportStar(fG(), vu)
  Kw.__exportStar(DG(), vu)
})
var OG = l((J_) => {
  'use strict'
  Object.defineProperty(J_, '__esModule', { value: !0 })
  J_.collectBody = void 0
  var Jw = AG(),
    tme = async (e = new Uint8Array(), t) => {
      if (e instanceof Uint8Array) return Jw.Uint8ArrayBlobAdapter.mutate(e)
      if (!e) return Jw.Uint8ArrayBlobAdapter.mutate(new Uint8Array())
      let n = t.streamCollector(e)
      return Jw.Uint8ArrayBlobAdapter.mutate(await n)
    }
  J_.collectBody = tme
})
var NG = l((X_) => {
  'use strict'
  Object.defineProperty(X_, '__esModule', { value: !0 })
  X_.Command = void 0
  var nme = qw(),
    Xw = class {
      constructor() {
        this.middlewareStack = (0, nme.constructStack)()
      }
    }
  X_.Command = Xw
})
var qG = l((Q_) => {
  'use strict'
  Object.defineProperty(Q_, '__esModule', { value: !0 })
  Q_.SENSITIVE_STRING = void 0
  Q_.SENSITIVE_STRING = '***SensitiveInformation***'
})
var kG = l((Z_) => {
  'use strict'
  Object.defineProperty(Z_, '__esModule', { value: !0 })
  Z_.createAggregatedClient = void 0
  var rme = (e, t) => {
    for (let n of Object.keys(e)) {
      let r = e[n],
        s = async function (i, c, a) {
          let u = new r(i)
          if (typeof c == 'function') this.send(u, c)
          else if (typeof a == 'function') {
            if (typeof c != 'object')
              throw new Error(`Expected http options but got ${typeof c}`)
            this.send(u, c || {}, a)
          } else return this.send(u, c)
        },
        o = (n[0].toLowerCase() + n.slice(1)).replace(/Command$/, '')
      t.prototype[o] = s
    }
  }
  Z_.createAggregatedClient = rme
})
var Zw = l((R) => {
  'use strict'
  Object.defineProperty(R, '__esModule', { value: !0 })
  R.logger =
    R.strictParseByte =
    R.strictParseShort =
    R.strictParseInt32 =
    R.strictParseInt =
    R.strictParseLong =
    R.limitedParseFloat32 =
    R.limitedParseFloat =
    R.handleFloat =
    R.limitedParseDouble =
    R.strictParseFloat32 =
    R.strictParseFloat =
    R.strictParseDouble =
    R.expectUnion =
    R.expectString =
    R.expectObject =
    R.expectNonNull =
    R.expectByte =
    R.expectShort =
    R.expectInt32 =
    R.expectInt =
    R.expectLong =
    R.expectFloat32 =
    R.expectNumber =
    R.expectBoolean =
    R.parseBoolean =
      void 0
  var sme = (e) => {
    switch (e) {
      case 'true':
        return !0
      case 'false':
        return !1
      default:
        throw new Error(`Unable to parse boolean value "${e}"`)
    }
  }
  R.parseBoolean = sme
  var ome = (e) => {
    if (e != null) {
      if (typeof e == 'number') {
        if (
          ((e === 0 || e === 1) &&
            R.logger.warn(eh(`Expected boolean, got ${typeof e}: ${e}`)),
          e === 0)
        )
          return !1
        if (e === 1) return !0
      }
      if (typeof e == 'string') {
        let t = e.toLowerCase()
        if (
          ((t === 'false' || t === 'true') &&
            R.logger.warn(eh(`Expected boolean, got ${typeof e}: ${e}`)),
          t === 'false')
        )
          return !1
        if (t === 'true') return !0
      }
      if (typeof e == 'boolean') return e
      throw new TypeError(`Expected boolean, got ${typeof e}: ${e}`)
    }
  }
  R.expectBoolean = ome
  var ime = (e) => {
    if (e != null) {
      if (typeof e == 'string') {
        let t = parseFloat(e)
        if (!Number.isNaN(t))
          return (
            String(t) !== String(e) &&
              R.logger.warn(eh(`Expected number but observed string: ${e}`)),
            t
          )
      }
      if (typeof e == 'number') return e
      throw new TypeError(`Expected number, got ${typeof e}: ${e}`)
    }
  }
  R.expectNumber = ime
  var ame = Math.ceil(2 ** 127 * (2 - 2 ** -23)),
    cme = (e) => {
      let t = (0, R.expectNumber)(e)
      if (
        t !== void 0 &&
        !Number.isNaN(t) &&
        t !== 1 / 0 &&
        t !== -1 / 0 &&
        Math.abs(t) > ame
      )
        throw new TypeError(`Expected 32-bit float, got ${e}`)
      return t
    }
  R.expectFloat32 = cme
  var dme = (e) => {
    if (e != null) {
      if (Number.isInteger(e) && !Number.isNaN(e)) return e
      throw new TypeError(`Expected integer, got ${typeof e}: ${e}`)
    }
  }
  R.expectLong = dme
  R.expectInt = R.expectLong
  var ume = (e) => Qw(e, 32)
  R.expectInt32 = ume
  var lme = (e) => Qw(e, 16)
  R.expectShort = lme
  var mme = (e) => Qw(e, 8)
  R.expectByte = mme
  var Qw = (e, t) => {
      let n = (0, R.expectLong)(e)
      if (n !== void 0 && pme(n, t) !== n)
        throw new TypeError(`Expected ${t}-bit integer, got ${e}`)
      return n
    },
    pme = (e, t) => {
      switch (t) {
        case 32:
          return Int32Array.of(e)[0]
        case 16:
          return Int16Array.of(e)[0]
        case 8:
          return Int8Array.of(e)[0]
      }
    },
    fme = (e, t) => {
      if (e == null)
        throw t
          ? new TypeError(`Expected a non-null value for ${t}`)
          : new TypeError('Expected a non-null value')
      return e
    }
  R.expectNonNull = fme
  var _me = (e) => {
    if (e == null) return
    if (typeof e == 'object' && !Array.isArray(e)) return e
    let t = Array.isArray(e) ? 'array' : typeof e
    throw new TypeError(`Expected object, got ${t}: ${e}`)
  }
  R.expectObject = _me
  var hme = (e) => {
    if (e != null) {
      if (typeof e == 'string') return e
      if (['boolean', 'number', 'bigint'].includes(typeof e))
        return (
          R.logger.warn(eh(`Expected string, got ${typeof e}: ${e}`)), String(e)
        )
      throw new TypeError(`Expected string, got ${typeof e}: ${e}`)
    }
  }
  R.expectString = hme
  var yme = (e) => {
    if (e == null) return
    let t = (0, R.expectObject)(e),
      n = Object.entries(t)
        .filter(([, r]) => r != null)
        .map(([r]) => r)
    if (n.length === 0)
      throw new TypeError(
        'Unions must have exactly one non-null member. None were found.',
      )
    if (n.length > 1)
      throw new TypeError(
        `Unions must have exactly one non-null member. Keys ${n} were not null.`,
      )
    return t
  }
  R.expectUnion = yme
  var gme = (e) =>
    typeof e == 'string' ? (0, R.expectNumber)(Bi(e)) : (0, R.expectNumber)(e)
  R.strictParseDouble = gme
  R.strictParseFloat = R.strictParseDouble
  var Eme = (e) =>
    typeof e == 'string' ? (0, R.expectFloat32)(Bi(e)) : (0, R.expectFloat32)(e)
  R.strictParseFloat32 = Eme
  var Sme = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g,
    Bi = (e) => {
      let t = e.match(Sme)
      if (t === null || t[0].length !== e.length)
        throw new TypeError('Expected real number, got implicit NaN')
      return parseFloat(e)
    },
    bme = (e) => (typeof e == 'string' ? MG(e) : (0, R.expectNumber)(e))
  R.limitedParseDouble = bme
  R.handleFloat = R.limitedParseDouble
  R.limitedParseFloat = R.limitedParseDouble
  var vme = (e) => (typeof e == 'string' ? MG(e) : (0, R.expectFloat32)(e))
  R.limitedParseFloat32 = vme
  var MG = (e) => {
      switch (e) {
        case 'NaN':
          return NaN
        case 'Infinity':
          return 1 / 0
        case '-Infinity':
          return -1 / 0
        default:
          throw new Error(`Unable to parse float value: ${e}`)
      }
    },
    Cme = (e) =>
      typeof e == 'string' ? (0, R.expectLong)(Bi(e)) : (0, R.expectLong)(e)
  R.strictParseLong = Cme
  R.strictParseInt = R.strictParseLong
  var wme = (e) =>
    typeof e == 'string' ? (0, R.expectInt32)(Bi(e)) : (0, R.expectInt32)(e)
  R.strictParseInt32 = wme
  var Tme = (e) =>
    typeof e == 'string' ? (0, R.expectShort)(Bi(e)) : (0, R.expectShort)(e)
  R.strictParseShort = Tme
  var xme = (e) =>
    typeof e == 'string' ? (0, R.expectByte)(Bi(e)) : (0, R.expectByte)(e)
  R.strictParseByte = xme
  var eh = (e) =>
    String(new TypeError(e).stack || e)
      .split(
        `
`,
      )
      .slice(0, 5)
      .filter((t) => !t.includes('stackTraceWarning')).join(`
`)
  R.logger = { warn: console.warn }
})
var FG = l((Jt) => {
  'use strict'
  Object.defineProperty(Jt, '__esModule', { value: !0 })
  Jt.parseEpochTimestamp =
    Jt.parseRfc7231DateTime =
    Jt.parseRfc3339DateTimeWithOffset =
    Jt.parseRfc3339DateTime =
    Jt.dateToUtcString =
      void 0
  var ss = Zw(),
    Ime = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    tT = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ]
  function Pme(e) {
    let t = e.getUTCFullYear(),
      n = e.getUTCMonth(),
      r = e.getUTCDay(),
      s = e.getUTCDate(),
      o = e.getUTCHours(),
      i = e.getUTCMinutes(),
      c = e.getUTCSeconds(),
      a = s < 10 ? `0${s}` : `${s}`,
      u = o < 10 ? `0${o}` : `${o}`,
      d = i < 10 ? `0${i}` : `${i}`,
      p = c < 10 ? `0${c}` : `${c}`
    return `${Ime[r]}, ${a} ${tT[n]} ${t} ${u}:${d}:${p} GMT`
  }
  Jt.dateToUtcString = Pme
  var Rme = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/,
    ),
    Dme = (e) => {
      if (e == null) return
      if (typeof e != 'string')
        throw new TypeError('RFC-3339 date-times must be expressed as strings')
      let t = Rme.exec(e)
      if (!t) throw new TypeError('Invalid RFC-3339 date-time value')
      let [n, r, s, o, i, c, a, u] = t,
        d = (0, ss.strictParseShort)(ji(r)),
        p = qn(s, 'month', 1, 12),
        f = qn(o, 'day', 1, 31)
      return Cu(d, p, f, {
        hours: i,
        minutes: c,
        seconds: a,
        fractionalMilliseconds: u,
      })
    }
  Jt.parseRfc3339DateTime = Dme
  var Ame = new RegExp(
      /^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/,
    ),
    Ome = (e) => {
      if (e == null) return
      if (typeof e != 'string')
        throw new TypeError('RFC-3339 date-times must be expressed as strings')
      let t = Ame.exec(e)
      if (!t) throw new TypeError('Invalid RFC-3339 date-time value')
      let [n, r, s, o, i, c, a, u, d] = t,
        p = (0, ss.strictParseShort)(ji(r)),
        f = qn(s, 'month', 1, 12),
        _ = qn(o, 'day', 1, 31),
        h = Cu(p, f, _, {
          hours: i,
          minutes: c,
          seconds: a,
          fractionalMilliseconds: u,
        })
      return d.toUpperCase() != 'Z' && h.setTime(h.getTime() - Hme(d)), h
    }
  Jt.parseRfc3339DateTimeWithOffset = Ome
  var Nme = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    qme = new RegExp(
      /^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/,
    ),
    kme = new RegExp(
      /^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/,
    ),
    Mme = (e) => {
      if (e == null) return
      if (typeof e != 'string')
        throw new TypeError('RFC-7231 date-times must be expressed as strings')
      let t = Nme.exec(e)
      if (t) {
        let [n, r, s, o, i, c, a, u] = t
        return Cu((0, ss.strictParseShort)(ji(o)), eT(s), qn(r, 'day', 1, 31), {
          hours: i,
          minutes: c,
          seconds: a,
          fractionalMilliseconds: u,
        })
      }
      if (((t = qme.exec(e)), t)) {
        let [n, r, s, o, i, c, a, u] = t
        return Bme(
          Cu(Ume(o), eT(s), qn(r, 'day', 1, 31), {
            hours: i,
            minutes: c,
            seconds: a,
            fractionalMilliseconds: u,
          }),
        )
      }
      if (((t = kme.exec(e)), t)) {
        let [n, r, s, o, i, c, a, u] = t
        return Cu(
          (0, ss.strictParseShort)(ji(u)),
          eT(r),
          qn(s.trimLeft(), 'day', 1, 31),
          { hours: o, minutes: i, seconds: c, fractionalMilliseconds: a },
        )
      }
      throw new TypeError('Invalid RFC-7231 date-time value')
    }
  Jt.parseRfc7231DateTime = Mme
  var Fme = (e) => {
    if (e == null) return
    let t
    if (typeof e == 'number') t = e
    else if (typeof e == 'string') t = (0, ss.strictParseDouble)(e)
    else
      throw new TypeError(
        'Epoch timestamps must be expressed as floating point numbers or their string representation',
      )
    if (Number.isNaN(t) || t === 1 / 0 || t === -1 / 0)
      throw new TypeError(
        'Epoch timestamps must be valid, non-Infinite, non-NaN numerics',
      )
    return new Date(Math.round(t * 1e3))
  }
  Jt.parseEpochTimestamp = Fme
  var Cu = (e, t, n, r) => {
      let s = t - 1
      return (
        Gme(e, s, n),
        new Date(
          Date.UTC(
            e,
            s,
            n,
            qn(r.hours, 'hour', 0, 23),
            qn(r.minutes, 'minute', 0, 59),
            qn(r.seconds, 'seconds', 0, 60),
            zme(r.fractionalMilliseconds),
          ),
        )
      )
    },
    Ume = (e) => {
      let t = new Date().getUTCFullYear(),
        n = Math.floor(t / 100) * 100 + (0, ss.strictParseShort)(ji(e))
      return n < t ? n + 100 : n
    },
    Lme = 50 * 365 * 24 * 60 * 60 * 1e3,
    Bme = (e) =>
      e.getTime() - new Date().getTime() > Lme
        ? new Date(
            Date.UTC(
              e.getUTCFullYear() - 100,
              e.getUTCMonth(),
              e.getUTCDate(),
              e.getUTCHours(),
              e.getUTCMinutes(),
              e.getUTCSeconds(),
              e.getUTCMilliseconds(),
            ),
          )
        : e,
    eT = (e) => {
      let t = tT.indexOf(e)
      if (t < 0) throw new TypeError(`Invalid month: ${e}`)
      return t + 1
    },
    jme = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    Gme = (e, t, n) => {
      let r = jme[t]
      if ((t === 1 && $me(e) && (r = 29), n > r))
        throw new TypeError(`Invalid day for ${tT[t]} in ${e}: ${n}`)
    },
    $me = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0),
    qn = (e, t, n, r) => {
      let s = (0, ss.strictParseByte)(ji(e))
      if (s < n || s > r)
        throw new TypeError(`${t} must be between ${n} and ${r}, inclusive`)
      return s
    },
    zme = (e) => (e == null ? 0 : (0, ss.strictParseFloat32)('0.' + e) * 1e3),
    Hme = (e) => {
      let t = e[0],
        n = 1
      if (t == '+') n = 1
      else if (t == '-') n = -1
      else throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`)
      let r = Number(e.substring(1, 3)),
        s = Number(e.substring(4, 6))
      return n * (r * 60 + s) * 60 * 1e3
    },
    ji = (e) => {
      let t = 0
      for (; t < e.length - 1 && e.charAt(t) === '0'; ) t++
      return t === 0 ? e : e.slice(t)
    }
})
var rT = l((Gi) => {
  'use strict'
  Object.defineProperty(Gi, '__esModule', { value: !0 })
  Gi.decorateServiceException = Gi.ServiceException = void 0
  var nT = class e extends Error {
    constructor(t) {
      super(t.message),
        Object.setPrototypeOf(this, e.prototype),
        (this.name = t.name),
        (this.$fault = t.$fault),
        (this.$metadata = t.$metadata)
    }
  }
  Gi.ServiceException = nT
  var Wme = (e, t = {}) => {
    Object.entries(t)
      .filter(([, r]) => r !== void 0)
      .forEach(([r, s]) => {
        ;(e[r] == null || e[r] === '') && (e[r] = s)
      })
    let n = e.message || e.Message || 'UnknownError'
    return (e.message = n), delete e.Message, e
  }
  Gi.decorateServiceException = Wme
})
var UG = l((Po) => {
  'use strict'
  Object.defineProperty(Po, '__esModule', { value: !0 })
  Po.withBaseException = Po.throwDefaultError = void 0
  var Vme = rT(),
    Yme = ({ output: e, parsedBody: t, exceptionCtor: n, errorCode: r }) => {
      let s = Jme(e),
        o = s.httpStatusCode ? s.httpStatusCode + '' : void 0,
        i = new n({
          name: t?.code || t?.Code || r || o || 'UnknownError',
          $fault: 'client',
          $metadata: s,
        })
      throw (0, Vme.decorateServiceException)(i, t)
    }
  Po.throwDefaultError = Yme
  var Kme =
    (e) =>
    ({ output: t, parsedBody: n, errorCode: r }) => {
      ;(0, Po.throwDefaultError)({
        output: t,
        parsedBody: n,
        exceptionCtor: e,
        errorCode: r,
      })
    }
  Po.withBaseException = Kme
  var Jme = (e) => {
    var t, n
    return {
      httpStatusCode: e.statusCode,
      requestId:
        (n =
          (t = e.headers['x-amzn-requestid']) !== null && t !== void 0
            ? t
            : e.headers['x-amzn-request-id']) !== null && n !== void 0
          ? n
          : e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }
  }
})
var LG = l((th) => {
  'use strict'
  Object.defineProperty(th, '__esModule', { value: !0 })
  th.loadConfigsForDefaultMode = void 0
  var Xme = (e) => {
    switch (e) {
      case 'standard':
        return { retryMode: 'standard', connectionTimeout: 3100 }
      case 'in-region':
        return { retryMode: 'standard', connectionTimeout: 1100 }
      case 'cross-region':
        return { retryMode: 'standard', connectionTimeout: 3100 }
      case 'mobile':
        return { retryMode: 'standard', connectionTimeout: 3e4 }
      default:
        return {}
    }
  }
  th.loadConfigsForDefaultMode = Xme
})
var jG = l((nh) => {
  'use strict'
  Object.defineProperty(nh, '__esModule', { value: !0 })
  nh.emitWarningIfUnsupportedVersion = void 0
  var BG = !1,
    Qme = (e) => {
      e && !BG && parseInt(e.substring(1, e.indexOf('.'))) < 14 && (BG = !0)
    }
  nh.emitWarningIfUnsupportedVersion = Qme
})
var sT = l((rh) => {
  'use strict'
  Object.defineProperty(rh, '__esModule', { value: !0 })
  rh.extendedEncodeURIComponent = void 0
  function Zme(e) {
    return encodeURIComponent(e).replace(/[!'()*]/g, function (t) {
      return '%' + t.charCodeAt(0).toString(16).toUpperCase()
    })
  }
  rh.extendedEncodeURIComponent = Zme
})
var GG = l((sh) => {
  'use strict'
  Object.defineProperty(sh, '__esModule', { value: !0 })
  sh.getArrayIfSingleItem = void 0
  var epe = (e) => (Array.isArray(e) ? e : [e])
  sh.getArrayIfSingleItem = epe
})
var $G = l((wu) => {
  'use strict'
  Object.defineProperty(wu, '__esModule', { value: !0 })
  wu.getValueFromTextNode = void 0
  var tpe = (e) => {
    let t = '#text'
    for (let n in e)
      e.hasOwnProperty(n) && e[n][t] !== void 0
        ? (e[n] = e[n][t])
        : typeof e[n] == 'object' &&
          e[n] !== null &&
          (e[n] = (0, wu.getValueFromTextNode)(e[n]))
    return e
  }
  wu.getValueFromTextNode = tpe
})
var zG = l((kn) => {
  'use strict'
  Object.defineProperty(kn, '__esModule', { value: !0 })
  kn.LazyJsonString = kn.StringWrapper = void 0
  var npe = function () {
    let e = Object.getPrototypeOf(this).constructor,
      t = Function.bind.apply(String, [null, ...arguments]),
      n = new t()
    return Object.setPrototypeOf(n, e.prototype), n
  }
  kn.StringWrapper = npe
  kn.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
      value: kn.StringWrapper,
      enumerable: !1,
      writable: !0,
      configurable: !0,
    },
  })
  Object.setPrototypeOf(kn.StringWrapper, String)
  var oT = class e extends kn.StringWrapper {
    deserializeJSON() {
      return JSON.parse(super.toString())
    }
    toJSON() {
      return super.toString()
    }
    static fromObject(t) {
      return t instanceof e
        ? t
        : t instanceof String || typeof t == 'string'
        ? new e(t)
        : new e(JSON.stringify(t))
    }
  }
  kn.LazyJsonString = oT
})
var VG = l((os) => {
  'use strict'
  Object.defineProperty(os, '__esModule', { value: !0 })
  os.take = os.convertMap = os.map = void 0
  function HG(e, t, n) {
    let r, s, o
    if (typeof t > 'u' && typeof n > 'u') (r = {}), (o = e)
    else {
      if (((r = e), typeof t == 'function'))
        return (s = t), (o = n), ope(r, s, o)
      o = t
    }
    for (let i of Object.keys(o)) {
      if (!Array.isArray(o[i])) {
        r[i] = o[i]
        continue
      }
      WG(r, null, o, i)
    }
    return r
  }
  os.map = HG
  var rpe = (e) => {
    let t = {}
    for (let [n, r] of Object.entries(e || {})) t[n] = [, r]
    return t
  }
  os.convertMap = rpe
  var spe = (e, t) => {
    let n = {}
    for (let r in t) WG(n, e, t, r)
    return n
  }
  os.take = spe
  var ope = (e, t, n) =>
      HG(
        e,
        Object.entries(n).reduce(
          (r, [s, o]) => (
            Array.isArray(o)
              ? (r[s] = o)
              : typeof o == 'function'
              ? (r[s] = [t, o()])
              : (r[s] = [t, o]),
            r
          ),
          {},
        ),
      ),
    WG = (e, t, n, r) => {
      if (t !== null) {
        let i = n[r]
        typeof i == 'function' && (i = [, i])
        let [c = ipe, a = ape, u = r] = i
        ;((typeof c == 'function' && c(t[u])) ||
          (typeof c != 'function' && c)) &&
          (e[r] = a(t[u]))
        return
      }
      let [s, o] = n[r]
      if (typeof o == 'function') {
        let i,
          c = s === void 0 && (i = o()) != null,
          a =
            (typeof s == 'function' && !!s(void 0)) ||
            (typeof s != 'function' && !!s)
        c ? (e[r] = i) : a && (e[r] = o())
      } else {
        let i = s === void 0 && o != null,
          c =
            (typeof s == 'function' && !!s(o)) ||
            (typeof s != 'function' && !!s)
        ;(i || c) && (e[r] = o)
      }
    },
    ipe = (e) => e != null,
    ape = (e) => e
})
var KG = l((oh) => {
  'use strict'
  Object.defineProperty(oh, '__esModule', { value: !0 })
  oh.resolvedPath = void 0
  var YG = sT(),
    cpe = (e, t, n, r, s, o) => {
      if (t != null && t[n] !== void 0) {
        let i = r()
        if (i.length <= 0)
          throw new Error(
            'Empty value provided for input HTTP label: ' + n + '.',
          )
        e = e.replace(
          s,
          o
            ? i
                .split('/')
                .map((c) => (0, YG.extendedEncodeURIComponent)(c))
                .join('/')
            : (0, YG.extendedEncodeURIComponent)(i),
        )
      } else
        throw new Error('No value provided for input HTTP label: ' + n + '.')
      return e
    }
  oh.resolvedPath = cpe
})
var JG = l((ih) => {
  'use strict'
  Object.defineProperty(ih, '__esModule', { value: !0 })
  ih.serializeFloat = void 0
  var dpe = (e) => {
    if (e !== e) return 'NaN'
    switch (e) {
      case 1 / 0:
        return 'Infinity'
      case -1 / 0:
        return '-Infinity'
      default:
        return e
    }
  }
  ih.serializeFloat = dpe
})
var XG = l((Tu) => {
  'use strict'
  Object.defineProperty(Tu, '__esModule', { value: !0 })
  Tu._json = void 0
  var upe = (e) => {
    if (e == null) return {}
    if (Array.isArray(e)) return e.filter((t) => t != null)
    if (typeof e == 'object') {
      let t = {}
      for (let n of Object.keys(e)) e[n] != null && (t[n] = (0, Tu._json)(e[n]))
      return t
    }
    return e
  }
  Tu._json = upe
})
var QG = l((ah) => {
  'use strict'
  Object.defineProperty(ah, '__esModule', { value: !0 })
  ah.splitEvery = void 0
  function lpe(e, t, n) {
    if (n <= 0 || !Number.isInteger(n))
      throw new Error(
        'Invalid number of delimiters (' + n + ') for splitEvery.',
      )
    let r = e.split(t)
    if (n === 1) return r
    let s = [],
      o = ''
    for (let i = 0; i < r.length; i++)
      o === '' ? (o = r[i]) : (o += t + r[i]),
        (i + 1) % n === 0 && (s.push(o), (o = ''))
    return o !== '' && s.push(o), s
  }
  ah.splitEvery = lpe
})
var v = l((we) => {
  'use strict'
  Object.defineProperty(we, '__esModule', { value: !0 })
  var Re = (x(), w(T))
  Re.__exportStar(tG(), we)
  Re.__exportStar(oG(), we)
  Re.__exportStar(OG(), we)
  Re.__exportStar(NG(), we)
  Re.__exportStar(qG(), we)
  Re.__exportStar(kG(), we)
  Re.__exportStar(FG(), we)
  Re.__exportStar(UG(), we)
  Re.__exportStar(LG(), we)
  Re.__exportStar(jG(), we)
  Re.__exportStar(rT(), we)
  Re.__exportStar(sT(), we)
  Re.__exportStar(GG(), we)
  Re.__exportStar($G(), we)
  Re.__exportStar(zG(), we)
  Re.__exportStar(VG(), we)
  Re.__exportStar(Zw(), we)
  Re.__exportStar(KG(), we)
  Re.__exportStar(JG(), we)
  Re.__exportStar(XG(), we)
  Re.__exportStar(QG(), we)
})
function xu() {
  return (
    ch > dh.length - 16 && (ZG.default.randomFillSync(dh), (ch = 0)),
    dh.slice(ch, (ch += 16))
  )
}
var ZG,
  dh,
  ch,
  iT = ce(() => {
    ;(ZG = ln(require('crypto'))), (dh = new Uint8Array(256)), (ch = dh.length)
  })
var e$,
  t$ = ce(() => {
    e$ =
      /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  })
function mpe(e) {
  return typeof e == 'string' && e$.test(e)
}
var is,
  Iu = ce(() => {
    t$()
    is = mpe
  })
function ppe(e, t = 0) {
  let n = (
    Ke[e[t + 0]] +
    Ke[e[t + 1]] +
    Ke[e[t + 2]] +
    Ke[e[t + 3]] +
    '-' +
    Ke[e[t + 4]] +
    Ke[e[t + 5]] +
    '-' +
    Ke[e[t + 6]] +
    Ke[e[t + 7]] +
    '-' +
    Ke[e[t + 8]] +
    Ke[e[t + 9]] +
    '-' +
    Ke[e[t + 10]] +
    Ke[e[t + 11]] +
    Ke[e[t + 12]] +
    Ke[e[t + 13]] +
    Ke[e[t + 14]] +
    Ke[e[t + 15]]
  ).toLowerCase()
  if (!is(n)) throw TypeError('Stringified UUID is invalid')
  return n
}
var Ke,
  as,
  Pu = ce(() => {
    Iu()
    Ke = []
    for (let e = 0; e < 256; ++e) Ke.push((e + 256).toString(16).substr(1))
    as = ppe
  })
function fpe(e, t, n) {
  let r = (t && n) || 0,
    s = t || new Array(16)
  e = e || {}
  let o = e.node || n$,
    i = e.clockseq !== void 0 ? e.clockseq : aT
  if (o == null || i == null) {
    let f = e.random || (e.rng || xu)()
    o == null && (o = n$ = [f[0] | 1, f[1], f[2], f[3], f[4], f[5]]),
      i == null && (i = aT = ((f[6] << 8) | f[7]) & 16383)
  }
  let c = e.msecs !== void 0 ? e.msecs : Date.now(),
    a = e.nsecs !== void 0 ? e.nsecs : dT + 1,
    u = c - cT + (a - dT) / 1e4
  if (
    (u < 0 && e.clockseq === void 0 && (i = (i + 1) & 16383),
    (u < 0 || c > cT) && e.nsecs === void 0 && (a = 0),
    a >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
  ;(cT = c), (dT = a), (aT = i), (c += 122192928e5)
  let d = ((c & 268435455) * 1e4 + a) % 4294967296
  ;(s[r++] = (d >>> 24) & 255),
    (s[r++] = (d >>> 16) & 255),
    (s[r++] = (d >>> 8) & 255),
    (s[r++] = d & 255)
  let p = ((c / 4294967296) * 1e4) & 268435455
  ;(s[r++] = (p >>> 8) & 255),
    (s[r++] = p & 255),
    (s[r++] = ((p >>> 24) & 15) | 16),
    (s[r++] = (p >>> 16) & 255),
    (s[r++] = (i >>> 8) | 128),
    (s[r++] = i & 255)
  for (let f = 0; f < 6; ++f) s[r + f] = o[f]
  return t || as(s)
}
var n$,
  aT,
  cT,
  dT,
  r$,
  s$ = ce(() => {
    iT()
    Pu()
    ;(cT = 0), (dT = 0)
    r$ = fpe
  })
function _pe(e) {
  if (!is(e)) throw TypeError('Invalid UUID')
  let t,
    n = new Uint8Array(16)
  return (
    (n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24),
    (n[1] = (t >>> 16) & 255),
    (n[2] = (t >>> 8) & 255),
    (n[3] = t & 255),
    (n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8),
    (n[5] = t & 255),
    (n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8),
    (n[7] = t & 255),
    (n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8),
    (n[9] = t & 255),
    (n[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255),
    (n[11] = (t / 4294967296) & 255),
    (n[12] = (t >>> 24) & 255),
    (n[13] = (t >>> 16) & 255),
    (n[14] = (t >>> 8) & 255),
    (n[15] = t & 255),
    n
  )
}
var uh,
  uT = ce(() => {
    Iu()
    uh = _pe
  })
function hpe(e) {
  e = unescape(encodeURIComponent(e))
  let t = []
  for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n))
  return t
}
function lh(e, t, n) {
  function r(s, o, i, c) {
    if (
      (typeof s == 'string' && (s = hpe(s)),
      typeof o == 'string' && (o = uh(o)),
      o.length !== 16)
    )
      throw TypeError(
        'Namespace must be array-like (16 iterable integer values, 0-255)',
      )
    let a = new Uint8Array(16 + s.length)
    if (
      (a.set(o),
      a.set(s, o.length),
      (a = n(a)),
      (a[6] = (a[6] & 15) | t),
      (a[8] = (a[8] & 63) | 128),
      i)
    ) {
      c = c || 0
      for (let u = 0; u < 16; ++u) i[c + u] = a[u]
      return i
    }
    return as(a)
  }
  try {
    r.name = e
  } catch {}
  return (r.DNS = ype), (r.URL = gpe), r
}
var ype,
  gpe,
  lT = ce(() => {
    Pu()
    uT()
    ;(ype = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'),
      (gpe = '6ba7b811-9dad-11d1-80b4-00c04fd430c8')
  })
function Epe(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    o$.default.createHash('md5').update(e).digest()
  )
}
var o$,
  i$,
  a$ = ce(() => {
    o$ = ln(require('crypto'))
    i$ = Epe
  })
var Spe,
  c$,
  d$ = ce(() => {
    lT()
    a$()
    ;(Spe = lh('v3', 48, i$)), (c$ = Spe)
  })
function bpe(e, t, n) {
  e = e || {}
  let r = e.random || (e.rng || xu)()
  if (((r[6] = (r[6] & 15) | 64), (r[8] = (r[8] & 63) | 128), t)) {
    n = n || 0
    for (let s = 0; s < 16; ++s) t[n + s] = r[s]
    return t
  }
  return as(r)
}
var u$,
  l$ = ce(() => {
    iT()
    Pu()
    u$ = bpe
  })
function vpe(e) {
  return (
    Array.isArray(e)
      ? (e = Buffer.from(e))
      : typeof e == 'string' && (e = Buffer.from(e, 'utf8')),
    m$.default.createHash('sha1').update(e).digest()
  )
}
var m$,
  p$,
  f$ = ce(() => {
    m$ = ln(require('crypto'))
    p$ = vpe
  })
var Cpe,
  _$,
  h$ = ce(() => {
    lT()
    f$()
    ;(Cpe = lh('v5', 80, p$)), (_$ = Cpe)
  })
var y$,
  g$ = ce(() => {
    y$ = '00000000-0000-0000-0000-000000000000'
  })
function wpe(e) {
  if (!is(e)) throw TypeError('Invalid UUID')
  return parseInt(e.substr(14, 1), 16)
}
var E$,
  S$ = ce(() => {
    Iu()
    E$ = wpe
  })
var b$ = {}
Mc(b$, {
  NIL: () => y$,
  parse: () => uh,
  stringify: () => as,
  v1: () => r$,
  v3: () => c$,
  v4: () => u$,
  v5: () => _$,
  validate: () => is,
  version: () => E$,
})
var v$ = ce(() => {
  s$()
  d$()
  l$()
  h$()
  g$()
  S$()
  Iu()
  Pu()
  uT()
})
var mh = l(($i) => {
  'use strict'
  Object.defineProperty($i, '__esModule', { value: !0 })
  $i.DynamoDBServiceException = $i.__ServiceException = void 0
  var C$ = v()
  Object.defineProperty($i, '__ServiceException', {
    enumerable: !0,
    get: function () {
      return C$.ServiceException
    },
  })
  var mT = class e extends C$.ServiceException {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e.prototype)
    }
  }
  $i.DynamoDBServiceException = mT
})
var HT = l((S) => {
  'use strict'
  Object.defineProperty(S, '__esModule', { value: !0 })
  S.InputCompressionType =
    S.ImportStatus =
    S.GlobalTableNotFoundException =
    S.ExportNotFoundException =
    S.S3SseAlgorithm =
    S.ExportStatus =
    S.ExportFormat =
    S.TransactionConflictException =
    S.ReturnValue =
    S.ResourceInUseException =
    S.TableStatus =
    S.IndexStatus =
    S.GlobalTableAlreadyExistsException =
    S.TableClass =
    S.ReplicaStatus =
    S.GlobalTableStatus =
    S.TableNotFoundException =
    S.TableInUseException =
    S.LimitExceededException =
    S.ContributorInsightsStatus =
    S.ContributorInsightsAction =
    S.ContinuousBackupsUnavailableException =
    S.PointInTimeRecoveryStatus =
    S.ContinuousBackupsStatus =
    S.ConditionalOperator =
    S.ComparisonOperator =
    S.ItemCollectionSizeLimitExceededException =
    S.ReturnItemCollectionMetrics =
    S.ResourceNotFoundException =
    S.ProvisionedThroughputExceededException =
    S.InvalidEndpointException =
    S.RequestLimitExceeded =
    S.InternalServerError =
    S.BatchStatementErrorCodeEnum =
    S.ReturnValuesOnConditionCheckFailure =
    S.ReturnConsumedCapacity =
    S.BackupTypeFilter =
    S.BackupNotFoundException =
    S.BackupInUseException =
    S.TimeToLiveStatus =
    S.StreamViewType =
    S.SSEStatus =
    S.SSEType =
    S.ProjectionType =
    S.KeyType =
    S.BillingMode =
    S.BackupType =
    S.BackupStatus =
    S.ScalarAttributeType =
    S.AttributeAction =
      void 0
  S.TransactionCanceledException =
    S.ConditionalCheckFailedException =
    S.AttributeValue =
    S.IndexNotFoundException =
    S.ReplicaNotFoundException =
    S.ReplicaAlreadyExistsException =
    S.InvalidRestoreTimeException =
    S.TableAlreadyExistsException =
    S.Select =
    S.ImportConflictException =
    S.PointInTimeRecoveryUnavailableException =
    S.InvalidExportTimeException =
    S.ExportConflictException =
    S.TransactionInProgressException =
    S.IdempotentParameterMismatchException =
    S.DuplicateItemException =
    S.DestinationStatus =
    S.ImportNotFoundException =
    S.InputFormat =
      void 0
  var ue = mh()
  S.AttributeAction = { ADD: 'ADD', DELETE: 'DELETE', PUT: 'PUT' }
  S.ScalarAttributeType = { B: 'B', N: 'N', S: 'S' }
  S.BackupStatus = {
    AVAILABLE: 'AVAILABLE',
    CREATING: 'CREATING',
    DELETED: 'DELETED',
  }
  S.BackupType = { AWS_BACKUP: 'AWS_BACKUP', SYSTEM: 'SYSTEM', USER: 'USER' }
  S.BillingMode = {
    PAY_PER_REQUEST: 'PAY_PER_REQUEST',
    PROVISIONED: 'PROVISIONED',
  }
  S.KeyType = { HASH: 'HASH', RANGE: 'RANGE' }
  S.ProjectionType = { ALL: 'ALL', INCLUDE: 'INCLUDE', KEYS_ONLY: 'KEYS_ONLY' }
  S.SSEType = { AES256: 'AES256', KMS: 'KMS' }
  S.SSEStatus = {
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLED: 'ENABLED',
    ENABLING: 'ENABLING',
    UPDATING: 'UPDATING',
  }
  S.StreamViewType = {
    KEYS_ONLY: 'KEYS_ONLY',
    NEW_AND_OLD_IMAGES: 'NEW_AND_OLD_IMAGES',
    NEW_IMAGE: 'NEW_IMAGE',
    OLD_IMAGE: 'OLD_IMAGE',
  }
  S.TimeToLiveStatus = {
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLED: 'ENABLED',
    ENABLING: 'ENABLING',
  }
  var pT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'BackupInUseException', $fault: 'client', ...t }),
        (this.name = 'BackupInUseException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.BackupInUseException = pT
  var fT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'BackupNotFoundException', $fault: 'client', ...t }),
        (this.name = 'BackupNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.BackupNotFoundException = fT
  S.BackupTypeFilter = {
    ALL: 'ALL',
    AWS_BACKUP: 'AWS_BACKUP',
    SYSTEM: 'SYSTEM',
    USER: 'USER',
  }
  S.ReturnConsumedCapacity = {
    INDEXES: 'INDEXES',
    NONE: 'NONE',
    TOTAL: 'TOTAL',
  }
  S.ReturnValuesOnConditionCheckFailure = { ALL_OLD: 'ALL_OLD', NONE: 'NONE' }
  S.BatchStatementErrorCodeEnum = {
    AccessDenied: 'AccessDenied',
    ConditionalCheckFailed: 'ConditionalCheckFailed',
    DuplicateItem: 'DuplicateItem',
    InternalServerError: 'InternalServerError',
    ItemCollectionSizeLimitExceeded: 'ItemCollectionSizeLimitExceeded',
    ProvisionedThroughputExceeded: 'ProvisionedThroughputExceeded',
    RequestLimitExceeded: 'RequestLimitExceeded',
    ResourceNotFound: 'ResourceNotFound',
    ThrottlingError: 'ThrottlingError',
    TransactionConflict: 'TransactionConflict',
    ValidationError: 'ValidationError',
  }
  var _T = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InternalServerError', $fault: 'server', ...t }),
        (this.name = 'InternalServerError'),
        (this.$fault = 'server'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.InternalServerError = _T
  var hT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'RequestLimitExceeded', $fault: 'client', ...t }),
        (this.name = 'RequestLimitExceeded'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.RequestLimitExceeded = hT
  var yT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InvalidEndpointException', $fault: 'client', ...t }),
        (this.name = 'InvalidEndpointException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message)
    }
  }
  S.InvalidEndpointException = yT
  var gT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ProvisionedThroughputExceededException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ProvisionedThroughputExceededException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ProvisionedThroughputExceededException = gT
  var ET = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ResourceNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ResourceNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ResourceNotFoundException = ET
  S.ReturnItemCollectionMetrics = { NONE: 'NONE', SIZE: 'SIZE' }
  var ST = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ItemCollectionSizeLimitExceededException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ItemCollectionSizeLimitExceededException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ItemCollectionSizeLimitExceededException = ST
  S.ComparisonOperator = {
    BEGINS_WITH: 'BEGINS_WITH',
    BETWEEN: 'BETWEEN',
    CONTAINS: 'CONTAINS',
    EQ: 'EQ',
    GE: 'GE',
    GT: 'GT',
    IN: 'IN',
    LE: 'LE',
    LT: 'LT',
    NE: 'NE',
    NOT_CONTAINS: 'NOT_CONTAINS',
    NOT_NULL: 'NOT_NULL',
    NULL: 'NULL',
  }
  S.ConditionalOperator = { AND: 'AND', OR: 'OR' }
  S.ContinuousBackupsStatus = { DISABLED: 'DISABLED', ENABLED: 'ENABLED' }
  S.PointInTimeRecoveryStatus = { DISABLED: 'DISABLED', ENABLED: 'ENABLED' }
  var bT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ContinuousBackupsUnavailableException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ContinuousBackupsUnavailableException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ContinuousBackupsUnavailableException = bT
  S.ContributorInsightsAction = { DISABLE: 'DISABLE', ENABLE: 'ENABLE' }
  S.ContributorInsightsStatus = {
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLED: 'ENABLED',
    ENABLING: 'ENABLING',
    FAILED: 'FAILED',
  }
  var vT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'LimitExceededException', $fault: 'client', ...t }),
        (this.name = 'LimitExceededException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.LimitExceededException = vT
  var CT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TableInUseException', $fault: 'client', ...t }),
        (this.name = 'TableInUseException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.TableInUseException = CT
  var wT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TableNotFoundException', $fault: 'client', ...t }),
        (this.name = 'TableNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.TableNotFoundException = wT
  S.GlobalTableStatus = {
    ACTIVE: 'ACTIVE',
    CREATING: 'CREATING',
    DELETING: 'DELETING',
    UPDATING: 'UPDATING',
  }
  S.ReplicaStatus = {
    ACTIVE: 'ACTIVE',
    CREATING: 'CREATING',
    CREATION_FAILED: 'CREATION_FAILED',
    DELETING: 'DELETING',
    INACCESSIBLE_ENCRYPTION_CREDENTIALS: 'INACCESSIBLE_ENCRYPTION_CREDENTIALS',
    REGION_DISABLED: 'REGION_DISABLED',
    UPDATING: 'UPDATING',
  }
  S.TableClass = {
    STANDARD: 'STANDARD',
    STANDARD_INFREQUENT_ACCESS: 'STANDARD_INFREQUENT_ACCESS',
  }
  var TT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'GlobalTableAlreadyExistsException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'GlobalTableAlreadyExistsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.GlobalTableAlreadyExistsException = TT
  S.IndexStatus = {
    ACTIVE: 'ACTIVE',
    CREATING: 'CREATING',
    DELETING: 'DELETING',
    UPDATING: 'UPDATING',
  }
  S.TableStatus = {
    ACTIVE: 'ACTIVE',
    ARCHIVED: 'ARCHIVED',
    ARCHIVING: 'ARCHIVING',
    CREATING: 'CREATING',
    DELETING: 'DELETING',
    INACCESSIBLE_ENCRYPTION_CREDENTIALS: 'INACCESSIBLE_ENCRYPTION_CREDENTIALS',
    UPDATING: 'UPDATING',
  }
  var xT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ResourceInUseException', $fault: 'client', ...t }),
        (this.name = 'ResourceInUseException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ResourceInUseException = xT
  S.ReturnValue = {
    ALL_NEW: 'ALL_NEW',
    ALL_OLD: 'ALL_OLD',
    NONE: 'NONE',
    UPDATED_NEW: 'UPDATED_NEW',
    UPDATED_OLD: 'UPDATED_OLD',
  }
  var IT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TransactionConflictException', $fault: 'client', ...t }),
        (this.name = 'TransactionConflictException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.TransactionConflictException = IT
  S.ExportFormat = { DYNAMODB_JSON: 'DYNAMODB_JSON', ION: 'ION' }
  S.ExportStatus = {
    COMPLETED: 'COMPLETED',
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
  }
  S.S3SseAlgorithm = { AES256: 'AES256', KMS: 'KMS' }
  var PT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ExportNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ExportNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ExportNotFoundException = PT
  var RT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'GlobalTableNotFoundException', $fault: 'client', ...t }),
        (this.name = 'GlobalTableNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.GlobalTableNotFoundException = RT
  S.ImportStatus = {
    CANCELLED: 'CANCELLED',
    CANCELLING: 'CANCELLING',
    COMPLETED: 'COMPLETED',
    FAILED: 'FAILED',
    IN_PROGRESS: 'IN_PROGRESS',
  }
  S.InputCompressionType = { GZIP: 'GZIP', NONE: 'NONE', ZSTD: 'ZSTD' }
  S.InputFormat = { CSV: 'CSV', DYNAMODB_JSON: 'DYNAMODB_JSON', ION: 'ION' }
  var DT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ImportNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ImportNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ImportNotFoundException = DT
  S.DestinationStatus = {
    ACTIVE: 'ACTIVE',
    DISABLED: 'DISABLED',
    DISABLING: 'DISABLING',
    ENABLE_FAILED: 'ENABLE_FAILED',
    ENABLING: 'ENABLING',
  }
  var AT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'DuplicateItemException', $fault: 'client', ...t }),
        (this.name = 'DuplicateItemException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.DuplicateItemException = AT
  var OT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'IdempotentParameterMismatchException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'IdempotentParameterMismatchException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message)
    }
  }
  S.IdempotentParameterMismatchException = OT
  var NT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TransactionInProgressException', $fault: 'client', ...t }),
        (this.name = 'TransactionInProgressException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message)
    }
  }
  S.TransactionInProgressException = NT
  var qT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ExportConflictException', $fault: 'client', ...t }),
        (this.name = 'ExportConflictException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ExportConflictException = qT
  var kT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InvalidExportTimeException', $fault: 'client', ...t }),
        (this.name = 'InvalidExportTimeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.InvalidExportTimeException = kT
  var MT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'PointInTimeRecoveryUnavailableException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'PointInTimeRecoveryUnavailableException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.PointInTimeRecoveryUnavailableException = MT
  var FT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ImportConflictException', $fault: 'client', ...t }),
        (this.name = 'ImportConflictException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ImportConflictException = FT
  S.Select = {
    ALL_ATTRIBUTES: 'ALL_ATTRIBUTES',
    ALL_PROJECTED_ATTRIBUTES: 'ALL_PROJECTED_ATTRIBUTES',
    COUNT: 'COUNT',
    SPECIFIC_ATTRIBUTES: 'SPECIFIC_ATTRIBUTES',
  }
  var UT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TableAlreadyExistsException', $fault: 'client', ...t }),
        (this.name = 'TableAlreadyExistsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.TableAlreadyExistsException = UT
  var LT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'InvalidRestoreTimeException', $fault: 'client', ...t }),
        (this.name = 'InvalidRestoreTimeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.InvalidRestoreTimeException = LT
  var BT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ReplicaAlreadyExistsException', $fault: 'client', ...t }),
        (this.name = 'ReplicaAlreadyExistsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ReplicaAlreadyExistsException = BT
  var jT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'ReplicaNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ReplicaNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.ReplicaNotFoundException = jT
  var GT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'IndexNotFoundException', $fault: 'client', ...t }),
        (this.name = 'IndexNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  S.IndexNotFoundException = GT
  var Tpe
  ;(function (e) {
    e.visit = (t, n) =>
      t.S !== void 0
        ? n.S(t.S)
        : t.N !== void 0
        ? n.N(t.N)
        : t.B !== void 0
        ? n.B(t.B)
        : t.SS !== void 0
        ? n.SS(t.SS)
        : t.NS !== void 0
        ? n.NS(t.NS)
        : t.BS !== void 0
        ? n.BS(t.BS)
        : t.M !== void 0
        ? n.M(t.M)
        : t.L !== void 0
        ? n.L(t.L)
        : t.NULL !== void 0
        ? n.NULL(t.NULL)
        : t.BOOL !== void 0
        ? n.BOOL(t.BOOL)
        : n._(t.$unknown[0], t.$unknown[1])
  })((Tpe = S.AttributeValue || (S.AttributeValue = {})))
  var $T = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({
        name: 'ConditionalCheckFailedException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'ConditionalCheckFailedException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Item = t.Item)
    }
  }
  S.ConditionalCheckFailedException = $T
  var zT = class e extends ue.DynamoDBServiceException {
    constructor(t) {
      super({ name: 'TransactionCanceledException', $fault: 'client', ...t }),
        (this.name = 'TransactionCanceledException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype),
        (this.Message = t.Message),
        (this.CancellationReasons = t.CancellationReasons)
    }
  }
  S.TransactionCanceledException = zT
})
var M = l((y) => {
  'use strict'
  Object.defineProperty(y, '__esModule', { value: !0 })
  y.se_UpdateItemCommand =
    y.se_UpdateGlobalTableSettingsCommand =
    y.se_UpdateGlobalTableCommand =
    y.se_UpdateContributorInsightsCommand =
    y.se_UpdateContinuousBackupsCommand =
    y.se_UntagResourceCommand =
    y.se_TransactWriteItemsCommand =
    y.se_TransactGetItemsCommand =
    y.se_TagResourceCommand =
    y.se_ScanCommand =
    y.se_RestoreTableToPointInTimeCommand =
    y.se_RestoreTableFromBackupCommand =
    y.se_QueryCommand =
    y.se_PutItemCommand =
    y.se_ListTagsOfResourceCommand =
    y.se_ListTablesCommand =
    y.se_ListImportsCommand =
    y.se_ListGlobalTablesCommand =
    y.se_ListExportsCommand =
    y.se_ListContributorInsightsCommand =
    y.se_ListBackupsCommand =
    y.se_ImportTableCommand =
    y.se_GetItemCommand =
    y.se_ExportTableToPointInTimeCommand =
    y.se_ExecuteTransactionCommand =
    y.se_ExecuteStatementCommand =
    y.se_EnableKinesisStreamingDestinationCommand =
    y.se_DisableKinesisStreamingDestinationCommand =
    y.se_DescribeTimeToLiveCommand =
    y.se_DescribeTableReplicaAutoScalingCommand =
    y.se_DescribeTableCommand =
    y.se_DescribeLimitsCommand =
    y.se_DescribeKinesisStreamingDestinationCommand =
    y.se_DescribeImportCommand =
    y.se_DescribeGlobalTableSettingsCommand =
    y.se_DescribeGlobalTableCommand =
    y.se_DescribeExportCommand =
    y.se_DescribeEndpointsCommand =
    y.se_DescribeContributorInsightsCommand =
    y.se_DescribeContinuousBackupsCommand =
    y.se_DescribeBackupCommand =
    y.se_DeleteTableCommand =
    y.se_DeleteItemCommand =
    y.se_DeleteBackupCommand =
    y.se_CreateTableCommand =
    y.se_CreateGlobalTableCommand =
    y.se_CreateBackupCommand =
    y.se_BatchWriteItemCommand =
    y.se_BatchGetItemCommand =
    y.se_BatchExecuteStatementCommand =
      void 0
  y.de_UpdateContributorInsightsCommand =
    y.de_UpdateContinuousBackupsCommand =
    y.de_UntagResourceCommand =
    y.de_TransactWriteItemsCommand =
    y.de_TransactGetItemsCommand =
    y.de_TagResourceCommand =
    y.de_ScanCommand =
    y.de_RestoreTableToPointInTimeCommand =
    y.de_RestoreTableFromBackupCommand =
    y.de_QueryCommand =
    y.de_PutItemCommand =
    y.de_ListTagsOfResourceCommand =
    y.de_ListTablesCommand =
    y.de_ListImportsCommand =
    y.de_ListGlobalTablesCommand =
    y.de_ListExportsCommand =
    y.de_ListContributorInsightsCommand =
    y.de_ListBackupsCommand =
    y.de_ImportTableCommand =
    y.de_GetItemCommand =
    y.de_ExportTableToPointInTimeCommand =
    y.de_ExecuteTransactionCommand =
    y.de_ExecuteStatementCommand =
    y.de_EnableKinesisStreamingDestinationCommand =
    y.de_DisableKinesisStreamingDestinationCommand =
    y.de_DescribeTimeToLiveCommand =
    y.de_DescribeTableReplicaAutoScalingCommand =
    y.de_DescribeTableCommand =
    y.de_DescribeLimitsCommand =
    y.de_DescribeKinesisStreamingDestinationCommand =
    y.de_DescribeImportCommand =
    y.de_DescribeGlobalTableSettingsCommand =
    y.de_DescribeGlobalTableCommand =
    y.de_DescribeExportCommand =
    y.de_DescribeEndpointsCommand =
    y.de_DescribeContributorInsightsCommand =
    y.de_DescribeContinuousBackupsCommand =
    y.de_DescribeBackupCommand =
    y.de_DeleteTableCommand =
    y.de_DeleteItemCommand =
    y.de_DeleteBackupCommand =
    y.de_CreateTableCommand =
    y.de_CreateGlobalTableCommand =
    y.de_CreateBackupCommand =
    y.de_BatchWriteItemCommand =
    y.de_BatchGetItemCommand =
    y.de_BatchExecuteStatementCommand =
    y.se_UpdateTimeToLiveCommand =
    y.se_UpdateTableReplicaAutoScalingCommand =
    y.se_UpdateTableCommand =
      void 0
  y.de_UpdateTimeToLiveCommand =
    y.de_UpdateTableReplicaAutoScalingCommand =
    y.de_UpdateTableCommand =
    y.de_UpdateItemCommand =
    y.de_UpdateGlobalTableSettingsCommand =
    y.de_UpdateGlobalTableCommand =
      void 0
  var xpe = tt(),
    m = v(),
    ph = (v$(), w(b$)),
    Ipe = mh(),
    ae = HT(),
    Ppe = async (e, t) => {
      let n = L('BatchExecuteStatement'),
        r
      return (r = JSON.stringify(Lhe(e, t))), U(t, n, '/', void 0, r)
    }
  y.se_BatchExecuteStatementCommand = Ppe
  var Rpe = async (e, t) => {
    let n = L('BatchGetItem'),
      r
    return (r = JSON.stringify(Bhe(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_BatchGetItemCommand = Rpe
  var Dpe = async (e, t) => {
    let n = L('BatchWriteItem'),
      r
    return (r = JSON.stringify($he(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_BatchWriteItemCommand = Dpe
  var Ape = async (e, t) => {
    let n = L('CreateBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_CreateBackupCommand = Ape
  var Ope = async (e, t) => {
    let n = L('CreateGlobalTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_CreateGlobalTableCommand = Ope
  var Npe = async (e, t) => {
    let n = L('CreateTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_CreateTableCommand = Npe
  var qpe = async (e, t) => {
    let n = L('DeleteBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DeleteBackupCommand = qpe
  var kpe = async (e, t) => {
    let n = L('DeleteItem'),
      r
    return (r = JSON.stringify(Yhe(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_DeleteItemCommand = kpe
  var Mpe = async (e, t) => {
    let n = L('DeleteTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DeleteTableCommand = Mpe
  var Fpe = async (e, t) => {
    let n = L('DescribeBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeBackupCommand = Fpe
  var Upe = async (e, t) => {
    let n = L('DescribeContinuousBackups'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeContinuousBackupsCommand = Upe
  var Lpe = async (e, t) => {
    let n = L('DescribeContributorInsights'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeContributorInsightsCommand = Lpe
  var Bpe = async (e, t) => {
    let n = L('DescribeEndpoints'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeEndpointsCommand = Bpe
  var jpe = async (e, t) => {
    let n = L('DescribeExport'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeExportCommand = jpe
  var Gpe = async (e, t) => {
    let n = L('DescribeGlobalTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeGlobalTableCommand = Gpe
  var $pe = async (e, t) => {
    let n = L('DescribeGlobalTableSettings'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeGlobalTableSettingsCommand = $pe
  var zpe = async (e, t) => {
    let n = L('DescribeImport'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeImportCommand = zpe
  var Hpe = async (e, t) => {
    let n = L('DescribeKinesisStreamingDestination'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeKinesisStreamingDestinationCommand = Hpe
  var Wpe = async (e, t) => {
    let n = L('DescribeLimits'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeLimitsCommand = Wpe
  var Vpe = async (e, t) => {
    let n = L('DescribeTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeTableCommand = Vpe
  var Ype = async (e, t) => {
    let n = L('DescribeTableReplicaAutoScaling'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeTableReplicaAutoScalingCommand = Ype
  var Kpe = async (e, t) => {
    let n = L('DescribeTimeToLive'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DescribeTimeToLiveCommand = Kpe
  var Jpe = async (e, t) => {
    let n = L('DisableKinesisStreamingDestination'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_DisableKinesisStreamingDestinationCommand = Jpe
  var Xpe = async (e, t) => {
    let n = L('EnableKinesisStreamingDestination'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_EnableKinesisStreamingDestinationCommand = Xpe
  var Qpe = async (e, t) => {
    let n = L('ExecuteStatement'),
      r
    return (r = JSON.stringify(Jhe(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_ExecuteStatementCommand = Qpe
  var Zpe = async (e, t) => {
    let n = L('ExecuteTransaction'),
      r
    return (r = JSON.stringify(Xhe(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_ExecuteTransactionCommand = Zpe
  var efe = async (e, t) => {
    let n = L('ExportTableToPointInTime'),
      r
    return (r = JSON.stringify(Zhe(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_ExportTableToPointInTimeCommand = efe
  var tfe = async (e, t) => {
    let n = L('GetItem'),
      r
    return (r = JSON.stringify(tye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_GetItemCommand = tfe
  var nfe = async (e, t) => {
    let n = L('ImportTable'),
      r
    return (r = JSON.stringify(iye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_ImportTableCommand = nfe
  var rfe = async (e, t) => {
    let n = L('ListBackups'),
      r
    return (r = JSON.stringify(lye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_ListBackupsCommand = rfe
  var sfe = async (e, t) => {
    let n = L('ListContributorInsights'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_ListContributorInsightsCommand = sfe
  var ofe = async (e, t) => {
    let n = L('ListExports'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_ListExportsCommand = ofe
  var ife = async (e, t) => {
    let n = L('ListGlobalTables'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_ListGlobalTablesCommand = ife
  var afe = async (e, t) => {
    let n = L('ListImports'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_ListImportsCommand = afe
  var cfe = async (e, t) => {
    let n = L('ListTables'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_ListTablesCommand = cfe
  var dfe = async (e, t) => {
    let n = L('ListTagsOfResource'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_ListTagsOfResourceCommand = dfe
  var ufe = async (e, t) => {
    let n = L('PutItem'),
      r
    return (r = JSON.stringify(yye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_PutItemCommand = ufe
  var lfe = async (e, t) => {
    let n = L('Query'),
      r
    return (r = JSON.stringify(Eye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_QueryCommand = lfe
  var mfe = async (e, t) => {
    let n = L('RestoreTableFromBackup'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_RestoreTableFromBackupCommand = mfe
  var pfe = async (e, t) => {
    let n = L('RestoreTableToPointInTime'),
      r
    return (r = JSON.stringify(Pye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_RestoreTableToPointInTimeCommand = pfe
  var ffe = async (e, t) => {
    let n = L('Scan'),
      r
    return (r = JSON.stringify(Rye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_ScanCommand = ffe
  var _fe = async (e, t) => {
    let n = L('TagResource'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_TagResourceCommand = _fe
  var hfe = async (e, t) => {
    let n = L('TransactGetItems'),
      r
    return (r = JSON.stringify(Oye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_TransactGetItemsCommand = hfe
  var yfe = async (e, t) => {
    let n = L('TransactWriteItems'),
      r
    return (r = JSON.stringify(kye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_TransactWriteItemsCommand = yfe
  var gfe = async (e, t) => {
    let n = L('UntagResource'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_UntagResourceCommand = gfe
  var Efe = async (e, t) => {
    let n = L('UpdateContinuousBackups'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateContinuousBackupsCommand = Efe
  var Sfe = async (e, t) => {
    let n = L('UpdateContributorInsights'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateContributorInsightsCommand = Sfe
  var bfe = async (e, t) => {
    let n = L('UpdateGlobalTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateGlobalTableCommand = bfe
  var vfe = async (e, t) => {
    let n = L('UpdateGlobalTableSettings'),
      r
    return (r = JSON.stringify(Fye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateGlobalTableSettingsCommand = vfe
  var Cfe = async (e, t) => {
    let n = L('UpdateItem'),
      r
    return (r = JSON.stringify(Uye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateItemCommand = Cfe
  var wfe = async (e, t) => {
    let n = L('UpdateTable'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateTableCommand = wfe
  var Tfe = async (e, t) => {
    let n = L('UpdateTableReplicaAutoScaling'),
      r
    return (r = JSON.stringify(Lye(e, t))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateTableReplicaAutoScalingCommand = Tfe
  var xfe = async (e, t) => {
    let n = L('UpdateTimeToLive'),
      r
    return (r = JSON.stringify((0, m._json)(e))), U(t, n, '/', void 0, r)
  }
  y.se_UpdateTimeToLiveCommand = xfe
  var Ife = async (e, t) => {
    if (e.statusCode >= 300) return Pfe(e, t)
    let n = await $(e.body, t),
      r = {}
    return (r = Yye(n, t)), { $metadata: I(e), ...r }
  }
  y.de_BatchExecuteStatementCommand = Ife
  var Pfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Rfe = async (e, t) => {
      if (e.statusCode >= 300) return Dfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Kye(n, t)), { $metadata: I(e), ...r }
    }
  y.de_BatchGetItemCommand = Rfe
  var Dfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Afe = async (e, t) => {
      if (e.statusCode >= 300) return Ofe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = ege(n, t)), { $metadata: I(e), ...r }
    }
  y.de_BatchWriteItemCommand = Afe
  var Ofe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await Ru(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Nfe = async (e, t) => {
      if (e.statusCode >= 300) return qfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = ige(n, t)), { $metadata: I(e), ...r }
    }
  y.de_CreateBackupCommand = Nfe
  var qfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'BackupInUseException':
        case 'com.amazonaws.dynamodb#BackupInUseException':
          throw await WT(n, t)
        case 'ContinuousBackupsUnavailableException':
        case 'com.amazonaws.dynamodb#ContinuousBackupsUnavailableException':
          throw await T$(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'TableInUseException':
        case 'com.amazonaws.dynamodb#TableInUseException':
          throw await YT(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    kfe = async (e, t) => {
      if (e.statusCode >= 300) return Mfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = age(n, t)), { $metadata: I(e), ...r }
    }
  y.de_CreateGlobalTableCommand = kfe
  var Mfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'GlobalTableAlreadyExistsException':
        case 'com.amazonaws.dynamodb#GlobalTableAlreadyExistsException':
          throw await Phe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Ffe = async (e, t) => {
      if (e.statusCode >= 300) return Ufe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = cge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_CreateTableCommand = Ffe
  var Ufe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Lfe = async (e, t) => {
      if (e.statusCode >= 300) return Bfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = dge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DeleteBackupCommand = Lfe
  var Bfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'BackupInUseException':
        case 'com.amazonaws.dynamodb#BackupInUseException':
          throw await WT(n, t)
        case 'BackupNotFoundException':
        case 'com.amazonaws.dynamodb#BackupNotFoundException':
          throw await VT(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    jfe = async (e, t) => {
      if (e.statusCode >= 300) return Gfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = uge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DeleteItemCommand = jfe
  var Gfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await fh(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await Ru(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await hh(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    $fe = async (e, t) => {
      if (e.statusCode >= 300) return zfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = mge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DeleteTableCommand = $fe
  var zfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Hfe = async (e, t) => {
      if (e.statusCode >= 300) return Wfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = pge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeBackupCommand = Hfe
  var Wfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'BackupNotFoundException':
        case 'com.amazonaws.dynamodb#BackupNotFoundException':
          throw await VT(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Vfe = async (e, t) => {
      if (e.statusCode >= 300) return Yfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = fge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeContinuousBackupsCommand = Vfe
  var Yfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Kfe = async (e, t) => {
      if (e.statusCode >= 300) return Jfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = _ge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeContributorInsightsCommand = Kfe
  var Jfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Xfe = async (e, t) => {
      if (e.statusCode >= 300) return Qfe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_DescribeEndpointsCommand = Xfe
  var Qfe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body),
        s = n.body
      return F({ output: e, parsedBody: s, errorCode: r })
    },
    Zfe = async (e, t) => {
      if (e.statusCode >= 300) return e_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = hge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeExportCommand = Zfe
  var e_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ExportNotFoundException':
        case 'com.amazonaws.dynamodb#ExportNotFoundException':
          throw await Ihe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    t_e = async (e, t) => {
      if (e.statusCode >= 300) return n_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = yge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeGlobalTableCommand = t_e
  var n_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await _h(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    r_e = async (e, t) => {
      if (e.statusCode >= 300) return s_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = gge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeGlobalTableSettingsCommand = r_e
  var s_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await _h(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    o_e = async (e, t) => {
      if (e.statusCode >= 300) return i_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Ege(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeImportCommand = o_e
  var i_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ImportNotFoundException':
        case 'com.amazonaws.dynamodb#ImportNotFoundException':
          throw await Dhe(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    a_e = async (e, t) => {
      if (e.statusCode >= 300) return c_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_DescribeKinesisStreamingDestinationCommand = a_e
  var c_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    d_e = async (e, t) => {
      if (e.statusCode >= 300) return u_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_DescribeLimitsCommand = d_e
  var u_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    l_e = async (e, t) => {
      if (e.statusCode >= 300) return m_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Sge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeTableCommand = l_e
  var m_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    p_e = async (e, t) => {
      if (e.statusCode >= 300) return f_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = bge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_DescribeTableReplicaAutoScalingCommand = p_e
  var f_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    __e = async (e, t) => {
      if (e.statusCode >= 300) return h_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_DescribeTimeToLiveCommand = __e
  var h_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    y_e = async (e, t) => {
      if (e.statusCode >= 300) return g_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_DisableKinesisStreamingDestinationCommand = y_e
  var g_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    E_e = async (e, t) => {
      if (e.statusCode >= 300) return S_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_EnableKinesisStreamingDestinationCommand = E_e
  var S_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    b_e = async (e, t) => {
      if (e.statusCode >= 300) return v_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = vge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ExecuteStatementCommand = b_e
  var v_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await fh(n, t)
        case 'DuplicateItemException':
        case 'com.amazonaws.dynamodb#DuplicateItemException':
          throw await The(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await Ru(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await hh(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    C_e = async (e, t) => {
      if (e.statusCode >= 300) return w_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Cge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ExecuteTransactionCommand = C_e
  var w_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'IdempotentParameterMismatchException':
        case 'com.amazonaws.dynamodb#IdempotentParameterMismatchException':
          throw await x$(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionCanceledException':
        case 'com.amazonaws.dynamodb#TransactionCanceledException':
          throw await KT(n, t)
        case 'TransactionInProgressException':
        case 'com.amazonaws.dynamodb#TransactionInProgressException':
          throw await D$(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    T_e = async (e, t) => {
      if (e.statusCode >= 300) return x_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = wge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ExportTableToPointInTimeCommand = T_e
  var x_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ExportConflictException':
        case 'com.amazonaws.dynamodb#ExportConflictException':
          throw await xhe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidExportTimeException':
        case 'com.amazonaws.dynamodb#InvalidExportTimeException':
          throw await Ohe(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'PointInTimeRecoveryUnavailableException':
        case 'com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException':
          throw await I$(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    I_e = async (e, t) => {
      if (e.statusCode >= 300) return P_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Tge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_GetItemCommand = I_e
  var P_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    R_e = async (e, t) => {
      if (e.statusCode >= 300) return D_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Dge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ImportTableCommand = R_e
  var D_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ImportConflictException':
        case 'com.amazonaws.dynamodb#ImportConflictException':
          throw await Rhe(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    A_e = async (e, t) => {
      if (e.statusCode >= 300) return O_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Uge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ListBackupsCommand = A_e
  var O_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    N_e = async (e, t) => {
      if (e.statusCode >= 300) return q_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_ListContributorInsightsCommand = N_e
  var q_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    k_e = async (e, t) => {
      if (e.statusCode >= 300) return M_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_ListExportsCommand = k_e
  var M_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    F_e = async (e, t) => {
      if (e.statusCode >= 300) return U_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_ListGlobalTablesCommand = F_e
  var U_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    L_e = async (e, t) => {
      if (e.statusCode >= 300) return B_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Lge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ListImportsCommand = L_e
  var B_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    j_e = async (e, t) => {
      if (e.statusCode >= 300) return G_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_ListTablesCommand = j_e
  var G_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    $_e = async (e, t) => {
      if (e.statusCode >= 300) return z_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_ListTagsOfResourceCommand = $_e
  var z_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    H_e = async (e, t) => {
      if (e.statusCode >= 300) return W_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = zge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_PutItemCommand = H_e
  var W_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await fh(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await Ru(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await hh(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    V_e = async (e, t) => {
      if (e.statusCode >= 300) return Y_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = Wge(n, t)), { $metadata: I(e), ...r }
    }
  y.de_QueryCommand = V_e
  var Y_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    K_e = async (e, t) => {
      if (e.statusCode >= 300) return J_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = nEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_RestoreTableFromBackupCommand = K_e
  var J_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'BackupInUseException':
        case 'com.amazonaws.dynamodb#BackupInUseException':
          throw await WT(n, t)
        case 'BackupNotFoundException':
        case 'com.amazonaws.dynamodb#BackupNotFoundException':
          throw await VT(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'TableAlreadyExistsException':
        case 'com.amazonaws.dynamodb#TableAlreadyExistsException':
          throw await R$(n, t)
        case 'TableInUseException':
        case 'com.amazonaws.dynamodb#TableInUseException':
          throw await YT(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    X_e = async (e, t) => {
      if (e.statusCode >= 300) return Q_e(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = rEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_RestoreTableToPointInTimeCommand = X_e
  var Q_e = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'InvalidRestoreTimeException':
        case 'com.amazonaws.dynamodb#InvalidRestoreTimeException':
          throw await Nhe(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'PointInTimeRecoveryUnavailableException':
        case 'com.amazonaws.dynamodb#PointInTimeRecoveryUnavailableException':
          throw await I$(n, t)
        case 'TableAlreadyExistsException':
        case 'com.amazonaws.dynamodb#TableAlreadyExistsException':
          throw await R$(n, t)
        case 'TableInUseException':
        case 'com.amazonaws.dynamodb#TableInUseException':
          throw await YT(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Z_e = async (e, t) => {
      if (e.statusCode >= 300) return ehe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = sEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_ScanCommand = Z_e
  var ehe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    the = async (e, t) =>
      e.statusCode >= 300
        ? nhe(e, t)
        : (await (0, m.collectBody)(e.body, t), { $metadata: I(e) })
  y.de_TagResourceCommand = the
  var nhe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    rhe = async (e, t) => {
      if (e.statusCode >= 300) return she(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = aEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_TransactGetItemsCommand = rhe
  var she = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionCanceledException':
        case 'com.amazonaws.dynamodb#TransactionCanceledException':
          throw await KT(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    ohe = async (e, t) => {
      if (e.statusCode >= 300) return ihe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = dEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_TransactWriteItemsCommand = ohe
  var ihe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'IdempotentParameterMismatchException':
        case 'com.amazonaws.dynamodb#IdempotentParameterMismatchException':
          throw await x$(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionCanceledException':
        case 'com.amazonaws.dynamodb#TransactionCanceledException':
          throw await KT(n, t)
        case 'TransactionInProgressException':
        case 'com.amazonaws.dynamodb#TransactionInProgressException':
          throw await D$(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    ahe = async (e, t) =>
      e.statusCode >= 300
        ? che(e, t)
        : (await (0, m.collectBody)(e.body, t), { $metadata: I(e) })
  y.de_UntagResourceCommand = ahe
  var che = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    dhe = async (e, t) => {
      if (e.statusCode >= 300) return uhe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = uEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_UpdateContinuousBackupsCommand = dhe
  var uhe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ContinuousBackupsUnavailableException':
        case 'com.amazonaws.dynamodb#ContinuousBackupsUnavailableException':
          throw await T$(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    lhe = async (e, t) => {
      if (e.statusCode >= 300) return mhe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_UpdateContributorInsightsCommand = lhe
  var mhe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    phe = async (e, t) => {
      if (e.statusCode >= 300) return fhe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = lEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_UpdateGlobalTableCommand = phe
  var fhe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await _h(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ReplicaAlreadyExistsException':
        case 'com.amazonaws.dynamodb#ReplicaAlreadyExistsException':
          throw await qhe(n, t)
        case 'ReplicaNotFoundException':
        case 'com.amazonaws.dynamodb#ReplicaNotFoundException':
          throw await P$(n, t)
        case 'TableNotFoundException':
        case 'com.amazonaws.dynamodb#TableNotFoundException':
          throw await Ro(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    _he = async (e, t) => {
      if (e.statusCode >= 300) return hhe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = mEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_UpdateGlobalTableSettingsCommand = _he
  var hhe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'GlobalTableNotFoundException':
        case 'com.amazonaws.dynamodb#GlobalTableNotFoundException':
          throw await _h(n, t)
        case 'IndexNotFoundException':
        case 'com.amazonaws.dynamodb#IndexNotFoundException':
          throw await Ahe(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ReplicaNotFoundException':
        case 'com.amazonaws.dynamodb#ReplicaNotFoundException':
          throw await P$(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    yhe = async (e, t) => {
      if (e.statusCode >= 300) return ghe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = pEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_UpdateItemCommand = yhe
  var ghe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'ConditionalCheckFailedException':
        case 'com.amazonaws.dynamodb#ConditionalCheckFailedException':
          throw await fh(n, t)
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'ItemCollectionSizeLimitExceededException':
        case 'com.amazonaws.dynamodb#ItemCollectionSizeLimitExceededException':
          throw await Ru(n, t)
        case 'ProvisionedThroughputExceededException':
        case 'com.amazonaws.dynamodb#ProvisionedThroughputExceededException':
          throw await Xt(n, t)
        case 'RequestLimitExceeded':
        case 'com.amazonaws.dynamodb#RequestLimitExceeded':
          throw await Ot(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        case 'TransactionConflictException':
        case 'com.amazonaws.dynamodb#TransactionConflictException':
          throw await hh(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Ehe = async (e, t) => {
      if (e.statusCode >= 300) return She(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = fEe(n, t)), { $metadata: I(e), ...r }
    }
  y.de_UpdateTableCommand = Ehe
  var She = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    bhe = async (e, t) => {
      if (e.statusCode >= 300) return vhe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = _Ee(n, t)), { $metadata: I(e), ...r }
    }
  y.de_UpdateTableReplicaAutoScalingCommand = bhe
  var vhe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    Che = async (e, t) => {
      if (e.statusCode >= 300) return whe(e, t)
      let n = await $(e.body, t),
        r = {}
      return (r = (0, m._json)(n)), { $metadata: I(e), ...r }
    }
  y.de_UpdateTimeToLiveCommand = Che
  var whe = async (e, t) => {
      let n = { ...e, body: await B(e.body, t) },
        r = j(e, n.body)
      switch (r) {
        case 'InternalServerError':
        case 'com.amazonaws.dynamodb#InternalServerError':
          throw await W(n, t)
        case 'InvalidEndpointException':
        case 'com.amazonaws.dynamodb#InvalidEndpointException':
          throw await te(n, t)
        case 'LimitExceededException':
        case 'com.amazonaws.dynamodb#LimitExceededException':
          throw await qe(n, t)
        case 'ResourceInUseException':
        case 'com.amazonaws.dynamodb#ResourceInUseException':
          throw await dn(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.dynamodb#ResourceNotFoundException':
          throw await _e(n, t)
        default:
          let s = n.body
          return F({ output: e, parsedBody: s, errorCode: r })
      }
    },
    WT = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.BackupInUseException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    VT = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.BackupNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    fh = async (e, t) => {
      let n = e.body,
        r = oge(n, t),
        s = new ae.ConditionalCheckFailedException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    T$ = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ContinuousBackupsUnavailableException({
          $metadata: I(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    The = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.DuplicateItemException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    xhe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ExportConflictException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ihe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ExportNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Phe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.GlobalTableAlreadyExistsException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    _h = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.GlobalTableNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    x$ = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.IdempotentParameterMismatchException({
          $metadata: I(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    Rhe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ImportConflictException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Dhe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ImportNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ahe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.IndexNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    W = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.InternalServerError({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    te = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.InvalidEndpointException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ohe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.InvalidExportTimeException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Nhe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.InvalidRestoreTimeException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ru = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ItemCollectionSizeLimitExceededException({
          $metadata: I(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    qe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.LimitExceededException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    I$ = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.PointInTimeRecoveryUnavailableException({
          $metadata: I(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    Xt = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ProvisionedThroughputExceededException({
          $metadata: I(e),
          ...r,
        })
      return (0, m.decorateServiceException)(s, n)
    },
    qhe = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ReplicaAlreadyExistsException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    P$ = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ReplicaNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ot = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.RequestLimitExceeded({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    dn = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ResourceInUseException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    _e = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.ResourceNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    R$ = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.TableAlreadyExistsException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    YT = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.TableInUseException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    Ro = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.TableNotFoundException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    KT = async (e, t) => {
      let n = e.body,
        r = cEe(n, t),
        s = new ae.TransactionCanceledException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    hh = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.TransactionConflictException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    D$ = async (e, t) => {
      let n = e.body,
        r = (0, m._json)(n),
        s = new ae.TransactionInProgressException({ $metadata: I(e), ...r })
      return (0, m.decorateServiceException)(s, n)
    },
    khe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Mhe(s, t)), n),
        {},
      ),
    Sr = (e, t) =>
      ae.AttributeValue.visit(e, {
        B: (n) => ({ B: t.base64Encoder(n) }),
        BOOL: (n) => ({ BOOL: n }),
        BS: (n) => ({ BS: Hhe(n, t) }),
        L: (n) => ({ L: uye(n, t) }),
        M: (n) => ({ M: mye(n, t) }),
        N: (n) => ({ N: n }),
        NS: (n) => ({ NS: (0, m._json)(n) }),
        NULL: (n) => ({ NULL: n }),
        S: (n) => ({ S: n }),
        SS: (n) => ({ SS: (0, m._json)(n) }),
        _: (n, r) => ({ name: r }),
      }),
    A$ = (e, t) => e.filter((n) => n != null).map((n) => Sr(n, t)),
    Mhe = (e, t) => (0, m.take)(e, { Action: [], Value: (n) => Sr(n, t) }),
    Fhe = (e, t) =>
      (0, m.take)(e, {
        PolicyName: [],
        TargetTrackingScalingPolicyConfiguration: (n) => Uhe(n, t),
      }),
    ds = (e, t) =>
      (0, m.take)(e, {
        AutoScalingDisabled: [],
        AutoScalingRoleArn: [],
        MaximumUnits: [],
        MinimumUnits: [],
        ScalingPolicyUpdate: (n) => Fhe(n, t),
      }),
    Uhe = (e, t) =>
      (0, m.take)(e, {
        DisableScaleIn: [],
        ScaleInCooldown: [],
        ScaleOutCooldown: [],
        TargetValue: m.serializeFloat,
      }),
    Lhe = (e, t) =>
      (0, m.take)(e, {
        ReturnConsumedCapacity: [],
        Statements: (n) => _ye(n, t),
      }),
    Bhe = (e, t) =>
      (0, m.take)(e, {
        RequestItems: (n) => jhe(n, t),
        ReturnConsumedCapacity: [],
      }),
    jhe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = dye(s, t)), n),
        {},
      ),
    Ghe = (e, t) =>
      (0, m.take)(e, {
        ConsistentRead: [],
        Parameters: (n) => XT(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
      }),
    $he = (e, t) =>
      (0, m.take)(e, {
        RequestItems: (n) => zhe(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
      }),
    zhe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = jye(s, t)), n),
        {},
      ),
    Hhe = (e, t) => e.filter((n) => n != null).map((n) => t.base64Encoder(n)),
    O$ = (e, t) =>
      (0, m.take)(e, {
        AttributeValueList: (n) => A$(n, t),
        ComparisonOperator: [],
      }),
    Whe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Key: (n) => un(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    Vhe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Key: (n) => un(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    Yhe = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (n) => JT(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Key: (n) => un(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    Khe = (e, t) => (0, m.take)(e, { Key: (n) => un(n, t) }),
    Jhe = (e, t) =>
      (0, m.take)(e, {
        ConsistentRead: [],
        Limit: [],
        NextToken: [],
        Parameters: (n) => XT(n, t),
        ReturnConsumedCapacity: [],
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
      }),
    Xhe = (e, t) =>
      (0, m.take)(e, {
        ClientRequestToken: [!0, (n) => n ?? (0, ph.v4)()],
        ReturnConsumedCapacity: [],
        TransactStatements: (n) => fye(n, t),
      }),
    JT = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Qhe(s, t)), n),
        {},
      ),
    Qhe = (e, t) =>
      (0, m.take)(e, {
        AttributeValueList: (n) => A$(n, t),
        ComparisonOperator: [],
        Exists: [],
        Value: (n) => Sr(n, t),
      }),
    Zhe = (e, t) =>
      (0, m.take)(e, {
        ClientToken: [!0, (n) => n ?? (0, ph.v4)()],
        ExportFormat: [],
        ExportTime: (n) => Math.round(n.getTime() / 1e3),
        S3Bucket: [],
        S3BucketOwner: [],
        S3Prefix: [],
        S3SseAlgorithm: [],
        S3SseKmsKeyId: [],
        TableArn: [],
      }),
    br = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Sr(s, t)), n),
        {},
      ),
    N$ = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = O$(s, t)), n),
        {},
      ),
    eye = (e, t) =>
      (0, m.take)(e, {
        ExpressionAttributeNames: m._json,
        Key: (n) => un(n, t),
        ProjectionExpression: [],
        TableName: [],
      }),
    tye = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConsistentRead: [],
        ExpressionAttributeNames: m._json,
        Key: (n) => un(n, t),
        ProjectionExpression: [],
        ReturnConsumedCapacity: [],
        TableName: [],
      }),
    nye = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedWriteCapacityAutoScalingUpdate: (n) => ds(n, t),
      }),
    rye = (e, t) => e.filter((n) => n != null).map((n) => nye(n, t)),
    sye = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedWriteCapacityAutoScalingSettingsUpdate: (n) => ds(n, t),
        ProvisionedWriteCapacityUnits: [],
      }),
    oye = (e, t) => e.filter((n) => n != null).map((n) => sye(n, t)),
    iye = (e, t) =>
      (0, m.take)(e, {
        ClientToken: [!0, (n) => n ?? (0, ph.v4)()],
        InputCompressionType: [],
        InputFormat: [],
        InputFormatOptions: m._json,
        S3BucketSource: m._json,
        TableCreationParameters: m._json,
      }),
    un = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Sr(s, t)), n),
        {},
      ),
    aye = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = O$(s, t)), n),
        {},
      ),
    cye = (e, t) => e.filter((n) => n != null).map((n) => un(n, t)),
    dye = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConsistentRead: [],
        ExpressionAttributeNames: m._json,
        Keys: (n) => cye(n, t),
        ProjectionExpression: [],
      }),
    uye = (e, t) => e.filter((n) => n != null).map((n) => Sr(n, t)),
    lye = (e, t) =>
      (0, m.take)(e, {
        BackupType: [],
        ExclusiveStartBackupArn: [],
        Limit: [],
        TableName: [],
        TimeRangeLowerBound: (n) => Math.round(n.getTime() / 1e3),
        TimeRangeUpperBound: (n) => Math.round(n.getTime() / 1e3),
      }),
    mye = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Sr(s, t)), n),
        {},
      ),
    pye = (e, t) =>
      (0, m.take)(e, {
        Parameters: (n) => XT(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        Statement: [],
      }),
    fye = (e, t) => e.filter((n) => n != null).map((n) => pye(n, t)),
    _ye = (e, t) => e.filter((n) => n != null).map((n) => Ghe(n, t)),
    XT = (e, t) => e.filter((n) => n != null).map((n) => Sr(n, t)),
    hye = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Item: (n) => QT(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    yye = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (n) => JT(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Item: (n) => QT(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
      }),
    QT = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Sr(s, t)), n),
        {},
      ),
    gye = (e, t) => (0, m.take)(e, { Item: (n) => QT(n, t) }),
    Eye = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConditionalOperator: [],
        ConsistentRead: [],
        ExclusiveStartKey: (n) => un(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        FilterExpression: [],
        IndexName: [],
        KeyConditionExpression: [],
        KeyConditions: (n) => aye(n, t),
        Limit: [],
        ProjectionExpression: [],
        QueryFilter: (n) => N$(n, t),
        ReturnConsumedCapacity: [],
        ScanIndexForward: [],
        Select: [],
        TableName: [],
      }),
    Sye = (e, t) =>
      (0, m.take)(e, {
        RegionName: [],
        ReplicaGlobalSecondaryIndexUpdates: (n) => Cye(n, t),
        ReplicaProvisionedReadCapacityAutoScalingUpdate: (n) => ds(n, t),
      }),
    bye = (e, t) => e.filter((n) => n != null).map((n) => Sye(n, t)),
    vye = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedReadCapacityAutoScalingUpdate: (n) => ds(n, t),
      }),
    Cye = (e, t) => e.filter((n) => n != null).map((n) => vye(n, t)),
    wye = (e, t) =>
      (0, m.take)(e, {
        IndexName: [],
        ProvisionedReadCapacityAutoScalingSettingsUpdate: (n) => ds(n, t),
        ProvisionedReadCapacityUnits: [],
      }),
    Tye = (e, t) => e.filter((n) => n != null).map((n) => wye(n, t)),
    xye = (e, t) =>
      (0, m.take)(e, {
        RegionName: [],
        ReplicaGlobalSecondaryIndexSettingsUpdate: (n) => Tye(n, t),
        ReplicaProvisionedReadCapacityAutoScalingSettingsUpdate: (n) =>
          ds(n, t),
        ReplicaProvisionedReadCapacityUnits: [],
        ReplicaTableClass: [],
      }),
    Iye = (e, t) => e.filter((n) => n != null).map((n) => xye(n, t)),
    Pye = (e, t) =>
      (0, m.take)(e, {
        BillingModeOverride: [],
        GlobalSecondaryIndexOverride: m._json,
        LocalSecondaryIndexOverride: m._json,
        ProvisionedThroughputOverride: m._json,
        RestoreDateTime: (n) => Math.round(n.getTime() / 1e3),
        SSESpecificationOverride: m._json,
        SourceTableArn: [],
        SourceTableName: [],
        TargetTableName: [],
        UseLatestRestorableTime: [],
      }),
    Rye = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConditionalOperator: [],
        ConsistentRead: [],
        ExclusiveStartKey: (n) => un(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        FilterExpression: [],
        IndexName: [],
        Limit: [],
        ProjectionExpression: [],
        ReturnConsumedCapacity: [],
        ScanFilter: (n) => N$(n, t),
        Segment: [],
        Select: [],
        TableName: [],
        TotalSegments: [],
      }),
    Dye = (e, t) => (0, m.take)(e, { Get: (n) => eye(n, t) }),
    Aye = (e, t) => e.filter((n) => n != null).map((n) => Dye(n, t)),
    Oye = (e, t) =>
      (0, m.take)(e, {
        ReturnConsumedCapacity: [],
        TransactItems: (n) => Aye(n, t),
      }),
    Nye = (e, t) =>
      (0, m.take)(e, {
        ConditionCheck: (n) => Whe(n, t),
        Delete: (n) => Vhe(n, t),
        Put: (n) => hye(n, t),
        Update: (n) => Mye(n, t),
      }),
    qye = (e, t) => e.filter((n) => n != null).map((n) => Nye(n, t)),
    kye = (e, t) =>
      (0, m.take)(e, {
        ClientRequestToken: [!0, (n) => n ?? (0, ph.v4)()],
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        TransactItems: (n) => qye(n, t),
      }),
    Mye = (e, t) =>
      (0, m.take)(e, {
        ConditionExpression: [],
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Key: (n) => un(n, t),
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
        UpdateExpression: [],
      }),
    Fye = (e, t) =>
      (0, m.take)(e, {
        GlobalTableBillingMode: [],
        GlobalTableGlobalSecondaryIndexSettingsUpdate: (n) => oye(n, t),
        GlobalTableName: [],
        GlobalTableProvisionedWriteCapacityAutoScalingSettingsUpdate: (n) =>
          ds(n, t),
        GlobalTableProvisionedWriteCapacityUnits: [],
        ReplicaSettingsUpdate: (n) => Iye(n, t),
      }),
    Uye = (e, t) =>
      (0, m.take)(e, {
        AttributeUpdates: (n) => khe(n, t),
        ConditionExpression: [],
        ConditionalOperator: [],
        Expected: (n) => JT(n, t),
        ExpressionAttributeNames: m._json,
        ExpressionAttributeValues: (n) => br(n, t),
        Key: (n) => un(n, t),
        ReturnConsumedCapacity: [],
        ReturnItemCollectionMetrics: [],
        ReturnValues: [],
        ReturnValuesOnConditionCheckFailure: [],
        TableName: [],
        UpdateExpression: [],
      }),
    Lye = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexUpdates: (n) => rye(n, t),
        ProvisionedWriteCapacityAutoScalingUpdate: (n) => ds(n, t),
        ReplicaUpdates: (n) => bye(n, t),
        TableName: [],
      }),
    Bye = (e, t) =>
      (0, m.take)(e, {
        DeleteRequest: (n) => Khe(n, t),
        PutRequest: (n) => gye(n, t),
      }),
    jye = (e, t) => e.filter((n) => n != null).map((n) => Bye(n, t)),
    Gye = (e, t) =>
      (0, m.take)(e, {
        ArchivalBackupArn: m.expectString,
        ArchivalDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ArchivalReason: m.expectString,
      }),
    Mn = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = zi((0, m.expectUnion)(s), t)), n),
        {},
      ),
    zi = (e, t) =>
      e.B != null
        ? { B: t.base64Decoder(e.B) }
        : (0, m.expectBoolean)(e.BOOL) !== void 0
        ? { BOOL: (0, m.expectBoolean)(e.BOOL) }
        : e.BS != null
        ? { BS: nge(e.BS, t) }
        : e.L != null
        ? { L: Fge(e.L, t) }
        : e.M != null
        ? { M: Bge(e.M, t) }
        : (0, m.expectString)(e.N) !== void 0
        ? { N: (0, m.expectString)(e.N) }
        : e.NS != null
        ? { NS: (0, m._json)(e.NS) }
        : (0, m.expectBoolean)(e.NULL) !== void 0
        ? { NULL: (0, m.expectBoolean)(e.NULL) }
        : (0, m.expectString)(e.S) !== void 0
        ? { S: (0, m.expectString)(e.S) }
        : e.SS != null
        ? { SS: (0, m._json)(e.SS) }
        : { $unknown: Object.entries(e)[0] },
    $ye = (e, t) =>
      (0, m.take)(e, {
        PolicyName: m.expectString,
        TargetTrackingScalingPolicyConfiguration: (n) => Hye(n, t),
      }),
    zye = (e, t) => (e || []).filter((r) => r != null).map((r) => $ye(r, t)),
    cs = (e, t) =>
      (0, m.take)(e, {
        AutoScalingDisabled: m.expectBoolean,
        AutoScalingRoleArn: m.expectString,
        MaximumUnits: m.expectLong,
        MinimumUnits: m.expectLong,
        ScalingPolicies: (n) => zye(n, t),
      }),
    Hye = (e, t) =>
      (0, m.take)(e, {
        DisableScaleIn: m.expectBoolean,
        ScaleInCooldown: m.expectInt32,
        ScaleOutCooldown: m.expectInt32,
        TargetValue: m.limitedParseDouble,
      }),
    q$ = (e, t) =>
      (0, m.take)(e, {
        BackupDetails: (n) => k$(n, t),
        SourceTableDetails: (n) => oEe(n, t),
        SourceTableFeatureDetails: (n) => iEe(n, t),
      }),
    k$ = (e, t) =>
      (0, m.take)(e, {
        BackupArn: m.expectString,
        BackupCreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupExpiryDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupName: m.expectString,
        BackupSizeBytes: m.expectLong,
        BackupStatus: m.expectString,
        BackupType: m.expectString,
      }),
    Wye = (e, t) => (e || []).filter((r) => r != null).map((r) => Vye(r, t)),
    Vye = (e, t) =>
      (0, m.take)(e, {
        BackupArn: m.expectString,
        BackupCreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupExpiryDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        BackupName: m.expectString,
        BackupSizeBytes: m.expectLong,
        BackupStatus: m.expectString,
        BackupType: m.expectString,
        TableArn: m.expectString,
        TableId: m.expectString,
        TableName: m.expectString,
      }),
    Yye = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => Hi(n, t),
        Responses: (n) => jge(n, t),
      }),
    Kye = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => Hi(n, t),
        Responses: (n) => Xye(n, t),
        UnprocessedKeys: (n) => Jye(n, t),
      }),
    Jye = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Mge(s, t)), n),
        {},
      ),
    Xye = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = gh(s, t)), n),
        {},
      ),
    Qye = (e, t) =>
      (0, m.take)(e, {
        Code: m.expectString,
        Item: (n) => Mn(n, t),
        Message: m.expectString,
      }),
    Zye = (e, t) =>
      (0, m.take)(e, {
        Error: (n) => Qye(n, t),
        Item: (n) => Mn(n, t),
        TableName: m.expectString,
      }),
    ege = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => Hi(n, t),
        ItemCollectionMetrics: (n) => j$(n, t),
        UnprocessedItems: (n) => tge(n, t),
      }),
    tge = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = yEe(s, t)), n),
        {},
      ),
    M$ = (e, t) =>
      (0, m.take)(e, {
        BillingMode: m.expectString,
        LastUpdateToPayPerRequestDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
      }),
    nge = (e, t) =>
      (e || []).filter((r) => r != null).map((r) => t.base64Decoder(r)),
    rge = (e, t) =>
      (0, m.take)(e, {
        Code: m.expectString,
        Item: (n) => Mn(n, t),
        Message: m.expectString,
      }),
    sge = (e, t) => (e || []).filter((r) => r != null).map((r) => rge(r, t)),
    F$ = (e, t) =>
      (0, m.take)(e, {
        CapacityUnits: m.limitedParseDouble,
        ReadCapacityUnits: m.limitedParseDouble,
        WriteCapacityUnits: m.limitedParseDouble,
      }),
    oge = (e, t) =>
      (0, m.take)(e, { Item: (n) => Mn(n, t), message: m.expectString }),
    us = (e, t) =>
      (0, m.take)(e, {
        CapacityUnits: m.limitedParseDouble,
        GlobalSecondaryIndexes: (n) => w$(n, t),
        LocalSecondaryIndexes: (n) => w$(n, t),
        ReadCapacityUnits: m.limitedParseDouble,
        Table: (n) => F$(n, t),
        TableName: m.expectString,
        WriteCapacityUnits: m.limitedParseDouble,
      }),
    Hi = (e, t) => (e || []).filter((r) => r != null).map((r) => us(r, t)),
    U$ = (e, t) =>
      (0, m.take)(e, {
        ContinuousBackupsStatus: m.expectString,
        PointInTimeRecoveryDescription: (n) => Gge(n, t),
      }),
    ige = (e, t) => (0, m.take)(e, { BackupDetails: (n) => k$(n, t) }),
    age = (e, t) => (0, m.take)(e, { GlobalTableDescription: (n) => ZT(n, t) }),
    cge = (e, t) => (0, m.take)(e, { TableDescription: (n) => Wi(n, t) }),
    dge = (e, t) => (0, m.take)(e, { BackupDescription: (n) => q$(n, t) }),
    uge = (e, t) =>
      (0, m.take)(e, {
        Attributes: (n) => Mn(n, t),
        ConsumedCapacity: (n) => us(n, t),
        ItemCollectionMetrics: (n) => yh(n, t),
      }),
    lge = (e, t) => (0, m.take)(e, { Key: (n) => Du(n, t) }),
    mge = (e, t) => (0, m.take)(e, { TableDescription: (n) => Wi(n, t) }),
    pge = (e, t) => (0, m.take)(e, { BackupDescription: (n) => q$(n, t) }),
    fge = (e, t) =>
      (0, m.take)(e, { ContinuousBackupsDescription: (n) => U$(n, t) }),
    _ge = (e, t) =>
      (0, m.take)(e, {
        ContributorInsightsRuleList: m._json,
        ContributorInsightsStatus: m.expectString,
        FailureException: m._json,
        IndexName: m.expectString,
        LastUpdateDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableName: m.expectString,
      }),
    hge = (e, t) => (0, m.take)(e, { ExportDescription: (n) => L$(n, t) }),
    yge = (e, t) => (0, m.take)(e, { GlobalTableDescription: (n) => ZT(n, t) }),
    gge = (e, t) =>
      (0, m.take)(e, {
        GlobalTableName: m.expectString,
        ReplicaSettings: (n) => H$(n, t),
      }),
    Ege = (e, t) => (0, m.take)(e, { ImportTableDescription: (n) => B$(n, t) }),
    Sge = (e, t) => (0, m.take)(e, { Table: (n) => Wi(n, t) }),
    bge = (e, t) =>
      (0, m.take)(e, { TableAutoScalingDescription: (n) => V$(n, t) }),
    vge = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => us(n, t),
        Items: (n) => gh(n, t),
        LastEvaluatedKey: (n) => Du(n, t),
        NextToken: m.expectString,
      }),
    Cge = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => Hi(n, t),
        Responses: (n) => G$(n, t),
      }),
    L$ = (e, t) =>
      (0, m.take)(e, {
        BilledSizeBytes: m.expectLong,
        ClientToken: m.expectString,
        EndTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ExportArn: m.expectString,
        ExportFormat: m.expectString,
        ExportManifest: m.expectString,
        ExportStatus: m.expectString,
        ExportTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        FailureCode: m.expectString,
        FailureMessage: m.expectString,
        ItemCount: m.expectLong,
        S3Bucket: m.expectString,
        S3BucketOwner: m.expectString,
        S3Prefix: m.expectString,
        S3SseAlgorithm: m.expectString,
        S3SseKmsKeyId: m.expectString,
        StartTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableArn: m.expectString,
        TableId: m.expectString,
      }),
    wge = (e, t) => (0, m.take)(e, { ExportDescription: (n) => L$(n, t) }),
    Tge = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => us(n, t),
        Item: (n) => Mn(n, t),
      }),
    xge = (e, t) =>
      (0, m.take)(e, {
        Backfilling: m.expectBoolean,
        IndexArn: m.expectString,
        IndexName: m.expectString,
        IndexSizeBytes: m.expectLong,
        IndexStatus: m.expectString,
        ItemCount: m.expectLong,
        KeySchema: m._json,
        Projection: m._json,
        ProvisionedThroughput: (n) => $$(n, t),
      }),
    Ige = (e, t) => (e || []).filter((r) => r != null).map((r) => xge(r, t)),
    ZT = (e, t) =>
      (0, m.take)(e, {
        CreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        GlobalTableArn: m.expectString,
        GlobalTableName: m.expectString,
        GlobalTableStatus: m.expectString,
        ReplicationGroup: (n) => z$(n, t),
      }),
    Pge = (e, t) =>
      (0, m.take)(e, {
        CloudWatchLogGroupArn: m.expectString,
        EndTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ImportArn: m.expectString,
        ImportStatus: m.expectString,
        InputFormat: m.expectString,
        S3BucketSource: m._json,
        StartTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableArn: m.expectString,
      }),
    Rge = (e, t) => (e || []).filter((r) => r != null).map((r) => Pge(r, t)),
    B$ = (e, t) =>
      (0, m.take)(e, {
        ClientToken: m.expectString,
        CloudWatchLogGroupArn: m.expectString,
        EndTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ErrorCount: m.expectLong,
        FailureCode: m.expectString,
        FailureMessage: m.expectString,
        ImportArn: m.expectString,
        ImportStatus: m.expectString,
        ImportedItemCount: m.expectLong,
        InputCompressionType: m.expectString,
        InputFormat: m.expectString,
        InputFormatOptions: m._json,
        ProcessedItemCount: m.expectLong,
        ProcessedSizeBytes: m.expectLong,
        S3BucketSource: m._json,
        StartTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableArn: m.expectString,
        TableCreationParameters: m._json,
        TableId: m.expectString,
      }),
    Dge = (e, t) => (0, m.take)(e, { ImportTableDescription: (n) => B$(n, t) }),
    Age = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = zi((0, m.expectUnion)(s), t)), n),
        {},
      ),
    yh = (e, t) =>
      (0, m.take)(e, {
        ItemCollectionKey: (n) => Age(n, t),
        SizeEstimateRangeGB: (n) => Nge(n, t),
      }),
    Oge = (e, t) => (e || []).filter((r) => r != null).map((r) => yh(r, t)),
    j$ = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = Oge(s, t)), n),
        {},
      ),
    Nge = (e, t) =>
      (e || [])
        .filter((r) => r != null)
        .map((r) => (0, m.limitedParseDouble)(r)),
    gh = (e, t) => (e || []).filter((r) => r != null).map((r) => Mn(r, t)),
    qge = (e, t) => (0, m.take)(e, { Item: (n) => Mn(n, t) }),
    G$ = (e, t) => (e || []).filter((r) => r != null).map((r) => qge(r, t)),
    Du = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = zi((0, m.expectUnion)(s), t)), n),
        {},
      ),
    kge = (e, t) => (e || []).filter((r) => r != null).map((r) => Du(r, t)),
    Mge = (e, t) =>
      (0, m.take)(e, {
        AttributesToGet: m._json,
        ConsistentRead: m.expectBoolean,
        ExpressionAttributeNames: m._json,
        Keys: (n) => kge(n, t),
        ProjectionExpression: m.expectString,
      }),
    Fge = (e, t) =>
      (e || [])
        .filter((r) => r != null)
        .map((r) => zi((0, m.expectUnion)(r), t)),
    Uge = (e, t) =>
      (0, m.take)(e, {
        BackupSummaries: (n) => Wye(n, t),
        LastEvaluatedBackupArn: m.expectString,
      }),
    Lge = (e, t) =>
      (0, m.take)(e, {
        ImportSummaryList: (n) => Rge(n, t),
        NextToken: m.expectString,
      }),
    Bge = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = zi((0, m.expectUnion)(s), t)), n),
        {},
      ),
    jge = (e, t) => (e || []).filter((r) => r != null).map((r) => Zye(r, t)),
    Gge = (e, t) =>
      (0, m.take)(e, {
        EarliestRestorableDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        LatestRestorableDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        PointInTimeRecoveryStatus: m.expectString,
      }),
    $$ = (e, t) =>
      (0, m.take)(e, {
        LastDecreaseDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        LastIncreaseDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        NumberOfDecreasesToday: m.expectLong,
        ReadCapacityUnits: m.expectLong,
        WriteCapacityUnits: m.expectLong,
      }),
    $ge = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = zi((0, m.expectUnion)(s), t)), n),
        {},
      ),
    zge = (e, t) =>
      (0, m.take)(e, {
        Attributes: (n) => Mn(n, t),
        ConsumedCapacity: (n) => us(n, t),
        ItemCollectionMetrics: (n) => yh(n, t),
      }),
    Hge = (e, t) => (0, m.take)(e, { Item: (n) => $ge(n, t) }),
    Wge = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => us(n, t),
        Count: m.expectInt32,
        Items: (n) => gh(n, t),
        LastEvaluatedKey: (n) => Du(n, t),
        ScannedCount: m.expectInt32,
      }),
    Vge = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexes: (n) => Xge(n, t),
        RegionName: m.expectString,
        ReplicaProvisionedReadCapacityAutoScalingSettings: (n) => cs(n, t),
        ReplicaProvisionedWriteCapacityAutoScalingSettings: (n) => cs(n, t),
        ReplicaStatus: m.expectString,
      }),
    Yge = (e, t) => (e || []).filter((r) => r != null).map((r) => Vge(r, t)),
    Kge = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexes: m._json,
        KMSMasterKeyId: m.expectString,
        ProvisionedThroughputOverride: m._json,
        RegionName: m.expectString,
        ReplicaInaccessibleDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        ReplicaStatus: m.expectString,
        ReplicaStatusDescription: m.expectString,
        ReplicaStatusPercentProgress: m.expectString,
        ReplicaTableClassSummary: (n) => ex(n, t),
      }),
    z$ = (e, t) => (e || []).filter((r) => r != null).map((r) => Kge(r, t)),
    Jge = (e, t) =>
      (0, m.take)(e, {
        IndexName: m.expectString,
        IndexStatus: m.expectString,
        ProvisionedReadCapacityAutoScalingSettings: (n) => cs(n, t),
        ProvisionedWriteCapacityAutoScalingSettings: (n) => cs(n, t),
      }),
    Xge = (e, t) => (e || []).filter((r) => r != null).map((r) => Jge(r, t)),
    Qge = (e, t) =>
      (0, m.take)(e, {
        IndexName: m.expectString,
        IndexStatus: m.expectString,
        ProvisionedReadCapacityAutoScalingSettings: (n) => cs(n, t),
        ProvisionedReadCapacityUnits: m.expectLong,
        ProvisionedWriteCapacityAutoScalingSettings: (n) => cs(n, t),
        ProvisionedWriteCapacityUnits: m.expectLong,
      }),
    Zge = (e, t) => (e || []).filter((r) => r != null).map((r) => Qge(r, t)),
    eEe = (e, t) =>
      (0, m.take)(e, {
        RegionName: m.expectString,
        ReplicaBillingModeSummary: (n) => M$(n, t),
        ReplicaGlobalSecondaryIndexSettings: (n) => Zge(n, t),
        ReplicaProvisionedReadCapacityAutoScalingSettings: (n) => cs(n, t),
        ReplicaProvisionedReadCapacityUnits: m.expectLong,
        ReplicaProvisionedWriteCapacityAutoScalingSettings: (n) => cs(n, t),
        ReplicaProvisionedWriteCapacityUnits: m.expectLong,
        ReplicaStatus: m.expectString,
        ReplicaTableClassSummary: (n) => ex(n, t),
      }),
    H$ = (e, t) => (e || []).filter((r) => r != null).map((r) => eEe(r, t)),
    tEe = (e, t) =>
      (0, m.take)(e, {
        RestoreDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        RestoreInProgress: m.expectBoolean,
        SourceBackupArn: m.expectString,
        SourceTableArn: m.expectString,
      }),
    nEe = (e, t) => (0, m.take)(e, { TableDescription: (n) => Wi(n, t) }),
    rEe = (e, t) => (0, m.take)(e, { TableDescription: (n) => Wi(n, t) }),
    sEe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => us(n, t),
        Count: m.expectInt32,
        Items: (n) => gh(n, t),
        LastEvaluatedKey: (n) => Du(n, t),
        ScannedCount: m.expectInt32,
      }),
    w$ = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => (s === null || (n[r] = F$(s, t)), n),
        {},
      ),
    oEe = (e, t) =>
      (0, m.take)(e, {
        BillingMode: m.expectString,
        ItemCount: m.expectLong,
        KeySchema: m._json,
        ProvisionedThroughput: m._json,
        TableArn: m.expectString,
        TableCreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableId: m.expectString,
        TableName: m.expectString,
        TableSizeBytes: m.expectLong,
      }),
    iEe = (e, t) =>
      (0, m.take)(e, {
        GlobalSecondaryIndexes: m._json,
        LocalSecondaryIndexes: m._json,
        SSEDescription: (n) => W$(n, t),
        StreamDescription: m._json,
        TimeToLiveDescription: m._json,
      }),
    W$ = (e, t) =>
      (0, m.take)(e, {
        InaccessibleEncryptionDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        KMSMasterKeyArn: m.expectString,
        SSEType: m.expectString,
        Status: m.expectString,
      }),
    V$ = (e, t) =>
      (0, m.take)(e, {
        Replicas: (n) => Yge(n, t),
        TableName: m.expectString,
        TableStatus: m.expectString,
      }),
    ex = (e, t) =>
      (0, m.take)(e, {
        LastUpdateDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        TableClass: m.expectString,
      }),
    Wi = (e, t) =>
      (0, m.take)(e, {
        ArchivalSummary: (n) => Gye(n, t),
        AttributeDefinitions: m._json,
        BillingModeSummary: (n) => M$(n, t),
        CreationDateTime: (n) =>
          (0, m.expectNonNull)(
            (0, m.parseEpochTimestamp)((0, m.expectNumber)(n)),
          ),
        DeletionProtectionEnabled: m.expectBoolean,
        GlobalSecondaryIndexes: (n) => Ige(n, t),
        GlobalTableVersion: m.expectString,
        ItemCount: m.expectLong,
        KeySchema: m._json,
        LatestStreamArn: m.expectString,
        LatestStreamLabel: m.expectString,
        LocalSecondaryIndexes: m._json,
        ProvisionedThroughput: (n) => $$(n, t),
        Replicas: (n) => z$(n, t),
        RestoreSummary: (n) => tEe(n, t),
        SSEDescription: (n) => W$(n, t),
        StreamSpecification: m._json,
        TableArn: m.expectString,
        TableClassSummary: (n) => ex(n, t),
        TableId: m.expectString,
        TableName: m.expectString,
        TableSizeBytes: m.expectLong,
        TableStatus: m.expectString,
      }),
    aEe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => Hi(n, t),
        Responses: (n) => G$(n, t),
      }),
    cEe = (e, t) =>
      (0, m.take)(e, {
        CancellationReasons: (n) => sge(n, t),
        Message: m.expectString,
      }),
    dEe = (e, t) =>
      (0, m.take)(e, {
        ConsumedCapacity: (n) => Hi(n, t),
        ItemCollectionMetrics: (n) => j$(n, t),
      }),
    uEe = (e, t) =>
      (0, m.take)(e, { ContinuousBackupsDescription: (n) => U$(n, t) }),
    lEe = (e, t) => (0, m.take)(e, { GlobalTableDescription: (n) => ZT(n, t) }),
    mEe = (e, t) =>
      (0, m.take)(e, {
        GlobalTableName: m.expectString,
        ReplicaSettings: (n) => H$(n, t),
      }),
    pEe = (e, t) =>
      (0, m.take)(e, {
        Attributes: (n) => Mn(n, t),
        ConsumedCapacity: (n) => us(n, t),
        ItemCollectionMetrics: (n) => yh(n, t),
      }),
    fEe = (e, t) => (0, m.take)(e, { TableDescription: (n) => Wi(n, t) }),
    _Ee = (e, t) =>
      (0, m.take)(e, { TableAutoScalingDescription: (n) => V$(n, t) }),
    hEe = (e, t) =>
      (0, m.take)(e, {
        DeleteRequest: (n) => lge(n, t),
        PutRequest: (n) => Hge(n, t),
      }),
    yEe = (e, t) => (e || []).filter((r) => r != null).map((r) => hEe(r, t)),
    I = (e) => ({
      httpStatusCode: e.statusCode,
      requestId:
        e.headers['x-amzn-requestid'] ??
        e.headers['x-amzn-request-id'] ??
        e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }),
    gEe = (e, t) => (0, m.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    F = (0, m.withBaseException)(Ipe.DynamoDBServiceException),
    U = async (e, t, n, r, s) => {
      let {
          hostname: o,
          protocol: i = 'https',
          port: c,
          path: a,
        } = await e.endpoint(),
        u = {
          protocol: i,
          hostname: o,
          port: c,
          method: 'POST',
          path: a.endsWith('/') ? a.slice(0, -1) + n : a + n,
          headers: t,
        }
      return (
        r !== void 0 && (u.hostname = r),
        s !== void 0 && (u.body = s),
        new xpe.HttpRequest(u)
      )
    }
  function L(e) {
    return {
      'content-type': 'application/x-amz-json-1.0',
      'x-amz-target': `DynamoDB_20120810.${e}`,
    }
  }
  var $ = (e, t) => gEe(e, t).then((n) => (n.length ? JSON.parse(n) : {})),
    B = async (e, t) => {
      let n = await $(e, t)
      return (n.message = n.message ?? n.Message), n
    },
    j = (e, t) => {
      let n = (o, i) =>
          Object.keys(o).find((c) => c.toLowerCase() === i.toLowerCase()),
        r = (o) => {
          let i = o
          return (
            typeof i == 'number' && (i = i.toString()),
            i.indexOf(',') >= 0 && (i = i.split(',')[0]),
            i.indexOf(':') >= 0 && (i = i.split(':')[0]),
            i.indexOf('#') >= 0 && (i = i.split('#')[1]),
            i
          )
        },
        s = n(e.headers, 'x-amzn-errortype')
      if (s !== void 0) return r(e.headers[s])
      if (t.code !== void 0) return r(t.code)
      if (t.__type !== void 0) return r(t.__type)
    }
})
var Eh = l((Vi) => {
  'use strict'
  Object.defineProperty(Vi, '__esModule', { value: !0 })
  Vi.DescribeEndpointsCommand = Vi.$Command = void 0
  var EEe = D(),
    SEe = O(),
    K$ = v()
  Object.defineProperty(Vi, '$Command', {
    enumerable: !0,
    get: function () {
      return K$.Command
    },
  })
  var Y$ = M(),
    tx = class e extends K$.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, SEe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, EEe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeEndpointsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, Y$.se_DescribeEndpointsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Y$.de_DescribeEndpointsCommand)(t, n)
      }
    }
  Vi.DescribeEndpointsCommand = tx
})
var J$ = l((Sh) => {
  'use strict'
  Object.defineProperty(Sh, '__esModule', { value: !0 })
  Sh.resolveClientEndpointParameters = void 0
  var bEe = (e) => ({
    ...e,
    useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
    useFipsEndpoint: e.useFipsEndpoint ?? !1,
    defaultSigningName: 'dynamodb',
  })
  Sh.resolveClientEndpointParameters = bEe
})
var X$ = l((Kze, vEe) => {
  vEe.exports = {
    name: '@aws-sdk/client-dynamodb',
    description:
      'AWS SDK for JavaScript Dynamodb Client for Node.js, Browser and React Native',
    version: '3.395.0',
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      'build:cjs': 'tsc -p tsconfig.cjs.json',
      'build:docs': 'typedoc',
      'build:es': 'tsc -p tsconfig.es.json',
      'build:include:deps':
        'lerna run --scope $npm_package_name --include-dependencies build',
      'build:types': 'tsc -p tsconfig.types.json',
      'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
      clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
      'extract:docs': 'api-extractor run --local',
      'generate:client':
        'node ../../scripts/generate-clients/single-service --solo dynamodb',
    },
    main: './dist-cjs/index.js',
    types: './dist-types/index.d.ts',
    module: './dist-es/index.js',
    sideEffects: !1,
    dependencies: {
      '@aws-crypto/sha256-browser': '3.0.0',
      '@aws-crypto/sha256-js': '3.0.0',
      '@aws-sdk/client-sts': '3.395.0',
      '@aws-sdk/credential-provider-node': '3.395.0',
      '@aws-sdk/middleware-endpoint-discovery': '3.391.0',
      '@aws-sdk/middleware-host-header': '3.391.0',
      '@aws-sdk/middleware-logger': '3.391.0',
      '@aws-sdk/middleware-recursion-detection': '3.391.0',
      '@aws-sdk/middleware-signing': '3.391.0',
      '@aws-sdk/middleware-user-agent': '3.391.0',
      '@aws-sdk/types': '3.391.0',
      '@aws-sdk/util-endpoints': '3.391.0',
      '@aws-sdk/util-user-agent-browser': '3.391.0',
      '@aws-sdk/util-user-agent-node': '3.391.0',
      '@smithy/config-resolver': '^2.0.3',
      '@smithy/fetch-http-handler': '^2.0.3',
      '@smithy/hash-node': '^2.0.3',
      '@smithy/invalid-dependency': '^2.0.3',
      '@smithy/middleware-content-length': '^2.0.3',
      '@smithy/middleware-endpoint': '^2.0.3',
      '@smithy/middleware-retry': '^2.0.3',
      '@smithy/middleware-serde': '^2.0.3',
      '@smithy/middleware-stack': '^2.0.0',
      '@smithy/node-config-provider': '^2.0.3',
      '@smithy/node-http-handler': '^2.0.3',
      '@smithy/protocol-http': '^2.0.3',
      '@smithy/smithy-client': '^2.0.3',
      '@smithy/types': '^2.2.0',
      '@smithy/url-parser': '^2.0.3',
      '@smithy/util-base64': '^2.0.0',
      '@smithy/util-body-length-browser': '^2.0.0',
      '@smithy/util-body-length-node': '^2.0.0',
      '@smithy/util-defaults-mode-browser': '^2.0.3',
      '@smithy/util-defaults-mode-node': '^2.0.3',
      '@smithy/util-retry': '^2.0.0',
      '@smithy/util-utf8': '^2.0.0',
      '@smithy/util-waiter': '^2.0.3',
      tslib: '^2.5.0',
      uuid: '^8.3.2',
    },
    devDependencies: {
      '@smithy/service-client-documentation-generator': '^2.0.0',
      '@tsconfig/node14': '1.0.3',
      '@types/node': '^14.14.31',
      '@types/uuid': '^8.3.0',
      concurrently: '7.0.0',
      'downlevel-dts': '0.10.1',
      rimraf: '3.0.2',
      typedoc: '0.23.23',
      typescript: '~4.9.5',
    },
    engines: { node: '>=14.0.0' },
    typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
    files: ['dist-*/**'],
    author: {
      name: 'AWS SDK for JavaScript Team',
      url: 'https://aws.amazon.com/javascript/',
    },
    license: 'Apache-2.0',
    browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
    'react-native': {
      './dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
    },
    homepage:
      'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-dynamodb',
    repository: {
      type: 'git',
      url: 'https://github.com/aws/aws-sdk-js-v3.git',
      directory: 'clients/client-dynamodb',
    },
  }
})
var Q$ = l((bh) => {
  'use strict'
  Object.defineProperty(bh, '__esModule', { value: !0 })
  bh.resolveStsAuthConfig = void 0
  var CEe = fr(),
    wEe = (e, { stsClientCtor: t }) =>
      (0, CEe.resolveAwsAuthConfig)({ ...e, stsClientCtor: t })
  bh.resolveStsAuthConfig = wEe
})
var Z$ = l((vh) => {
  'use strict'
  Object.defineProperty(vh, '__esModule', { value: !0 })
  vh.resolveClientEndpointParameters = void 0
  var TEe = (e) => ({
    ...e,
    useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
    useFipsEndpoint: e.useFipsEndpoint ?? !1,
    useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
    defaultSigningName: 'sts',
  })
  vh.resolveClientEndpointParameters = TEe
})
var ez = l((Qze, xEe) => {
  xEe.exports = {
    name: '@aws-sdk/client-sts',
    description:
      'AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native',
    version: '3.395.0',
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      'build:cjs': 'tsc -p tsconfig.cjs.json',
      'build:docs': 'typedoc',
      'build:es': 'tsc -p tsconfig.es.json',
      'build:include:deps':
        'lerna run --scope $npm_package_name --include-dependencies build',
      'build:types': 'tsc -p tsconfig.types.json',
      'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
      clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
      'extract:docs': 'api-extractor run --local',
      'generate:client':
        'node ../../scripts/generate-clients/single-service --solo sts',
      test: 'yarn test:unit',
      'test:unit': 'jest',
    },
    main: './dist-cjs/index.js',
    types: './dist-types/index.d.ts',
    module: './dist-es/index.js',
    sideEffects: !1,
    dependencies: {
      '@aws-crypto/sha256-browser': '3.0.0',
      '@aws-crypto/sha256-js': '3.0.0',
      '@aws-sdk/credential-provider-node': '3.395.0',
      '@aws-sdk/middleware-host-header': '3.391.0',
      '@aws-sdk/middleware-logger': '3.391.0',
      '@aws-sdk/middleware-recursion-detection': '3.391.0',
      '@aws-sdk/middleware-sdk-sts': '3.391.0',
      '@aws-sdk/middleware-signing': '3.391.0',
      '@aws-sdk/middleware-user-agent': '3.391.0',
      '@aws-sdk/types': '3.391.0',
      '@aws-sdk/util-endpoints': '3.391.0',
      '@aws-sdk/util-user-agent-browser': '3.391.0',
      '@aws-sdk/util-user-agent-node': '3.391.0',
      '@smithy/config-resolver': '^2.0.3',
      '@smithy/fetch-http-handler': '^2.0.3',
      '@smithy/hash-node': '^2.0.3',
      '@smithy/invalid-dependency': '^2.0.3',
      '@smithy/middleware-content-length': '^2.0.3',
      '@smithy/middleware-endpoint': '^2.0.3',
      '@smithy/middleware-retry': '^2.0.3',
      '@smithy/middleware-serde': '^2.0.3',
      '@smithy/middleware-stack': '^2.0.0',
      '@smithy/node-config-provider': '^2.0.3',
      '@smithy/node-http-handler': '^2.0.3',
      '@smithy/protocol-http': '^2.0.3',
      '@smithy/smithy-client': '^2.0.3',
      '@smithy/types': '^2.2.0',
      '@smithy/url-parser': '^2.0.3',
      '@smithy/util-base64': '^2.0.0',
      '@smithy/util-body-length-browser': '^2.0.0',
      '@smithy/util-body-length-node': '^2.0.0',
      '@smithy/util-defaults-mode-browser': '^2.0.3',
      '@smithy/util-defaults-mode-node': '^2.0.3',
      '@smithy/util-retry': '^2.0.0',
      '@smithy/util-utf8': '^2.0.0',
      'fast-xml-parser': '4.2.5',
      tslib: '^2.5.0',
    },
    devDependencies: {
      '@smithy/service-client-documentation-generator': '^2.0.0',
      '@tsconfig/node14': '1.0.3',
      '@types/node': '^14.14.31',
      concurrently: '7.0.0',
      'downlevel-dts': '0.10.1',
      rimraf: '3.0.2',
      typedoc: '0.23.23',
      typescript: '~4.9.5',
    },
    engines: { node: '>=14.0.0' },
    typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
    files: ['dist-*/**'],
    author: {
      name: 'AWS SDK for JavaScript Team',
      url: 'https://aws.amazon.com/javascript/',
    },
    license: 'Apache-2.0',
    browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
    'react-native': {
      './dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
    },
    homepage:
      'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts',
    repository: {
      type: 'git',
      url: 'https://github.com/aws/aws-sdk-js-v3.git',
      directory: 'clients/client-sts',
    },
  }
})
var Ch = l((Yi) => {
  'use strict'
  Object.defineProperty(Yi, '__esModule', { value: !0 })
  Yi.STSServiceException = Yi.__ServiceException = void 0
  var tz = v()
  Object.defineProperty(Yi, '__ServiceException', {
    enumerable: !0,
    get: function () {
      return tz.ServiceException
    },
  })
  var nx = class e extends tz.ServiceException {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e.prototype)
    }
  }
  Yi.STSServiceException = nx
})
var ms = l((ee) => {
  'use strict'
  Object.defineProperty(ee, '__esModule', { value: !0 })
  ee.GetSessionTokenResponseFilterSensitiveLog =
    ee.GetFederationTokenResponseFilterSensitiveLog =
    ee.AssumeRoleWithWebIdentityResponseFilterSensitiveLog =
    ee.AssumeRoleWithWebIdentityRequestFilterSensitiveLog =
    ee.AssumeRoleWithSAMLResponseFilterSensitiveLog =
    ee.AssumeRoleWithSAMLRequestFilterSensitiveLog =
    ee.AssumeRoleResponseFilterSensitiveLog =
    ee.CredentialsFilterSensitiveLog =
    ee.InvalidAuthorizationMessageException =
    ee.IDPCommunicationErrorException =
    ee.InvalidIdentityTokenException =
    ee.IDPRejectedClaimException =
    ee.RegionDisabledException =
    ee.PackedPolicyTooLargeException =
    ee.MalformedPolicyDocumentException =
    ee.ExpiredTokenException =
      void 0
  var lx = v(),
    ls = Ch(),
    rx = class e extends ls.STSServiceException {
      constructor(t) {
        super({ name: 'ExpiredTokenException', $fault: 'client', ...t }),
          (this.name = 'ExpiredTokenException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  ee.ExpiredTokenException = rx
  var sx = class e extends ls.STSServiceException {
    constructor(t) {
      super({
        name: 'MalformedPolicyDocumentException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'MalformedPolicyDocumentException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.MalformedPolicyDocumentException = sx
  var ox = class e extends ls.STSServiceException {
    constructor(t) {
      super({ name: 'PackedPolicyTooLargeException', $fault: 'client', ...t }),
        (this.name = 'PackedPolicyTooLargeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.PackedPolicyTooLargeException = ox
  var ix = class e extends ls.STSServiceException {
    constructor(t) {
      super({ name: 'RegionDisabledException', $fault: 'client', ...t }),
        (this.name = 'RegionDisabledException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.RegionDisabledException = ix
  var ax = class e extends ls.STSServiceException {
    constructor(t) {
      super({ name: 'IDPRejectedClaimException', $fault: 'client', ...t }),
        (this.name = 'IDPRejectedClaimException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.IDPRejectedClaimException = ax
  var cx = class e extends ls.STSServiceException {
    constructor(t) {
      super({ name: 'InvalidIdentityTokenException', $fault: 'client', ...t }),
        (this.name = 'InvalidIdentityTokenException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.InvalidIdentityTokenException = cx
  var dx = class e extends ls.STSServiceException {
    constructor(t) {
      super({ name: 'IDPCommunicationErrorException', $fault: 'client', ...t }),
        (this.name = 'IDPCommunicationErrorException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.IDPCommunicationErrorException = dx
  var ux = class e extends ls.STSServiceException {
    constructor(t) {
      super({
        name: 'InvalidAuthorizationMessageException',
        $fault: 'client',
        ...t,
      }),
        (this.name = 'InvalidAuthorizationMessageException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  ee.InvalidAuthorizationMessageException = ux
  var IEe = (e) => ({
    ...e,
    ...(e.SecretAccessKey && { SecretAccessKey: lx.SENSITIVE_STRING }),
  })
  ee.CredentialsFilterSensitiveLog = IEe
  var PEe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ee.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ee.AssumeRoleResponseFilterSensitiveLog = PEe
  var REe = (e) => ({
    ...e,
    ...(e.SAMLAssertion && { SAMLAssertion: lx.SENSITIVE_STRING }),
  })
  ee.AssumeRoleWithSAMLRequestFilterSensitiveLog = REe
  var DEe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ee.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ee.AssumeRoleWithSAMLResponseFilterSensitiveLog = DEe
  var AEe = (e) => ({
    ...e,
    ...(e.WebIdentityToken && { WebIdentityToken: lx.SENSITIVE_STRING }),
  })
  ee.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AEe
  var OEe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ee.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ee.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = OEe
  var NEe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ee.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ee.GetFederationTokenResponseFilterSensitiveLog = NEe
  var qEe = (e) => ({
    ...e,
    ...(e.Credentials && {
      Credentials: (0, ee.CredentialsFilterSensitiveLog)(e.Credentials),
    }),
  })
  ee.GetSessionTokenResponseFilterSensitiveLog = qEe
})
var wh = l((vr) => {
  'use strict'
  var nz =
      ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD',
    kEe = nz + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040',
    rz = '[' + nz + '][' + kEe + ']*',
    MEe = new RegExp('^' + rz + '$'),
    FEe = function (e, t) {
      let n = [],
        r = t.exec(e)
      for (; r; ) {
        let s = []
        s.startIndex = t.lastIndex - r[0].length
        let o = r.length
        for (let i = 0; i < o; i++) s.push(r[i])
        n.push(s), (r = t.exec(e))
      }
      return n
    },
    UEe = function (e) {
      let t = MEe.exec(e)
      return !(t === null || typeof t > 'u')
    }
  vr.isExist = function (e) {
    return typeof e < 'u'
  }
  vr.isEmptyObject = function (e) {
    return Object.keys(e).length === 0
  }
  vr.merge = function (e, t, n) {
    if (t) {
      let r = Object.keys(t),
        s = r.length
      for (let o = 0; o < s; o++)
        n === 'strict' ? (e[r[o]] = [t[r[o]]]) : (e[r[o]] = t[r[o]])
    }
  }
  vr.getValue = function (e) {
    return vr.isExist(e) ? e : ''
  }
  vr.isName = UEe
  vr.getAllMatches = FEe
  vr.nameRegexp = rz
})
var px = l((cz) => {
  'use strict'
  var mx = wh(),
    LEe = { allowBooleanAttributes: !1, unpairedTags: [] }
  cz.validate = function (e, t) {
    t = Object.assign({}, LEe, t)
    let n = [],
      r = !1,
      s = !1
    e[0] === '\uFEFF' && (e = e.substr(1))
    for (let o = 0; o < e.length; o++)
      if (e[o] === '<' && e[o + 1] === '?') {
        if (((o += 2), (o = oz(e, o)), o.err)) return o
      } else if (e[o] === '<') {
        let i = o
        if ((o++, e[o] === '!')) {
          o = iz(e, o)
          continue
        } else {
          let c = !1
          e[o] === '/' && ((c = !0), o++)
          let a = ''
          for (
            ;
            o < e.length &&
            e[o] !== '>' &&
            e[o] !== ' ' &&
            e[o] !== '	' &&
            e[o] !==
              `
` &&
            e[o] !== '\r';
            o++
          )
            a += e[o]
          if (
            ((a = a.trim()),
            a[a.length - 1] === '/' &&
              ((a = a.substring(0, a.length - 1)), o--),
            !VEe(a))
          ) {
            let p
            return (
              a.trim().length === 0
                ? (p = "Invalid space after '<'.")
                : (p = "Tag '" + a + "' is an invalid name."),
              ke('InvalidTag', p, gt(e, o))
            )
          }
          let u = GEe(e, o)
          if (u === !1)
            return ke(
              'InvalidAttr',
              "Attributes for '" + a + "' have open quote.",
              gt(e, o),
            )
          let d = u.value
          if (((o = u.index), d[d.length - 1] === '/')) {
            let p = o - d.length
            d = d.substring(0, d.length - 1)
            let f = az(d, t)
            if (f === !0) r = !0
            else return ke(f.err.code, f.err.msg, gt(e, p + f.err.line))
          } else if (c)
            if (u.tagClosed) {
              if (d.trim().length > 0)
                return ke(
                  'InvalidTag',
                  "Closing tag '" +
                    a +
                    "' can't have attributes or invalid starting.",
                  gt(e, i),
                )
              {
                let p = n.pop()
                if (a !== p.tagName) {
                  let f = gt(e, p.tagStartPos)
                  return ke(
                    'InvalidTag',
                    "Expected closing tag '" +
                      p.tagName +
                      "' (opened in line " +
                      f.line +
                      ', col ' +
                      f.col +
                      ") instead of closing tag '" +
                      a +
                      "'.",
                    gt(e, i),
                  )
                }
                n.length == 0 && (s = !0)
              }
            } else
              return ke(
                'InvalidTag',
                "Closing tag '" + a + "' doesn't have proper closing.",
                gt(e, o),
              )
          else {
            let p = az(d, t)
            if (p !== !0)
              return ke(p.err.code, p.err.msg, gt(e, o - d.length + p.err.line))
            if (s === !0)
              return ke(
                'InvalidXml',
                'Multiple possible root nodes found.',
                gt(e, o),
              )
            t.unpairedTags.indexOf(a) !== -1 ||
              n.push({ tagName: a, tagStartPos: i }),
              (r = !0)
          }
          for (o++; o < e.length; o++)
            if (e[o] === '<')
              if (e[o + 1] === '!') {
                o++, (o = iz(e, o))
                continue
              } else if (e[o + 1] === '?') {
                if (((o = oz(e, ++o)), o.err)) return o
              } else break
            else if (e[o] === '&') {
              let p = HEe(e, o)
              if (p == -1)
                return ke('InvalidChar', "char '&' is not expected.", gt(e, o))
              o = p
            } else if (s === !0 && !sz(e[o]))
              return ke('InvalidXml', 'Extra text at the end', gt(e, o))
          e[o] === '<' && o--
        }
      } else {
        if (sz(e[o])) continue
        return ke(
          'InvalidChar',
          "char '" + e[o] + "' is not expected.",
          gt(e, o),
        )
      }
    if (r) {
      if (n.length == 1)
        return ke(
          'InvalidTag',
          "Unclosed tag '" + n[0].tagName + "'.",
          gt(e, n[0].tagStartPos),
        )
      if (n.length > 0)
        return ke(
          'InvalidXml',
          "Invalid '" +
            JSON.stringify(
              n.map((o) => o.tagName),
              null,
              4,
            ).replace(/\r?\n/g, '') +
            "' found.",
          { line: 1, col: 1 },
        )
    } else return ke('InvalidXml', 'Start tag expected.', 1)
    return !0
  }
  function sz(e) {
    return (
      e === ' ' ||
      e === '	' ||
      e ===
        `
` ||
      e === '\r'
    )
  }
  function oz(e, t) {
    let n = t
    for (; t < e.length; t++)
      if (e[t] == '?' || e[t] == ' ') {
        let r = e.substr(n, t - n)
        if (t > 5 && r === 'xml')
          return ke(
            'InvalidXml',
            'XML declaration allowed only at the start of the document.',
            gt(e, t),
          )
        if (e[t] == '?' && e[t + 1] == '>') {
          t++
          break
        } else continue
      }
    return t
  }
  function iz(e, t) {
    if (e.length > t + 5 && e[t + 1] === '-' && e[t + 2] === '-') {
      for (t += 3; t < e.length; t++)
        if (e[t] === '-' && e[t + 1] === '-' && e[t + 2] === '>') {
          t += 2
          break
        }
    } else if (
      e.length > t + 8 &&
      e[t + 1] === 'D' &&
      e[t + 2] === 'O' &&
      e[t + 3] === 'C' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'Y' &&
      e[t + 6] === 'P' &&
      e[t + 7] === 'E'
    ) {
      let n = 1
      for (t += 8; t < e.length; t++)
        if (e[t] === '<') n++
        else if (e[t] === '>' && (n--, n === 0)) break
    } else if (
      e.length > t + 9 &&
      e[t + 1] === '[' &&
      e[t + 2] === 'C' &&
      e[t + 3] === 'D' &&
      e[t + 4] === 'A' &&
      e[t + 5] === 'T' &&
      e[t + 6] === 'A' &&
      e[t + 7] === '['
    ) {
      for (t += 8; t < e.length; t++)
        if (e[t] === ']' && e[t + 1] === ']' && e[t + 2] === '>') {
          t += 2
          break
        }
    }
    return t
  }
  var BEe = '"',
    jEe = "'"
  function GEe(e, t) {
    let n = '',
      r = '',
      s = !1
    for (; t < e.length; t++) {
      if (e[t] === BEe || e[t] === jEe)
        r === '' ? (r = e[t]) : r !== e[t] || (r = '')
      else if (e[t] === '>' && r === '') {
        s = !0
        break
      }
      n += e[t]
    }
    return r !== '' ? !1 : { value: n, index: t, tagClosed: s }
  }
  var $Ee = new RegExp(
    `(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
    'g',
  )
  function az(e, t) {
    let n = mx.getAllMatches(e, $Ee),
      r = {}
    for (let s = 0; s < n.length; s++) {
      if (n[s][1].length === 0)
        return ke(
          'InvalidAttr',
          "Attribute '" + n[s][2] + "' has no space in starting.",
          Au(n[s]),
        )
      if (n[s][3] !== void 0 && n[s][4] === void 0)
        return ke(
          'InvalidAttr',
          "Attribute '" + n[s][2] + "' is without value.",
          Au(n[s]),
        )
      if (n[s][3] === void 0 && !t.allowBooleanAttributes)
        return ke(
          'InvalidAttr',
          "boolean attribute '" + n[s][2] + "' is not allowed.",
          Au(n[s]),
        )
      let o = n[s][2]
      if (!WEe(o))
        return ke(
          'InvalidAttr',
          "Attribute '" + o + "' is an invalid name.",
          Au(n[s]),
        )
      if (!r.hasOwnProperty(o)) r[o] = 1
      else
        return ke('InvalidAttr', "Attribute '" + o + "' is repeated.", Au(n[s]))
    }
    return !0
  }
  function zEe(e, t) {
    let n = /\d/
    for (e[t] === 'x' && (t++, (n = /[\da-fA-F]/)); t < e.length; t++) {
      if (e[t] === ';') return t
      if (!e[t].match(n)) break
    }
    return -1
  }
  function HEe(e, t) {
    if ((t++, e[t] === ';')) return -1
    if (e[t] === '#') return t++, zEe(e, t)
    let n = 0
    for (; t < e.length; t++, n++)
      if (!(e[t].match(/\w/) && n < 20)) {
        if (e[t] === ';') break
        return -1
      }
    return t
  }
  function ke(e, t, n) {
    return { err: { code: e, msg: t, line: n.line || n, col: n.col } }
  }
  function WEe(e) {
    return mx.isName(e)
  }
  function VEe(e) {
    return mx.isName(e)
  }
  function gt(e, t) {
    let n = e.substring(0, t).split(/\r?\n/)
    return { line: n.length, col: n[n.length - 1].length + 1 }
  }
  function Au(e) {
    return e.startIndex + e[1].length
  }
})
var uz = l((fx) => {
  var dz = {
      preserveOrder: !1,
      attributeNamePrefix: '@_',
      attributesGroupName: !1,
      textNodeName: '#text',
      ignoreAttributes: !0,
      removeNSPrefix: !1,
      allowBooleanAttributes: !1,
      parseTagValue: !0,
      parseAttributeValue: !1,
      trimValues: !0,
      cdataPropName: !1,
      numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
      tagValueProcessor: function (e, t) {
        return t
      },
      attributeValueProcessor: function (e, t) {
        return t
      },
      stopNodes: [],
      alwaysCreateTextNode: !1,
      isArray: () => !1,
      commentPropName: !1,
      unpairedTags: [],
      processEntities: !0,
      htmlEntities: !1,
      ignoreDeclaration: !1,
      ignorePiTags: !1,
      transformTagName: !1,
      transformAttributeName: !1,
      updateTag: function (e, t, n) {
        return e
      },
    },
    YEe = function (e) {
      return Object.assign({}, dz, e)
    }
  fx.buildOptions = YEe
  fx.defaultOptions = dz
})
var mz = l((sHe, lz) => {
  'use strict'
  var _x = class {
    constructor(t) {
      ;(this.tagname = t), (this.child = []), (this[':@'] = {})
    }
    add(t, n) {
      t === '__proto__' && (t = '#__proto__'), this.child.push({ [t]: n })
    }
    addChild(t) {
      t.tagname === '__proto__' && (t.tagname = '#__proto__'),
        t[':@'] && Object.keys(t[':@']).length > 0
          ? this.child.push({ [t.tagname]: t.child, ':@': t[':@'] })
          : this.child.push({ [t.tagname]: t.child })
    }
  }
  lz.exports = _x
})
var fz = l((oHe, pz) => {
  var KEe = wh()
  function JEe(e, t) {
    let n = {}
    if (
      e[t + 3] === 'O' &&
      e[t + 4] === 'C' &&
      e[t + 5] === 'T' &&
      e[t + 6] === 'Y' &&
      e[t + 7] === 'P' &&
      e[t + 8] === 'E'
    ) {
      t = t + 9
      let r = 1,
        s = !1,
        o = !1,
        i = ''
      for (; t < e.length; t++)
        if (e[t] === '<' && !o) {
          if (s && ZEe(e, t))
            (t += 7),
              ([entityName, val, t] = XEe(e, t + 1)),
              val.indexOf('&') === -1 &&
                (n[rSe(entityName)] = {
                  regx: RegExp(`&${entityName};`, 'g'),
                  val,
                })
          else if (s && eSe(e, t)) t += 8
          else if (s && tSe(e, t)) t += 8
          else if (s && nSe(e, t)) t += 9
          else if (QEe) o = !0
          else throw new Error('Invalid DOCTYPE')
          r++, (i = '')
        } else if (e[t] === '>') {
          if (
            (o ? e[t - 1] === '-' && e[t - 2] === '-' && ((o = !1), r--) : r--,
            r === 0)
          )
            break
        } else e[t] === '[' ? (s = !0) : (i += e[t])
      if (r !== 0) throw new Error('Unclosed DOCTYPE')
    } else throw new Error('Invalid Tag instead of DOCTYPE')
    return { entities: n, i: t }
  }
  function XEe(e, t) {
    let n = ''
    for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++) n += e[t]
    if (((n = n.trim()), n.indexOf(' ') !== -1))
      throw new Error('External entites are not supported')
    let r = e[t++],
      s = ''
    for (; t < e.length && e[t] !== r; t++) s += e[t]
    return [n, s, t]
  }
  function QEe(e, t) {
    return e[t + 1] === '!' && e[t + 2] === '-' && e[t + 3] === '-'
  }
  function ZEe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'E' &&
      e[t + 3] === 'N' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'I' &&
      e[t + 6] === 'T' &&
      e[t + 7] === 'Y'
    )
  }
  function eSe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'E' &&
      e[t + 3] === 'L' &&
      e[t + 4] === 'E' &&
      e[t + 5] === 'M' &&
      e[t + 6] === 'E' &&
      e[t + 7] === 'N' &&
      e[t + 8] === 'T'
    )
  }
  function tSe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'A' &&
      e[t + 3] === 'T' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'L' &&
      e[t + 6] === 'I' &&
      e[t + 7] === 'S' &&
      e[t + 8] === 'T'
    )
  }
  function nSe(e, t) {
    return (
      e[t + 1] === '!' &&
      e[t + 2] === 'N' &&
      e[t + 3] === 'O' &&
      e[t + 4] === 'T' &&
      e[t + 5] === 'A' &&
      e[t + 6] === 'T' &&
      e[t + 7] === 'I' &&
      e[t + 8] === 'O' &&
      e[t + 9] === 'N'
    )
  }
  function rSe(e) {
    if (KEe.isName(e)) return e
    throw new Error(`Invalid entity name ${e}`)
  }
  pz.exports = JEe
})
var hz = l((iHe, _z) => {
  var sSe = /^[-+]?0x[a-fA-F0-9]+$/,
    oSe =
      /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/
  !Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt)
  !Number.parseFloat &&
    window.parseFloat &&
    (Number.parseFloat = window.parseFloat)
  var iSe = { hex: !0, leadingZeros: !0, decimalPoint: '.', eNotation: !0 }
  function aSe(e, t = {}) {
    if (((t = Object.assign({}, iSe, t)), !e || typeof e != 'string')) return e
    let n = e.trim()
    if (t.skipLike !== void 0 && t.skipLike.test(n)) return e
    if (t.hex && sSe.test(n)) return Number.parseInt(n, 16)
    {
      let r = oSe.exec(n)
      if (r) {
        let s = r[1],
          o = r[2],
          i = cSe(r[3]),
          c = r[4] || r[6]
        if (!t.leadingZeros && o.length > 0 && s && n[2] !== '.') return e
        if (!t.leadingZeros && o.length > 0 && !s && n[1] !== '.') return e
        {
          let a = Number(n),
            u = '' + a
          return u.search(/[eE]/) !== -1 || c
            ? t.eNotation
              ? a
              : e
            : n.indexOf('.') !== -1
            ? (u === '0' && i === '') || u === i || (s && u === '-' + i)
              ? a
              : e
            : o
            ? i === u || s + i === u
              ? a
              : e
            : n === u || n === s + u
            ? a
            : e
        }
      } else return e
    }
  }
  function cSe(e) {
    return (
      e &&
        e.indexOf('.') !== -1 &&
        ((e = e.replace(/0+$/, '')),
        e === '.'
          ? (e = '0')
          : e[0] === '.'
          ? (e = '0' + e)
          : e[e.length - 1] === '.' && (e = e.substr(0, e.length - 1))),
      e
    )
  }
  _z.exports = aSe
})
var gz = l((cHe, yz) => {
  'use strict'
  var Ex = wh(),
    Ou = mz(),
    dSe = fz(),
    uSe = hz(),
    aHe =
      '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'.replace(
        /NAME/g,
        Ex.nameRegexp,
      ),
    hx = class {
      constructor(t) {
        ;(this.options = t),
          (this.currentNode = null),
          (this.tagsNodeStack = []),
          (this.docTypeEntities = {}),
          (this.lastEntities = {
            apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
            gt: { regex: /&(gt|#62|#x3E);/g, val: '>' },
            lt: { regex: /&(lt|#60|#x3C);/g, val: '<' },
            quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
          }),
          (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: '&' }),
          (this.htmlEntities = {
            space: { regex: /&(nbsp|#160);/g, val: ' ' },
            cent: { regex: /&(cent|#162);/g, val: '\xA2' },
            pound: { regex: /&(pound|#163);/g, val: '\xA3' },
            yen: { regex: /&(yen|#165);/g, val: '\xA5' },
            euro: { regex: /&(euro|#8364);/g, val: '\u20AC' },
            copyright: { regex: /&(copy|#169);/g, val: '\xA9' },
            reg: { regex: /&(reg|#174);/g, val: '\xAE' },
            inr: { regex: /&(inr|#8377);/g, val: '\u20B9' },
          }),
          (this.addExternalEntities = lSe),
          (this.parseXml = hSe),
          (this.parseTextData = mSe),
          (this.resolveNameSpace = pSe),
          (this.buildAttributesMap = _Se),
          (this.isItStopNode = SSe),
          (this.replaceEntitiesValue = gSe),
          (this.readStopNodeData = vSe),
          (this.saveTextToParentTag = ESe),
          (this.addChild = ySe)
      }
    }
  function lSe(e) {
    let t = Object.keys(e)
    for (let n = 0; n < t.length; n++) {
      let r = t[n]
      this.lastEntities[r] = {
        regex: new RegExp('&' + r + ';', 'g'),
        val: e[r],
      }
    }
  }
  function mSe(e, t, n, r, s, o, i) {
    if (
      e !== void 0 &&
      (this.options.trimValues && !r && (e = e.trim()), e.length > 0)
    ) {
      i || (e = this.replaceEntitiesValue(e))
      let c = this.options.tagValueProcessor(t, e, n, s, o)
      return c == null
        ? e
        : typeof c != typeof e || c !== e
        ? c
        : this.options.trimValues
        ? gx(e, this.options.parseTagValue, this.options.numberParseOptions)
        : e.trim() === e
        ? gx(e, this.options.parseTagValue, this.options.numberParseOptions)
        : e
    }
  }
  function pSe(e) {
    if (this.options.removeNSPrefix) {
      let t = e.split(':'),
        n = e.charAt(0) === '/' ? '/' : ''
      if (t[0] === 'xmlns') return ''
      t.length === 2 && (e = n + t[1])
    }
    return e
  }
  var fSe = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, 'gm')
  function _Se(e, t, n) {
    if (!this.options.ignoreAttributes && typeof e == 'string') {
      let r = Ex.getAllMatches(e, fSe),
        s = r.length,
        o = {}
      for (let i = 0; i < s; i++) {
        let c = this.resolveNameSpace(r[i][1]),
          a = r[i][4],
          u = this.options.attributeNamePrefix + c
        if (c.length)
          if (
            (this.options.transformAttributeName &&
              (u = this.options.transformAttributeName(u)),
            u === '__proto__' && (u = '#__proto__'),
            a !== void 0)
          ) {
            this.options.trimValues && (a = a.trim()),
              (a = this.replaceEntitiesValue(a))
            let d = this.options.attributeValueProcessor(c, a, t)
            d == null
              ? (o[u] = a)
              : typeof d != typeof a || d !== a
              ? (o[u] = d)
              : (o[u] = gx(
                  a,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions,
                ))
          } else this.options.allowBooleanAttributes && (o[u] = !0)
      }
      if (!Object.keys(o).length) return
      if (this.options.attributesGroupName) {
        let i = {}
        return (i[this.options.attributesGroupName] = o), i
      }
      return o
    }
  }
  var hSe = function (e) {
    e = e.replace(
      /\r\n?/g,
      `
`,
    )
    let t = new Ou('!xml'),
      n = t,
      r = '',
      s = ''
    for (let o = 0; o < e.length; o++)
      if (e[o] === '<')
        if (e[o + 1] === '/') {
          let c = Do(e, '>', o, 'Closing Tag is not closed.'),
            a = e.substring(o + 2, c).trim()
          if (this.options.removeNSPrefix) {
            let p = a.indexOf(':')
            p !== -1 && (a = a.substr(p + 1))
          }
          this.options.transformTagName &&
            (a = this.options.transformTagName(a)),
            n && (r = this.saveTextToParentTag(r, n, s))
          let u = s.substring(s.lastIndexOf('.') + 1)
          if (a && this.options.unpairedTags.indexOf(a) !== -1)
            throw new Error(
              `Unpaired tag can not be used as closing tag: </${a}>`,
            )
          let d = 0
          u && this.options.unpairedTags.indexOf(u) !== -1
            ? ((d = s.lastIndexOf('.', s.lastIndexOf('.') - 1)),
              this.tagsNodeStack.pop())
            : (d = s.lastIndexOf('.')),
            (s = s.substring(0, d)),
            (n = this.tagsNodeStack.pop()),
            (r = ''),
            (o = c)
        } else if (e[o + 1] === '?') {
          let c = yx(e, o, !1, '?>')
          if (!c) throw new Error('Pi Tag is not closed.')
          if (
            ((r = this.saveTextToParentTag(r, n, s)),
            !(
              (this.options.ignoreDeclaration && c.tagName === '?xml') ||
              this.options.ignorePiTags
            ))
          ) {
            let a = new Ou(c.tagName)
            a.add(this.options.textNodeName, ''),
              c.tagName !== c.tagExp &&
                c.attrExpPresent &&
                (a[':@'] = this.buildAttributesMap(c.tagExp, s, c.tagName)),
              this.addChild(n, a, s)
          }
          o = c.closeIndex + 1
        } else if (e.substr(o + 1, 3) === '!--') {
          let c = Do(e, '-->', o + 4, 'Comment is not closed.')
          if (this.options.commentPropName) {
            let a = e.substring(o + 4, c - 2)
            ;(r = this.saveTextToParentTag(r, n, s)),
              n.add(this.options.commentPropName, [
                { [this.options.textNodeName]: a },
              ])
          }
          o = c
        } else if (e.substr(o + 1, 2) === '!D') {
          let c = dSe(e, o)
          ;(this.docTypeEntities = c.entities), (o = c.i)
        } else if (e.substr(o + 1, 2) === '![') {
          let c = Do(e, ']]>', o, 'CDATA is not closed.') - 2,
            a = e.substring(o + 9, c)
          if (
            ((r = this.saveTextToParentTag(r, n, s)),
            this.options.cdataPropName)
          )
            n.add(this.options.cdataPropName, [
              { [this.options.textNodeName]: a },
            ])
          else {
            let u = this.parseTextData(a, n.tagname, s, !0, !1, !0)
            u == null && (u = ''), n.add(this.options.textNodeName, u)
          }
          o = c + 2
        } else {
          let c = yx(e, o, this.options.removeNSPrefix),
            a = c.tagName,
            u = c.tagExp,
            d = c.attrExpPresent,
            p = c.closeIndex
          this.options.transformTagName &&
            (a = this.options.transformTagName(a)),
            n &&
              r &&
              n.tagname !== '!xml' &&
              (r = this.saveTextToParentTag(r, n, s, !1))
          let f = n
          if (
            (f &&
              this.options.unpairedTags.indexOf(f.tagname) !== -1 &&
              ((n = this.tagsNodeStack.pop()),
              (s = s.substring(0, s.lastIndexOf('.')))),
            a !== t.tagname && (s += s ? '.' + a : a),
            this.isItStopNode(this.options.stopNodes, s, a))
          ) {
            let _ = ''
            if (u.length > 0 && u.lastIndexOf('/') === u.length - 1)
              o = c.closeIndex
            else if (this.options.unpairedTags.indexOf(a) !== -1)
              o = c.closeIndex
            else {
              let g = this.readStopNodeData(e, a, p + 1)
              if (!g) throw new Error(`Unexpected end of ${a}`)
              ;(o = g.i), (_ = g.tagContent)
            }
            let h = new Ou(a)
            a !== u && d && (h[':@'] = this.buildAttributesMap(u, s, a)),
              _ && (_ = this.parseTextData(_, a, s, !0, d, !0, !0)),
              (s = s.substr(0, s.lastIndexOf('.'))),
              h.add(this.options.textNodeName, _),
              this.addChild(n, h, s)
          } else {
            if (u.length > 0 && u.lastIndexOf('/') === u.length - 1) {
              a[a.length - 1] === '/'
                ? ((a = a.substr(0, a.length - 1)), (u = a))
                : (u = u.substr(0, u.length - 1)),
                this.options.transformTagName &&
                  (a = this.options.transformTagName(a))
              let _ = new Ou(a)
              a !== u && d && (_[':@'] = this.buildAttributesMap(u, s, a)),
                this.addChild(n, _, s),
                (s = s.substr(0, s.lastIndexOf('.')))
            } else {
              let _ = new Ou(a)
              this.tagsNodeStack.push(n),
                a !== u && d && (_[':@'] = this.buildAttributesMap(u, s, a)),
                this.addChild(n, _, s),
                (n = _)
            }
            ;(r = ''), (o = p)
          }
        }
      else r += e[o]
    return t.child
  }
  function ySe(e, t, n) {
    let r = this.options.updateTag(t.tagname, n, t[':@'])
    r === !1 || (typeof r == 'string' && (t.tagname = r), e.addChild(t))
  }
  var gSe = function (e) {
    if (this.options.processEntities) {
      for (let t in this.docTypeEntities) {
        let n = this.docTypeEntities[t]
        e = e.replace(n.regx, n.val)
      }
      for (let t in this.lastEntities) {
        let n = this.lastEntities[t]
        e = e.replace(n.regex, n.val)
      }
      if (this.options.htmlEntities)
        for (let t in this.htmlEntities) {
          let n = this.htmlEntities[t]
          e = e.replace(n.regex, n.val)
        }
      e = e.replace(this.ampEntity.regex, this.ampEntity.val)
    }
    return e
  }
  function ESe(e, t, n, r) {
    return (
      e &&
        (r === void 0 && (r = Object.keys(t.child).length === 0),
        (e = this.parseTextData(
          e,
          t.tagname,
          n,
          !1,
          t[':@'] ? Object.keys(t[':@']).length !== 0 : !1,
          r,
        )),
        e !== void 0 && e !== '' && t.add(this.options.textNodeName, e),
        (e = '')),
      e
    )
  }
  function SSe(e, t, n) {
    let r = '*.' + n
    for (let s in e) {
      let o = e[s]
      if (r === o || t === o) return !0
    }
    return !1
  }
  function bSe(e, t, n = '>') {
    let r,
      s = ''
    for (let o = t; o < e.length; o++) {
      let i = e[o]
      if (r) i === r && (r = '')
      else if (i === '"' || i === "'") r = i
      else if (i === n[0])
        if (n[1]) {
          if (e[o + 1] === n[1]) return { data: s, index: o }
        } else return { data: s, index: o }
      else i === '	' && (i = ' ')
      s += i
    }
  }
  function Do(e, t, n, r) {
    let s = e.indexOf(t, n)
    if (s === -1) throw new Error(r)
    return s + t.length - 1
  }
  function yx(e, t, n, r = '>') {
    let s = bSe(e, t + 1, r)
    if (!s) return
    let o = s.data,
      i = s.index,
      c = o.search(/\s/),
      a = o,
      u = !0
    if (
      (c !== -1 &&
        ((a = o.substr(0, c).replace(/\s\s*$/, '')), (o = o.substr(c + 1))),
      n)
    ) {
      let d = a.indexOf(':')
      d !== -1 && ((a = a.substr(d + 1)), (u = a !== s.data.substr(d + 1)))
    }
    return { tagName: a, tagExp: o, closeIndex: i, attrExpPresent: u }
  }
  function vSe(e, t, n) {
    let r = n,
      s = 1
    for (; n < e.length; n++)
      if (e[n] === '<')
        if (e[n + 1] === '/') {
          let o = Do(e, '>', n, `${t} is not closed`)
          if (e.substring(n + 2, o).trim() === t && (s--, s === 0))
            return { tagContent: e.substring(r, n), i: o }
          n = o
        } else if (e[n + 1] === '?')
          n = Do(e, '?>', n + 1, 'StopNode is not closed.')
        else if (e.substr(n + 1, 3) === '!--')
          n = Do(e, '-->', n + 3, 'StopNode is not closed.')
        else if (e.substr(n + 1, 2) === '![')
          n = Do(e, ']]>', n, 'StopNode is not closed.') - 2
        else {
          let o = yx(e, n, '>')
          o &&
            ((o && o.tagName) === t &&
              o.tagExp[o.tagExp.length - 1] !== '/' &&
              s++,
            (n = o.closeIndex))
        }
  }
  function gx(e, t, n) {
    if (t && typeof e == 'string') {
      let r = e.trim()
      return r === 'true' ? !0 : r === 'false' ? !1 : uSe(e, n)
    } else return Ex.isExist(e) ? e : ''
  }
  yz.exports = hx
})
var bz = l((Sz) => {
  'use strict'
  function CSe(e, t) {
    return Ez(e, t)
  }
  function Ez(e, t, n) {
    let r,
      s = {}
    for (let o = 0; o < e.length; o++) {
      let i = e[o],
        c = wSe(i),
        a = ''
      if ((n === void 0 ? (a = c) : (a = n + '.' + c), c === t.textNodeName))
        r === void 0 ? (r = i[c]) : (r += '' + i[c])
      else {
        if (c === void 0) continue
        if (i[c]) {
          let u = Ez(i[c], t, a),
            d = xSe(u, t)
          i[':@']
            ? TSe(u, i[':@'], a, t)
            : Object.keys(u).length === 1 &&
              u[t.textNodeName] !== void 0 &&
              !t.alwaysCreateTextNode
            ? (u = u[t.textNodeName])
            : Object.keys(u).length === 0 &&
              (t.alwaysCreateTextNode ? (u[t.textNodeName] = '') : (u = '')),
            s[c] !== void 0 && s.hasOwnProperty(c)
              ? (Array.isArray(s[c]) || (s[c] = [s[c]]), s[c].push(u))
              : t.isArray(c, a, d)
              ? (s[c] = [u])
              : (s[c] = u)
        }
      }
    }
    return (
      typeof r == 'string'
        ? r.length > 0 && (s[t.textNodeName] = r)
        : r !== void 0 && (s[t.textNodeName] = r),
      s
    )
  }
  function wSe(e) {
    let t = Object.keys(e)
    for (let n = 0; n < t.length; n++) {
      let r = t[n]
      if (r !== ':@') return r
    }
  }
  function TSe(e, t, n, r) {
    if (t) {
      let s = Object.keys(t),
        o = s.length
      for (let i = 0; i < o; i++) {
        let c = s[i]
        r.isArray(c, n + '.' + c, !0, !0) ? (e[c] = [t[c]]) : (e[c] = t[c])
      }
    }
  }
  function xSe(e, t) {
    let { textNodeName: n } = t,
      r = Object.keys(e).length
    return !!(
      r === 0 ||
      (r === 1 && (e[n] || typeof e[n] == 'boolean' || e[n] === 0))
    )
  }
  Sz.prettify = CSe
})
var Cz = l((uHe, vz) => {
  var { buildOptions: ISe } = uz(),
    PSe = gz(),
    { prettify: RSe } = bz(),
    DSe = px(),
    Sx = class {
      constructor(t) {
        ;(this.externalEntities = {}), (this.options = ISe(t))
      }
      parse(t, n) {
        if (typeof t != 'string')
          if (t.toString) t = t.toString()
          else
            throw new Error('XML data is accepted in String or Bytes[] form.')
        if (n) {
          n === !0 && (n = {})
          let o = DSe.validate(t, n)
          if (o !== !0) throw Error(`${o.err.msg}:${o.err.line}:${o.err.col}`)
        }
        let r = new PSe(this.options)
        r.addExternalEntities(this.externalEntities)
        let s = r.parseXml(t)
        return this.options.preserveOrder || s === void 0
          ? s
          : RSe(s, this.options)
      }
      addEntity(t, n) {
        if (n.indexOf('&') !== -1)
          throw new Error("Entity value can't have '&'")
        if (t.indexOf('&') !== -1 || t.indexOf(';') !== -1)
          throw new Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'",
          )
        if (n === '&')
          throw new Error("An entity with value '&' is not permitted")
        this.externalEntities[t] = n
      }
    }
  vz.exports = Sx
})
var Pz = l((lHe, Iz) => {
  var ASe = `
`
  function OSe(e, t) {
    let n = ''
    return t.format && t.indentBy.length > 0 && (n = ASe), Tz(e, t, '', n)
  }
  function Tz(e, t, n, r) {
    let s = '',
      o = !1
    for (let i = 0; i < e.length; i++) {
      let c = e[i],
        a = NSe(c),
        u = ''
      if (
        (n.length === 0 ? (u = a) : (u = `${n}.${a}`), a === t.textNodeName)
      ) {
        let h = c[a]
        qSe(u, t) || ((h = t.tagValueProcessor(a, h)), (h = xz(h, t))),
          o && (s += r),
          (s += h),
          (o = !1)
        continue
      } else if (a === t.cdataPropName) {
        o && (s += r), (s += `<![CDATA[${c[a][0][t.textNodeName]}]]>`), (o = !1)
        continue
      } else if (a === t.commentPropName) {
        ;(s += r + `<!--${c[a][0][t.textNodeName]}-->`), (o = !0)
        continue
      } else if (a[0] === '?') {
        let h = wz(c[':@'], t),
          g = a === '?xml' ? '' : r,
          E = c[a][0][t.textNodeName]
        ;(E = E.length !== 0 ? ' ' + E : ''),
          (s += g + `<${a}${E}${h}?>`),
          (o = !0)
        continue
      }
      let d = r
      d !== '' && (d += t.indentBy)
      let p = wz(c[':@'], t),
        f = r + `<${a}${p}`,
        _ = Tz(c[a], t, u, d)
      t.unpairedTags.indexOf(a) !== -1
        ? t.suppressUnpairedNode
          ? (s += f + '>')
          : (s += f + '/>')
        : (!_ || _.length === 0) && t.suppressEmptyNode
        ? (s += f + '/>')
        : _ && _.endsWith('>')
        ? (s += f + `>${_}${r}</${a}>`)
        : ((s += f + '>'),
          _ && r !== '' && (_.includes('/>') || _.includes('</'))
            ? (s += r + t.indentBy + _ + r)
            : (s += _),
          (s += `</${a}>`)),
        (o = !0)
    }
    return s
  }
  function NSe(e) {
    let t = Object.keys(e)
    for (let n = 0; n < t.length; n++) {
      let r = t[n]
      if (r !== ':@') return r
    }
  }
  function wz(e, t) {
    let n = ''
    if (e && !t.ignoreAttributes)
      for (let r in e) {
        let s = t.attributeValueProcessor(r, e[r])
        ;(s = xz(s, t)),
          s === !0 && t.suppressBooleanAttributes
            ? (n += ` ${r.substr(t.attributeNamePrefix.length)}`)
            : (n += ` ${r.substr(t.attributeNamePrefix.length)}="${s}"`)
      }
    return n
  }
  function qSe(e, t) {
    e = e.substr(0, e.length - t.textNodeName.length - 1)
    let n = e.substr(e.lastIndexOf('.') + 1)
    for (let r in t.stopNodes)
      if (t.stopNodes[r] === e || t.stopNodes[r] === '*.' + n) return !0
    return !1
  }
  function xz(e, t) {
    if (e && e.length > 0 && t.processEntities)
      for (let n = 0; n < t.entities.length; n++) {
        let r = t.entities[n]
        e = e.replace(r.regex, r.val)
      }
    return e
  }
  Iz.exports = OSe
})
var Dz = l((mHe, Rz) => {
  'use strict'
  var kSe = Pz(),
    MSe = {
      attributeNamePrefix: '@_',
      attributesGroupName: !1,
      textNodeName: '#text',
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: '  ',
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function (e, t) {
        return t
      },
      attributeValueProcessor: function (e, t) {
        return t
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [
        { regex: new RegExp('&', 'g'), val: '&amp;' },
        { regex: new RegExp('>', 'g'), val: '&gt;' },
        { regex: new RegExp('<', 'g'), val: '&lt;' },
        { regex: new RegExp("'", 'g'), val: '&apos;' },
        { regex: new RegExp('"', 'g'), val: '&quot;' },
      ],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1,
    }
  function ps(e) {
    ;(this.options = Object.assign({}, MSe, e)),
      this.options.ignoreAttributes || this.options.attributesGroupName
        ? (this.isAttribute = function () {
            return !1
          })
        : ((this.attrPrefixLen = this.options.attributeNamePrefix.length),
          (this.isAttribute = LSe)),
      (this.processTextOrObjNode = FSe),
      this.options.format
        ? ((this.indentate = USe),
          (this.tagEndChar = `>
`),
          (this.newLine = `
`))
        : ((this.indentate = function () {
            return ''
          }),
          (this.tagEndChar = '>'),
          (this.newLine = ''))
  }
  ps.prototype.build = function (e) {
    return this.options.preserveOrder
      ? kSe(e, this.options)
      : (Array.isArray(e) &&
          this.options.arrayNodeName &&
          this.options.arrayNodeName.length > 1 &&
          (e = { [this.options.arrayNodeName]: e }),
        this.j2x(e, 0).val)
  }
  ps.prototype.j2x = function (e, t) {
    let n = '',
      r = ''
    for (let s in e)
      if (!(typeof e[s] > 'u'))
        if (e[s] === null)
          s[0] === '?'
            ? (r += this.indentate(t) + '<' + s + '?' + this.tagEndChar)
            : (r += this.indentate(t) + '<' + s + '/' + this.tagEndChar)
        else if (e[s] instanceof Date)
          r += this.buildTextValNode(e[s], s, '', t)
        else if (typeof e[s] != 'object') {
          let o = this.isAttribute(s)
          if (o) n += this.buildAttrPairStr(o, '' + e[s])
          else if (s === this.options.textNodeName) {
            let i = this.options.tagValueProcessor(s, '' + e[s])
            r += this.replaceEntitiesValue(i)
          } else r += this.buildTextValNode(e[s], s, '', t)
        } else if (Array.isArray(e[s])) {
          let o = e[s].length,
            i = ''
          for (let c = 0; c < o; c++) {
            let a = e[s][c]
            typeof a > 'u' ||
              (a === null
                ? s[0] === '?'
                  ? (r += this.indentate(t) + '<' + s + '?' + this.tagEndChar)
                  : (r += this.indentate(t) + '<' + s + '/' + this.tagEndChar)
                : typeof a == 'object'
                ? this.options.oneListGroup
                  ? (i += this.j2x(a, t + 1).val)
                  : (i += this.processTextOrObjNode(a, s, t))
                : (i += this.buildTextValNode(a, s, '', t)))
          }
          this.options.oneListGroup && (i = this.buildObjectNode(i, s, '', t)),
            (r += i)
        } else if (
          this.options.attributesGroupName &&
          s === this.options.attributesGroupName
        ) {
          let o = Object.keys(e[s]),
            i = o.length
          for (let c = 0; c < i; c++)
            n += this.buildAttrPairStr(o[c], '' + e[s][o[c]])
        } else r += this.processTextOrObjNode(e[s], s, t)
    return { attrStr: n, val: r }
  }
  ps.prototype.buildAttrPairStr = function (e, t) {
    return (
      (t = this.options.attributeValueProcessor(e, '' + t)),
      (t = this.replaceEntitiesValue(t)),
      this.options.suppressBooleanAttributes && t === 'true'
        ? ' ' + e
        : ' ' + e + '="' + t + '"'
    )
  }
  function FSe(e, t, n) {
    let r = this.j2x(e, n + 1)
    return e[this.options.textNodeName] !== void 0 &&
      Object.keys(e).length === 1
      ? this.buildTextValNode(e[this.options.textNodeName], t, r.attrStr, n)
      : this.buildObjectNode(r.val, t, r.attrStr, n)
  }
  ps.prototype.buildObjectNode = function (e, t, n, r) {
    if (e === '')
      return t[0] === '?'
        ? this.indentate(r) + '<' + t + n + '?' + this.tagEndChar
        : this.indentate(r) + '<' + t + n + this.closeTag(t) + this.tagEndChar
    {
      let s = '</' + t + this.tagEndChar,
        o = ''
      return (
        t[0] === '?' && ((o = '?'), (s = '')),
        n && e.indexOf('<') === -1
          ? this.indentate(r) + '<' + t + n + o + '>' + e + s
          : this.options.commentPropName !== !1 &&
            t === this.options.commentPropName &&
            o.length === 0
          ? this.indentate(r) + `<!--${e}-->` + this.newLine
          : this.indentate(r) +
            '<' +
            t +
            n +
            o +
            this.tagEndChar +
            e +
            this.indentate(r) +
            s
      )
    }
  }
  ps.prototype.closeTag = function (e) {
    let t = ''
    return (
      this.options.unpairedTags.indexOf(e) !== -1
        ? this.options.suppressUnpairedNode || (t = '/')
        : this.options.suppressEmptyNode
        ? (t = '/')
        : (t = `></${e}`),
      t
    )
  }
  ps.prototype.buildTextValNode = function (e, t, n, r) {
    if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
      return this.indentate(r) + `<![CDATA[${e}]]>` + this.newLine
    if (
      this.options.commentPropName !== !1 &&
      t === this.options.commentPropName
    )
      return this.indentate(r) + `<!--${e}-->` + this.newLine
    if (t[0] === '?')
      return this.indentate(r) + '<' + t + n + '?' + this.tagEndChar
    {
      let s = this.options.tagValueProcessor(t, e)
      return (
        (s = this.replaceEntitiesValue(s)),
        s === ''
          ? this.indentate(r) + '<' + t + n + this.closeTag(t) + this.tagEndChar
          : this.indentate(r) +
            '<' +
            t +
            n +
            '>' +
            s +
            '</' +
            t +
            this.tagEndChar
      )
    }
  }
  ps.prototype.replaceEntitiesValue = function (e) {
    if (e && e.length > 0 && this.options.processEntities)
      for (let t = 0; t < this.options.entities.length; t++) {
        let n = this.options.entities[t]
        e = e.replace(n.regex, n.val)
      }
    return e
  }
  function USe(e) {
    return this.options.indentBy.repeat(e)
  }
  function LSe(e) {
    return e.startsWith(this.options.attributeNamePrefix)
      ? e.substr(this.attrPrefixLen)
      : !1
  }
  Rz.exports = ps
})
var Oz = l((pHe, Az) => {
  'use strict'
  var BSe = px(),
    jSe = Cz(),
    GSe = Dz()
  Az.exports = { XMLParser: jSe, XMLValidator: BSe, XMLBuilder: GSe }
})
var wr = l((se) => {
  'use strict'
  Object.defineProperty(se, '__esModule', { value: !0 })
  se.de_GetSessionTokenCommand =
    se.de_GetFederationTokenCommand =
    se.de_GetCallerIdentityCommand =
    se.de_GetAccessKeyInfoCommand =
    se.de_DecodeAuthorizationMessageCommand =
    se.de_AssumeRoleWithWebIdentityCommand =
    se.de_AssumeRoleWithSAMLCommand =
    se.de_AssumeRoleCommand =
    se.se_GetSessionTokenCommand =
    se.se_GetFederationTokenCommand =
    se.se_GetCallerIdentityCommand =
    se.se_GetAccessKeyInfoCommand =
    se.se_DecodeAuthorizationMessageCommand =
    se.se_AssumeRoleWithWebIdentityCommand =
    se.se_AssumeRoleWithSAMLCommand =
    se.se_AssumeRoleCommand =
      void 0
  var $Se = tt(),
    H = v(),
    zSe = Oz(),
    fs = ms(),
    HSe = Ch(),
    WSe = async (e, t) => {
      let n = ys,
        r
      return (
        (r = Es({ ...gbe(e, t), Action: 'AssumeRole', Version: '2011-06-15' })),
        hs(t, n, '/', void 0, r)
      )
    }
  se.se_AssumeRoleCommand = WSe
  var VSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...Ebe(e, t),
        Action: 'AssumeRoleWithSAML',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_AssumeRoleWithSAMLCommand = VSe
  var YSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...Sbe(e, t),
        Action: 'AssumeRoleWithWebIdentity',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_AssumeRoleWithWebIdentityCommand = YSe
  var KSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...bbe(e, t),
        Action: 'DecodeAuthorizationMessage',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_DecodeAuthorizationMessageCommand = KSe
  var JSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...vbe(e, t),
        Action: 'GetAccessKeyInfo',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_GetAccessKeyInfoCommand = JSe
  var XSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...Cbe(e, t),
        Action: 'GetCallerIdentity',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_GetCallerIdentityCommand = XSe
  var QSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...wbe(e, t),
        Action: 'GetFederationToken',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_GetFederationTokenCommand = QSe
  var ZSe = async (e, t) => {
    let n = ys,
      r
    return (
      (r = Es({
        ...Tbe(e, t),
        Action: 'GetSessionToken',
        Version: '2011-06-15',
      })),
      hs(t, n, '/', void 0, r)
    )
  }
  se.se_GetSessionTokenCommand = ZSe
  var ebe = async (e, t) => {
    if (e.statusCode >= 300) return tbe(e, t)
    let n = await Cr(e.body, t),
      r = {}
    return (r = Abe(n.AssumeRoleResult, t)), { $metadata: rt(e), ...r }
  }
  se.de_AssumeRoleCommand = ebe
  var tbe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body)
      switch (r) {
        case 'ExpiredTokenException':
        case 'com.amazonaws.sts#ExpiredTokenException':
          throw await bx(n, t)
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Th(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await xh(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await Nu(n, t)
        default:
          let s = n.body
          return _s({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    nbe = async (e, t) => {
      if (e.statusCode >= 300) return rbe(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (
        (r = Obe(n.AssumeRoleWithSAMLResult, t)), { $metadata: rt(e), ...r }
      )
    }
  se.de_AssumeRoleWithSAMLCommand = nbe
  var rbe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body)
      switch (r) {
        case 'ExpiredTokenException':
        case 'com.amazonaws.sts#ExpiredTokenException':
          throw await bx(n, t)
        case 'IDPRejectedClaim':
        case 'com.amazonaws.sts#IDPRejectedClaimException':
          throw await Nz(n, t)
        case 'InvalidIdentityToken':
        case 'com.amazonaws.sts#InvalidIdentityTokenException':
          throw await qz(n, t)
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Th(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await xh(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await Nu(n, t)
        default:
          let s = n.body
          return _s({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    sbe = async (e, t) => {
      if (e.statusCode >= 300) return obe(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (
        (r = Nbe(n.AssumeRoleWithWebIdentityResult, t)),
        { $metadata: rt(e), ...r }
      )
    }
  se.de_AssumeRoleWithWebIdentityCommand = sbe
  var obe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body)
      switch (r) {
        case 'ExpiredTokenException':
        case 'com.amazonaws.sts#ExpiredTokenException':
          throw await bx(n, t)
        case 'IDPCommunicationError':
        case 'com.amazonaws.sts#IDPCommunicationErrorException':
          throw await hbe(n, t)
        case 'IDPRejectedClaim':
        case 'com.amazonaws.sts#IDPRejectedClaimException':
          throw await Nz(n, t)
        case 'InvalidIdentityToken':
        case 'com.amazonaws.sts#InvalidIdentityTokenException':
          throw await qz(n, t)
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Th(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await xh(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await Nu(n, t)
        default:
          let s = n.body
          return _s({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    ibe = async (e, t) => {
      if (e.statusCode >= 300) return abe(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (
        (r = qbe(n.DecodeAuthorizationMessageResult, t)),
        { $metadata: rt(e), ...r }
      )
    }
  se.de_DecodeAuthorizationMessageCommand = ibe
  var abe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body)
      switch (r) {
        case 'InvalidAuthorizationMessageException':
        case 'com.amazonaws.sts#InvalidAuthorizationMessageException':
          throw await ybe(n, t)
        default:
          let s = n.body
          return _s({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    cbe = async (e, t) => {
      if (e.statusCode >= 300) return dbe(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (r = Fbe(n.GetAccessKeyInfoResult, t)), { $metadata: rt(e), ...r }
    }
  se.de_GetAccessKeyInfoCommand = cbe
  var dbe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body),
        s = n.body
      return _s({ output: e, parsedBody: s.Error, errorCode: r })
    },
    ube = async (e, t) => {
      if (e.statusCode >= 300) return lbe(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (r = Ube(n.GetCallerIdentityResult, t)), { $metadata: rt(e), ...r }
    }
  se.de_GetCallerIdentityCommand = ube
  var lbe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body),
        s = n.body
      return _s({ output: e, parsedBody: s.Error, errorCode: r })
    },
    mbe = async (e, t) => {
      if (e.statusCode >= 300) return pbe(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (
        (r = Lbe(n.GetFederationTokenResult, t)), { $metadata: rt(e), ...r }
      )
    }
  se.de_GetFederationTokenCommand = mbe
  var pbe = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body)
      switch (r) {
        case 'MalformedPolicyDocument':
        case 'com.amazonaws.sts#MalformedPolicyDocumentException':
          throw await Th(n, t)
        case 'PackedPolicyTooLarge':
        case 'com.amazonaws.sts#PackedPolicyTooLargeException':
          throw await xh(n, t)
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await Nu(n, t)
        default:
          let s = n.body
          return _s({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    fbe = async (e, t) => {
      if (e.statusCode >= 300) return _be(e, t)
      let n = await Cr(e.body, t),
        r = {}
      return (r = Bbe(n.GetSessionTokenResult, t)), { $metadata: rt(e), ...r }
    }
  se.de_GetSessionTokenCommand = fbe
  var _be = async (e, t) => {
      let n = { ...e, body: await gs(e.body, t) },
        r = Ss(e, n.body)
      switch (r) {
        case 'RegionDisabledException':
        case 'com.amazonaws.sts#RegionDisabledException':
          throw await Nu(n, t)
        default:
          let s = n.body
          return _s({ output: e, parsedBody: s.Error, errorCode: r })
      }
    },
    bx = async (e, t) => {
      let n = e.body,
        r = kbe(n.Error, t),
        s = new fs.ExpiredTokenException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    hbe = async (e, t) => {
      let n = e.body,
        r = jbe(n.Error, t),
        s = new fs.IDPCommunicationErrorException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    Nz = async (e, t) => {
      let n = e.body,
        r = Gbe(n.Error, t),
        s = new fs.IDPRejectedClaimException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    ybe = async (e, t) => {
      let n = e.body,
        r = $be(n.Error, t),
        s = new fs.InvalidAuthorizationMessageException({
          $metadata: rt(e),
          ...r,
        })
      return (0, H.decorateServiceException)(s, n)
    },
    qz = async (e, t) => {
      let n = e.body,
        r = zbe(n.Error, t),
        s = new fs.InvalidIdentityTokenException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    Th = async (e, t) => {
      let n = e.body,
        r = Hbe(n.Error, t),
        s = new fs.MalformedPolicyDocumentException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    xh = async (e, t) => {
      let n = e.body,
        r = Wbe(n.Error, t),
        s = new fs.PackedPolicyTooLargeException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    Nu = async (e, t) => {
      let n = e.body,
        r = Vbe(n.Error, t),
        s = new fs.RegionDisabledException({ $metadata: rt(e), ...r })
      return (0, H.decorateServiceException)(s, n)
    },
    gbe = (e, t) => {
      let n = {}
      if (
        (e.RoleArn != null && (n.RoleArn = e.RoleArn),
        e.RoleSessionName != null && (n.RoleSessionName = e.RoleSessionName),
        e.PolicyArns != null)
      ) {
        let r = Ih(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      if (
        (e.Policy != null && (n.Policy = e.Policy),
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        e.Tags != null)
      ) {
        let r = kz(e.Tags, t)
        e.Tags?.length === 0 && (n.Tags = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `Tags.${s}`
            n[i] = o
          })
      }
      if (e.TransitiveTagKeys != null) {
        let r = Dbe(e.TransitiveTagKeys, t)
        e.TransitiveTagKeys?.length === 0 && (n.TransitiveTagKeys = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `TransitiveTagKeys.${s}`
            n[i] = o
          })
      }
      if (
        (e.ExternalId != null && (n.ExternalId = e.ExternalId),
        e.SerialNumber != null && (n.SerialNumber = e.SerialNumber),
        e.TokenCode != null && (n.TokenCode = e.TokenCode),
        e.SourceIdentity != null && (n.SourceIdentity = e.SourceIdentity),
        e.ProvidedContexts != null)
      ) {
        let r = Pbe(e.ProvidedContexts, t)
        e.ProvidedContexts?.length === 0 && (n.ProvidedContexts = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `ProvidedContexts.${s}`
            n[i] = o
          })
      }
      return n
    },
    Ebe = (e, t) => {
      let n = {}
      if (
        (e.RoleArn != null && (n.RoleArn = e.RoleArn),
        e.PrincipalArn != null && (n.PrincipalArn = e.PrincipalArn),
        e.SAMLAssertion != null && (n.SAMLAssertion = e.SAMLAssertion),
        e.PolicyArns != null)
      ) {
        let r = Ih(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      return (
        e.Policy != null && (n.Policy = e.Policy),
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        n
      )
    },
    Sbe = (e, t) => {
      let n = {}
      if (
        (e.RoleArn != null && (n.RoleArn = e.RoleArn),
        e.RoleSessionName != null && (n.RoleSessionName = e.RoleSessionName),
        e.WebIdentityToken != null && (n.WebIdentityToken = e.WebIdentityToken),
        e.ProviderId != null && (n.ProviderId = e.ProviderId),
        e.PolicyArns != null)
      ) {
        let r = Ih(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      return (
        e.Policy != null && (n.Policy = e.Policy),
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        n
      )
    },
    bbe = (e, t) => {
      let n = {}
      return (
        e.EncodedMessage != null && (n.EncodedMessage = e.EncodedMessage), n
      )
    },
    vbe = (e, t) => {
      let n = {}
      return e.AccessKeyId != null && (n.AccessKeyId = e.AccessKeyId), n
    },
    Cbe = (e, t) => ({}),
    wbe = (e, t) => {
      let n = {}
      if (
        (e.Name != null && (n.Name = e.Name),
        e.Policy != null && (n.Policy = e.Policy),
        e.PolicyArns != null)
      ) {
        let r = Ih(e.PolicyArns, t)
        e.PolicyArns?.length === 0 && (n.PolicyArns = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `PolicyArns.${s}`
            n[i] = o
          })
      }
      if (
        (e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        e.Tags != null)
      ) {
        let r = kz(e.Tags, t)
        e.Tags?.length === 0 && (n.Tags = []),
          Object.entries(r).forEach(([s, o]) => {
            let i = `Tags.${s}`
            n[i] = o
          })
      }
      return n
    },
    Tbe = (e, t) => {
      let n = {}
      return (
        e.DurationSeconds != null && (n.DurationSeconds = e.DurationSeconds),
        e.SerialNumber != null && (n.SerialNumber = e.SerialNumber),
        e.TokenCode != null && (n.TokenCode = e.TokenCode),
        n
      )
    },
    Ih = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) {
        if (s === null) continue
        let o = xbe(s, t)
        Object.entries(o).forEach(([i, c]) => {
          n[`member.${r}.${i}`] = c
        }),
          r++
      }
      return n
    },
    xbe = (e, t) => {
      let n = {}
      return e.arn != null && (n.arn = e.arn), n
    },
    Ibe = (e, t) => {
      let n = {}
      return (
        e.ProviderArn != null && (n.ProviderArn = e.ProviderArn),
        e.ContextAssertion != null && (n.ContextAssertion = e.ContextAssertion),
        n
      )
    },
    Pbe = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) {
        if (s === null) continue
        let o = Ibe(s, t)
        Object.entries(o).forEach(([i, c]) => {
          n[`member.${r}.${i}`] = c
        }),
          r++
      }
      return n
    },
    Rbe = (e, t) => {
      let n = {}
      return (
        e.Key != null && (n.Key = e.Key),
        e.Value != null && (n.Value = e.Value),
        n
      )
    },
    Dbe = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) s !== null && ((n[`member.${r}`] = s), r++)
      return n
    },
    kz = (e, t) => {
      let n = {},
        r = 1
      for (let s of e) {
        if (s === null) continue
        let o = Rbe(s, t)
        Object.entries(o).forEach(([i, c]) => {
          n[`member.${r}.${i}`] = c
        }),
          r++
      }
      return n
    },
    vx = (e, t) => {
      let n = {}
      return (
        e.AssumedRoleId !== void 0 &&
          (n.AssumedRoleId = (0, H.expectString)(e.AssumedRoleId)),
        e.Arn !== void 0 && (n.Arn = (0, H.expectString)(e.Arn)),
        n
      )
    },
    Abe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = qu(e.Credentials, t)),
        e.AssumedRoleUser !== void 0 &&
          (n.AssumedRoleUser = vx(e.AssumedRoleUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, H.strictParseInt32)(e.PackedPolicySize)),
        e.SourceIdentity !== void 0 &&
          (n.SourceIdentity = (0, H.expectString)(e.SourceIdentity)),
        n
      )
    },
    Obe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = qu(e.Credentials, t)),
        e.AssumedRoleUser !== void 0 &&
          (n.AssumedRoleUser = vx(e.AssumedRoleUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, H.strictParseInt32)(e.PackedPolicySize)),
        e.Subject !== void 0 && (n.Subject = (0, H.expectString)(e.Subject)),
        e.SubjectType !== void 0 &&
          (n.SubjectType = (0, H.expectString)(e.SubjectType)),
        e.Issuer !== void 0 && (n.Issuer = (0, H.expectString)(e.Issuer)),
        e.Audience !== void 0 && (n.Audience = (0, H.expectString)(e.Audience)),
        e.NameQualifier !== void 0 &&
          (n.NameQualifier = (0, H.expectString)(e.NameQualifier)),
        e.SourceIdentity !== void 0 &&
          (n.SourceIdentity = (0, H.expectString)(e.SourceIdentity)),
        n
      )
    },
    Nbe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = qu(e.Credentials, t)),
        e.SubjectFromWebIdentityToken !== void 0 &&
          (n.SubjectFromWebIdentityToken = (0, H.expectString)(
            e.SubjectFromWebIdentityToken,
          )),
        e.AssumedRoleUser !== void 0 &&
          (n.AssumedRoleUser = vx(e.AssumedRoleUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, H.strictParseInt32)(e.PackedPolicySize)),
        e.Provider !== void 0 && (n.Provider = (0, H.expectString)(e.Provider)),
        e.Audience !== void 0 && (n.Audience = (0, H.expectString)(e.Audience)),
        e.SourceIdentity !== void 0 &&
          (n.SourceIdentity = (0, H.expectString)(e.SourceIdentity)),
        n
      )
    },
    qu = (e, t) => {
      let n = {}
      return (
        e.AccessKeyId !== void 0 &&
          (n.AccessKeyId = (0, H.expectString)(e.AccessKeyId)),
        e.SecretAccessKey !== void 0 &&
          (n.SecretAccessKey = (0, H.expectString)(e.SecretAccessKey)),
        e.SessionToken !== void 0 &&
          (n.SessionToken = (0, H.expectString)(e.SessionToken)),
        e.Expiration !== void 0 &&
          (n.Expiration = (0, H.expectNonNull)(
            (0, H.parseRfc3339DateTimeWithOffset)(e.Expiration),
          )),
        n
      )
    },
    qbe = (e, t) => {
      let n = {}
      return (
        e.DecodedMessage !== void 0 &&
          (n.DecodedMessage = (0, H.expectString)(e.DecodedMessage)),
        n
      )
    },
    kbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    Mbe = (e, t) => {
      let n = {}
      return (
        e.FederatedUserId !== void 0 &&
          (n.FederatedUserId = (0, H.expectString)(e.FederatedUserId)),
        e.Arn !== void 0 && (n.Arn = (0, H.expectString)(e.Arn)),
        n
      )
    },
    Fbe = (e, t) => {
      let n = {}
      return (
        e.Account !== void 0 && (n.Account = (0, H.expectString)(e.Account)), n
      )
    },
    Ube = (e, t) => {
      let n = {}
      return (
        e.UserId !== void 0 && (n.UserId = (0, H.expectString)(e.UserId)),
        e.Account !== void 0 && (n.Account = (0, H.expectString)(e.Account)),
        e.Arn !== void 0 && (n.Arn = (0, H.expectString)(e.Arn)),
        n
      )
    },
    Lbe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = qu(e.Credentials, t)),
        e.FederatedUser !== void 0 &&
          (n.FederatedUser = Mbe(e.FederatedUser, t)),
        e.PackedPolicySize !== void 0 &&
          (n.PackedPolicySize = (0, H.strictParseInt32)(e.PackedPolicySize)),
        n
      )
    },
    Bbe = (e, t) => {
      let n = {}
      return (
        e.Credentials !== void 0 && (n.Credentials = qu(e.Credentials, t)), n
      )
    },
    jbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    Gbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    $be = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    zbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    Hbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    Wbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    Vbe = (e, t) => {
      let n = {}
      return (
        e.message !== void 0 && (n.message = (0, H.expectString)(e.message)), n
      )
    },
    rt = (e) => ({
      httpStatusCode: e.statusCode,
      requestId:
        e.headers['x-amzn-requestid'] ??
        e.headers['x-amzn-request-id'] ??
        e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }),
    Ybe = (e, t) => (0, H.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    _s = (0, H.withBaseException)(HSe.STSServiceException),
    hs = async (e, t, n, r, s) => {
      let {
          hostname: o,
          protocol: i = 'https',
          port: c,
          path: a,
        } = await e.endpoint(),
        u = {
          protocol: i,
          hostname: o,
          port: c,
          method: 'POST',
          path: a.endsWith('/') ? a.slice(0, -1) + n : a + n,
          headers: t,
        }
      return (
        r !== void 0 && (u.hostname = r),
        s !== void 0 && (u.body = s),
        new $Se.HttpRequest(u)
      )
    },
    ys = { 'content-type': 'application/x-www-form-urlencoded' },
    Cr = (e, t) =>
      Ybe(e, t).then((n) => {
        if (n.length) {
          let r = new zSe.XMLParser({
            attributeNamePrefix: '',
            htmlEntities: !0,
            ignoreAttributes: !1,
            ignoreDeclaration: !0,
            parseTagValue: !1,
            trimValues: !1,
            tagValueProcessor: (a, u) =>
              u.trim() === '' &&
              u.includes(`
`)
                ? ''
                : void 0,
          })
          r.addEntity('#xD', '\r'),
            r.addEntity(
              '#10',
              `
`,
            )
          let s = r.parse(n),
            o = '#text',
            i = Object.keys(s)[0],
            c = s[i]
          return (
            c[o] && ((c[i] = c[o]), delete c[o]), (0, H.getValueFromTextNode)(c)
          )
        }
        return {}
      }),
    gs = async (e, t) => {
      let n = await Cr(e, t)
      return (
        n.Error && (n.Error.message = n.Error.message ?? n.Error.Message), n
      )
    },
    Es = (e) =>
      Object.entries(e)
        .map(
          ([t, n]) =>
            (0, H.extendedEncodeURIComponent)(t) +
            '=' +
            (0, H.extendedEncodeURIComponent)(n),
        )
        .join('&'),
    Ss = (e, t) => {
      if (t.Error?.Code !== void 0) return t.Error.Code
      if (e.statusCode == 404) return 'NotFound'
    }
})
var Ph = l((Ki) => {
  'use strict'
  Object.defineProperty(Ki, '__esModule', { value: !0 })
  Ki.AssumeRoleCommand = Ki.$Command = void 0
  var Kbe = fr(),
    Jbe = D(),
    Xbe = O(),
    Fz = v()
  Object.defineProperty(Ki, '$Command', {
    enumerable: !0,
    get: function () {
      return Fz.Command
    },
  })
  var Qbe = ms(),
    Mz = wr(),
    Cx = class e extends Fz.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Xbe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Jbe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, Kbe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'AssumeRoleCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: Qbe.AssumeRoleResponseFilterSensitiveLog,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, Mz.se_AssumeRoleCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Mz.de_AssumeRoleCommand)(t, n)
      }
    }
  Ki.AssumeRoleCommand = Cx
})
var Rh = l((Ji) => {
  'use strict'
  Object.defineProperty(Ji, '__esModule', { value: !0 })
  Ji.AssumeRoleWithWebIdentityCommand = Ji.$Command = void 0
  var Zbe = D(),
    eve = O(),
    Bz = v()
  Object.defineProperty(Ji, '$Command', {
    enumerable: !0,
    get: function () {
      return Bz.Command
    },
  })
  var Uz = ms(),
    Lz = wr(),
    wx = class e extends Bz.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, eve.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Zbe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'AssumeRoleWithWebIdentityCommand',
            inputFilterSensitiveLog:
              Uz.AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
            outputFilterSensitiveLog:
              Uz.AssumeRoleWithWebIdentityResponseFilterSensitiveLog,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, Lz.se_AssumeRoleWithWebIdentityCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Lz.de_AssumeRoleWithWebIdentityCommand)(t, n)
      }
    }
  Ji.AssumeRoleWithWebIdentityCommand = wx
})
var Tx = l((Fn) => {
  'use strict'
  Object.defineProperty(Fn, '__esModule', { value: !0 })
  Fn.decorateDefaultCredentialProvider =
    Fn.getDefaultRoleAssumerWithWebIdentity =
    Fn.getDefaultRoleAssumer =
      void 0
  var tve = Ph(),
    nve = Rh(),
    jz = 'us-east-1',
    Gz = (e) =>
      typeof e != 'function'
        ? e === void 0
          ? jz
          : e
        : async () => {
            try {
              return await e()
            } catch {
              return jz
            }
          },
    rve = (e, t) => {
      let n, r
      return async (s, o) => {
        if (((r = s), !n)) {
          let { logger: c, region: a, requestHandler: u } = e
          n = new t({
            logger: c,
            credentialDefaultProvider: () => async () => r,
            region: Gz(a || e.region),
            ...(u ? { requestHandler: u } : {}),
          })
        }
        let { Credentials: i } = await n.send(new tve.AssumeRoleCommand(o))
        if (!i || !i.AccessKeyId || !i.SecretAccessKey)
          throw new Error(
            `Invalid response from STS.assumeRole call with role ${o.RoleArn}`,
          )
        return {
          accessKeyId: i.AccessKeyId,
          secretAccessKey: i.SecretAccessKey,
          sessionToken: i.SessionToken,
          expiration: i.Expiration,
        }
      }
    }
  Fn.getDefaultRoleAssumer = rve
  var sve = (e, t) => {
    let n
    return async (r) => {
      if (!n) {
        let { logger: o, region: i, requestHandler: c } = e
        n = new t({
          logger: o,
          region: Gz(i || e.region),
          ...(c ? { requestHandler: c } : {}),
        })
      }
      let { Credentials: s } = await n.send(
        new nve.AssumeRoleWithWebIdentityCommand(r),
      )
      if (!s || !s.AccessKeyId || !s.SecretAccessKey)
        throw new Error(
          `Invalid response from STS.assumeRoleWithWebIdentity call with role ${r.RoleArn}`,
        )
      return {
        accessKeyId: s.AccessKeyId,
        secretAccessKey: s.SecretAccessKey,
        sessionToken: s.SessionToken,
        expiration: s.Expiration,
      }
    }
  }
  Fn.getDefaultRoleAssumerWithWebIdentity = sve
  var ove = (e) => (t) =>
    e({
      roleAssumer: (0, Fn.getDefaultRoleAssumer)(t, t.stsClientCtor),
      roleAssumerWithWebIdentity: (0, Fn.getDefaultRoleAssumerWithWebIdentity)(
        t,
        t.stsClientCtor,
      ),
      ...t,
    })
  Fn.decorateDefaultCredentialProvider = ove
})
var $z = l((st) => {
  'use strict'
  Object.defineProperty(st, '__esModule', { value: !0 })
  st.fromEnv =
    st.ENV_EXPIRATION =
    st.ENV_SESSION =
    st.ENV_SECRET =
    st.ENV_KEY =
      void 0
  var ive = Y()
  st.ENV_KEY = 'AWS_ACCESS_KEY_ID'
  st.ENV_SECRET = 'AWS_SECRET_ACCESS_KEY'
  st.ENV_SESSION = 'AWS_SESSION_TOKEN'
  st.ENV_EXPIRATION = 'AWS_CREDENTIAL_EXPIRATION'
  var ave = () => async () => {
    let e = process.env[st.ENV_KEY],
      t = process.env[st.ENV_SECRET],
      n = process.env[st.ENV_SESSION],
      r = process.env[st.ENV_EXPIRATION]
    if (e && t)
      return {
        accessKeyId: e,
        secretAccessKey: t,
        ...(n && { sessionToken: n }),
        ...(r && { expiration: new Date(r) }),
      }
    throw new ive.CredentialsProviderError(
      'Unable to find environment variable credentials.',
    )
  }
  st.fromEnv = ave
})
var Ix = l((xx) => {
  'use strict'
  Object.defineProperty(xx, '__esModule', { value: !0 })
  var cve = (x(), w(T))
  cve.__exportStar($z(), xx)
})
var ku = l((Dh) => {
  'use strict'
  Object.defineProperty(Dh, '__esModule', { value: !0 })
  Dh.getHomeDir = void 0
  var dve = require('os'),
    uve = require('path'),
    lve = () => {
      let {
        HOME: e,
        USERPROFILE: t,
        HOMEPATH: n,
        HOMEDRIVE: r = `C:${uve.sep}`,
      } = process.env
      return e || t || (n ? `${r}${n}` : (0, dve.homedir)())
    }
  Dh.getHomeDir = lve
})
var zz = l((Un) => {
  'use strict'
  Object.defineProperty(Un, '__esModule', { value: !0 })
  Un.getProfileName = Un.DEFAULT_PROFILE = Un.ENV_PROFILE = void 0
  Un.ENV_PROFILE = 'AWS_PROFILE'
  Un.DEFAULT_PROFILE = 'default'
  var mve = (e) =>
    e.profile || process.env[Un.ENV_PROFILE] || Un.DEFAULT_PROFILE
  Un.getProfileName = mve
})
var Px = l((Ah) => {
  'use strict'
  Object.defineProperty(Ah, '__esModule', { value: !0 })
  Ah.getSSOTokenFilepath = void 0
  var pve = require('crypto'),
    fve = require('path'),
    _ve = ku(),
    hve = (e) => {
      let n = (0, pve.createHash)('sha1').update(e).digest('hex')
      return (0, fve.join)(
        (0, _ve.getHomeDir)(),
        '.aws',
        'sso',
        'cache',
        `${n}.json`,
      )
    }
  Ah.getSSOTokenFilepath = hve
})
var Hz = l((Oh) => {
  'use strict'
  Object.defineProperty(Oh, '__esModule', { value: !0 })
  Oh.getSSOTokenFromFile = void 0
  var yve = require('fs'),
    gve = Px(),
    { readFile: Eve } = yve.promises,
    Sve = async (e) => {
      let t = (0, gve.getSSOTokenFilepath)(e),
        n = await Eve(t, 'utf8')
      return JSON.parse(n)
    }
  Oh.getSSOTokenFromFile = Sve
})
var Rx = l((Ao) => {
  'use strict'
  Object.defineProperty(Ao, '__esModule', { value: !0 })
  Ao.getConfigFilepath = Ao.ENV_CONFIG_PATH = void 0
  var bve = require('path'),
    vve = ku()
  Ao.ENV_CONFIG_PATH = 'AWS_CONFIG_FILE'
  var Cve = () =>
    process.env[Ao.ENV_CONFIG_PATH] ||
    (0, bve.join)((0, vve.getHomeDir)(), '.aws', 'config')
  Ao.getConfigFilepath = Cve
})
var Wz = l((Oo) => {
  'use strict'
  Object.defineProperty(Oo, '__esModule', { value: !0 })
  Oo.getCredentialsFilepath = Oo.ENV_CREDENTIALS_PATH = void 0
  var wve = require('path'),
    Tve = ku()
  Oo.ENV_CREDENTIALS_PATH = 'AWS_SHARED_CREDENTIALS_FILE'
  var xve = () =>
    process.env[Oo.ENV_CREDENTIALS_PATH] ||
    (0, wve.join)((0, Tve.getHomeDir)(), '.aws', 'credentials')
  Oo.getCredentialsFilepath = xve
})
var Yz = l((Nh) => {
  'use strict'
  Object.defineProperty(Nh, '__esModule', { value: !0 })
  Nh.getProfileData = void 0
  var Vz = /^profile\s(["'])?([^\1]+)\1$/,
    Ive = (e) =>
      Object.entries(e)
        .filter(([t]) => Vz.test(t))
        .reduce((t, [n, r]) => ({ ...t, [Vz.exec(n)[2]]: r }), {
          ...(e.default && { default: e.default }),
        })
  Nh.getProfileData = Ive
})
var Dx = l((qh) => {
  'use strict'
  Object.defineProperty(qh, '__esModule', { value: !0 })
  qh.parseIni = void 0
  var Pve = ['__proto__', 'profile __proto__'],
    Rve = (e) => {
      let t = {},
        n
      for (let r of e.split(/\r?\n/))
        if (
          ((r = r.split(/(^|\s)[;#]/)[0].trim()),
          r[0] === '[' && r[r.length - 1] === ']')
        ) {
          if (((n = r.substring(1, r.length - 1)), Pve.includes(n)))
            throw new Error(`Found invalid profile name "${n}"`)
        } else if (n) {
          let o = r.indexOf('='),
            i = 0,
            c = r.length - 1
          if (o !== -1 && o !== i && o !== c) {
            let [u, d] = [r.substring(0, o).trim(), r.substring(o + 1).trim()]
            ;(t[n] = t[n] || {}), (t[n][u] = d)
          }
        }
      return t
    }
  qh.parseIni = Rve
})
var Ox = l((kh) => {
  'use strict'
  Object.defineProperty(kh, '__esModule', { value: !0 })
  kh.slurpFile = void 0
  var Dve = require('fs'),
    { readFile: Ave } = Dve.promises,
    Ax = {},
    Ove = (e, t) => (
      (!Ax[e] || t?.ignoreCache) && (Ax[e] = Ave(e, 'utf8')), Ax[e]
    )
  kh.slurpFile = Ove
})
var Nx = l((Mh) => {
  'use strict'
  Object.defineProperty(Mh, '__esModule', { value: !0 })
  Mh.loadSharedConfigFiles = void 0
  var Nve = Rx(),
    qve = Wz(),
    kve = Yz(),
    Kz = Dx(),
    Jz = Ox(),
    Xz = () => ({}),
    Mve = async (e = {}) => {
      let {
          filepath: t = (0, qve.getCredentialsFilepath)(),
          configFilepath: n = (0, Nve.getConfigFilepath)(),
        } = e,
        r = await Promise.all([
          (0, Jz.slurpFile)(n, { ignoreCache: e.ignoreCache })
            .then(Kz.parseIni)
            .then(kve.getProfileData)
            .catch(Xz),
          (0, Jz.slurpFile)(t, { ignoreCache: e.ignoreCache })
            .then(Kz.parseIni)
            .catch(Xz),
        ])
      return { configFile: r[0], credentialsFile: r[1] }
    }
  Mh.loadSharedConfigFiles = Mve
})
var Zz = l((Fh) => {
  'use strict'
  Object.defineProperty(Fh, '__esModule', { value: !0 })
  Fh.getSsoSessionData = void 0
  var Qz = /^sso-session\s(["'])?([^\1]+)\1$/,
    Fve = (e) =>
      Object.entries(e)
        .filter(([t]) => Qz.test(t))
        .reduce((t, [n, r]) => ({ ...t, [Qz.exec(n)[2]]: r }), {})
  Fh.getSsoSessionData = Fve
})
var eH = l((Uh) => {
  'use strict'
  Object.defineProperty(Uh, '__esModule', { value: !0 })
  Uh.loadSsoSessionData = void 0
  var Uve = Rx(),
    Lve = Zz(),
    Bve = Dx(),
    jve = Ox(),
    Gve = () => ({}),
    $ve = async (e = {}) => {
      var t
      return (0, jve.slurpFile)(
        (t = e.configFilepath) !== null && t !== void 0
          ? t
          : (0, Uve.getConfigFilepath)(),
      )
        .then(Bve.parseIni)
        .then(Lve.getSsoSessionData)
        .catch(Gve)
    }
  Uh.loadSsoSessionData = $ve
})
var tH = l((Lh) => {
  'use strict'
  Object.defineProperty(Lh, '__esModule', { value: !0 })
  Lh.mergeConfigFiles = void 0
  var zve = (...e) => {
    let t = {}
    for (let n of e)
      for (let [r, s] of Object.entries(n))
        t[r] !== void 0 ? Object.assign(t[r], s) : (t[r] = s)
    return t
  }
  Lh.mergeConfigFiles = zve
})
var nH = l((Bh) => {
  'use strict'
  Object.defineProperty(Bh, '__esModule', { value: !0 })
  Bh.parseKnownFiles = void 0
  var Hve = Nx(),
    Wve = tH(),
    Vve = async (e) => {
      let t = await (0, Hve.loadSharedConfigFiles)(e)
      return (0, Wve.mergeConfigFiles)(t.configFile, t.credentialsFile)
    }
  Bh.parseKnownFiles = Vve
})
var sH = l((rH) => {
  'use strict'
  Object.defineProperty(rH, '__esModule', { value: !0 })
})
var ct = l((Ln) => {
  'use strict'
  Object.defineProperty(Ln, '__esModule', { value: !0 })
  var bs = (x(), w(T))
  bs.__exportStar(ku(), Ln)
  bs.__exportStar(zz(), Ln)
  bs.__exportStar(Px(), Ln)
  bs.__exportStar(Hz(), Ln)
  bs.__exportStar(Nx(), Ln)
  bs.__exportStar(eH(), Ln)
  bs.__exportStar(nH(), Ln)
  bs.__exportStar(sH(), Ln)
})
var Gh = l((jh) => {
  'use strict'
  Object.defineProperty(jh, '__esModule', { value: !0 })
  jh.httpRequest = void 0
  var qx = Y(),
    Yve = require('buffer'),
    Kve = require('http')
  function Jve(e) {
    return new Promise((t, n) => {
      var r
      let s = (0, Kve.request)({
        method: 'GET',
        ...e,
        hostname:
          (r = e.hostname) === null || r === void 0
            ? void 0
            : r.replace(/^\[(.+)\]$/, '$1'),
      })
      s.on('error', (o) => {
        n(
          Object.assign(
            new qx.ProviderError(
              'Unable to connect to instance metadata service',
            ),
            o,
          ),
        ),
          s.destroy()
      }),
        s.on('timeout', () => {
          n(
            new qx.ProviderError('TimeoutError from instance metadata service'),
          ),
            s.destroy()
        }),
        s.on('response', (o) => {
          let { statusCode: i = 400 } = o
          ;(i < 200 || 300 <= i) &&
            (n(
              Object.assign(
                new qx.ProviderError(
                  'Error response received from instance metadata service',
                ),
                { statusCode: i },
              ),
            ),
            s.destroy())
          let c = []
          o.on('data', (a) => {
            c.push(a)
          }),
            o.on('end', () => {
              t(Yve.Buffer.concat(c)), s.destroy()
            })
        }),
        s.end()
    })
  }
  jh.httpRequest = Jve
})
var kx = l((Xi) => {
  'use strict'
  Object.defineProperty(Xi, '__esModule', { value: !0 })
  Xi.fromImdsCredentials = Xi.isImdsCredentials = void 0
  var Xve = (e) =>
    !!e &&
    typeof e == 'object' &&
    typeof e.AccessKeyId == 'string' &&
    typeof e.SecretAccessKey == 'string' &&
    typeof e.Token == 'string' &&
    typeof e.Expiration == 'string'
  Xi.isImdsCredentials = Xve
  var Qve = (e) => ({
    accessKeyId: e.AccessKeyId,
    secretAccessKey: e.SecretAccessKey,
    sessionToken: e.Token,
    expiration: new Date(e.Expiration),
  })
  Xi.fromImdsCredentials = Qve
})
var $h = l((Bn) => {
  'use strict'
  Object.defineProperty(Bn, '__esModule', { value: !0 })
  Bn.providerConfigFromInit =
    Bn.DEFAULT_MAX_RETRIES =
    Bn.DEFAULT_TIMEOUT =
      void 0
  Bn.DEFAULT_TIMEOUT = 1e3
  Bn.DEFAULT_MAX_RETRIES = 0
  var Zve = ({
    maxRetries: e = Bn.DEFAULT_MAX_RETRIES,
    timeout: t = Bn.DEFAULT_TIMEOUT,
  }) => ({ maxRetries: e, timeout: t })
  Bn.providerConfigFromInit = Zve
})
var Mx = l((zh) => {
  'use strict'
  Object.defineProperty(zh, '__esModule', { value: !0 })
  zh.retry = void 0
  var eCe = (e, t) => {
    let n = e()
    for (let r = 0; r < t; r++) n = n.catch(e)
    return n
  }
  zh.retry = eCe
})
var iH = l((je) => {
  'use strict'
  Object.defineProperty(je, '__esModule', { value: !0 })
  je.fromContainerMetadata =
    je.ENV_CMDS_AUTH_TOKEN =
    je.ENV_CMDS_RELATIVE_URI =
    je.ENV_CMDS_FULL_URI =
      void 0
  var Hh = Y(),
    tCe = require('url'),
    nCe = Gh(),
    oH = kx(),
    rCe = $h(),
    sCe = Mx()
  je.ENV_CMDS_FULL_URI = 'AWS_CONTAINER_CREDENTIALS_FULL_URI'
  je.ENV_CMDS_RELATIVE_URI = 'AWS_CONTAINER_CREDENTIALS_RELATIVE_URI'
  je.ENV_CMDS_AUTH_TOKEN = 'AWS_CONTAINER_AUTHORIZATION_TOKEN'
  var oCe = (e = {}) => {
    let { timeout: t, maxRetries: n } = (0, rCe.providerConfigFromInit)(e)
    return () =>
      (0, sCe.retry)(async () => {
        let r = await uCe(),
          s = JSON.parse(await iCe(t, r))
        if (!(0, oH.isImdsCredentials)(s))
          throw new Hh.CredentialsProviderError(
            'Invalid response received from instance metadata service.',
          )
        return (0, oH.fromImdsCredentials)(s)
      }, n)
  }
  je.fromContainerMetadata = oCe
  var iCe = async (e, t) => (
      process.env[je.ENV_CMDS_AUTH_TOKEN] &&
        (t.headers = {
          ...t.headers,
          Authorization: process.env[je.ENV_CMDS_AUTH_TOKEN],
        }),
      (await (0, nCe.httpRequest)({ ...t, timeout: e })).toString()
    ),
    aCe = '169.254.170.2',
    cCe = { localhost: !0, '127.0.0.1': !0 },
    dCe = { 'http:': !0, 'https:': !0 },
    uCe = async () => {
      if (process.env[je.ENV_CMDS_RELATIVE_URI])
        return { hostname: aCe, path: process.env[je.ENV_CMDS_RELATIVE_URI] }
      if (process.env[je.ENV_CMDS_FULL_URI]) {
        let e = (0, tCe.parse)(process.env[je.ENV_CMDS_FULL_URI])
        if (!e.hostname || !(e.hostname in cCe))
          throw new Hh.CredentialsProviderError(
            `${e.hostname} is not a valid container metadata service hostname`,
            !1,
          )
        if (!e.protocol || !(e.protocol in dCe))
          throw new Hh.CredentialsProviderError(
            `${e.protocol} is not a valid container metadata service protocol`,
            !1,
          )
        return { ...e, port: e.port ? parseInt(e.port, 10) : void 0 }
      }
      throw new Hh.CredentialsProviderError(
        `The container metadata credential provider cannot be used unless the ${je.ENV_CMDS_RELATIVE_URI} or ${je.ENV_CMDS_FULL_URI} environment variable is set`,
        !1,
      )
    }
})
var aH = l((Wh) => {
  'use strict'
  Object.defineProperty(Wh, '__esModule', { value: !0 })
  Wh.fromEnv = void 0
  var lCe = Y(),
    mCe = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new lCe.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  Wh.fromEnv = mCe
})
var dH = l((Vh) => {
  'use strict'
  Object.defineProperty(Vh, '__esModule', { value: !0 })
  Vh.fromSharedConfigFiles = void 0
  var pCe = Y(),
    cH = ct(),
    fCe =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, cH.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          cH.loadSharedConfigFiles)(n),
          i = o[r] || {},
          c = s[r] || {},
          a = t === 'config' ? { ...i, ...c } : { ...c, ...i }
        try {
          let u = e(a)
          if (u === void 0) throw new Error()
          return u
        } catch (u) {
          throw new pCe.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  Vh.fromSharedConfigFiles = fCe
})
var uH = l((Yh) => {
  'use strict'
  Object.defineProperty(Yh, '__esModule', { value: !0 })
  Yh.fromStatic = void 0
  var _Ce = Y(),
    hCe = (e) => typeof e == 'function',
    yCe = (e) => (hCe(e) ? async () => await e() : (0, _Ce.fromStatic)(e))
  Yh.fromStatic = yCe
})
var mH = l((Kh) => {
  'use strict'
  Object.defineProperty(Kh, '__esModule', { value: !0 })
  Kh.loadConfig = void 0
  var lH = Y(),
    gCe = aH(),
    ECe = dH(),
    SCe = uH(),
    bCe = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, lH.memoize)(
        (0, lH.chain)(
          (0, gCe.fromEnv)(e),
          (0, ECe.fromSharedConfigFiles)(t, r),
          (0, SCe.fromStatic)(n),
        ),
      )
  Kh.loadConfig = bCe
})
var pH = l((Fx) => {
  'use strict'
  Object.defineProperty(Fx, '__esModule', { value: !0 })
  var vCe = (x(), w(T))
  vCe.__exportStar(mH(), Fx)
})
var fH = l((Mu) => {
  'use strict'
  Object.defineProperty(Mu, '__esModule', { value: !0 })
  Mu.Endpoint = void 0
  var CCe
  ;(function (e) {
    ;(e.IPv4 = 'http://169.254.169.254'), (e.IPv6 = 'http://[fd00:ec2::254]')
  })((CCe = Mu.Endpoint || (Mu.Endpoint = {})))
})
var _H = l((jn) => {
  'use strict'
  Object.defineProperty(jn, '__esModule', { value: !0 })
  jn.ENDPOINT_CONFIG_OPTIONS =
    jn.CONFIG_ENDPOINT_NAME =
    jn.ENV_ENDPOINT_NAME =
      void 0
  jn.ENV_ENDPOINT_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT'
  jn.CONFIG_ENDPOINT_NAME = 'ec2_metadata_service_endpoint'
  jn.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[jn.ENV_ENDPOINT_NAME],
    configFileSelector: (e) => e[jn.CONFIG_ENDPOINT_NAME],
    default: void 0,
  }
})
var Ux = l((Fu) => {
  'use strict'
  Object.defineProperty(Fu, '__esModule', { value: !0 })
  Fu.EndpointMode = void 0
  var wCe
  ;(function (e) {
    ;(e.IPv4 = 'IPv4'), (e.IPv6 = 'IPv6')
  })((wCe = Fu.EndpointMode || (Fu.EndpointMode = {})))
})
var hH = l((Gn) => {
  'use strict'
  Object.defineProperty(Gn, '__esModule', { value: !0 })
  Gn.ENDPOINT_MODE_CONFIG_OPTIONS =
    Gn.CONFIG_ENDPOINT_MODE_NAME =
    Gn.ENV_ENDPOINT_MODE_NAME =
      void 0
  var TCe = Ux()
  Gn.ENV_ENDPOINT_MODE_NAME = 'AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE'
  Gn.CONFIG_ENDPOINT_MODE_NAME = 'ec2_metadata_service_endpoint_mode'
  Gn.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[Gn.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (e) => e[Gn.CONFIG_ENDPOINT_MODE_NAME],
    default: TCe.EndpointMode.IPv4,
  }
})
var Bx = l((Jh) => {
  'use strict'
  Object.defineProperty(Jh, '__esModule', { value: !0 })
  Jh.getInstanceMetadataEndpoint = void 0
  var gH = pH(),
    xCe = vo(),
    yH = fH(),
    ICe = _H(),
    Lx = Ux(),
    PCe = hH(),
    RCe = async () => (0, xCe.parseUrl)((await DCe()) || (await ACe()))
  Jh.getInstanceMetadataEndpoint = RCe
  var DCe = async () => (0, gH.loadConfig)(ICe.ENDPOINT_CONFIG_OPTIONS)(),
    ACe = async () => {
      let e = await (0, gH.loadConfig)(PCe.ENDPOINT_MODE_CONFIG_OPTIONS)()
      switch (e) {
        case Lx.EndpointMode.IPv4:
          return yH.Endpoint.IPv4
        case Lx.EndpointMode.IPv6:
          return yH.Endpoint.IPv6
        default:
          throw new Error(
            `Unsupported endpoint mode: ${e}. Select from ${Object.values(
              Lx.EndpointMode,
            )}`,
          )
      }
    }
})
var EH = l((Xh) => {
  'use strict'
  Object.defineProperty(Xh, '__esModule', { value: !0 })
  Xh.getExtendedInstanceMetadataCredentials = void 0
  var OCe = 5 * 60,
    NCe = 5 * 60,
    qCe =
      'https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html',
    kCe = (e, t) => {
      var n
      let r = OCe + Math.floor(Math.random() * NCe),
        s = new Date(Date.now() + r * 1e3)
      t.warn(
        'Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: ' +
          qCe,
      )
      let o =
        (n = e.originalExpiration) !== null && n !== void 0 ? n : e.expiration
      return { ...e, ...(o ? { originalExpiration: o } : {}), expiration: s }
    }
  Xh.getExtendedInstanceMetadataCredentials = kCe
})
var bH = l((Qh) => {
  'use strict'
  Object.defineProperty(Qh, '__esModule', { value: !0 })
  Qh.staticStabilityProvider = void 0
  var SH = EH(),
    MCe = (e, t = {}) => {
      let n = t?.logger || console,
        r
      return async () => {
        let s
        try {
          ;(s = await e()),
            s.expiration &&
              s.expiration.getTime() < Date.now() &&
              (s = (0, SH.getExtendedInstanceMetadataCredentials)(s, n))
        } catch (o) {
          if (r)
            n.warn('Credential renew failed: ', o),
              (s = (0, SH.getExtendedInstanceMetadataCredentials)(r, n))
          else throw o
        }
        return (r = s), s
      }
    }
  Qh.staticStabilityProvider = MCe
})
var TH = l((Zh) => {
  'use strict'
  Object.defineProperty(Zh, '__esModule', { value: !0 })
  Zh.fromInstanceMetadata = void 0
  var FCe = Y(),
    jx = Gh(),
    vH = kx(),
    UCe = $h(),
    CH = Mx(),
    LCe = Bx(),
    BCe = bH(),
    wH = '/latest/meta-data/iam/security-credentials/',
    jCe = '/latest/api/token',
    GCe = (e = {}) =>
      (0, BCe.staticStabilityProvider)($Ce(e), { logger: e.logger })
  Zh.fromInstanceMetadata = GCe
  var $Ce = (e) => {
      let t = !1,
        { timeout: n, maxRetries: r } = (0, UCe.providerConfigFromInit)(e),
        s = async (o, i) => {
          let c = (
            await (0, CH.retry)(async () => {
              let a
              try {
                a = await HCe(i)
              } catch (u) {
                throw (u.statusCode === 401 && (t = !1), u)
              }
              return a
            }, o)
          ).trim()
          return (0, CH.retry)(async () => {
            let a
            try {
              a = await WCe(c, i)
            } catch (u) {
              throw (u.statusCode === 401 && (t = !1), u)
            }
            return a
          }, o)
        }
      return async () => {
        let o = await (0, LCe.getInstanceMetadataEndpoint)()
        if (t) return s(r, { ...o, timeout: n })
        {
          let i
          try {
            i = (await zCe({ ...o, timeout: n })).toString()
          } catch (c) {
            if (c?.statusCode === 400)
              throw Object.assign(c, {
                message: 'EC2 Metadata token request returned error',
              })
            return (
              (c.message === 'TimeoutError' ||
                [403, 404, 405].includes(c.statusCode)) &&
                (t = !0),
              s(r, { ...o, timeout: n })
            )
          }
          return s(r, {
            ...o,
            headers: { 'x-aws-ec2-metadata-token': i },
            timeout: n,
          })
        }
      }
    },
    zCe = async (e) =>
      (0, jx.httpRequest)({
        ...e,
        path: jCe,
        method: 'PUT',
        headers: { 'x-aws-ec2-metadata-token-ttl-seconds': '21600' },
      }),
    HCe = async (e) =>
      (await (0, jx.httpRequest)({ ...e, path: wH })).toString(),
    WCe = async (e, t) => {
      let n = JSON.parse(
        (await (0, jx.httpRequest)({ ...t, path: wH + e })).toString(),
      )
      if (!(0, vH.isImdsCredentials)(n))
        throw new FCe.CredentialsProviderError(
          'Invalid response received from instance metadata service.',
        )
      return (0, vH.fromImdsCredentials)(n)
    }
})
var IH = l((xH) => {
  'use strict'
  Object.defineProperty(xH, '__esModule', { value: !0 })
})
var ty = l(($n) => {
  'use strict'
  Object.defineProperty($n, '__esModule', { value: !0 })
  $n.getInstanceMetadataEndpoint = $n.httpRequest = void 0
  var ey = (x(), w(T))
  ey.__exportStar(iH(), $n)
  ey.__exportStar(TH(), $n)
  ey.__exportStar($h(), $n)
  ey.__exportStar(IH(), $n)
  var VCe = Gh()
  Object.defineProperty($n, 'httpRequest', {
    enumerable: !0,
    get: function () {
      return VCe.httpRequest
    },
  })
  var YCe = Bx()
  Object.defineProperty($n, 'getInstanceMetadataEndpoint', {
    enumerable: !0,
    get: function () {
      return YCe.getInstanceMetadataEndpoint
    },
  })
})
var RH = l((ny) => {
  'use strict'
  Object.defineProperty(ny, '__esModule', { value: !0 })
  ny.resolveCredentialSource = void 0
  var KCe = Ix(),
    PH = ty(),
    JCe = Y(),
    XCe = (e, t) => {
      let n = {
        EcsContainer: PH.fromContainerMetadata,
        Ec2InstanceMetadata: PH.fromInstanceMetadata,
        Environment: KCe.fromEnv,
      }
      if (e in n) return n[e]()
      throw new JCe.CredentialsProviderError(
        `Unsupported credential source in profile ${t}. Got ${e}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,
      )
    }
  ny.resolveCredentialSource = XCe
})
var DH = l((Qi) => {
  'use strict'
  Object.defineProperty(Qi, '__esModule', { value: !0 })
  Qi.resolveAssumeRoleCredentials = Qi.isAssumeRoleProfile = void 0
  var Gx = Y(),
    QCe = ct(),
    ZCe = RH(),
    e0e = $x(),
    t0e = (e) =>
      !!e &&
      typeof e == 'object' &&
      typeof e.role_arn == 'string' &&
      ['undefined', 'string'].indexOf(typeof e.role_session_name) > -1 &&
      ['undefined', 'string'].indexOf(typeof e.external_id) > -1 &&
      ['undefined', 'string'].indexOf(typeof e.mfa_serial) > -1 &&
      (n0e(e) || r0e(e))
  Qi.isAssumeRoleProfile = t0e
  var n0e = (e) =>
      typeof e.source_profile == 'string' && typeof e.credential_source > 'u',
    r0e = (e) =>
      typeof e.credential_source == 'string' && typeof e.source_profile > 'u',
    s0e = async (e, t, n, r = {}) => {
      let s = t[e]
      if (!n.roleAssumer)
        throw new Gx.CredentialsProviderError(
          `Profile ${e} requires a role to be assumed, but no role assumption callback was provided.`,
          !1,
        )
      let { source_profile: o } = s
      if (o && o in r)
        throw new Gx.CredentialsProviderError(
          `Detected a cycle attempting to resolve credentials for profile ${(0,
          QCe.getProfileName)(n)}. Profiles visited: ` +
            Object.keys(r).join(', '),
          !1,
        )
      let i = o
          ? (0, e0e.resolveProfileData)(o, t, n, { ...r, [o]: !0 })
          : (0, ZCe.resolveCredentialSource)(s.credential_source, e)(),
        c = {
          RoleArn: s.role_arn,
          RoleSessionName: s.role_session_name || `aws-sdk-js-${Date.now()}`,
          ExternalId: s.external_id,
        },
        { mfa_serial: a } = s
      if (a) {
        if (!n.mfaCodeProvider)
          throw new Gx.CredentialsProviderError(
            `Profile ${e} requires multi-factor authentication, but no MFA code callback was provided.`,
            !1,
          )
        ;(c.SerialNumber = a), (c.TokenCode = await n.mfaCodeProvider(a))
      }
      let u = await i
      return n.roleAssumer(u, c)
    }
  Qi.resolveAssumeRoleCredentials = s0e
})
var AH = l((ry) => {
  'use strict'
  Object.defineProperty(ry, '__esModule', { value: !0 })
  ry.getValidatedProcessCredentials = void 0
  var o0e = (e, t) => {
    if (t.Version !== 1)
      throw Error(`Profile ${e} credential_process did not return Version 1.`)
    if (t.AccessKeyId === void 0 || t.SecretAccessKey === void 0)
      throw Error(
        `Profile ${e} credential_process returned invalid credentials.`,
      )
    if (t.Expiration) {
      let n = new Date()
      if (new Date(t.Expiration) < n)
        throw Error(
          `Profile ${e} credential_process returned expired credentials.`,
        )
    }
    return {
      accessKeyId: t.AccessKeyId,
      secretAccessKey: t.SecretAccessKey,
      ...(t.SessionToken && { sessionToken: t.SessionToken }),
      ...(t.Expiration && { expiration: new Date(t.Expiration) }),
    }
  }
  ry.getValidatedProcessCredentials = o0e
})
var OH = l((sy) => {
  'use strict'
  Object.defineProperty(sy, '__esModule', { value: !0 })
  sy.resolveProcessCredentials = void 0
  var zx = Y(),
    i0e = require('child_process'),
    a0e = require('util'),
    c0e = AH(),
    d0e = async (e, t) => {
      let n = t[e]
      if (t[e]) {
        let r = n.credential_process
        if (r !== void 0) {
          let s = (0, a0e.promisify)(i0e.exec)
          try {
            let { stdout: o } = await s(r),
              i
            try {
              i = JSON.parse(o.trim())
            } catch {
              throw Error(
                `Profile ${e} credential_process returned invalid JSON.`,
              )
            }
            return (0, c0e.getValidatedProcessCredentials)(e, i)
          } catch (o) {
            throw new zx.CredentialsProviderError(o.message)
          }
        } else
          throw new zx.CredentialsProviderError(
            `Profile ${e} did not contain credential_process.`,
          )
      } else
        throw new zx.CredentialsProviderError(
          `Profile ${e} could not be found in shared credentials file.`,
        )
    }
  sy.resolveProcessCredentials = d0e
})
var qH = l((oy) => {
  'use strict'
  Object.defineProperty(oy, '__esModule', { value: !0 })
  oy.fromProcess = void 0
  var NH = ct(),
    u0e = OH(),
    l0e =
      (e = {}) =>
      async () => {
        let t = await (0, NH.parseKnownFiles)(e)
        return (0, u0e.resolveProcessCredentials)((0, NH.getProfileName)(e), t)
      }
  oy.fromProcess = l0e
})
var Wx = l((Hx) => {
  'use strict'
  Object.defineProperty(Hx, '__esModule', { value: !0 })
  var m0e = (x(), w(T))
  m0e.__exportStar(qH(), Hx)
})
var kH = l((Zi) => {
  'use strict'
  Object.defineProperty(Zi, '__esModule', { value: !0 })
  Zi.resolveProcessCredentials = Zi.isProcessProfile = void 0
  var p0e = Wx(),
    f0e = (e) =>
      !!e && typeof e == 'object' && typeof e.credential_process == 'string'
  Zi.isProcessProfile = f0e
  var _0e = async (e, t) => (0, p0e.fromProcess)({ ...e, profile: t })()
  Zi.resolveProcessCredentials = _0e
})
var Vx = l((iy) => {
  'use strict'
  Object.defineProperty(iy, '__esModule', { value: !0 })
  iy.isSsoProfile = void 0
  var h0e = (e) =>
    e &&
    (typeof e.sso_start_url == 'string' ||
      typeof e.sso_account_id == 'string' ||
      typeof e.sso_session == 'string' ||
      typeof e.sso_region == 'string' ||
      typeof e.sso_role_name == 'string')
  iy.isSsoProfile = h0e
})
var MH = l((ay) => {
  'use strict'
  Object.defineProperty(ay, '__esModule', { value: !0 })
  ay.resolveClientEndpointParameters = void 0
  var y0e = (e) => ({
    ...e,
    useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
    useFipsEndpoint: e.useFipsEndpoint ?? !1,
    defaultSigningName: 'awsssoportal',
  })
  ay.resolveClientEndpointParameters = y0e
})
var FH = l((l3e, g0e) => {
  g0e.exports = {
    name: '@aws-sdk/client-sso',
    description:
      'AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native',
    version: '3.395.0',
    scripts: {
      build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
      'build:cjs': 'tsc -p tsconfig.cjs.json',
      'build:docs': 'typedoc',
      'build:es': 'tsc -p tsconfig.es.json',
      'build:include:deps':
        'lerna run --scope $npm_package_name --include-dependencies build',
      'build:types': 'tsc -p tsconfig.types.json',
      'build:types:downlevel': 'downlevel-dts dist-types dist-types/ts3.4',
      clean: 'rimraf ./dist-* && rimraf *.tsbuildinfo',
      'extract:docs': 'api-extractor run --local',
      'generate:client':
        'node ../../scripts/generate-clients/single-service --solo sso',
    },
    main: './dist-cjs/index.js',
    types: './dist-types/index.d.ts',
    module: './dist-es/index.js',
    sideEffects: !1,
    dependencies: {
      '@aws-crypto/sha256-browser': '3.0.0',
      '@aws-crypto/sha256-js': '3.0.0',
      '@aws-sdk/middleware-host-header': '3.391.0',
      '@aws-sdk/middleware-logger': '3.391.0',
      '@aws-sdk/middleware-recursion-detection': '3.391.0',
      '@aws-sdk/middleware-user-agent': '3.391.0',
      '@aws-sdk/types': '3.391.0',
      '@aws-sdk/util-endpoints': '3.391.0',
      '@aws-sdk/util-user-agent-browser': '3.391.0',
      '@aws-sdk/util-user-agent-node': '3.391.0',
      '@smithy/config-resolver': '^2.0.3',
      '@smithy/fetch-http-handler': '^2.0.3',
      '@smithy/hash-node': '^2.0.3',
      '@smithy/invalid-dependency': '^2.0.3',
      '@smithy/middleware-content-length': '^2.0.3',
      '@smithy/middleware-endpoint': '^2.0.3',
      '@smithy/middleware-retry': '^2.0.3',
      '@smithy/middleware-serde': '^2.0.3',
      '@smithy/middleware-stack': '^2.0.0',
      '@smithy/node-config-provider': '^2.0.3',
      '@smithy/node-http-handler': '^2.0.3',
      '@smithy/protocol-http': '^2.0.3',
      '@smithy/smithy-client': '^2.0.3',
      '@smithy/types': '^2.2.0',
      '@smithy/url-parser': '^2.0.3',
      '@smithy/util-base64': '^2.0.0',
      '@smithy/util-body-length-browser': '^2.0.0',
      '@smithy/util-body-length-node': '^2.0.0',
      '@smithy/util-defaults-mode-browser': '^2.0.3',
      '@smithy/util-defaults-mode-node': '^2.0.3',
      '@smithy/util-retry': '^2.0.0',
      '@smithy/util-utf8': '^2.0.0',
      tslib: '^2.5.0',
    },
    devDependencies: {
      '@smithy/service-client-documentation-generator': '^2.0.0',
      '@tsconfig/node14': '1.0.3',
      '@types/node': '^14.14.31',
      concurrently: '7.0.0',
      'downlevel-dts': '0.10.1',
      rimraf: '3.0.2',
      typedoc: '0.23.23',
      typescript: '~4.9.5',
    },
    engines: { node: '>=14.0.0' },
    typesVersions: { '<4.0': { 'dist-types/*': ['dist-types/ts3.4/*'] } },
    files: ['dist-*/**'],
    author: {
      name: 'AWS SDK for JavaScript Team',
      url: 'https://aws.amazon.com/javascript/',
    },
    license: 'Apache-2.0',
    browser: { './dist-es/runtimeConfig': './dist-es/runtimeConfig.browser' },
    'react-native': {
      './dist-es/runtimeConfig': './dist-es/runtimeConfig.native',
    },
    homepage:
      'https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso',
    repository: {
      type: 'git',
      url: 'https://github.com/aws/aws-sdk-js-v3.git',
      directory: 'clients/client-sso',
    },
  }
})
var UH = l((cy) => {
  'use strict'
  Object.defineProperty(cy, '__esModule', { value: !0 })
  cy.fromEnv = void 0
  var E0e = Y(),
    S0e = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new E0e.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  cy.fromEnv = S0e
})
var BH = l((dy) => {
  'use strict'
  Object.defineProperty(dy, '__esModule', { value: !0 })
  dy.fromSharedConfigFiles = void 0
  var b0e = Y(),
    LH = ct(),
    v0e =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, LH.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          LH.loadSharedConfigFiles)(n),
          i = o[r] || {},
          c = s[r] || {},
          a = t === 'config' ? { ...i, ...c } : { ...c, ...i }
        try {
          let u = e(a)
          if (u === void 0) throw new Error()
          return u
        } catch (u) {
          throw new b0e.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  dy.fromSharedConfigFiles = v0e
})
var jH = l((uy) => {
  'use strict'
  Object.defineProperty(uy, '__esModule', { value: !0 })
  uy.fromStatic = void 0
  var C0e = Y(),
    w0e = (e) => typeof e == 'function',
    T0e = (e) => (w0e(e) ? async () => await e() : (0, C0e.fromStatic)(e))
  uy.fromStatic = T0e
})
var $H = l((ly) => {
  'use strict'
  Object.defineProperty(ly, '__esModule', { value: !0 })
  ly.loadConfig = void 0
  var GH = Y(),
    x0e = UH(),
    I0e = BH(),
    P0e = jH(),
    R0e = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, GH.memoize)(
        (0, GH.chain)(
          (0, x0e.fromEnv)(e),
          (0, I0e.fromSharedConfigFiles)(t, r),
          (0, P0e.fromStatic)(n),
        ),
      )
  ly.loadConfig = R0e
})
var zH = l((Yx) => {
  'use strict'
  Object.defineProperty(Yx, '__esModule', { value: !0 })
  var D0e = (x(), w(T))
  D0e.__exportStar($H(), Yx)
})
var WH = l((my, HH) => {
  'use strict'
  Object.defineProperty(my, '__esModule', { value: !0 })
  my.isCrtAvailable = void 0
  var A0e = () => {
    try {
      return typeof require == 'function' &&
        typeof HH < 'u' &&
        require('aws-crt')
        ? ['md/crt-avail']
        : null
    } catch {
      return null
    }
  }
  my.isCrtAvailable = A0e
})
var Uu = l((zn) => {
  'use strict'
  Object.defineProperty(zn, '__esModule', { value: !0 })
  zn.defaultUserAgent = zn.UA_APP_ID_INI_NAME = zn.UA_APP_ID_ENV_NAME = void 0
  var O0e = zH(),
    VH = require('os'),
    Kx = require('process'),
    N0e = WH()
  zn.UA_APP_ID_ENV_NAME = 'AWS_SDK_UA_APP_ID'
  zn.UA_APP_ID_INI_NAME = 'sdk-ua-app-id'
  var q0e = ({ serviceId: e, clientVersion: t }) => {
    let n = [
        ['aws-sdk-js', t],
        ['ua', '2.0'],
        [`os/${(0, VH.platform)()}`, (0, VH.release)()],
        ['lang/js'],
        ['md/nodejs', `${Kx.versions.node}`],
      ],
      r = (0, N0e.isCrtAvailable)()
    r && n.push(r),
      e && n.push([`api/${e}`, t]),
      Kx.env.AWS_EXECUTION_ENV &&
        n.push([`exec-env/${Kx.env.AWS_EXECUTION_ENV}`])
    let s = (0, O0e.loadConfig)({
        environmentVariableSelector: (i) => i[zn.UA_APP_ID_ENV_NAME],
        configFileSelector: (i) => i[zn.UA_APP_ID_INI_NAME],
        default: void 0,
      })(),
      o
    return async () => {
      if (!o) {
        let i = await s
        o = i ? [...n, [`app/${i}`]] : [...n]
      }
      return o
    }
  }
  zn.defaultUserAgent = q0e
})
var Lu = l((py) => {
  'use strict'
  Object.defineProperty(py, '__esModule', { value: !0 })
  py.Hash = void 0
  var Jx = _o(),
    k0e = Pn(),
    M0e = require('buffer'),
    YH = require('crypto'),
    Xx = class {
      constructor(t, n) {
        ;(this.algorithmIdentifier = t), (this.secret = n), this.reset()
      }
      update(t, n) {
        this.hash.update((0, k0e.toUint8Array)(KH(t, n)))
      }
      digest() {
        return Promise.resolve(this.hash.digest())
      }
      reset() {
        this.hash = this.secret
          ? (0, YH.createHmac)(this.algorithmIdentifier, KH(this.secret))
          : (0, YH.createHash)(this.algorithmIdentifier)
      }
    }
  py.Hash = Xx
  function KH(e, t) {
    return M0e.Buffer.isBuffer(e)
      ? e
      : typeof e == 'string'
      ? (0, Jx.fromString)(e, t)
      : ArrayBuffer.isView(e)
      ? (0, Jx.fromArrayBuffer)(e.buffer, e.byteOffset, e.byteLength)
      : (0, Jx.fromArrayBuffer)(e)
  }
})
var JH = l((fy) => {
  'use strict'
  Object.defineProperty(fy, '__esModule', { value: !0 })
  fy.fromEnv = void 0
  var F0e = Y(),
    U0e = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new F0e.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  fy.fromEnv = U0e
})
var QH = l((_y) => {
  'use strict'
  Object.defineProperty(_y, '__esModule', { value: !0 })
  _y.fromSharedConfigFiles = void 0
  var L0e = Y(),
    XH = ct(),
    B0e =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, XH.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          XH.loadSharedConfigFiles)(n),
          i = o[r] || {},
          c = s[r] || {},
          a = t === 'config' ? { ...i, ...c } : { ...c, ...i }
        try {
          let u = e(a)
          if (u === void 0) throw new Error()
          return u
        } catch (u) {
          throw new L0e.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  _y.fromSharedConfigFiles = B0e
})
var ZH = l((hy) => {
  'use strict'
  Object.defineProperty(hy, '__esModule', { value: !0 })
  hy.fromStatic = void 0
  var j0e = Y(),
    G0e = (e) => typeof e == 'function',
    $0e = (e) => (G0e(e) ? async () => await e() : (0, j0e.fromStatic)(e))
  hy.fromStatic = $0e
})
var t3 = l((yy) => {
  'use strict'
  Object.defineProperty(yy, '__esModule', { value: !0 })
  yy.loadConfig = void 0
  var e3 = Y(),
    z0e = JH(),
    H0e = QH(),
    W0e = ZH(),
    V0e = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, e3.memoize)(
        (0, e3.chain)(
          (0, z0e.fromEnv)(e),
          (0, H0e.fromSharedConfigFiles)(t, r),
          (0, W0e.fromStatic)(n),
        ),
      )
  yy.loadConfig = V0e
})
var Zx = l((Qx) => {
  'use strict'
  Object.defineProperty(Qx, '__esModule', { value: !0 })
  var Y0e = (x(), w(T))
  Y0e.__exportStar(t3(), Qx)
})
var r3 = l((gy) => {
  'use strict'
  Object.defineProperty(gy, '__esModule', { value: !0 })
  gy.calculateBodyLength = void 0
  var n3 = require('fs'),
    K0e = (e) => {
      if (!e) return 0
      if (typeof e == 'string') return Buffer.from(e).length
      if (typeof e.byteLength == 'number') return e.byteLength
      if (typeof e.size == 'number') return e.size
      if (typeof e.path == 'string' || Buffer.isBuffer(e.path))
        return (0, n3.lstatSync)(e.path).size
      if (typeof e.fd == 'number') return (0, n3.fstatSync)(e.fd).size
      throw new Error(`Body Length computation failed for ${e}`)
    }
  gy.calculateBodyLength = K0e
})
var tI = l((eI) => {
  'use strict'
  Object.defineProperty(eI, '__esModule', { value: !0 })
  var J0e = (x(), w(T))
  J0e.__exportStar(r3(), eI)
})
var _3 = l((Ey) => {
  'use strict'
  Object.defineProperty(Ey, '__esModule', { value: !0 })
  Ey.ruleSet = void 0
  var l3 = 'required',
    Tr = 'fn',
    xr = 'argv',
    ea = 'ref',
    nI = 'PartitionResult',
    Hn = 'tree',
    Bu = 'error',
    ju = 'endpoint',
    s3 = { [l3]: !1, type: 'String' },
    o3 = { [l3]: !0, default: !1, type: 'Boolean' },
    m3 = { [ea]: 'Endpoint' },
    p3 = { [Tr]: 'booleanEquals', [xr]: [{ [ea]: 'UseFIPS' }, !0] },
    f3 = { [Tr]: 'booleanEquals', [xr]: [{ [ea]: 'UseDualStack' }, !0] },
    Wn = {},
    i3 = {
      [Tr]: 'booleanEquals',
      [xr]: [!0, { [Tr]: 'getAttr', [xr]: [{ [ea]: nI }, 'supportsFIPS'] }],
    },
    a3 = {
      [Tr]: 'booleanEquals',
      [xr]: [
        !0,
        { [Tr]: 'getAttr', [xr]: [{ [ea]: nI }, 'supportsDualStack'] },
      ],
    },
    c3 = [m3],
    d3 = [p3],
    u3 = [f3],
    X0e = {
      version: '1.0',
      parameters: { Region: s3, UseDualStack: o3, UseFIPS: o3, Endpoint: s3 },
      rules: [
        {
          conditions: [
            { [Tr]: 'aws.partition', [xr]: [{ [ea]: 'Region' }], assign: nI },
          ],
          type: Hn,
          rules: [
            {
              conditions: [
                { [Tr]: 'isSet', [xr]: c3 },
                { [Tr]: 'parseURL', [xr]: c3, assign: 'url' },
              ],
              type: Hn,
              rules: [
                {
                  conditions: d3,
                  error:
                    'Invalid Configuration: FIPS and custom endpoint are not supported',
                  type: Bu,
                },
                {
                  type: Hn,
                  rules: [
                    {
                      conditions: u3,
                      error:
                        'Invalid Configuration: Dualstack and custom endpoint are not supported',
                      type: Bu,
                    },
                    {
                      endpoint: { url: m3, properties: Wn, headers: Wn },
                      type: ju,
                    },
                  ],
                },
              ],
            },
            {
              conditions: [p3, f3],
              type: Hn,
              rules: [
                {
                  conditions: [i3, a3],
                  type: Hn,
                  rules: [
                    {
                      endpoint: {
                        url: 'https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                        properties: Wn,
                        headers: Wn,
                      },
                      type: ju,
                    },
                  ],
                },
                {
                  error:
                    'FIPS and DualStack are enabled, but this partition does not support one or both',
                  type: Bu,
                },
              ],
            },
            {
              conditions: d3,
              type: Hn,
              rules: [
                {
                  conditions: [i3],
                  type: Hn,
                  rules: [
                    {
                      type: Hn,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}',
                            properties: Wn,
                            headers: Wn,
                          },
                          type: ju,
                        },
                      ],
                    },
                  ],
                },
                {
                  error:
                    'FIPS is enabled but this partition does not support FIPS',
                  type: Bu,
                },
              ],
            },
            {
              conditions: u3,
              type: Hn,
              rules: [
                {
                  conditions: [a3],
                  type: Hn,
                  rules: [
                    {
                      endpoint: {
                        url: 'https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}',
                        properties: Wn,
                        headers: Wn,
                      },
                      type: ju,
                    },
                  ],
                },
                {
                  error:
                    'DualStack is enabled but this partition does not support DualStack',
                  type: Bu,
                },
              ],
            },
            {
              endpoint: {
                url: 'https://portal.sso.{Region}.{PartitionResult#dnsSuffix}',
                properties: Wn,
                headers: Wn,
              },
              type: ju,
            },
          ],
        },
      ],
    }
  Ey.ruleSet = X0e
})
var h3 = l((Sy) => {
  'use strict'
  Object.defineProperty(Sy, '__esModule', { value: !0 })
  Sy.defaultEndpointResolver = void 0
  var Q0e = Ai(),
    Z0e = _3(),
    ewe = (e, t = {}) =>
      (0, Q0e.resolveEndpoint)(Z0e.ruleSet, {
        endpointParams: e,
        logger: t.logger,
      })
  Sy.defaultEndpointResolver = ewe
})
var E3 = l((by) => {
  'use strict'
  Object.defineProperty(by, '__esModule', { value: !0 })
  by.getRuntimeConfig = void 0
  var twe = v(),
    nwe = vo(),
    y3 = Mi(),
    g3 = Pn(),
    rwe = h3(),
    swe = (e) => ({
      apiVersion: '2019-06-10',
      base64Decoder: e?.base64Decoder ?? y3.fromBase64,
      base64Encoder: e?.base64Encoder ?? y3.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? rwe.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      logger: e?.logger ?? new twe.NoOpLogger(),
      serviceId: e?.serviceId ?? 'SSO',
      urlParser: e?.urlParser ?? nwe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? g3.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? g3.toUtf8,
    })
  by.getRuntimeConfig = swe
})
var S3 = l((vy) => {
  'use strict'
  Object.defineProperty(vy, '__esModule', { value: !0 })
  vy.fromEnv = void 0
  var owe = Y(),
    iwe = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new owe.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  vy.fromEnv = iwe
})
var v3 = l((Cy) => {
  'use strict'
  Object.defineProperty(Cy, '__esModule', { value: !0 })
  Cy.fromSharedConfigFiles = void 0
  var awe = Y(),
    b3 = ct(),
    cwe =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, b3.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          b3.loadSharedConfigFiles)(n),
          i = o[r] || {},
          c = s[r] || {},
          a = t === 'config' ? { ...i, ...c } : { ...c, ...i }
        try {
          let u = e(a)
          if (u === void 0) throw new Error()
          return u
        } catch (u) {
          throw new awe.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  Cy.fromSharedConfigFiles = cwe
})
var C3 = l((wy) => {
  'use strict'
  Object.defineProperty(wy, '__esModule', { value: !0 })
  wy.fromStatic = void 0
  var dwe = Y(),
    uwe = (e) => typeof e == 'function',
    lwe = (e) => (uwe(e) ? async () => await e() : (0, dwe.fromStatic)(e))
  wy.fromStatic = lwe
})
var T3 = l((Ty) => {
  'use strict'
  Object.defineProperty(Ty, '__esModule', { value: !0 })
  Ty.loadConfig = void 0
  var w3 = Y(),
    mwe = S3(),
    pwe = v3(),
    fwe = C3(),
    _we = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, w3.memoize)(
        (0, w3.chain)(
          (0, mwe.fromEnv)(e),
          (0, pwe.fromSharedConfigFiles)(t, r),
          (0, fwe.fromStatic)(n),
        ),
      )
  Ty.loadConfig = _we
})
var x3 = l((rI) => {
  'use strict'
  Object.defineProperty(rI, '__esModule', { value: !0 })
  var hwe = (x(), w(T))
  hwe.__exportStar(T3(), rI)
})
var I3 = l((Et) => {
  'use strict'
  Object.defineProperty(Et, '__esModule', { value: !0 })
  Et.IMDS_REGION_PATH =
    Et.DEFAULTS_MODE_OPTIONS =
    Et.ENV_IMDS_DISABLED =
    Et.AWS_DEFAULT_REGION_ENV =
    Et.AWS_REGION_ENV =
    Et.AWS_EXECUTION_ENV =
      void 0
  Et.AWS_EXECUTION_ENV = 'AWS_EXECUTION_ENV'
  Et.AWS_REGION_ENV = 'AWS_REGION'
  Et.AWS_DEFAULT_REGION_ENV = 'AWS_DEFAULT_REGION'
  Et.ENV_IMDS_DISABLED = 'AWS_EC2_METADATA_DISABLED'
  Et.DEFAULTS_MODE_OPTIONS = [
    'in-region',
    'cross-region',
    'mobile',
    'standard',
    'legacy',
  ]
  Et.IMDS_REGION_PATH = '/latest/meta-data/placement/region'
})
var P3 = l((xy) => {
  'use strict'
  Object.defineProperty(xy, '__esModule', { value: !0 })
  xy.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0
  var ywe = 'AWS_DEFAULTS_MODE',
    gwe = 'defaults_mode'
  xy.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (e) => e[ywe],
    configFileSelector: (e) => e[gwe],
    default: 'legacy',
  }
})
var A3 = l((Iy) => {
  'use strict'
  Object.defineProperty(Iy, '__esModule', { value: !0 })
  Iy.resolveDefaultsModeConfig = void 0
  var Ewe = An(),
    R3 = ty(),
    D3 = x3(),
    Swe = Y(),
    vs = I3(),
    bwe = P3(),
    vwe = ({
      region: e = (0, D3.loadConfig)(Ewe.NODE_REGION_CONFIG_OPTIONS),
      defaultsMode: t = (0, D3.loadConfig)(
        bwe.NODE_DEFAULTS_MODE_CONFIG_OPTIONS,
      ),
    } = {}) =>
      (0, Swe.memoize)(async () => {
        let n = typeof t == 'function' ? await t() : t
        switch (n?.toLowerCase()) {
          case 'auto':
            return Cwe(e)
          case 'in-region':
          case 'cross-region':
          case 'mobile':
          case 'standard':
          case 'legacy':
            return Promise.resolve(n?.toLocaleLowerCase())
          case void 0:
            return Promise.resolve('legacy')
          default:
            throw new Error(
              `Invalid parameter for "defaultsMode", expect ${vs.DEFAULTS_MODE_OPTIONS.join(
                ', ',
              )}, got ${n}`,
            )
        }
      })
  Iy.resolveDefaultsModeConfig = vwe
  var Cwe = async (e) => {
      if (e) {
        let t = typeof e == 'function' ? await e() : e,
          n = await wwe()
        return n ? (t === n ? 'in-region' : 'cross-region') : 'standard'
      }
      return 'standard'
    },
    wwe = async () => {
      var e
      if (
        process.env[vs.AWS_EXECUTION_ENV] &&
        (process.env[vs.AWS_REGION_ENV] ||
          process.env[vs.AWS_DEFAULT_REGION_ENV])
      )
        return (e = process.env[vs.AWS_REGION_ENV]) !== null && e !== void 0
          ? e
          : process.env[vs.AWS_DEFAULT_REGION_ENV]
      if (!process.env[vs.ENV_IMDS_DISABLED])
        try {
          let t = await (0, R3.getInstanceMetadataEndpoint)()
          return (
            await (0, R3.httpRequest)({ ...t, path: vs.IMDS_REGION_PATH })
          ).toString()
        } catch {}
    }
})
var Gu = l((sI) => {
  'use strict'
  Object.defineProperty(sI, '__esModule', { value: !0 })
  var Twe = (x(), w(T))
  Twe.__exportStar(A3(), sI)
})
var q3 = l((Ry) => {
  'use strict'
  Object.defineProperty(Ry, '__esModule', { value: !0 })
  Ry.getRuntimeConfig = void 0
  var xwe = (x(), w(T)),
    Iwe = xwe.__importDefault(FH()),
    Pwe = Uu(),
    Py = An(),
    Rwe = Lu(),
    O3 = Er(),
    $u = Zx(),
    N3 = Li(),
    Dwe = tI(),
    Awe = Kt(),
    Owe = E3(),
    Nwe = v(),
    qwe = Gu(),
    kwe = v(),
    Mwe = (e) => {
      ;(0, kwe.emitWarningIfUnsupportedVersion)(process.version)
      let t = (0, qwe.resolveDefaultsModeConfig)(e),
        n = () => t().then(Nwe.loadConfigsForDefaultMode),
        r = (0, Owe.getRuntimeConfig)(e)
      return {
        ...r,
        ...e,
        runtime: 'node',
        defaultsMode: t,
        bodyLengthChecker: e?.bodyLengthChecker ?? Dwe.calculateBodyLength,
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, Pwe.defaultUserAgent)({
            serviceId: r.serviceId,
            clientVersion: Iwe.default.version,
          }),
        maxAttempts:
          e?.maxAttempts ??
          (0, $u.loadConfig)(O3.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          e?.region ??
          (0, $u.loadConfig)(
            Py.NODE_REGION_CONFIG_OPTIONS,
            Py.NODE_REGION_CONFIG_FILE_OPTIONS,
          ),
        requestHandler: e?.requestHandler ?? new N3.NodeHttpHandler(n),
        retryMode:
          e?.retryMode ??
          (0, $u.loadConfig)({
            ...O3.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () =>
              (await n()).retryMode || Awe.DEFAULT_RETRY_MODE,
          }),
        sha256: e?.sha256 ?? Rwe.Hash.bind(null, 'sha256'),
        streamCollector: e?.streamCollector ?? N3.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, $u.loadConfig)(Py.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, $u.loadConfig)(Py.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    }
  Ry.getRuntimeConfig = Mwe
})
var M3 = l((Dy) => {
  'use strict'
  Object.defineProperty(Dy, '__esModule', { value: !0 })
  Dy.resolveRuntimeExtensions = void 0
  var k3 = Vr(),
    Fwe = (e) => e,
    Uwe = (e, t) => {
      let n = { ...Fwe((0, k3.getDefaultClientConfiguration)(e)) }
      return (
        t.forEach((r) => r.configureClient(n)),
        { ...e, ...(0, k3.resolveDefaultRuntimeConfig)(n) }
      )
    }
  Dy.resolveRuntimeExtensions = Uwe
})
var zu = l((ta) => {
  'use strict'
  Object.defineProperty(ta, '__esModule', { value: !0 })
  ta.SSOClient = ta.__Client = void 0
  var F3 = Yd(),
    Lwe = Kd(),
    Bwe = Jd(),
    U3 = du(),
    jwe = An(),
    Gwe = mu(),
    $we = D(),
    L3 = Er(),
    B3 = v()
  Object.defineProperty(ta, '__Client', {
    enumerable: !0,
    get: function () {
      return B3.Client
    },
  })
  var zwe = MH(),
    Hwe = q3(),
    Wwe = M3(),
    oI = class extends B3.Client {
      constructor(...[t]) {
        let n = (0, Hwe.getRuntimeConfig)(t || {}),
          r = (0, zwe.resolveClientEndpointParameters)(n),
          s = (0, jwe.resolveRegionConfig)(r),
          o = (0, $we.resolveEndpointConfig)(s),
          i = (0, L3.resolveRetryConfig)(o),
          c = (0, F3.resolveHostHeaderConfig)(i),
          a = (0, U3.resolveUserAgentConfig)(c),
          u = (0, Wwe.resolveRuntimeExtensions)(a, t?.extensions || [])
        super(u),
          (this.config = u),
          this.middlewareStack.use((0, L3.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, Gwe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, F3.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, Lwe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, Bwe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, U3.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  ta.SSOClient = oI
})
var Ay = l((na) => {
  'use strict'
  Object.defineProperty(na, '__esModule', { value: !0 })
  na.SSOServiceException = na.__ServiceException = void 0
  var j3 = v()
  Object.defineProperty(na, '__ServiceException', {
    enumerable: !0,
    get: function () {
      return j3.ServiceException
    },
  })
  var iI = class e extends j3.ServiceException {
    constructor(t) {
      super(t), Object.setPrototypeOf(this, e.prototype)
    }
  }
  na.SSOServiceException = iI
})
var No = l((Te) => {
  'use strict'
  Object.defineProperty(Te, '__esModule', { value: !0 })
  Te.LogoutRequestFilterSensitiveLog =
    Te.ListAccountsRequestFilterSensitiveLog =
    Te.ListAccountRolesRequestFilterSensitiveLog =
    Te.GetRoleCredentialsResponseFilterSensitiveLog =
    Te.RoleCredentialsFilterSensitiveLog =
    Te.GetRoleCredentialsRequestFilterSensitiveLog =
    Te.UnauthorizedException =
    Te.TooManyRequestsException =
    Te.ResourceNotFoundException =
    Te.InvalidRequestException =
      void 0
  var ra = v(),
    Oy = Ay(),
    aI = class e extends Oy.SSOServiceException {
      constructor(t) {
        super({ name: 'InvalidRequestException', $fault: 'client', ...t }),
          (this.name = 'InvalidRequestException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, e.prototype)
      }
    }
  Te.InvalidRequestException = aI
  var cI = class e extends Oy.SSOServiceException {
    constructor(t) {
      super({ name: 'ResourceNotFoundException', $fault: 'client', ...t }),
        (this.name = 'ResourceNotFoundException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  Te.ResourceNotFoundException = cI
  var dI = class e extends Oy.SSOServiceException {
    constructor(t) {
      super({ name: 'TooManyRequestsException', $fault: 'client', ...t }),
        (this.name = 'TooManyRequestsException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  Te.TooManyRequestsException = dI
  var uI = class e extends Oy.SSOServiceException {
    constructor(t) {
      super({ name: 'UnauthorizedException', $fault: 'client', ...t }),
        (this.name = 'UnauthorizedException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, e.prototype)
    }
  }
  Te.UnauthorizedException = uI
  var Vwe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: ra.SENSITIVE_STRING }),
  })
  Te.GetRoleCredentialsRequestFilterSensitiveLog = Vwe
  var Ywe = (e) => ({
    ...e,
    ...(e.secretAccessKey && { secretAccessKey: ra.SENSITIVE_STRING }),
    ...(e.sessionToken && { sessionToken: ra.SENSITIVE_STRING }),
  })
  Te.RoleCredentialsFilterSensitiveLog = Ywe
  var Kwe = (e) => ({
    ...e,
    ...(e.roleCredentials && {
      roleCredentials: (0, Te.RoleCredentialsFilterSensitiveLog)(
        e.roleCredentials,
      ),
    }),
  })
  Te.GetRoleCredentialsResponseFilterSensitiveLog = Kwe
  var Jwe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: ra.SENSITIVE_STRING }),
  })
  Te.ListAccountRolesRequestFilterSensitiveLog = Jwe
  var Xwe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: ra.SENSITIVE_STRING }),
  })
  Te.ListAccountsRequestFilterSensitiveLog = Xwe
  var Qwe = (e) => ({
    ...e,
    ...(e.accessToken && { accessToken: ra.SENSITIVE_STRING }),
  })
  Te.LogoutRequestFilterSensitiveLog = Qwe
})
var Hu = l((Ge) => {
  'use strict'
  Object.defineProperty(Ge, '__esModule', { value: !0 })
  Ge.de_LogoutCommand =
    Ge.de_ListAccountsCommand =
    Ge.de_ListAccountRolesCommand =
    Ge.de_GetRoleCredentialsCommand =
    Ge.se_LogoutCommand =
    Ge.se_ListAccountsCommand =
    Ge.se_ListAccountRolesCommand =
    Ge.se_GetRoleCredentialsCommand =
      void 0
  var Ny = tt(),
    K = v(),
    qy = No(),
    Zwe = Ay(),
    eTe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = (0, K.map)({}, Ly, { 'x-amz-sso_bearer_token': e.accessToken }),
        c = `${
          o?.endsWith('/') ? o.slice(0, -1) : o || ''
        }/federation/credentials`,
        a = (0, K.map)({
          role_name: [, (0, K.expectNonNull)(e.roleName, 'roleName')],
          account_id: [, (0, K.expectNonNull)(e.accountId, 'accountId')],
        }),
        u
      return new Ny.HttpRequest({
        protocol: r,
        hostname: n,
        port: s,
        method: 'GET',
        headers: i,
        path: c,
        query: a,
        body: u,
      })
    }
  Ge.se_GetRoleCredentialsCommand = eTe
  var tTe = async (e, t) => {
    let {
        hostname: n,
        protocol: r = 'https',
        port: s,
        path: o,
      } = await t.endpoint(),
      i = (0, K.map)({}, Ly, { 'x-amz-sso_bearer_token': e.accessToken }),
      c = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/assignment/roles`,
      a = (0, K.map)({
        next_token: [, e.nextToken],
        max_result: [
          () => e.maxResults !== void 0,
          () => e.maxResults.toString(),
        ],
        account_id: [, (0, K.expectNonNull)(e.accountId, 'accountId')],
      }),
      u
    return new Ny.HttpRequest({
      protocol: r,
      hostname: n,
      port: s,
      method: 'GET',
      headers: i,
      path: c,
      query: a,
      body: u,
    })
  }
  Ge.se_ListAccountRolesCommand = tTe
  var nTe = async (e, t) => {
    let {
        hostname: n,
        protocol: r = 'https',
        port: s,
        path: o,
      } = await t.endpoint(),
      i = (0, K.map)({}, Ly, { 'x-amz-sso_bearer_token': e.accessToken }),
      c = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/assignment/accounts`,
      a = (0, K.map)({
        next_token: [, e.nextToken],
        max_result: [
          () => e.maxResults !== void 0,
          () => e.maxResults.toString(),
        ],
      }),
      u
    return new Ny.HttpRequest({
      protocol: r,
      hostname: n,
      port: s,
      method: 'GET',
      headers: i,
      path: c,
      query: a,
      body: u,
    })
  }
  Ge.se_ListAccountsCommand = nTe
  var rTe = async (e, t) => {
    let {
        hostname: n,
        protocol: r = 'https',
        port: s,
        path: o,
      } = await t.endpoint(),
      i = (0, K.map)({}, Ly, { 'x-amz-sso_bearer_token': e.accessToken }),
      c = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/logout`,
      a
    return new Ny.HttpRequest({
      protocol: r,
      hostname: n,
      port: s,
      method: 'POST',
      headers: i,
      path: c,
      body: a,
    })
  }
  Ge.se_LogoutCommand = rTe
  var sTe = async (e, t) => {
    if (e.statusCode !== 200 && e.statusCode >= 300) return oTe(e, t)
    let n = (0, K.map)({ $metadata: Cs(e) }),
      r = (0, K.expectNonNull)(
        (0, K.expectObject)(await By(e.body, t)),
        'body',
      ),
      s = (0, K.take)(r, { roleCredentials: K._json })
    return Object.assign(n, s), n
  }
  Ge.de_GetRoleCredentialsCommand = sTe
  var oTe = async (e, t) => {
      let n = { ...e, body: await jy(e.body, t) },
        r = Gy(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await My(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.sso#ResourceNotFoundException':
          throw await lI(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Fy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Uy(n, t)
        default:
          let s = n.body
          return ky({ output: e, parsedBody: s, errorCode: r })
      }
    },
    iTe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return aTe(e, t)
      let n = (0, K.map)({ $metadata: Cs(e) }),
        r = (0, K.expectNonNull)(
          (0, K.expectObject)(await By(e.body, t)),
          'body',
        ),
        s = (0, K.take)(r, { nextToken: K.expectString, roleList: K._json })
      return Object.assign(n, s), n
    }
  Ge.de_ListAccountRolesCommand = iTe
  var aTe = async (e, t) => {
      let n = { ...e, body: await jy(e.body, t) },
        r = Gy(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await My(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.sso#ResourceNotFoundException':
          throw await lI(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Fy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Uy(n, t)
        default:
          let s = n.body
          return ky({ output: e, parsedBody: s, errorCode: r })
      }
    },
    cTe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return dTe(e, t)
      let n = (0, K.map)({ $metadata: Cs(e) }),
        r = (0, K.expectNonNull)(
          (0, K.expectObject)(await By(e.body, t)),
          'body',
        ),
        s = (0, K.take)(r, { accountList: K._json, nextToken: K.expectString })
      return Object.assign(n, s), n
    }
  Ge.de_ListAccountsCommand = cTe
  var dTe = async (e, t) => {
      let n = { ...e, body: await jy(e.body, t) },
        r = Gy(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await My(n, t)
        case 'ResourceNotFoundException':
        case 'com.amazonaws.sso#ResourceNotFoundException':
          throw await lI(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Fy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Uy(n, t)
        default:
          let s = n.body
          return ky({ output: e, parsedBody: s, errorCode: r })
      }
    },
    uTe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return lTe(e, t)
      let n = (0, K.map)({ $metadata: Cs(e) })
      return await (0, K.collectBody)(e.body, t), n
    }
  Ge.de_LogoutCommand = uTe
  var lTe = async (e, t) => {
      let n = { ...e, body: await jy(e.body, t) },
        r = Gy(e, n.body)
      switch (r) {
        case 'InvalidRequestException':
        case 'com.amazonaws.sso#InvalidRequestException':
          throw await My(n, t)
        case 'TooManyRequestsException':
        case 'com.amazonaws.sso#TooManyRequestsException':
          throw await Fy(n, t)
        case 'UnauthorizedException':
        case 'com.amazonaws.sso#UnauthorizedException':
          throw await Uy(n, t)
        default:
          let s = n.body
          return ky({ output: e, parsedBody: s, errorCode: r })
      }
    },
    ky = (0, K.withBaseException)(Zwe.SSOServiceException),
    My = async (e, t) => {
      let n = (0, K.map)({}),
        r = e.body,
        s = (0, K.take)(r, { message: K.expectString })
      Object.assign(n, s)
      let o = new qy.InvalidRequestException({ $metadata: Cs(e), ...n })
      return (0, K.decorateServiceException)(o, e.body)
    },
    lI = async (e, t) => {
      let n = (0, K.map)({}),
        r = e.body,
        s = (0, K.take)(r, { message: K.expectString })
      Object.assign(n, s)
      let o = new qy.ResourceNotFoundException({ $metadata: Cs(e), ...n })
      return (0, K.decorateServiceException)(o, e.body)
    },
    Fy = async (e, t) => {
      let n = (0, K.map)({}),
        r = e.body,
        s = (0, K.take)(r, { message: K.expectString })
      Object.assign(n, s)
      let o = new qy.TooManyRequestsException({ $metadata: Cs(e), ...n })
      return (0, K.decorateServiceException)(o, e.body)
    },
    Uy = async (e, t) => {
      let n = (0, K.map)({}),
        r = e.body,
        s = (0, K.take)(r, { message: K.expectString })
      Object.assign(n, s)
      let o = new qy.UnauthorizedException({ $metadata: Cs(e), ...n })
      return (0, K.decorateServiceException)(o, e.body)
    },
    Cs = (e) => ({
      httpStatusCode: e.statusCode,
      requestId:
        e.headers['x-amzn-requestid'] ??
        e.headers['x-amzn-request-id'] ??
        e.headers['x-amz-request-id'],
      extendedRequestId: e.headers['x-amz-id-2'],
      cfId: e.headers['x-amz-cf-id'],
    }),
    mTe = (e, t) => (0, K.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    Ly = (e) =>
      e != null &&
      e !== '' &&
      (!Object.getOwnPropertyNames(e).includes('length') || e.length != 0) &&
      (!Object.getOwnPropertyNames(e).includes('size') || e.size != 0),
    By = (e, t) => mTe(e, t).then((n) => (n.length ? JSON.parse(n) : {})),
    jy = async (e, t) => {
      let n = await By(e, t)
      return (n.message = n.message ?? n.Message), n
    },
    Gy = (e, t) => {
      let n = (o, i) =>
          Object.keys(o).find((c) => c.toLowerCase() === i.toLowerCase()),
        r = (o) => {
          let i = o
          return (
            typeof i == 'number' && (i = i.toString()),
            i.indexOf(',') >= 0 && (i = i.split(',')[0]),
            i.indexOf(':') >= 0 && (i = i.split(':')[0]),
            i.indexOf('#') >= 0 && (i = i.split('#')[1]),
            i
          )
        },
        s = n(e.headers, 'x-amzn-errortype')
      if (s !== void 0) return r(e.headers[s])
      if (t.code !== void 0) return r(t.code)
      if (t.__type !== void 0) return r(t.__type)
    }
})
var pI = l((sa) => {
  'use strict'
  Object.defineProperty(sa, '__esModule', { value: !0 })
  sa.GetRoleCredentialsCommand = sa.$Command = void 0
  var pTe = D(),
    fTe = O(),
    z3 = v()
  Object.defineProperty(sa, '$Command', {
    enumerable: !0,
    get: function () {
      return z3.Command
    },
  })
  var G3 = No(),
    $3 = Hu(),
    mI = class e extends z3.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, fTe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, pTe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'GetRoleCredentialsCommand',
            inputFilterSensitiveLog:
              G3.GetRoleCredentialsRequestFilterSensitiveLog,
            outputFilterSensitiveLog:
              G3.GetRoleCredentialsResponseFilterSensitiveLog,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, $3.se_GetRoleCredentialsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, $3.de_GetRoleCredentialsCommand)(t, n)
      }
    }
  sa.GetRoleCredentialsCommand = mI
})
var $y = l((oa) => {
  'use strict'
  Object.defineProperty(oa, '__esModule', { value: !0 })
  oa.ListAccountRolesCommand = oa.$Command = void 0
  var _Te = D(),
    hTe = O(),
    W3 = v()
  Object.defineProperty(oa, '$Command', {
    enumerable: !0,
    get: function () {
      return W3.Command
    },
  })
  var yTe = No(),
    H3 = Hu(),
    fI = class e extends W3.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, hTe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, _Te.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'ListAccountRolesCommand',
            inputFilterSensitiveLog:
              yTe.ListAccountRolesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, H3.se_ListAccountRolesCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, H3.de_ListAccountRolesCommand)(t, n)
      }
    }
  oa.ListAccountRolesCommand = fI
})
var zy = l((ia) => {
  'use strict'
  Object.defineProperty(ia, '__esModule', { value: !0 })
  ia.ListAccountsCommand = ia.$Command = void 0
  var gTe = D(),
    ETe = O(),
    Y3 = v()
  Object.defineProperty(ia, '$Command', {
    enumerable: !0,
    get: function () {
      return Y3.Command
    },
  })
  var STe = No(),
    V3 = Hu(),
    _I = class e extends Y3.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ETe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, gTe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'ListAccountsCommand',
            inputFilterSensitiveLog: STe.ListAccountsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, V3.se_ListAccountsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, V3.de_ListAccountsCommand)(t, n)
      }
    }
  ia.ListAccountsCommand = _I
})
var yI = l((aa) => {
  'use strict'
  Object.defineProperty(aa, '__esModule', { value: !0 })
  aa.LogoutCommand = aa.$Command = void 0
  var bTe = D(),
    vTe = O(),
    J3 = v()
  Object.defineProperty(aa, '$Command', {
    enumerable: !0,
    get: function () {
      return J3.Command
    },
  })
  var CTe = No(),
    K3 = Hu(),
    hI = class e extends J3.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, vTe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, bTe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOClient',
            commandName: 'LogoutCommand',
            inputFilterSensitiveLog: CTe.LogoutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, K3.se_LogoutCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, K3.de_LogoutCommand)(t, n)
      }
    }
  aa.LogoutCommand = hI
})
var X3 = l((Wy) => {
  'use strict'
  Object.defineProperty(Wy, '__esModule', { value: !0 })
  Wy.SSO = void 0
  var wTe = v(),
    TTe = pI(),
    xTe = $y(),
    ITe = zy(),
    PTe = yI(),
    RTe = zu(),
    DTe = {
      GetRoleCredentialsCommand: TTe.GetRoleCredentialsCommand,
      ListAccountRolesCommand: xTe.ListAccountRolesCommand,
      ListAccountsCommand: ITe.ListAccountsCommand,
      LogoutCommand: PTe.LogoutCommand,
    },
    Hy = class extends RTe.SSOClient {}
  Wy.SSO = Hy
  ;(0, wTe.createAggregatedClient)(DTe, Hy)
})
var Q3 = l((ca) => {
  'use strict'
  Object.defineProperty(ca, '__esModule', { value: !0 })
  var Vy = (x(), w(T))
  Vy.__exportStar(pI(), ca)
  Vy.__exportStar($y(), ca)
  Vy.__exportStar(zy(), ca)
  Vy.__exportStar(yI(), ca)
})
var e2 = l((Z3) => {
  'use strict'
  Object.defineProperty(Z3, '__esModule', { value: !0 })
})
var t2 = l((Yy) => {
  'use strict'
  Object.defineProperty(Yy, '__esModule', { value: !0 })
  Yy.paginateListAccountRoles = void 0
  var ATe = $y(),
    OTe = zu(),
    NTe = async (e, t, ...n) =>
      await e.send(new ATe.ListAccountRolesCommand(t), ...n)
  async function* qTe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.nextToken = r),
        (t.maxResults = e.pageSize),
        e.client instanceof OTe.SSOClient)
      )
        o = await NTe(e.client, t, ...n)
      else throw new Error('Invalid client, expected SSO | SSOClient')
      yield o
      let i = r
      ;(r = o.nextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  Yy.paginateListAccountRoles = qTe
})
var n2 = l((Ky) => {
  'use strict'
  Object.defineProperty(Ky, '__esModule', { value: !0 })
  Ky.paginateListAccounts = void 0
  var kTe = zy(),
    MTe = zu(),
    FTe = async (e, t, ...n) =>
      await e.send(new kTe.ListAccountsCommand(t), ...n)
  async function* UTe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.nextToken = r),
        (t.maxResults = e.pageSize),
        e.client instanceof MTe.SSOClient)
      )
        o = await FTe(e.client, t, ...n)
      else throw new Error('Invalid client, expected SSO | SSOClient')
      yield o
      let i = r
      ;(r = o.nextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  Ky.paginateListAccounts = UTe
})
var r2 = l((Wu) => {
  'use strict'
  Object.defineProperty(Wu, '__esModule', { value: !0 })
  var gI = (x(), w(T))
  gI.__exportStar(e2(), Wu)
  gI.__exportStar(t2(), Wu)
  gI.__exportStar(n2(), Wu)
})
var s2 = l((EI) => {
  'use strict'
  Object.defineProperty(EI, '__esModule', { value: !0 })
  var LTe = (x(), w(T))
  LTe.__exportStar(No(), EI)
})
var o2 = l((Ir) => {
  'use strict'
  Object.defineProperty(Ir, '__esModule', { value: !0 })
  Ir.SSOServiceException = void 0
  var Vu = (x(), w(T))
  Vu.__exportStar(zu(), Ir)
  Vu.__exportStar(X3(), Ir)
  Vu.__exportStar(Q3(), Ir)
  Vu.__exportStar(r2(), Ir)
  Vu.__exportStar(s2(), Ir)
  var BTe = Ay()
  Object.defineProperty(Ir, 'SSOServiceException', {
    enumerable: !0,
    get: function () {
      return BTe.SSOServiceException
    },
  })
})
var Qy = l((Ee) => {
  'use strict'
  Object.defineProperty(Ee, '__esModule', { value: !0 })
  Ee.UnsupportedGrantTypeException =
    Ee.UnauthorizedClientException =
    Ee.SlowDownException =
    Ee.SSOOIDCClient =
    Ee.InvalidScopeException =
    Ee.InvalidRequestException =
    Ee.InvalidClientException =
    Ee.InternalServerException =
    Ee.ExpiredTokenException =
    Ee.CreateTokenCommand =
    Ee.AuthorizationPendingException =
    Ee.AccessDeniedException =
      void 0
  var i2 = Yd(),
    jTe = Kd(),
    GTe = Jd(),
    a2 = du(),
    $Te = An(),
    zTe = mu(),
    HTe = D(),
    c2 = Er(),
    WTe = v(),
    VTe = (e) => {
      var t, n
      return {
        ...e,
        useDualstackEndpoint:
          (t = e.useDualstackEndpoint) !== null && t !== void 0 ? t : !1,
        useFipsEndpoint:
          (n = e.useFipsEndpoint) !== null && n !== void 0 ? n : !1,
        defaultSigningName: 'awsssooidc',
      }
    },
    YTe = { version: '3.387.0' },
    KTe = Uu(),
    Jy = An(),
    JTe = Lu(),
    d2 = Er(),
    Yu = Zx(),
    u2 = Li(),
    XTe = tI(),
    QTe = Kt(),
    ZTe = v(),
    exe = vo(),
    l2 = Mi(),
    m2 = Pn(),
    txe = Ai(),
    S2 = 'required',
    Pr = 'fn',
    Rr = 'argv',
    da = 'ref',
    SI = 'PartitionResult',
    Vn = 'tree',
    Ku = 'error',
    Ju = 'endpoint',
    p2 = { [S2]: !1, type: 'String' },
    f2 = { [S2]: !0, default: !1, type: 'Boolean' },
    b2 = { [da]: 'Endpoint' },
    v2 = { [Pr]: 'booleanEquals', [Rr]: [{ [da]: 'UseFIPS' }, !0] },
    C2 = { [Pr]: 'booleanEquals', [Rr]: [{ [da]: 'UseDualStack' }, !0] },
    Yn = {},
    _2 = {
      [Pr]: 'booleanEquals',
      [Rr]: [!0, { [Pr]: 'getAttr', [Rr]: [{ [da]: SI }, 'supportsFIPS'] }],
    },
    h2 = {
      [Pr]: 'booleanEquals',
      [Rr]: [
        !0,
        { [Pr]: 'getAttr', [Rr]: [{ [da]: SI }, 'supportsDualStack'] },
      ],
    },
    y2 = [b2],
    g2 = [v2],
    E2 = [C2],
    nxe = {
      version: '1.0',
      parameters: { Region: p2, UseDualStack: f2, UseFIPS: f2, Endpoint: p2 },
      rules: [
        {
          conditions: [
            { [Pr]: 'aws.partition', [Rr]: [{ [da]: 'Region' }], assign: SI },
          ],
          type: Vn,
          rules: [
            {
              conditions: [
                { [Pr]: 'isSet', [Rr]: y2 },
                { [Pr]: 'parseURL', [Rr]: y2, assign: 'url' },
              ],
              type: Vn,
              rules: [
                {
                  conditions: g2,
                  error:
                    'Invalid Configuration: FIPS and custom endpoint are not supported',
                  type: Ku,
                },
                {
                  type: Vn,
                  rules: [
                    {
                      conditions: E2,
                      error:
                        'Invalid Configuration: Dualstack and custom endpoint are not supported',
                      type: Ku,
                    },
                    {
                      endpoint: { url: b2, properties: Yn, headers: Yn },
                      type: Ju,
                    },
                  ],
                },
              ],
            },
            {
              conditions: [v2, C2],
              type: Vn,
              rules: [
                {
                  conditions: [_2, h2],
                  type: Vn,
                  rules: [
                    {
                      endpoint: {
                        url: 'https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                        properties: Yn,
                        headers: Yn,
                      },
                      type: Ju,
                    },
                  ],
                },
                {
                  error:
                    'FIPS and DualStack are enabled, but this partition does not support one or both',
                  type: Ku,
                },
              ],
            },
            {
              conditions: g2,
              type: Vn,
              rules: [
                {
                  conditions: [_2],
                  type: Vn,
                  rules: [
                    {
                      type: Vn,
                      rules: [
                        {
                          endpoint: {
                            url: 'https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}',
                            properties: Yn,
                            headers: Yn,
                          },
                          type: Ju,
                        },
                      ],
                    },
                  ],
                },
                {
                  error:
                    'FIPS is enabled but this partition does not support FIPS',
                  type: Ku,
                },
              ],
            },
            {
              conditions: E2,
              type: Vn,
              rules: [
                {
                  conditions: [h2],
                  type: Vn,
                  rules: [
                    {
                      endpoint: {
                        url: 'https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}',
                        properties: Yn,
                        headers: Yn,
                      },
                      type: Ju,
                    },
                  ],
                },
                {
                  error:
                    'DualStack is enabled but this partition does not support DualStack',
                  type: Ku,
                },
              ],
            },
            {
              endpoint: {
                url: 'https://oidc.{Region}.{PartitionResult#dnsSuffix}',
                properties: Yn,
                headers: Yn,
              },
              type: Ju,
            },
          ],
        },
      ],
    },
    rxe = nxe,
    sxe = (e, t = {}) =>
      (0, txe.resolveEndpoint)(rxe, { endpointParams: e, logger: t.logger }),
    oxe = (e) => {
      var t, n, r, s, o, i, c, a, u
      return {
        apiVersion: '2019-06-10',
        base64Decoder:
          (t = e?.base64Decoder) !== null && t !== void 0 ? t : l2.fromBase64,
        base64Encoder:
          (n = e?.base64Encoder) !== null && n !== void 0 ? n : l2.toBase64,
        disableHostPrefix:
          (r = e?.disableHostPrefix) !== null && r !== void 0 ? r : !1,
        endpointProvider:
          (s = e?.endpointProvider) !== null && s !== void 0 ? s : sxe,
        logger:
          (o = e?.logger) !== null && o !== void 0 ? o : new ZTe.NoOpLogger(),
        serviceId: (i = e?.serviceId) !== null && i !== void 0 ? i : 'SSO OIDC',
        urlParser:
          (c = e?.urlParser) !== null && c !== void 0 ? c : exe.parseUrl,
        utf8Decoder:
          (a = e?.utf8Decoder) !== null && a !== void 0 ? a : m2.fromUtf8,
        utf8Encoder:
          (u = e?.utf8Encoder) !== null && u !== void 0 ? u : m2.toUtf8,
      }
    },
    ixe = v(),
    axe = Gu(),
    cxe = v(),
    dxe = (e) => {
      var t, n, r, s, o, i, c, a, u, d
      ;(0, cxe.emitWarningIfUnsupportedVersion)(process.version)
      let p = (0, axe.resolveDefaultsModeConfig)(e),
        f = () => p().then(ixe.loadConfigsForDefaultMode),
        _ = oxe(e)
      return {
        ..._,
        ...e,
        runtime: 'node',
        defaultsMode: p,
        bodyLengthChecker:
          (t = e?.bodyLengthChecker) !== null && t !== void 0
            ? t
            : XTe.calculateBodyLength,
        defaultUserAgentProvider:
          (n = e?.defaultUserAgentProvider) !== null && n !== void 0
            ? n
            : (0, KTe.defaultUserAgent)({
                serviceId: _.serviceId,
                clientVersion: YTe.version,
              }),
        maxAttempts:
          (r = e?.maxAttempts) !== null && r !== void 0
            ? r
            : (0, Yu.loadConfig)(d2.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          (s = e?.region) !== null && s !== void 0
            ? s
            : (0, Yu.loadConfig)(
                Jy.NODE_REGION_CONFIG_OPTIONS,
                Jy.NODE_REGION_CONFIG_FILE_OPTIONS,
              ),
        requestHandler:
          (o = e?.requestHandler) !== null && o !== void 0
            ? o
            : new u2.NodeHttpHandler(f),
        retryMode:
          (i = e?.retryMode) !== null && i !== void 0
            ? i
            : (0, Yu.loadConfig)({
                ...d2.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () =>
                  (await f()).retryMode || QTe.DEFAULT_RETRY_MODE,
              }),
        sha256:
          (c = e?.sha256) !== null && c !== void 0
            ? c
            : JTe.Hash.bind(null, 'sha256'),
        streamCollector:
          (a = e?.streamCollector) !== null && a !== void 0
            ? a
            : u2.streamCollector,
        useDualstackEndpoint:
          (u = e?.useDualstackEndpoint) !== null && u !== void 0
            ? u
            : (0, Yu.loadConfig)(Jy.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          (d = e?.useFipsEndpoint) !== null && d !== void 0
            ? d
            : (0, Yu.loadConfig)(Jy.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    },
    w2 = class extends WTe.Client {
      constructor(...[e]) {
        let t = dxe(e || {}),
          n = VTe(t),
          r = (0, $Te.resolveRegionConfig)(n),
          s = (0, HTe.resolveEndpointConfig)(r),
          o = (0, c2.resolveRetryConfig)(s),
          i = (0, i2.resolveHostHeaderConfig)(o),
          c = (0, a2.resolveUserAgentConfig)(i)
        super(c),
          (this.config = c),
          this.middlewareStack.use((0, c2.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, zTe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, i2.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, jTe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, GTe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, a2.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  Ee.SSOOIDCClient = w2
  var uxe = v(),
    lxe = D(),
    mxe = O(),
    pxe = v(),
    bI = tt(),
    C = v(),
    fxe = v(),
    Nt = class T2 extends fxe.ServiceException {
      constructor(t) {
        super(t), Object.setPrototypeOf(this, T2.prototype)
      }
    },
    x2 = class I2 extends Nt {
      constructor(t) {
        super({ name: 'AccessDeniedException', $fault: 'client', ...t }),
          (this.name = 'AccessDeniedException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, I2.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    }
  Ee.AccessDeniedException = x2
  var P2 = class R2 extends Nt {
    constructor(t) {
      super({ name: 'AuthorizationPendingException', $fault: 'client', ...t }),
        (this.name = 'AuthorizationPendingException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, R2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.AuthorizationPendingException = P2
  var D2 = class A2 extends Nt {
    constructor(t) {
      super({ name: 'ExpiredTokenException', $fault: 'client', ...t }),
        (this.name = 'ExpiredTokenException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, A2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.ExpiredTokenException = D2
  var O2 = class N2 extends Nt {
    constructor(t) {
      super({ name: 'InternalServerException', $fault: 'server', ...t }),
        (this.name = 'InternalServerException'),
        (this.$fault = 'server'),
        Object.setPrototypeOf(this, N2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.InternalServerException = O2
  var q2 = class k2 extends Nt {
    constructor(t) {
      super({ name: 'InvalidClientException', $fault: 'client', ...t }),
        (this.name = 'InvalidClientException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, k2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.InvalidClientException = q2
  var _xe = class M2 extends Nt {
      constructor(t) {
        super({ name: 'InvalidGrantException', $fault: 'client', ...t }),
          (this.name = 'InvalidGrantException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, M2.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    },
    F2 = class U2 extends Nt {
      constructor(t) {
        super({ name: 'InvalidRequestException', $fault: 'client', ...t }),
          (this.name = 'InvalidRequestException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, U2.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    }
  Ee.InvalidRequestException = F2
  var L2 = class B2 extends Nt {
    constructor(t) {
      super({ name: 'InvalidScopeException', $fault: 'client', ...t }),
        (this.name = 'InvalidScopeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, B2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.InvalidScopeException = L2
  var j2 = class G2 extends Nt {
    constructor(t) {
      super({ name: 'SlowDownException', $fault: 'client', ...t }),
        (this.name = 'SlowDownException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, G2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.SlowDownException = j2
  var $2 = class z2 extends Nt {
    constructor(t) {
      super({ name: 'UnauthorizedClientException', $fault: 'client', ...t }),
        (this.name = 'UnauthorizedClientException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, z2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.UnauthorizedClientException = $2
  var H2 = class W2 extends Nt {
    constructor(t) {
      super({ name: 'UnsupportedGrantTypeException', $fault: 'client', ...t }),
        (this.name = 'UnsupportedGrantTypeException'),
        (this.$fault = 'client'),
        Object.setPrototypeOf(this, W2.prototype),
        (this.error = t.error),
        (this.error_description = t.error_description)
    }
  }
  Ee.UnsupportedGrantTypeException = H2
  var hxe = class V2 extends Nt {
      constructor(t) {
        super({
          name: 'InvalidClientMetadataException',
          $fault: 'client',
          ...t,
        }),
          (this.name = 'InvalidClientMetadataException'),
          (this.$fault = 'client'),
          Object.setPrototypeOf(this, V2.prototype),
          (this.error = t.error),
          (this.error_description = t.error_description)
      }
    },
    yxe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = { 'content-type': 'application/json' },
        c = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/token`,
        a
      return (
        (a = JSON.stringify(
          (0, C.take)(e, {
            clientId: [],
            clientSecret: [],
            code: [],
            deviceCode: [],
            grantType: [],
            redirectUri: [],
            refreshToken: [],
            scope: (u) => (0, C._json)(u),
          }),
        )),
        new bI.HttpRequest({
          protocol: r,
          hostname: n,
          port: s,
          method: 'POST',
          headers: i,
          path: c,
          body: a,
        })
      )
    },
    gxe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = { 'content-type': 'application/json' },
        c = `${o?.endsWith('/') ? o.slice(0, -1) : o || ''}/client/register`,
        a
      return (
        (a = JSON.stringify(
          (0, C.take)(e, {
            clientName: [],
            clientType: [],
            scopes: (u) => (0, C._json)(u),
          }),
        )),
        new bI.HttpRequest({
          protocol: r,
          hostname: n,
          port: s,
          method: 'POST',
          headers: i,
          path: c,
          body: a,
        })
      )
    },
    Exe = async (e, t) => {
      let {
          hostname: n,
          protocol: r = 'https',
          port: s,
          path: o,
        } = await t.endpoint(),
        i = { 'content-type': 'application/json' },
        c = `${
          o?.endsWith('/') ? o.slice(0, -1) : o || ''
        }/device_authorization`,
        a
      return (
        (a = JSON.stringify(
          (0, C.take)(e, { clientId: [], clientSecret: [], startUrl: [] }),
        )),
        new bI.HttpRequest({
          protocol: r,
          hostname: n,
          port: s,
          method: 'POST',
          headers: i,
          path: c,
          body: a,
        })
      )
    },
    Sxe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return bxe(e, t)
      let n = (0, C.map)({ $metadata: dt(e) }),
        r = (0, C.expectNonNull)(
          (0, C.expectObject)(await Xy(e.body, t)),
          'body',
        ),
        s = (0, C.take)(r, {
          accessToken: C.expectString,
          expiresIn: C.expectInt32,
          idToken: C.expectString,
          refreshToken: C.expectString,
          tokenType: C.expectString,
        })
      return Object.assign(n, s), n
    },
    bxe = async (e, t) => {
      let n = { ...e, body: await TI(e.body, t) },
        r = xI(e, n.body)
      switch (r) {
        case 'AccessDeniedException':
        case 'com.amazonaws.ssooidc#AccessDeniedException':
          throw await xxe(n, t)
        case 'AuthorizationPendingException':
        case 'com.amazonaws.ssooidc#AuthorizationPendingException':
          throw await Ixe(n, t)
        case 'ExpiredTokenException':
        case 'com.amazonaws.ssooidc#ExpiredTokenException':
          throw await Pxe(n, t)
        case 'InternalServerException':
        case 'com.amazonaws.ssooidc#InternalServerException':
          throw await CI(n, t)
        case 'InvalidClientException':
        case 'com.amazonaws.ssooidc#InvalidClientException':
          throw await Y2(n, t)
        case 'InvalidGrantException':
        case 'com.amazonaws.ssooidc#InvalidGrantException':
          throw await Dxe(n, t)
        case 'InvalidRequestException':
        case 'com.amazonaws.ssooidc#InvalidRequestException':
          throw await wI(n, t)
        case 'InvalidScopeException':
        case 'com.amazonaws.ssooidc#InvalidScopeException':
          throw await K2(n, t)
        case 'SlowDownException':
        case 'com.amazonaws.ssooidc#SlowDownException':
          throw await J2(n, t)
        case 'UnauthorizedClientException':
        case 'com.amazonaws.ssooidc#UnauthorizedClientException':
          throw await X2(n, t)
        case 'UnsupportedGrantTypeException':
        case 'com.amazonaws.ssooidc#UnsupportedGrantTypeException':
          throw await Axe(n, t)
        default:
          let s = n.body
          return vI({ output: e, parsedBody: s, errorCode: r })
      }
    },
    vxe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return Cxe(e, t)
      let n = (0, C.map)({ $metadata: dt(e) }),
        r = (0, C.expectNonNull)(
          (0, C.expectObject)(await Xy(e.body, t)),
          'body',
        ),
        s = (0, C.take)(r, {
          authorizationEndpoint: C.expectString,
          clientId: C.expectString,
          clientIdIssuedAt: C.expectLong,
          clientSecret: C.expectString,
          clientSecretExpiresAt: C.expectLong,
          tokenEndpoint: C.expectString,
        })
      return Object.assign(n, s), n
    },
    Cxe = async (e, t) => {
      let n = { ...e, body: await TI(e.body, t) },
        r = xI(e, n.body)
      switch (r) {
        case 'InternalServerException':
        case 'com.amazonaws.ssooidc#InternalServerException':
          throw await CI(n, t)
        case 'InvalidClientMetadataException':
        case 'com.amazonaws.ssooidc#InvalidClientMetadataException':
          throw await Rxe(n, t)
        case 'InvalidRequestException':
        case 'com.amazonaws.ssooidc#InvalidRequestException':
          throw await wI(n, t)
        case 'InvalidScopeException':
        case 'com.amazonaws.ssooidc#InvalidScopeException':
          throw await K2(n, t)
        default:
          let s = n.body
          return vI({ output: e, parsedBody: s, errorCode: r })
      }
    },
    wxe = async (e, t) => {
      if (e.statusCode !== 200 && e.statusCode >= 300) return Txe(e, t)
      let n = (0, C.map)({ $metadata: dt(e) }),
        r = (0, C.expectNonNull)(
          (0, C.expectObject)(await Xy(e.body, t)),
          'body',
        ),
        s = (0, C.take)(r, {
          deviceCode: C.expectString,
          expiresIn: C.expectInt32,
          interval: C.expectInt32,
          userCode: C.expectString,
          verificationUri: C.expectString,
          verificationUriComplete: C.expectString,
        })
      return Object.assign(n, s), n
    },
    Txe = async (e, t) => {
      let n = { ...e, body: await TI(e.body, t) },
        r = xI(e, n.body)
      switch (r) {
        case 'InternalServerException':
        case 'com.amazonaws.ssooidc#InternalServerException':
          throw await CI(n, t)
        case 'InvalidClientException':
        case 'com.amazonaws.ssooidc#InvalidClientException':
          throw await Y2(n, t)
        case 'InvalidRequestException':
        case 'com.amazonaws.ssooidc#InvalidRequestException':
          throw await wI(n, t)
        case 'SlowDownException':
        case 'com.amazonaws.ssooidc#SlowDownException':
          throw await J2(n, t)
        case 'UnauthorizedClientException':
        case 'com.amazonaws.ssooidc#UnauthorizedClientException':
          throw await X2(n, t)
        default:
          let s = n.body
          return vI({ output: e, parsedBody: s, errorCode: r })
      }
    },
    vI = (0, C.withBaseException)(Nt),
    xxe = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new x2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    Ixe = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new P2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    Pxe = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new D2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    CI = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new O2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    Y2 = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new q2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    Rxe = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new hxe({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    Dxe = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new _xe({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    wI = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new F2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    K2 = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new L2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    J2 = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new j2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    X2 = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new $2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    Axe = async (e, t) => {
      let n = (0, C.map)({}),
        r = e.body,
        s = (0, C.take)(r, {
          error: C.expectString,
          error_description: C.expectString,
        })
      Object.assign(n, s)
      let o = new H2({ $metadata: dt(e), ...n })
      return (0, C.decorateServiceException)(o, e.body)
    },
    dt = (e) => {
      var t, n
      return {
        httpStatusCode: e.statusCode,
        requestId:
          (n =
            (t = e.headers['x-amzn-requestid']) !== null && t !== void 0
              ? t
              : e.headers['x-amzn-request-id']) !== null && n !== void 0
            ? n
            : e.headers['x-amz-request-id'],
        extendedRequestId: e.headers['x-amz-id-2'],
        cfId: e.headers['x-amz-cf-id'],
      }
    },
    Oxe = (e, t) => (0, C.collectBody)(e, t).then((n) => t.utf8Encoder(n)),
    Xy = (e, t) => Oxe(e, t).then((n) => (n.length ? JSON.parse(n) : {})),
    TI = async (e, t) => {
      var n
      let r = await Xy(e, t)
      return (
        (r.message = (n = r.message) !== null && n !== void 0 ? n : r.Message),
        r
      )
    },
    xI = (e, t) => {
      let n = (o, i) =>
          Object.keys(o).find((c) => c.toLowerCase() === i.toLowerCase()),
        r = (o) => {
          let i = o
          return (
            typeof i == 'number' && (i = i.toString()),
            i.indexOf(',') >= 0 && (i = i.split(',')[0]),
            i.indexOf(':') >= 0 && (i = i.split(':')[0]),
            i.indexOf('#') >= 0 && (i = i.split('#')[1]),
            i
          )
        },
        s = n(e.headers, 'x-amzn-errortype')
      if (s !== void 0) return r(e.headers[s])
      if (t.code !== void 0) return r(t.code)
      if (t.__type !== void 0) return r(t.__type)
    },
    Q2 = class Z2 extends pxe.Command {
      constructor(t) {
        super(), (this.input = t)
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, mxe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, lxe.getEndpointPlugin)(
              n,
              Z2.getEndpointParameterInstructions(),
            ),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOOIDCClient',
            commandName: 'CreateTokenCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return yxe(t, n)
      }
      deserialize(t, n) {
        return Sxe(t, n)
      }
    }
  Ee.CreateTokenCommand = Q2
  var Nxe = D(),
    qxe = O(),
    kxe = v(),
    Mxe = class eW extends kxe.Command {
      constructor(t) {
        super(), (this.input = t)
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, qxe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Nxe.getEndpointPlugin)(
              n,
              eW.getEndpointParameterInstructions(),
            ),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOOIDCClient',
            commandName: 'RegisterClientCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return gxe(t, n)
      }
      deserialize(t, n) {
        return vxe(t, n)
      }
    },
    Fxe = D(),
    Uxe = O(),
    Lxe = v(),
    Bxe = class tW extends Lxe.Command {
      constructor(t) {
        super(), (this.input = t)
      }
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, Uxe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, Fxe.getEndpointPlugin)(
              n,
              tW.getEndpointParameterInstructions(),
            ),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'SSOOIDCClient',
            commandName: 'StartDeviceAuthorizationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return Exe(t, n)
      }
      deserialize(t, n) {
        return wxe(t, n)
      }
    },
    jxe = {
      CreateTokenCommand: Q2,
      RegisterClientCommand: Mxe,
      StartDeviceAuthorizationCommand: Bxe,
    },
    Gxe = class extends w2 {}
  ;(0, uxe.createAggregatedClient)(jxe, Gxe)
})
var Zy = l((ua) => {
  'use strict'
  Object.defineProperty(ua, '__esModule', { value: !0 })
  ua.REFRESH_MESSAGE = ua.EXPIRE_WINDOW_MS = void 0
  ua.EXPIRE_WINDOW_MS = 5 * 60 * 1e3
  ua.REFRESH_MESSAGE =
    "To refresh this SSO session run 'aws sso login' with the corresponding profile."
})
var nW = l((eg) => {
  'use strict'
  Object.defineProperty(eg, '__esModule', { value: !0 })
  eg.getSsoOidcClient = void 0
  var $xe = Qy(),
    II = {},
    zxe = (e) => {
      if (II[e]) return II[e]
      let t = new $xe.SSOOIDCClient({ region: e })
      return (II[e] = t), t
    }
  eg.getSsoOidcClient = zxe
})
var rW = l((tg) => {
  'use strict'
  Object.defineProperty(tg, '__esModule', { value: !0 })
  tg.getNewSsoOidcToken = void 0
  var Hxe = Qy(),
    Wxe = nW(),
    Vxe = (e, t) =>
      (0, Wxe.getSsoOidcClient)(t).send(
        new Hxe.CreateTokenCommand({
          clientId: e.clientId,
          clientSecret: e.clientSecret,
          refreshToken: e.refreshToken,
          grantType: 'refresh_token',
        }),
      )
  tg.getNewSsoOidcToken = Vxe
})
var sW = l((ng) => {
  'use strict'
  Object.defineProperty(ng, '__esModule', { value: !0 })
  ng.validateTokenExpiry = void 0
  var Yxe = Y(),
    Kxe = Zy(),
    Jxe = (e) => {
      if (e.expiration && e.expiration.getTime() < Date.now())
        throw new Yxe.TokenProviderError(
          `Token is expired. ${Kxe.REFRESH_MESSAGE}`,
          !1,
        )
    }
  ng.validateTokenExpiry = Jxe
})
var oW = l((rg) => {
  'use strict'
  Object.defineProperty(rg, '__esModule', { value: !0 })
  rg.validateTokenKey = void 0
  var Xxe = Y(),
    Qxe = Zy(),
    Zxe = (e, t, n = !1) => {
      if (typeof t > 'u')
        throw new Xxe.TokenProviderError(
          `Value not present for '${e}' in SSO Token${
            n ? '. Cannot refresh' : ''
          }. ${Qxe.REFRESH_MESSAGE}`,
          !1,
        )
    }
  rg.validateTokenKey = Zxe
})
var iW = l((sg) => {
  'use strict'
  Object.defineProperty(sg, '__esModule', { value: !0 })
  sg.writeSSOTokenToFile = void 0
  var eIe = ct(),
    tIe = require('fs'),
    { writeFile: nIe } = tIe.promises,
    rIe = (e, t) => {
      let n = (0, eIe.getSSOTokenFilepath)(e),
        r = JSON.stringify(t, null, 2)
      return nIe(n, r)
    }
  sg.writeSSOTokenToFile = rIe
})
var PI = l((ig) => {
  'use strict'
  Object.defineProperty(ig, '__esModule', { value: !0 })
  ig.fromSso = void 0
  var Xu = Y(),
    og = ct(),
    aW = Zy(),
    sIe = rW(),
    cW = sW(),
    qo = oW(),
    oIe = iW(),
    dW = new Date(0),
    iIe =
      (e = {}) =>
      async () => {
        let t = await (0, og.parseKnownFiles)(e),
          n = (0, og.getProfileName)(e),
          r = t[n]
        if (r) {
          if (!r.sso_session)
            throw new Xu.TokenProviderError(
              `Profile '${n}' is missing required property 'sso_session'.`,
            )
        } else
          throw new Xu.TokenProviderError(
            `Profile '${n}' could not be found in shared credentials file.`,
            !1,
          )
        let s = r.sso_session,
          i = (await (0, og.loadSsoSessionData)(e))[s]
        if (!i)
          throw new Xu.TokenProviderError(
            `Sso session '${s}' could not be found in shared credentials file.`,
            !1,
          )
        for (let _ of ['sso_start_url', 'sso_region'])
          if (!i[_])
            throw new Xu.TokenProviderError(
              `Sso session '${s}' is missing required property '${_}'.`,
              !1,
            )
        let c = i.sso_start_url,
          a = i.sso_region,
          u
        try {
          u = await (0, og.getSSOTokenFromFile)(s)
        } catch {
          throw new Xu.TokenProviderError(
            `The SSO session token associated with profile=${n} was not found or is invalid. ${aW.REFRESH_MESSAGE}`,
            !1,
          )
        }
        ;(0, qo.validateTokenKey)('accessToken', u.accessToken),
          (0, qo.validateTokenKey)('expiresAt', u.expiresAt)
        let { accessToken: d, expiresAt: p } = u,
          f = { token: d, expiration: new Date(p) }
        if (f.expiration.getTime() - Date.now() > aW.EXPIRE_WINDOW_MS) return f
        if (Date.now() - dW.getTime() < 30 * 1e3)
          return (0, cW.validateTokenExpiry)(f), f
        ;(0, qo.validateTokenKey)('clientId', u.clientId, !0),
          (0, qo.validateTokenKey)('clientSecret', u.clientSecret, !0),
          (0, qo.validateTokenKey)('refreshToken', u.refreshToken, !0)
        try {
          dW.setTime(Date.now())
          let _ = await (0, sIe.getNewSsoOidcToken)(u, a)
          ;(0, qo.validateTokenKey)('accessToken', _.accessToken),
            (0, qo.validateTokenKey)('expiresIn', _.expiresIn)
          let h = new Date(Date.now() + _.expiresIn * 1e3)
          try {
            await (0, oIe.writeSSOTokenToFile)(s, {
              ...u,
              accessToken: _.accessToken,
              expiresAt: h.toISOString(),
              refreshToken: _.refreshToken,
            })
          } catch {}
          return { token: _.accessToken, expiration: h }
        } catch {
          return (0, cW.validateTokenExpiry)(f), f
        }
      }
  ig.fromSso = iIe
})
var uW = l((ag) => {
  'use strict'
  Object.defineProperty(ag, '__esModule', { value: !0 })
  ag.fromStatic = void 0
  var aIe = Y(),
    cIe =
      ({ token: e }) =>
      async () => {
        if (!e || !e.token)
          throw new aIe.TokenProviderError(
            'Please pass a valid token to fromStatic',
            !1,
          )
        return e
      }
  ag.fromStatic = cIe
})
var lW = l((cg) => {
  'use strict'
  Object.defineProperty(cg, '__esModule', { value: !0 })
  cg.nodeProvider = void 0
  var RI = Y(),
    dIe = PI(),
    uIe = (e = {}) =>
      (0, RI.memoize)(
        (0, RI.chain)((0, dIe.fromSso)(e), async () => {
          throw new RI.TokenProviderError(
            'Could not load token from any providers',
            !1,
          )
        }),
        (t) =>
          t.expiration !== void 0 && t.expiration.getTime() - Date.now() < 3e5,
        (t) => t.expiration !== void 0,
      )
  cg.nodeProvider = uIe
})
var mW = l((la) => {
  'use strict'
  Object.defineProperty(la, '__esModule', { value: !0 })
  var dg = (x(), w(T))
  dg.__exportStar(Qy(), la)
  dg.__exportStar(PI(), la)
  dg.__exportStar(uW(), la)
  dg.__exportStar(lW(), la)
})
var fW = l((ug) => {
  'use strict'
  Object.defineProperty(ug, '__esModule', { value: !0 })
  ug.resolveSSOCredentials = void 0
  var pW = o2(),
    lIe = mW(),
    Qu = Y(),
    mIe = ct(),
    pIe = 15 * 60 * 1e3,
    Zu = !1,
    fIe = async ({
      ssoStartUrl: e,
      ssoSession: t,
      ssoAccountId: n,
      ssoRegion: r,
      ssoRoleName: s,
      ssoClient: o,
      profile: i,
    }) => {
      let c,
        a =
          'To refresh this SSO session run aws sso login with the corresponding profile.'
      if (t)
        try {
          let E = await (0, lIe.fromSso)({ profile: i })()
          c = {
            accessToken: E.token,
            expiresAt: new Date(E.expiration).toISOString(),
          }
        } catch (E) {
          throw new Qu.CredentialsProviderError(E.message, Zu)
        }
      else
        try {
          c = await (0, mIe.getSSOTokenFromFile)(e)
        } catch {
          throw new Qu.CredentialsProviderError(
            `The SSO session associated with this profile is invalid. ${a}`,
            Zu,
          )
        }
      if (new Date(c.expiresAt).getTime() - Date.now() <= pIe)
        throw new Qu.CredentialsProviderError(
          `The SSO session associated with this profile has expired. ${a}`,
          Zu,
        )
      let { accessToken: u } = c,
        d = o || new pW.SSOClient({ region: r }),
        p
      try {
        p = await d.send(
          new pW.GetRoleCredentialsCommand({
            accountId: n,
            roleName: s,
            accessToken: u,
          }),
        )
      } catch (E) {
        throw Qu.CredentialsProviderError.from(E, Zu)
      }
      let {
        roleCredentials: {
          accessKeyId: f,
          secretAccessKey: _,
          sessionToken: h,
          expiration: g,
        } = {},
      } = p
      if (!f || !_ || !h || !g)
        throw new Qu.CredentialsProviderError(
          'SSO returns an invalid temporary credential.',
          Zu,
        )
      return {
        accessKeyId: f,
        secretAccessKey: _,
        sessionToken: h,
        expiration: new Date(g),
      }
    }
  ug.resolveSSOCredentials = fIe
})
var DI = l((lg) => {
  'use strict'
  Object.defineProperty(lg, '__esModule', { value: !0 })
  lg.validateSsoProfile = void 0
  var _Ie = Y(),
    hIe = (e) => {
      let {
        sso_start_url: t,
        sso_account_id: n,
        sso_region: r,
        sso_role_name: s,
      } = e
      if (!t || !n || !r || !s)
        throw new _Ie.CredentialsProviderError(
          `Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(
            e,
          ).join(', ')}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`,
          !1,
        )
      return e
    }
  lg.validateSsoProfile = hIe
})
var hW = l((mg) => {
  'use strict'
  Object.defineProperty(mg, '__esModule', { value: !0 })
  mg.fromSSO = void 0
  var el = Y(),
    AI = ct(),
    yIe = Vx(),
    _W = fW(),
    gIe = DI(),
    EIe =
      (e = {}) =>
      async () => {
        let {
            ssoStartUrl: t,
            ssoAccountId: n,
            ssoRegion: r,
            ssoRoleName: s,
            ssoClient: o,
            ssoSession: i,
          } = e,
          c = (0, AI.getProfileName)(e)
        if (!t && !n && !r && !s && !i) {
          let u = (await (0, AI.parseKnownFiles)(e))[c]
          if (!u)
            throw new el.CredentialsProviderError(`Profile ${c} was not found.`)
          if (!(0, yIe.isSsoProfile)(u))
            throw new el.CredentialsProviderError(
              `Profile ${c} is not configured with SSO credentials.`,
            )
          if (u?.sso_session) {
            let E = (await (0, AI.loadSsoSessionData)(e))[u.sso_session],
              P = ` configurations in profile ${c} and sso-session ${u.sso_session}`
            if (r && r !== E.sso_region)
              throw new el.CredentialsProviderError(
                'Conflicting SSO region' + P,
                !1,
              )
            if (t && t !== E.sso_start_url)
              throw new el.CredentialsProviderError(
                'Conflicting SSO start_url' + P,
                !1,
              )
            ;(u.sso_region = E.sso_region), (u.sso_start_url = E.sso_start_url)
          }
          let {
            sso_start_url: d,
            sso_account_id: p,
            sso_region: f,
            sso_role_name: _,
            sso_session: h,
          } = (0, gIe.validateSsoProfile)(u)
          return (0, _W.resolveSSOCredentials)({
            ssoStartUrl: d,
            ssoSession: h,
            ssoAccountId: p,
            ssoRegion: f,
            ssoRoleName: _,
            ssoClient: o,
            profile: c,
          })
        } else {
          if (!t || !n || !r || !s)
            throw new el.CredentialsProviderError(
              'Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"',
            )
          return (0, _W.resolveSSOCredentials)({
            ssoStartUrl: t,
            ssoSession: i,
            ssoAccountId: n,
            ssoRegion: r,
            ssoRoleName: s,
            ssoClient: o,
            profile: c,
          })
        }
      }
  mg.fromSSO = EIe
})
var gW = l((yW) => {
  'use strict'
  Object.defineProperty(yW, '__esModule', { value: !0 })
})
var fg = l((ma) => {
  'use strict'
  Object.defineProperty(ma, '__esModule', { value: !0 })
  var pg = (x(), w(T))
  pg.__exportStar(hW(), ma)
  pg.__exportStar(Vx(), ma)
  pg.__exportStar(gW(), ma)
  pg.__exportStar(DI(), ma)
})
var SW = l((pa) => {
  'use strict'
  Object.defineProperty(pa, '__esModule', { value: !0 })
  pa.resolveSsoCredentials = pa.isSsoProfile = void 0
  var EW = fg(),
    SIe = fg()
  Object.defineProperty(pa, 'isSsoProfile', {
    enumerable: !0,
    get: function () {
      return SIe.isSsoProfile
    },
  })
  var bIe = (e) => {
    let {
      sso_start_url: t,
      sso_account_id: n,
      sso_session: r,
      sso_region: s,
      sso_role_name: o,
    } = (0, EW.validateSsoProfile)(e)
    return (0, EW.fromSSO)({
      ssoStartUrl: t,
      ssoAccountId: n,
      ssoSession: r,
      ssoRegion: s,
      ssoRoleName: o,
    })()
  }
  pa.resolveSsoCredentials = bIe
})
var bW = l((fa) => {
  'use strict'
  Object.defineProperty(fa, '__esModule', { value: !0 })
  fa.resolveStaticCredentials = fa.isStaticCredsProfile = void 0
  var vIe = (e) =>
    !!e &&
    typeof e == 'object' &&
    typeof e.aws_access_key_id == 'string' &&
    typeof e.aws_secret_access_key == 'string' &&
    ['undefined', 'string'].indexOf(typeof e.aws_session_token) > -1
  fa.isStaticCredsProfile = vIe
  var CIe = (e) =>
    Promise.resolve({
      accessKeyId: e.aws_access_key_id,
      secretAccessKey: e.aws_secret_access_key,
      sessionToken: e.aws_session_token,
    })
  fa.resolveStaticCredentials = CIe
})
var OI = l((_g) => {
  'use strict'
  Object.defineProperty(_g, '__esModule', { value: !0 })
  _g.fromWebToken = void 0
  var wIe = Y(),
    TIe = (e) => () => {
      let {
        roleArn: t,
        roleSessionName: n,
        webIdentityToken: r,
        providerId: s,
        policyArns: o,
        policy: i,
        durationSeconds: c,
        roleAssumerWithWebIdentity: a,
      } = e
      if (!a)
        throw new wIe.CredentialsProviderError(
          `Role Arn '${t}' needs to be assumed with web identity, but no role assumption callback was provided.`,
          !1,
        )
      return a({
        RoleArn: t,
        RoleSessionName: n ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: r,
        ProviderId: s,
        PolicyArns: o,
        Policy: i,
        DurationSeconds: c,
      })
    }
  _g.fromWebToken = TIe
})
var vW = l((hg) => {
  'use strict'
  Object.defineProperty(hg, '__esModule', { value: !0 })
  hg.fromTokenFile = void 0
  var xIe = Y(),
    IIe = require('fs'),
    PIe = OI(),
    RIe = 'AWS_WEB_IDENTITY_TOKEN_FILE',
    DIe = 'AWS_ROLE_ARN',
    AIe = 'AWS_ROLE_SESSION_NAME',
    OIe =
      (e = {}) =>
      async () => {
        var t, n, r
        let s =
            (t = e?.webIdentityTokenFile) !== null && t !== void 0
              ? t
              : process.env[RIe],
          o = (n = e?.roleArn) !== null && n !== void 0 ? n : process.env[DIe],
          i =
            (r = e?.roleSessionName) !== null && r !== void 0
              ? r
              : process.env[AIe]
        if (!s || !o)
          throw new xIe.CredentialsProviderError(
            'Web identity configuration not specified',
          )
        return (0, PIe.fromWebToken)({
          ...e,
          webIdentityToken: (0, IIe.readFileSync)(s, { encoding: 'ascii' }),
          roleArn: o,
          roleSessionName: i,
        })()
      }
  hg.fromTokenFile = OIe
})
var NI = l((yg) => {
  'use strict'
  Object.defineProperty(yg, '__esModule', { value: !0 })
  var CW = (x(), w(T))
  CW.__exportStar(vW(), yg)
  CW.__exportStar(OI(), yg)
})
var wW = l((_a) => {
  'use strict'
  Object.defineProperty(_a, '__esModule', { value: !0 })
  _a.resolveWebIdentityCredentials = _a.isWebIdentityProfile = void 0
  var NIe = NI(),
    qIe = (e) =>
      !!e &&
      typeof e == 'object' &&
      typeof e.web_identity_token_file == 'string' &&
      typeof e.role_arn == 'string' &&
      ['undefined', 'string'].indexOf(typeof e.role_session_name) > -1
  _a.isWebIdentityProfile = qIe
  var kIe = async (e, t) =>
    (0, NIe.fromTokenFile)({
      webIdentityTokenFile: e.web_identity_token_file,
      roleArn: e.role_arn,
      roleSessionName: e.role_session_name,
      roleAssumerWithWebIdentity: t.roleAssumerWithWebIdentity,
    })()
  _a.resolveWebIdentityCredentials = kIe
})
var $x = l((Eg) => {
  'use strict'
  Object.defineProperty(Eg, '__esModule', { value: !0 })
  Eg.resolveProfileData = void 0
  var MIe = Y(),
    TW = DH(),
    xW = kH(),
    IW = SW(),
    gg = bW(),
    PW = wW(),
    FIe = async (e, t, n, r = {}) => {
      let s = t[e]
      if (Object.keys(r).length > 0 && (0, gg.isStaticCredsProfile)(s))
        return (0, gg.resolveStaticCredentials)(s)
      if ((0, TW.isAssumeRoleProfile)(s))
        return (0, TW.resolveAssumeRoleCredentials)(e, t, n, r)
      if ((0, gg.isStaticCredsProfile)(s))
        return (0, gg.resolveStaticCredentials)(s)
      if ((0, PW.isWebIdentityProfile)(s))
        return (0, PW.resolveWebIdentityCredentials)(s, n)
      if ((0, xW.isProcessProfile)(s))
        return (0, xW.resolveProcessCredentials)(n, e)
      if ((0, IW.isSsoProfile)(s)) return (0, IW.resolveSsoCredentials)(s)
      throw new MIe.CredentialsProviderError(
        `Profile ${e} could not be found or parsed in shared credentials file.`,
      )
    }
  Eg.resolveProfileData = FIe
})
var DW = l((Sg) => {
  'use strict'
  Object.defineProperty(Sg, '__esModule', { value: !0 })
  Sg.fromIni = void 0
  var RW = ct(),
    UIe = $x(),
    LIe =
      (e = {}) =>
      async () => {
        let t = await (0, RW.parseKnownFiles)(e)
        return (0, UIe.resolveProfileData)((0, RW.getProfileName)(e), t, e)
      }
  Sg.fromIni = LIe
})
var AW = l((qI) => {
  'use strict'
  Object.defineProperty(qI, '__esModule', { value: !0 })
  var BIe = (x(), w(T))
  BIe.__exportStar(DW(), qI)
})
var OW = l((ko) => {
  'use strict'
  Object.defineProperty(ko, '__esModule', { value: !0 })
  ko.remoteProvider = ko.ENV_IMDS_DISABLED = void 0
  var bg = ty(),
    jIe = Y()
  ko.ENV_IMDS_DISABLED = 'AWS_EC2_METADATA_DISABLED'
  var GIe = (e) =>
    process.env[bg.ENV_CMDS_RELATIVE_URI] || process.env[bg.ENV_CMDS_FULL_URI]
      ? (0, bg.fromContainerMetadata)(e)
      : process.env[ko.ENV_IMDS_DISABLED]
      ? async () => {
          throw new jIe.CredentialsProviderError(
            'EC2 Instance Metadata Service access disabled',
          )
        }
      : (0, bg.fromInstanceMetadata)(e)
  ko.remoteProvider = GIe
})
var NW = l((vg) => {
  'use strict'
  Object.defineProperty(vg, '__esModule', { value: !0 })
  vg.defaultProvider = void 0
  var $Ie = Ix(),
    zIe = AW(),
    HIe = Wx(),
    WIe = fg(),
    VIe = NI(),
    kI = Y(),
    YIe = ct(),
    KIe = OW(),
    JIe = (e = {}) =>
      (0, kI.memoize)(
        (0, kI.chain)(
          ...(e.profile || process.env[YIe.ENV_PROFILE]
            ? []
            : [(0, $Ie.fromEnv)()]),
          (0, WIe.fromSSO)(e),
          (0, zIe.fromIni)(e),
          (0, HIe.fromProcess)(e),
          (0, VIe.fromTokenFile)(e),
          (0, KIe.remoteProvider)(e),
          async () => {
            throw new kI.CredentialsProviderError(
              'Could not load credentials from any providers',
              !1,
            )
          },
        ),
        (t) =>
          t.expiration !== void 0 && t.expiration.getTime() - Date.now() < 3e5,
        (t) => t.expiration !== void 0,
      )
  vg.defaultProvider = JIe
})
var FI = l((MI) => {
  'use strict'
  Object.defineProperty(MI, '__esModule', { value: !0 })
  var XIe = (x(), w(T))
  XIe.__exportStar(NW(), MI)
})
var qW = l((Cg) => {
  'use strict'
  Object.defineProperty(Cg, '__esModule', { value: !0 })
  Cg.fromEnv = void 0
  var QIe = Y(),
    ZIe = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new QIe.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  Cg.fromEnv = ZIe
})
var MW = l((wg) => {
  'use strict'
  Object.defineProperty(wg, '__esModule', { value: !0 })
  wg.fromSharedConfigFiles = void 0
  var ePe = Y(),
    kW = ct(),
    tPe =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, kW.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          kW.loadSharedConfigFiles)(n),
          i = o[r] || {},
          c = s[r] || {},
          a = t === 'config' ? { ...i, ...c } : { ...c, ...i }
        try {
          let u = e(a)
          if (u === void 0) throw new Error()
          return u
        } catch (u) {
          throw new ePe.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  wg.fromSharedConfigFiles = tPe
})
var FW = l((Tg) => {
  'use strict'
  Object.defineProperty(Tg, '__esModule', { value: !0 })
  Tg.fromStatic = void 0
  var nPe = Y(),
    rPe = (e) => typeof e == 'function',
    sPe = (e) => (rPe(e) ? async () => await e() : (0, nPe.fromStatic)(e))
  Tg.fromStatic = sPe
})
var LW = l((xg) => {
  'use strict'
  Object.defineProperty(xg, '__esModule', { value: !0 })
  xg.loadConfig = void 0
  var UW = Y(),
    oPe = qW(),
    iPe = MW(),
    aPe = FW(),
    cPe = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, UW.memoize)(
        (0, UW.chain)(
          (0, oPe.fromEnv)(e),
          (0, iPe.fromSharedConfigFiles)(t, r),
          (0, aPe.fromStatic)(n),
        ),
      )
  xg.loadConfig = cPe
})
var BW = l((UI) => {
  'use strict'
  Object.defineProperty(UI, '__esModule', { value: !0 })
  var dPe = (x(), w(T))
  dPe.__exportStar(LW(), UI)
})
var GW = l((Ig) => {
  'use strict'
  Object.defineProperty(Ig, '__esModule', { value: !0 })
  Ig.calculateBodyLength = void 0
  var jW = require('fs'),
    uPe = (e) => {
      if (!e) return 0
      if (typeof e == 'string') return Buffer.from(e).length
      if (typeof e.byteLength == 'number') return e.byteLength
      if (typeof e.size == 'number') return e.size
      if (typeof e.path == 'string' || Buffer.isBuffer(e.path))
        return (0, jW.lstatSync)(e.path).size
      if (typeof e.fd == 'number') return (0, jW.fstatSync)(e.fd).size
      throw new Error(`Body Length computation failed for ${e}`)
    }
  Ig.calculateBodyLength = uPe
})
var $W = l((LI) => {
  'use strict'
  Object.defineProperty(LI, '__esModule', { value: !0 })
  var lPe = (x(), w(T))
  lPe.__exportStar(GW(), LI)
})
var lV = l((Pg) => {
  'use strict'
  Object.defineProperty(Pg, '__esModule', { value: !0 })
  Pg.ruleSet = void 0
  var tV = 'required',
    J = 'type',
    me = 'fn',
    pe = 'argv',
    ws = 'ref',
    zW = !1,
    mPe = !0,
    Mo = 'booleanEquals',
    ot = 'tree',
    Je = 'stringEquals',
    nV = 'sigv4',
    rV = 'sts',
    sV = 'us-east-1',
    ve = 'endpoint',
    HW = 'https://sts.{Region}.{PartitionResult#dnsSuffix}',
    ha = 'error',
    jI = 'getAttr',
    WW = { [tV]: !1, [J]: 'String' },
    BI = { [tV]: !0, default: !1, [J]: 'Boolean' },
    oV = { [ws]: 'Endpoint' },
    VW = { [me]: 'isSet', [pe]: [{ [ws]: 'Region' }] },
    Xe = { [ws]: 'Region' },
    YW = { [me]: 'aws.partition', [pe]: [Xe], assign: 'PartitionResult' },
    iV = { [ws]: 'UseFIPS' },
    aV = { [ws]: 'UseDualStack' },
    it = {
      url: 'https://sts.amazonaws.com',
      properties: {
        authSchemes: [{ name: nV, signingName: rV, signingRegion: sV }],
      },
      headers: {},
    },
    qt = {},
    KW = {
      conditions: [{ [me]: Je, [pe]: [Xe, 'aws-global'] }],
      [ve]: it,
      [J]: ve,
    },
    cV = { [me]: Mo, [pe]: [iV, !0] },
    dV = { [me]: Mo, [pe]: [aV, !0] },
    JW = {
      [me]: Mo,
      [pe]: [
        !0,
        { [me]: jI, [pe]: [{ [ws]: 'PartitionResult' }, 'supportsFIPS'] },
      ],
    },
    uV = { [ws]: 'PartitionResult' },
    XW = {
      [me]: Mo,
      [pe]: [!0, { [me]: jI, [pe]: [uV, 'supportsDualStack'] }],
    },
    QW = [{ [me]: 'isSet', [pe]: [oV] }],
    ZW = [cV],
    eV = [dV],
    pPe = {
      version: '1.0',
      parameters: {
        Region: WW,
        UseDualStack: BI,
        UseFIPS: BI,
        Endpoint: WW,
        UseGlobalEndpoint: BI,
      },
      rules: [
        {
          conditions: [
            { [me]: Mo, [pe]: [{ [ws]: 'UseGlobalEndpoint' }, mPe] },
            { [me]: 'not', [pe]: QW },
            VW,
            YW,
            { [me]: Mo, [pe]: [iV, zW] },
            { [me]: Mo, [pe]: [aV, zW] },
          ],
          [J]: ot,
          rules: [
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'ap-northeast-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'ap-south-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'ap-southeast-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'ap-southeast-2'] }],
              endpoint: it,
              [J]: ve,
            },
            KW,
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'ca-central-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'eu-central-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'eu-north-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'eu-west-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'eu-west-2'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'eu-west-3'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'sa-east-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, sV] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'us-east-2'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'us-west-1'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              conditions: [{ [me]: Je, [pe]: [Xe, 'us-west-2'] }],
              endpoint: it,
              [J]: ve,
            },
            {
              endpoint: {
                url: HW,
                properties: {
                  authSchemes: [
                    { name: nV, signingName: rV, signingRegion: '{Region}' },
                  ],
                },
                headers: qt,
              },
              [J]: ve,
            },
          ],
        },
        {
          conditions: QW,
          [J]: ot,
          rules: [
            {
              conditions: ZW,
              error:
                'Invalid Configuration: FIPS and custom endpoint are not supported',
              [J]: ha,
            },
            {
              [J]: ot,
              rules: [
                {
                  conditions: eV,
                  error:
                    'Invalid Configuration: Dualstack and custom endpoint are not supported',
                  [J]: ha,
                },
                { endpoint: { url: oV, properties: qt, headers: qt }, [J]: ve },
              ],
            },
          ],
        },
        {
          [J]: ot,
          rules: [
            {
              conditions: [VW],
              [J]: ot,
              rules: [
                {
                  conditions: [YW],
                  [J]: ot,
                  rules: [
                    {
                      conditions: [cV, dV],
                      [J]: ot,
                      rules: [
                        {
                          conditions: [JW, XW],
                          [J]: ot,
                          rules: [
                            {
                              [J]: ot,
                              rules: [
                                {
                                  endpoint: {
                                    url: 'https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                                    properties: qt,
                                    headers: qt,
                                  },
                                  [J]: ve,
                                },
                              ],
                            },
                          ],
                        },
                        {
                          error:
                            'FIPS and DualStack are enabled, but this partition does not support one or both',
                          [J]: ha,
                        },
                      ],
                    },
                    {
                      conditions: ZW,
                      [J]: ot,
                      rules: [
                        {
                          conditions: [JW],
                          [J]: ot,
                          rules: [
                            {
                              [J]: ot,
                              rules: [
                                {
                                  conditions: [
                                    {
                                      [me]: Je,
                                      [pe]: [
                                        'aws-us-gov',
                                        { [me]: jI, [pe]: [uV, 'name'] },
                                      ],
                                    },
                                  ],
                                  endpoint: {
                                    url: 'https://sts.{Region}.amazonaws.com',
                                    properties: qt,
                                    headers: qt,
                                  },
                                  [J]: ve,
                                },
                                {
                                  endpoint: {
                                    url: 'https://sts-fips.{Region}.{PartitionResult#dnsSuffix}',
                                    properties: qt,
                                    headers: qt,
                                  },
                                  [J]: ve,
                                },
                              ],
                            },
                          ],
                        },
                        {
                          error:
                            'FIPS is enabled but this partition does not support FIPS',
                          [J]: ha,
                        },
                      ],
                    },
                    {
                      conditions: eV,
                      [J]: ot,
                      rules: [
                        {
                          conditions: [XW],
                          [J]: ot,
                          rules: [
                            {
                              [J]: ot,
                              rules: [
                                {
                                  endpoint: {
                                    url: 'https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}',
                                    properties: qt,
                                    headers: qt,
                                  },
                                  [J]: ve,
                                },
                              ],
                            },
                          ],
                        },
                        {
                          error:
                            'DualStack is enabled but this partition does not support DualStack',
                          [J]: ha,
                        },
                      ],
                    },
                    {
                      [J]: ot,
                      rules: [
                        KW,
                        {
                          endpoint: { url: HW, properties: qt, headers: qt },
                          [J]: ve,
                        },
                      ],
                    },
                  ],
                },
              ],
            },
            { error: 'Invalid Configuration: Missing Region', [J]: ha },
          ],
        },
      ],
    }
  Pg.ruleSet = pPe
})
var mV = l((Rg) => {
  'use strict'
  Object.defineProperty(Rg, '__esModule', { value: !0 })
  Rg.defaultEndpointResolver = void 0
  var fPe = Ai(),
    _Pe = lV(),
    hPe = (e, t = {}) =>
      (0, fPe.resolveEndpoint)(_Pe.ruleSet, {
        endpointParams: e,
        logger: t.logger,
      })
  Rg.defaultEndpointResolver = hPe
})
var _V = l((Dg) => {
  'use strict'
  Object.defineProperty(Dg, '__esModule', { value: !0 })
  Dg.getRuntimeConfig = void 0
  var yPe = v(),
    gPe = vo(),
    pV = Mi(),
    fV = Pn(),
    EPe = mV(),
    SPe = (e) => ({
      apiVersion: '2011-06-15',
      base64Decoder: e?.base64Decoder ?? pV.fromBase64,
      base64Encoder: e?.base64Encoder ?? pV.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? EPe.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      logger: e?.logger ?? new yPe.NoOpLogger(),
      serviceId: e?.serviceId ?? 'STS',
      urlParser: e?.urlParser ?? gPe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? fV.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? fV.toUtf8,
    })
  Dg.getRuntimeConfig = SPe
})
var gV = l((Og) => {
  'use strict'
  Object.defineProperty(Og, '__esModule', { value: !0 })
  Og.getRuntimeConfig = void 0
  var bPe = (x(), w(T)),
    vPe = bPe.__importDefault(ez()),
    CPe = Tx(),
    wPe = FI(),
    TPe = Uu(),
    Ag = An(),
    xPe = Lu(),
    hV = Er(),
    tl = BW(),
    yV = Li(),
    IPe = $W(),
    PPe = Kt(),
    RPe = _V(),
    DPe = v(),
    APe = Gu(),
    OPe = v(),
    NPe = (e) => {
      ;(0, OPe.emitWarningIfUnsupportedVersion)(process.version)
      let t = (0, APe.resolveDefaultsModeConfig)(e),
        n = () => t().then(DPe.loadConfigsForDefaultMode),
        r = (0, RPe.getRuntimeConfig)(e)
      return {
        ...r,
        ...e,
        runtime: 'node',
        defaultsMode: t,
        bodyLengthChecker: e?.bodyLengthChecker ?? IPe.calculateBodyLength,
        credentialDefaultProvider:
          e?.credentialDefaultProvider ??
          (0, CPe.decorateDefaultCredentialProvider)(wPe.defaultProvider),
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, TPe.defaultUserAgent)({
            serviceId: r.serviceId,
            clientVersion: vPe.default.version,
          }),
        maxAttempts:
          e?.maxAttempts ??
          (0, tl.loadConfig)(hV.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          e?.region ??
          (0, tl.loadConfig)(
            Ag.NODE_REGION_CONFIG_OPTIONS,
            Ag.NODE_REGION_CONFIG_FILE_OPTIONS,
          ),
        requestHandler: e?.requestHandler ?? new yV.NodeHttpHandler(n),
        retryMode:
          e?.retryMode ??
          (0, tl.loadConfig)({
            ...hV.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () =>
              (await n()).retryMode || PPe.DEFAULT_RETRY_MODE,
          }),
        sha256: e?.sha256 ?? xPe.Hash.bind(null, 'sha256'),
        streamCollector: e?.streamCollector ?? yV.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, tl.loadConfig)(Ag.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, tl.loadConfig)(Ag.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    }
  Og.getRuntimeConfig = NPe
})
var SV = l((Ng) => {
  'use strict'
  Object.defineProperty(Ng, '__esModule', { value: !0 })
  Ng.resolveRuntimeExtensions = void 0
  var EV = Vr(),
    qPe = (e) => e,
    kPe = (e, t) => {
      let n = { ...qPe((0, EV.getDefaultClientConfiguration)(e)) }
      return (
        t.forEach((r) => r.configureClient(n)),
        { ...e, ...(0, EV.resolveDefaultRuntimeConfig)(n) }
      )
    }
  Ng.resolveRuntimeExtensions = kPe
})
var qg = l((ya) => {
  'use strict'
  Object.defineProperty(ya, '__esModule', { value: !0 })
  ya.STSClient = ya.__Client = void 0
  var bV = Yd(),
    MPe = Kd(),
    FPe = Jd(),
    UPe = Q$(),
    vV = du(),
    LPe = An(),
    BPe = mu(),
    jPe = D(),
    CV = Er(),
    wV = v()
  Object.defineProperty(ya, '__Client', {
    enumerable: !0,
    get: function () {
      return wV.Client
    },
  })
  var GPe = Z$(),
    $Pe = gV(),
    zPe = SV(),
    GI = class e extends wV.Client {
      constructor(...[t]) {
        let n = (0, $Pe.getRuntimeConfig)(t || {}),
          r = (0, GPe.resolveClientEndpointParameters)(n),
          s = (0, LPe.resolveRegionConfig)(r),
          o = (0, jPe.resolveEndpointConfig)(s),
          i = (0, CV.resolveRetryConfig)(o),
          c = (0, bV.resolveHostHeaderConfig)(i),
          a = (0, UPe.resolveStsAuthConfig)(c, { stsClientCtor: e }),
          u = (0, vV.resolveUserAgentConfig)(a),
          d = (0, zPe.resolveRuntimeExtensions)(u, t?.extensions || [])
        super(d),
          (this.config = d),
          this.middlewareStack.use((0, CV.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, BPe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, bV.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, MPe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, FPe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, vV.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  ya.STSClient = GI
})
var zI = l((ga) => {
  'use strict'
  Object.defineProperty(ga, '__esModule', { value: !0 })
  ga.AssumeRoleWithSAMLCommand = ga.$Command = void 0
  var HPe = D(),
    WPe = O(),
    IV = v()
  Object.defineProperty(ga, '$Command', {
    enumerable: !0,
    get: function () {
      return IV.Command
    },
  })
  var TV = ms(),
    xV = wr(),
    $I = class e extends IV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, WPe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, HPe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'AssumeRoleWithSAMLCommand',
            inputFilterSensitiveLog:
              TV.AssumeRoleWithSAMLRequestFilterSensitiveLog,
            outputFilterSensitiveLog:
              TV.AssumeRoleWithSAMLResponseFilterSensitiveLog,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, xV.se_AssumeRoleWithSAMLCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, xV.de_AssumeRoleWithSAMLCommand)(t, n)
      }
    }
  ga.AssumeRoleWithSAMLCommand = $I
})
var WI = l((Ea) => {
  'use strict'
  Object.defineProperty(Ea, '__esModule', { value: !0 })
  Ea.DecodeAuthorizationMessageCommand = Ea.$Command = void 0
  var VPe = fr(),
    YPe = D(),
    KPe = O(),
    RV = v()
  Object.defineProperty(Ea, '$Command', {
    enumerable: !0,
    get: function () {
      return RV.Command
    },
  })
  var PV = wr(),
    HI = class e extends RV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, KPe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, YPe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, VPe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'DecodeAuthorizationMessageCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, PV.se_DecodeAuthorizationMessageCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, PV.de_DecodeAuthorizationMessageCommand)(t, n)
      }
    }
  Ea.DecodeAuthorizationMessageCommand = HI
})
var YI = l((Sa) => {
  'use strict'
  Object.defineProperty(Sa, '__esModule', { value: !0 })
  Sa.GetAccessKeyInfoCommand = Sa.$Command = void 0
  var JPe = fr(),
    XPe = D(),
    QPe = O(),
    AV = v()
  Object.defineProperty(Sa, '$Command', {
    enumerable: !0,
    get: function () {
      return AV.Command
    },
  })
  var DV = wr(),
    VI = class e extends AV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, QPe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, XPe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, JPe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetAccessKeyInfoCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, DV.se_GetAccessKeyInfoCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, DV.de_GetAccessKeyInfoCommand)(t, n)
      }
    }
  Sa.GetAccessKeyInfoCommand = VI
})
var JI = l((ba) => {
  'use strict'
  Object.defineProperty(ba, '__esModule', { value: !0 })
  ba.GetCallerIdentityCommand = ba.$Command = void 0
  var ZPe = fr(),
    eRe = D(),
    tRe = O(),
    NV = v()
  Object.defineProperty(ba, '$Command', {
    enumerable: !0,
    get: function () {
      return NV.Command
    },
  })
  var OV = wr(),
    KI = class e extends NV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, tRe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, eRe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, ZPe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetCallerIdentityCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, OV.se_GetCallerIdentityCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, OV.de_GetCallerIdentityCommand)(t, n)
      }
    }
  ba.GetCallerIdentityCommand = KI
})
var QI = l((va) => {
  'use strict'
  Object.defineProperty(va, '__esModule', { value: !0 })
  va.GetFederationTokenCommand = va.$Command = void 0
  var nRe = fr(),
    rRe = D(),
    sRe = O(),
    kV = v()
  Object.defineProperty(va, '$Command', {
    enumerable: !0,
    get: function () {
      return kV.Command
    },
  })
  var oRe = ms(),
    qV = wr(),
    XI = class e extends kV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, sRe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, rRe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, nRe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetFederationTokenCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog:
              oRe.GetFederationTokenResponseFilterSensitiveLog,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, qV.se_GetFederationTokenCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, qV.de_GetFederationTokenCommand)(t, n)
      }
    }
  va.GetFederationTokenCommand = XI
})
var eP = l((Ca) => {
  'use strict'
  Object.defineProperty(Ca, '__esModule', { value: !0 })
  Ca.GetSessionTokenCommand = Ca.$Command = void 0
  var iRe = fr(),
    aRe = D(),
    cRe = O(),
    FV = v()
  Object.defineProperty(Ca, '$Command', {
    enumerable: !0,
    get: function () {
      return FV.Command
    },
  })
  var dRe = ms(),
    MV = wr(),
    ZI = class e extends FV.Command {
      static getEndpointParameterInstructions() {
        return {
          UseGlobalEndpoint: {
            type: 'builtInParams',
            name: 'useGlobalEndpoint',
          },
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, cRe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, aRe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          ),
          this.middlewareStack.use((0, iRe.getAwsAuthPlugin)(n))
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'STSClient',
            commandName: 'GetSessionTokenCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog:
              dRe.GetSessionTokenResponseFilterSensitiveLog,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, MV.se_GetSessionTokenCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, MV.de_GetSessionTokenCommand)(t, n)
      }
    }
  Ca.GetSessionTokenCommand = ZI
})
var UV = l((Mg) => {
  'use strict'
  Object.defineProperty(Mg, '__esModule', { value: !0 })
  Mg.STS = void 0
  var uRe = v(),
    lRe = Ph(),
    mRe = zI(),
    pRe = Rh(),
    fRe = WI(),
    _Re = YI(),
    hRe = JI(),
    yRe = QI(),
    gRe = eP(),
    ERe = qg(),
    SRe = {
      AssumeRoleCommand: lRe.AssumeRoleCommand,
      AssumeRoleWithSAMLCommand: mRe.AssumeRoleWithSAMLCommand,
      AssumeRoleWithWebIdentityCommand: pRe.AssumeRoleWithWebIdentityCommand,
      DecodeAuthorizationMessageCommand: fRe.DecodeAuthorizationMessageCommand,
      GetAccessKeyInfoCommand: _Re.GetAccessKeyInfoCommand,
      GetCallerIdentityCommand: hRe.GetCallerIdentityCommand,
      GetFederationTokenCommand: yRe.GetFederationTokenCommand,
      GetSessionTokenCommand: gRe.GetSessionTokenCommand,
    },
    kg = class extends ERe.STSClient {}
  Mg.STS = kg
  ;(0, uRe.createAggregatedClient)(SRe, kg)
})
var LV = l((Kn) => {
  'use strict'
  Object.defineProperty(Kn, '__esModule', { value: !0 })
  var Ts = (x(), w(T))
  Ts.__exportStar(Ph(), Kn)
  Ts.__exportStar(zI(), Kn)
  Ts.__exportStar(Rh(), Kn)
  Ts.__exportStar(WI(), Kn)
  Ts.__exportStar(YI(), Kn)
  Ts.__exportStar(JI(), Kn)
  Ts.__exportStar(QI(), Kn)
  Ts.__exportStar(eP(), Kn)
})
var BV = l((tP) => {
  'use strict'
  Object.defineProperty(tP, '__esModule', { value: !0 })
  var bRe = (x(), w(T))
  bRe.__exportStar(ms(), tP)
})
var zV = l((Jn) => {
  'use strict'
  Object.defineProperty(Jn, '__esModule', { value: !0 })
  Jn.decorateDefaultCredentialProvider =
    Jn.getDefaultRoleAssumerWithWebIdentity =
    Jn.getDefaultRoleAssumer =
      void 0
  var jV = Tx(),
    GV = qg(),
    $V = (e, t) =>
      t
        ? class extends e {
            constructor(r) {
              super(r)
              for (let s of t) this.middlewareStack.use(s)
            }
          }
        : e,
    vRe = (e = {}, t) => (0, jV.getDefaultRoleAssumer)(e, $V(GV.STSClient, t))
  Jn.getDefaultRoleAssumer = vRe
  var CRe = (e = {}, t) =>
    (0, jV.getDefaultRoleAssumerWithWebIdentity)(e, $V(GV.STSClient, t))
  Jn.getDefaultRoleAssumerWithWebIdentity = CRe
  var wRe = (e) => (t) =>
    e({
      roleAssumer: (0, Jn.getDefaultRoleAssumer)(t),
      roleAssumerWithWebIdentity: (0, Jn.getDefaultRoleAssumerWithWebIdentity)(
        t,
      ),
      ...t,
    })
  Jn.decorateDefaultCredentialProvider = wRe
})
var HV = l((Dr) => {
  'use strict'
  Object.defineProperty(Dr, '__esModule', { value: !0 })
  Dr.STSServiceException = void 0
  var nl = (x(), w(T))
  nl.__exportStar(qg(), Dr)
  nl.__exportStar(UV(), Dr)
  nl.__exportStar(LV(), Dr)
  nl.__exportStar(BV(), Dr)
  nl.__exportStar(zV(), Dr)
  var TRe = Ch()
  Object.defineProperty(Dr, 'STSServiceException', {
    enumerable: !0,
    get: function () {
      return TRe.STSServiceException
    },
  })
})
var WV = l((Fg) => {
  'use strict'
  Object.defineProperty(Fg, '__esModule', { value: !0 })
  Fg.fromEnv = void 0
  var xRe = Y(),
    IRe = (e) => async () => {
      try {
        let t = e(process.env)
        if (t === void 0) throw new Error()
        return t
      } catch (t) {
        throw new xRe.CredentialsProviderError(
          t.message ||
            `Cannot load config from environment variables with getter: ${e}`,
        )
      }
    }
  Fg.fromEnv = IRe
})
var YV = l((Ug) => {
  'use strict'
  Object.defineProperty(Ug, '__esModule', { value: !0 })
  Ug.fromSharedConfigFiles = void 0
  var PRe = Y(),
    VV = ct(),
    RRe =
      (e, { preferredFile: t = 'config', ...n } = {}) =>
      async () => {
        let r = (0, VV.getProfileName)(n),
          { configFile: s, credentialsFile: o } = await (0,
          VV.loadSharedConfigFiles)(n),
          i = o[r] || {},
          c = s[r] || {},
          a = t === 'config' ? { ...i, ...c } : { ...c, ...i }
        try {
          let u = e(a)
          if (u === void 0) throw new Error()
          return u
        } catch (u) {
          throw new PRe.CredentialsProviderError(
            u.message ||
              `Cannot load config for profile ${r} in SDK configuration files with getter: ${e}`,
          )
        }
      }
  Ug.fromSharedConfigFiles = RRe
})
var KV = l((Lg) => {
  'use strict'
  Object.defineProperty(Lg, '__esModule', { value: !0 })
  Lg.fromStatic = void 0
  var DRe = Y(),
    ARe = (e) => typeof e == 'function',
    ORe = (e) => (ARe(e) ? async () => await e() : (0, DRe.fromStatic)(e))
  Lg.fromStatic = ORe
})
var XV = l((Bg) => {
  'use strict'
  Object.defineProperty(Bg, '__esModule', { value: !0 })
  Bg.loadConfig = void 0
  var JV = Y(),
    NRe = WV(),
    qRe = YV(),
    kRe = KV(),
    MRe = (
      { environmentVariableSelector: e, configFileSelector: t, default: n },
      r = {},
    ) =>
      (0, JV.memoize)(
        (0, JV.chain)(
          (0, NRe.fromEnv)(e),
          (0, qRe.fromSharedConfigFiles)(t, r),
          (0, kRe.fromStatic)(n),
        ),
      )
  Bg.loadConfig = MRe
})
var QV = l((nP) => {
  'use strict'
  Object.defineProperty(nP, '__esModule', { value: !0 })
  var FRe = (x(), w(T))
  FRe.__exportStar(XV(), nP)
})
var e6 = l((jg) => {
  'use strict'
  Object.defineProperty(jg, '__esModule', { value: !0 })
  jg.calculateBodyLength = void 0
  var ZV = require('fs'),
    URe = (e) => {
      if (!e) return 0
      if (typeof e == 'string') return Buffer.from(e).length
      if (typeof e.byteLength == 'number') return e.byteLength
      if (typeof e.size == 'number') return e.size
      if (typeof e.path == 'string' || Buffer.isBuffer(e.path))
        return (0, ZV.lstatSync)(e.path).size
      if (typeof e.fd == 'number') return (0, ZV.fstatSync)(e.fd).size
      throw new Error(`Body Length computation failed for ${e}`)
    }
  jg.calculateBodyLength = URe
})
var t6 = l((rP) => {
  'use strict'
  Object.defineProperty(rP, '__esModule', { value: !0 })
  var LRe = (x(), w(T))
  LRe.__exportStar(e6(), rP)
})
var y6 = l((Gg) => {
  'use strict'
  Object.defineProperty(Gg, '__esModule', { value: !0 })
  Gg.ruleSet = void 0
  var m6 = 'required',
    Qt = 'fn',
    Zt = 'argv',
    Ta = 'ref',
    n6 = 'isSet',
    ut = 'tree',
    wa = 'error',
    Fo = 'endpoint',
    sP = 'PartitionResult',
    oP = 'getAttr',
    r6 = 'stringEquals',
    s6 = { [m6]: !1, type: 'String' },
    o6 = { [m6]: !0, default: !1, type: 'Boolean' },
    i6 = { [Ta]: 'Endpoint' },
    p6 = { [Qt]: 'booleanEquals', [Zt]: [{ [Ta]: 'UseFIPS' }, !0] },
    f6 = { [Qt]: 'booleanEquals', [Zt]: [{ [Ta]: 'UseDualStack' }, !0] },
    kt = {},
    _6 = { [Ta]: 'Region' },
    a6 = {
      [Qt]: 'booleanEquals',
      [Zt]: [!0, { [Qt]: oP, [Zt]: [{ [Ta]: sP }, 'supportsFIPS'] }],
    },
    h6 = { [Ta]: sP },
    c6 = {
      [Qt]: 'booleanEquals',
      [Zt]: [!0, { [Qt]: oP, [Zt]: [h6, 'supportsDualStack'] }],
    },
    d6 = [p6],
    u6 = [f6],
    l6 = [_6],
    BRe = {
      version: '1.0',
      parameters: { Region: s6, UseDualStack: o6, UseFIPS: o6, Endpoint: s6 },
      rules: [
        {
          conditions: [{ [Qt]: n6, [Zt]: [i6] }],
          type: ut,
          rules: [
            {
              conditions: d6,
              error:
                'Invalid Configuration: FIPS and custom endpoint are not supported',
              type: wa,
            },
            {
              type: ut,
              rules: [
                {
                  conditions: u6,
                  error:
                    'Invalid Configuration: Dualstack and custom endpoint are not supported',
                  type: wa,
                },
                {
                  endpoint: { url: i6, properties: kt, headers: kt },
                  type: Fo,
                },
              ],
            },
          ],
        },
        {
          type: ut,
          rules: [
            {
              conditions: [{ [Qt]: n6, [Zt]: l6 }],
              type: ut,
              rules: [
                {
                  conditions: [{ [Qt]: 'aws.partition', [Zt]: l6, assign: sP }],
                  type: ut,
                  rules: [
                    {
                      conditions: [p6, f6],
                      type: ut,
                      rules: [
                        {
                          conditions: [a6, c6],
                          type: ut,
                          rules: [
                            {
                              type: ut,
                              rules: [
                                {
                                  endpoint: {
                                    url: 'https://dynamodb-fips.{Region}.{PartitionResult#dualStackDnsSuffix}',
                                    properties: kt,
                                    headers: kt,
                                  },
                                  type: Fo,
                                },
                              ],
                            },
                          ],
                        },
                        {
                          error:
                            'FIPS and DualStack are enabled, but this partition does not support one or both',
                          type: wa,
                        },
                      ],
                    },
                    {
                      conditions: d6,
                      type: ut,
                      rules: [
                        {
                          conditions: [a6],
                          type: ut,
                          rules: [
                            {
                              type: ut,
                              rules: [
                                {
                                  conditions: [
                                    {
                                      [Qt]: r6,
                                      [Zt]: [
                                        'aws-us-gov',
                                        { [Qt]: oP, [Zt]: [h6, 'name'] },
                                      ],
                                    },
                                  ],
                                  endpoint: {
                                    url: 'https://dynamodb.{Region}.amazonaws.com',
                                    properties: kt,
                                    headers: kt,
                                  },
                                  type: Fo,
                                },
                                {
                                  endpoint: {
                                    url: 'https://dynamodb-fips.{Region}.{PartitionResult#dnsSuffix}',
                                    properties: kt,
                                    headers: kt,
                                  },
                                  type: Fo,
                                },
                              ],
                            },
                          ],
                        },
                        {
                          error:
                            'FIPS is enabled but this partition does not support FIPS',
                          type: wa,
                        },
                      ],
                    },
                    {
                      conditions: u6,
                      type: ut,
                      rules: [
                        {
                          conditions: [c6],
                          type: ut,
                          rules: [
                            {
                              type: ut,
                              rules: [
                                {
                                  endpoint: {
                                    url: 'https://dynamodb.{Region}.{PartitionResult#dualStackDnsSuffix}',
                                    properties: kt,
                                    headers: kt,
                                  },
                                  type: Fo,
                                },
                              ],
                            },
                          ],
                        },
                        {
                          error:
                            'DualStack is enabled but this partition does not support DualStack',
                          type: wa,
                        },
                      ],
                    },
                    {
                      type: ut,
                      rules: [
                        {
                          conditions: [{ [Qt]: r6, [Zt]: [_6, 'local'] }],
                          endpoint: {
                            url: 'http://localhost:8000',
                            properties: {
                              authSchemes: [
                                {
                                  name: 'sigv4',
                                  signingName: 'dynamodb',
                                  signingRegion: 'us-east-1',
                                },
                              ],
                            },
                            headers: kt,
                          },
                          type: Fo,
                        },
                        {
                          endpoint: {
                            url: 'https://dynamodb.{Region}.{PartitionResult#dnsSuffix}',
                            properties: kt,
                            headers: kt,
                          },
                          type: Fo,
                        },
                      ],
                    },
                  ],
                },
              ],
            },
            { error: 'Invalid Configuration: Missing Region', type: wa },
          ],
        },
      ],
    }
  Gg.ruleSet = BRe
})
var g6 = l(($g) => {
  'use strict'
  Object.defineProperty($g, '__esModule', { value: !0 })
  $g.defaultEndpointResolver = void 0
  var jRe = Ai(),
    GRe = y6(),
    $Re = (e, t = {}) =>
      (0, jRe.resolveEndpoint)(GRe.ruleSet, {
        endpointParams: e,
        logger: t.logger,
      })
  $g.defaultEndpointResolver = $Re
})
var b6 = l((zg) => {
  'use strict'
  Object.defineProperty(zg, '__esModule', { value: !0 })
  zg.getRuntimeConfig = void 0
  var zRe = v(),
    HRe = vo(),
    E6 = Mi(),
    S6 = Pn(),
    WRe = g6(),
    VRe = (e) => ({
      apiVersion: '2012-08-10',
      base64Decoder: e?.base64Decoder ?? E6.fromBase64,
      base64Encoder: e?.base64Encoder ?? E6.toBase64,
      disableHostPrefix: e?.disableHostPrefix ?? !1,
      endpointProvider: e?.endpointProvider ?? WRe.defaultEndpointResolver,
      extensions: e?.extensions ?? [],
      logger: e?.logger ?? new zRe.NoOpLogger(),
      serviceId: e?.serviceId ?? 'DynamoDB',
      urlParser: e?.urlParser ?? HRe.parseUrl,
      utf8Decoder: e?.utf8Decoder ?? S6.fromUtf8,
      utf8Encoder: e?.utf8Encoder ?? S6.toUtf8,
    })
  zg.getRuntimeConfig = VRe
})
var w6 = l((Wg) => {
  'use strict'
  Object.defineProperty(Wg, '__esModule', { value: !0 })
  Wg.getRuntimeConfig = void 0
  var YRe = (x(), w(T)),
    KRe = YRe.__importDefault(X$()),
    JRe = HV(),
    XRe = FI(),
    QRe = HC(),
    ZRe = Uu(),
    Hg = An(),
    eDe = Lu(),
    v6 = Er(),
    xa = QV(),
    C6 = Li(),
    tDe = t6(),
    nDe = Kt(),
    rDe = b6(),
    sDe = v(),
    oDe = Gu(),
    iDe = v(),
    aDe = (e) => {
      ;(0, iDe.emitWarningIfUnsupportedVersion)(process.version)
      let t = (0, oDe.resolveDefaultsModeConfig)(e),
        n = () => t().then(sDe.loadConfigsForDefaultMode),
        r = (0, rDe.getRuntimeConfig)(e)
      return {
        ...r,
        ...e,
        runtime: 'node',
        defaultsMode: t,
        bodyLengthChecker: e?.bodyLengthChecker ?? tDe.calculateBodyLength,
        credentialDefaultProvider:
          e?.credentialDefaultProvider ??
          (0, JRe.decorateDefaultCredentialProvider)(XRe.defaultProvider),
        defaultUserAgentProvider:
          e?.defaultUserAgentProvider ??
          (0, ZRe.defaultUserAgent)({
            serviceId: r.serviceId,
            clientVersion: KRe.default.version,
          }),
        endpointDiscoveryEnabledProvider:
          e?.endpointDiscoveryEnabledProvider ??
          (0, xa.loadConfig)(QRe.NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS),
        maxAttempts:
          e?.maxAttempts ??
          (0, xa.loadConfig)(v6.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region:
          e?.region ??
          (0, xa.loadConfig)(
            Hg.NODE_REGION_CONFIG_OPTIONS,
            Hg.NODE_REGION_CONFIG_FILE_OPTIONS,
          ),
        requestHandler: e?.requestHandler ?? new C6.NodeHttpHandler(n),
        retryMode:
          e?.retryMode ??
          (0, xa.loadConfig)({
            ...v6.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async () =>
              (await n()).retryMode || nDe.DEFAULT_RETRY_MODE,
          }),
        sha256: e?.sha256 ?? eDe.Hash.bind(null, 'sha256'),
        streamCollector: e?.streamCollector ?? C6.streamCollector,
        useDualstackEndpoint:
          e?.useDualstackEndpoint ??
          (0, xa.loadConfig)(Hg.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint:
          e?.useFipsEndpoint ??
          (0, xa.loadConfig)(Hg.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS),
      }
    }
  Wg.getRuntimeConfig = aDe
})
var x6 = l((Vg) => {
  'use strict'
  Object.defineProperty(Vg, '__esModule', { value: !0 })
  Vg.resolveRuntimeExtensions = void 0
  var T6 = Vr(),
    cDe = (e) => e,
    dDe = (e, t) => {
      let n = { ...cDe((0, T6.getDefaultClientConfiguration)(e)) }
      return (
        t.forEach((r) => r.configureClient(n)),
        { ...e, ...(0, T6.resolveDefaultRuntimeConfig)(n) }
      )
    }
  Vg.resolveRuntimeExtensions = dDe
})
var Ar = l((Ia) => {
  'use strict'
  Object.defineProperty(Ia, '__esModule', { value: !0 })
  Ia.DynamoDBClient = Ia.__Client = void 0
  var uDe = HC(),
    I6 = Yd(),
    lDe = Kd(),
    mDe = Jd(),
    P6 = fr(),
    R6 = du(),
    pDe = An(),
    fDe = mu(),
    _De = D(),
    D6 = Er(),
    A6 = v()
  Object.defineProperty(Ia, '__Client', {
    enumerable: !0,
    get: function () {
      return A6.Client
    },
  })
  var hDe = Eh(),
    yDe = J$(),
    gDe = w6(),
    EDe = x6(),
    iP = class extends A6.Client {
      constructor(...[t]) {
        let n = (0, gDe.getRuntimeConfig)(t || {}),
          r = (0, yDe.resolveClientEndpointParameters)(n),
          s = (0, pDe.resolveRegionConfig)(r),
          o = (0, _De.resolveEndpointConfig)(s),
          i = (0, D6.resolveRetryConfig)(o),
          c = (0, I6.resolveHostHeaderConfig)(i),
          a = (0, P6.resolveAwsAuthConfig)(c),
          u = (0, R6.resolveUserAgentConfig)(a),
          d = (0, uDe.resolveEndpointDiscoveryConfig)(u, {
            endpointDiscoveryCommandCtor: hDe.DescribeEndpointsCommand,
          }),
          p = (0, EDe.resolveRuntimeExtensions)(d, t?.extensions || [])
        super(p),
          (this.config = p),
          this.middlewareStack.use((0, D6.getRetryPlugin)(this.config)),
          this.middlewareStack.use(
            (0, fDe.getContentLengthPlugin)(this.config),
          ),
          this.middlewareStack.use((0, I6.getHostHeaderPlugin)(this.config)),
          this.middlewareStack.use((0, lDe.getLoggerPlugin)(this.config)),
          this.middlewareStack.use(
            (0, mDe.getRecursionDetectionPlugin)(this.config),
          ),
          this.middlewareStack.use((0, P6.getAwsAuthPlugin)(this.config)),
          this.middlewareStack.use((0, R6.getUserAgentPlugin)(this.config))
      }
      destroy() {
        super.destroy()
      }
    }
  Ia.DynamoDBClient = iP
})
var cP = l((Pa) => {
  'use strict'
  Object.defineProperty(Pa, '__esModule', { value: !0 })
  Pa.BatchExecuteStatementCommand = Pa.$Command = void 0
  var SDe = D(),
    bDe = O(),
    N6 = v()
  Object.defineProperty(Pa, '$Command', {
    enumerable: !0,
    get: function () {
      return N6.Command
    },
  })
  var O6 = M(),
    aP = class e extends N6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, bDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, SDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'BatchExecuteStatementCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, O6.se_BatchExecuteStatementCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, O6.de_BatchExecuteStatementCommand)(t, n)
      }
    }
  Pa.BatchExecuteStatementCommand = aP
})
var uP = l((Ra) => {
  'use strict'
  Object.defineProperty(Ra, '__esModule', { value: !0 })
  Ra.BatchGetItemCommand = Ra.$Command = void 0
  var vDe = D(),
    CDe = O(),
    k6 = v()
  Object.defineProperty(Ra, '$Command', {
    enumerable: !0,
    get: function () {
      return k6.Command
    },
  })
  var q6 = M(),
    dP = class e extends k6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, CDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, vDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'BatchGetItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, q6.se_BatchGetItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, q6.de_BatchGetItemCommand)(t, n)
      }
    }
  Ra.BatchGetItemCommand = dP
})
var mP = l((Da) => {
  'use strict'
  Object.defineProperty(Da, '__esModule', { value: !0 })
  Da.BatchWriteItemCommand = Da.$Command = void 0
  var wDe = D(),
    TDe = O(),
    F6 = v()
  Object.defineProperty(Da, '$Command', {
    enumerable: !0,
    get: function () {
      return F6.Command
    },
  })
  var M6 = M(),
    lP = class e extends F6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, TDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, wDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'BatchWriteItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, M6.se_BatchWriteItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, M6.de_BatchWriteItemCommand)(t, n)
      }
    }
  Da.BatchWriteItemCommand = lP
})
var fP = l((Aa) => {
  'use strict'
  Object.defineProperty(Aa, '__esModule', { value: !0 })
  Aa.CreateBackupCommand = Aa.$Command = void 0
  var xDe = D(),
    IDe = O(),
    L6 = v()
  Object.defineProperty(Aa, '$Command', {
    enumerable: !0,
    get: function () {
      return L6.Command
    },
  })
  var U6 = M(),
    pP = class e extends L6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, IDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, xDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'CreateBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, U6.se_CreateBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, U6.de_CreateBackupCommand)(t, n)
      }
    }
  Aa.CreateBackupCommand = pP
})
var hP = l((Oa) => {
  'use strict'
  Object.defineProperty(Oa, '__esModule', { value: !0 })
  Oa.CreateGlobalTableCommand = Oa.$Command = void 0
  var PDe = D(),
    RDe = O(),
    j6 = v()
  Object.defineProperty(Oa, '$Command', {
    enumerable: !0,
    get: function () {
      return j6.Command
    },
  })
  var B6 = M(),
    _P = class e extends j6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, RDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, PDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'CreateGlobalTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, B6.se_CreateGlobalTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, B6.de_CreateGlobalTableCommand)(t, n)
      }
    }
  Oa.CreateGlobalTableCommand = _P
})
var gP = l((Na) => {
  'use strict'
  Object.defineProperty(Na, '__esModule', { value: !0 })
  Na.CreateTableCommand = Na.$Command = void 0
  var DDe = D(),
    ADe = O(),
    $6 = v()
  Object.defineProperty(Na, '$Command', {
    enumerable: !0,
    get: function () {
      return $6.Command
    },
  })
  var G6 = M(),
    yP = class e extends $6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ADe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, DDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'CreateTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, G6.se_CreateTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, G6.de_CreateTableCommand)(t, n)
      }
    }
  Na.CreateTableCommand = yP
})
var SP = l((qa) => {
  'use strict'
  Object.defineProperty(qa, '__esModule', { value: !0 })
  qa.DeleteBackupCommand = qa.$Command = void 0
  var ODe = D(),
    NDe = O(),
    H6 = v()
  Object.defineProperty(qa, '$Command', {
    enumerable: !0,
    get: function () {
      return H6.Command
    },
  })
  var z6 = M(),
    EP = class e extends H6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, NDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, ODe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DeleteBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, z6.se_DeleteBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, z6.de_DeleteBackupCommand)(t, n)
      }
    }
  qa.DeleteBackupCommand = EP
})
var vP = l((ka) => {
  'use strict'
  Object.defineProperty(ka, '__esModule', { value: !0 })
  ka.DeleteItemCommand = ka.$Command = void 0
  var qDe = D(),
    kDe = O(),
    V6 = v()
  Object.defineProperty(ka, '$Command', {
    enumerable: !0,
    get: function () {
      return V6.Command
    },
  })
  var W6 = M(),
    bP = class e extends V6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, kDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, qDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DeleteItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, W6.se_DeleteItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, W6.de_DeleteItemCommand)(t, n)
      }
    }
  ka.DeleteItemCommand = bP
})
var wP = l((Ma) => {
  'use strict'
  Object.defineProperty(Ma, '__esModule', { value: !0 })
  Ma.DeleteTableCommand = Ma.$Command = void 0
  var MDe = D(),
    FDe = O(),
    K6 = v()
  Object.defineProperty(Ma, '$Command', {
    enumerable: !0,
    get: function () {
      return K6.Command
    },
  })
  var Y6 = M(),
    CP = class e extends K6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, FDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, MDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DeleteTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, Y6.se_DeleteTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Y6.de_DeleteTableCommand)(t, n)
      }
    }
  Ma.DeleteTableCommand = CP
})
var xP = l((Fa) => {
  'use strict'
  Object.defineProperty(Fa, '__esModule', { value: !0 })
  Fa.DescribeBackupCommand = Fa.$Command = void 0
  var UDe = D(),
    LDe = O(),
    X6 = v()
  Object.defineProperty(Fa, '$Command', {
    enumerable: !0,
    get: function () {
      return X6.Command
    },
  })
  var J6 = M(),
    TP = class e extends X6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, LDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, UDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, J6.se_DescribeBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, J6.de_DescribeBackupCommand)(t, n)
      }
    }
  Fa.DescribeBackupCommand = TP
})
var PP = l((Ua) => {
  'use strict'
  Object.defineProperty(Ua, '__esModule', { value: !0 })
  Ua.DescribeContinuousBackupsCommand = Ua.$Command = void 0
  var BDe = D(),
    jDe = O(),
    Z6 = v()
  Object.defineProperty(Ua, '$Command', {
    enumerable: !0,
    get: function () {
      return Z6.Command
    },
  })
  var Q6 = M(),
    IP = class e extends Z6.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, jDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, BDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeContinuousBackupsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, Q6.se_DescribeContinuousBackupsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, Q6.de_DescribeContinuousBackupsCommand)(t, n)
      }
    }
  Ua.DescribeContinuousBackupsCommand = IP
})
var DP = l((La) => {
  'use strict'
  Object.defineProperty(La, '__esModule', { value: !0 })
  La.DescribeContributorInsightsCommand = La.$Command = void 0
  var GDe = D(),
    $De = O(),
    tY = v()
  Object.defineProperty(La, '$Command', {
    enumerable: !0,
    get: function () {
      return tY.Command
    },
  })
  var eY = M(),
    RP = class e extends tY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, $De.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, GDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeContributorInsightsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, eY.se_DescribeContributorInsightsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, eY.de_DescribeContributorInsightsCommand)(t, n)
      }
    }
  La.DescribeContributorInsightsCommand = RP
})
var OP = l((Ba) => {
  'use strict'
  Object.defineProperty(Ba, '__esModule', { value: !0 })
  Ba.DescribeExportCommand = Ba.$Command = void 0
  var zDe = D(),
    HDe = O(),
    rY = v()
  Object.defineProperty(Ba, '$Command', {
    enumerable: !0,
    get: function () {
      return rY.Command
    },
  })
  var nY = M(),
    AP = class e extends rY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, HDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, zDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeExportCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, nY.se_DescribeExportCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, nY.de_DescribeExportCommand)(t, n)
      }
    }
  Ba.DescribeExportCommand = AP
})
var qP = l((ja) => {
  'use strict'
  Object.defineProperty(ja, '__esModule', { value: !0 })
  ja.DescribeGlobalTableCommand = ja.$Command = void 0
  var WDe = D(),
    VDe = O(),
    oY = v()
  Object.defineProperty(ja, '$Command', {
    enumerable: !0,
    get: function () {
      return oY.Command
    },
  })
  var sY = M(),
    NP = class e extends oY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, VDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, WDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeGlobalTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, sY.se_DescribeGlobalTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, sY.de_DescribeGlobalTableCommand)(t, n)
      }
    }
  ja.DescribeGlobalTableCommand = NP
})
var MP = l((Ga) => {
  'use strict'
  Object.defineProperty(Ga, '__esModule', { value: !0 })
  Ga.DescribeGlobalTableSettingsCommand = Ga.$Command = void 0
  var YDe = D(),
    KDe = O(),
    aY = v()
  Object.defineProperty(Ga, '$Command', {
    enumerable: !0,
    get: function () {
      return aY.Command
    },
  })
  var iY = M(),
    kP = class e extends aY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, KDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, YDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeGlobalTableSettingsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, iY.se_DescribeGlobalTableSettingsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, iY.de_DescribeGlobalTableSettingsCommand)(t, n)
      }
    }
  Ga.DescribeGlobalTableSettingsCommand = kP
})
var UP = l(($a) => {
  'use strict'
  Object.defineProperty($a, '__esModule', { value: !0 })
  $a.DescribeImportCommand = $a.$Command = void 0
  var JDe = D(),
    XDe = O(),
    dY = v()
  Object.defineProperty($a, '$Command', {
    enumerable: !0,
    get: function () {
      return dY.Command
    },
  })
  var cY = M(),
    FP = class e extends dY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, XDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, JDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeImportCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, cY.se_DescribeImportCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, cY.de_DescribeImportCommand)(t, n)
      }
    }
  $a.DescribeImportCommand = FP
})
var BP = l((za) => {
  'use strict'
  Object.defineProperty(za, '__esModule', { value: !0 })
  za.DescribeKinesisStreamingDestinationCommand = za.$Command = void 0
  var QDe = D(),
    ZDe = O(),
    lY = v()
  Object.defineProperty(za, '$Command', {
    enumerable: !0,
    get: function () {
      return lY.Command
    },
  })
  var uY = M(),
    LP = class e extends lY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ZDe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, QDe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeKinesisStreamingDestinationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, uY.se_DescribeKinesisStreamingDestinationCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, uY.de_DescribeKinesisStreamingDestinationCommand)(t, n)
      }
    }
  za.DescribeKinesisStreamingDestinationCommand = LP
})
var GP = l((Ha) => {
  'use strict'
  Object.defineProperty(Ha, '__esModule', { value: !0 })
  Ha.DescribeLimitsCommand = Ha.$Command = void 0
  var eAe = D(),
    tAe = O(),
    pY = v()
  Object.defineProperty(Ha, '$Command', {
    enumerable: !0,
    get: function () {
      return pY.Command
    },
  })
  var mY = M(),
    jP = class e extends pY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, tAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, eAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeLimitsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, mY.se_DescribeLimitsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, mY.de_DescribeLimitsCommand)(t, n)
      }
    }
  Ha.DescribeLimitsCommand = jP
})
var rl = l((Wa) => {
  'use strict'
  Object.defineProperty(Wa, '__esModule', { value: !0 })
  Wa.DescribeTableCommand = Wa.$Command = void 0
  var nAe = D(),
    rAe = O(),
    _Y = v()
  Object.defineProperty(Wa, '$Command', {
    enumerable: !0,
    get: function () {
      return _Y.Command
    },
  })
  var fY = M(),
    $P = class e extends _Y.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, rAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, nAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, fY.se_DescribeTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, fY.de_DescribeTableCommand)(t, n)
      }
    }
  Wa.DescribeTableCommand = $P
})
var HP = l((Va) => {
  'use strict'
  Object.defineProperty(Va, '__esModule', { value: !0 })
  Va.DescribeTableReplicaAutoScalingCommand = Va.$Command = void 0
  var sAe = D(),
    oAe = O(),
    yY = v()
  Object.defineProperty(Va, '$Command', {
    enumerable: !0,
    get: function () {
      return yY.Command
    },
  })
  var hY = M(),
    zP = class e extends yY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, oAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, sAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeTableReplicaAutoScalingCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, hY.se_DescribeTableReplicaAutoScalingCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, hY.de_DescribeTableReplicaAutoScalingCommand)(t, n)
      }
    }
  Va.DescribeTableReplicaAutoScalingCommand = zP
})
var VP = l((Ya) => {
  'use strict'
  Object.defineProperty(Ya, '__esModule', { value: !0 })
  Ya.DescribeTimeToLiveCommand = Ya.$Command = void 0
  var iAe = D(),
    aAe = O(),
    EY = v()
  Object.defineProperty(Ya, '$Command', {
    enumerable: !0,
    get: function () {
      return EY.Command
    },
  })
  var gY = M(),
    WP = class e extends EY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, aAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, iAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DescribeTimeToLiveCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, gY.se_DescribeTimeToLiveCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, gY.de_DescribeTimeToLiveCommand)(t, n)
      }
    }
  Ya.DescribeTimeToLiveCommand = WP
})
var KP = l((Ka) => {
  'use strict'
  Object.defineProperty(Ka, '__esModule', { value: !0 })
  Ka.DisableKinesisStreamingDestinationCommand = Ka.$Command = void 0
  var cAe = D(),
    dAe = O(),
    bY = v()
  Object.defineProperty(Ka, '$Command', {
    enumerable: !0,
    get: function () {
      return bY.Command
    },
  })
  var SY = M(),
    YP = class e extends bY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, dAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, cAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'DisableKinesisStreamingDestinationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, SY.se_DisableKinesisStreamingDestinationCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, SY.de_DisableKinesisStreamingDestinationCommand)(t, n)
      }
    }
  Ka.DisableKinesisStreamingDestinationCommand = YP
})
var XP = l((Ja) => {
  'use strict'
  Object.defineProperty(Ja, '__esModule', { value: !0 })
  Ja.EnableKinesisStreamingDestinationCommand = Ja.$Command = void 0
  var uAe = D(),
    lAe = O(),
    CY = v()
  Object.defineProperty(Ja, '$Command', {
    enumerable: !0,
    get: function () {
      return CY.Command
    },
  })
  var vY = M(),
    JP = class e extends CY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, lAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, uAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'EnableKinesisStreamingDestinationCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, vY.se_EnableKinesisStreamingDestinationCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, vY.de_EnableKinesisStreamingDestinationCommand)(t, n)
      }
    }
  Ja.EnableKinesisStreamingDestinationCommand = JP
})
var ZP = l((Xa) => {
  'use strict'
  Object.defineProperty(Xa, '__esModule', { value: !0 })
  Xa.ExecuteStatementCommand = Xa.$Command = void 0
  var mAe = D(),
    pAe = O(),
    TY = v()
  Object.defineProperty(Xa, '$Command', {
    enumerable: !0,
    get: function () {
      return TY.Command
    },
  })
  var wY = M(),
    QP = class e extends TY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, pAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, mAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ExecuteStatementCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, wY.se_ExecuteStatementCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, wY.de_ExecuteStatementCommand)(t, n)
      }
    }
  Xa.ExecuteStatementCommand = QP
})
var tR = l((Qa) => {
  'use strict'
  Object.defineProperty(Qa, '__esModule', { value: !0 })
  Qa.ExecuteTransactionCommand = Qa.$Command = void 0
  var fAe = D(),
    _Ae = O(),
    IY = v()
  Object.defineProperty(Qa, '$Command', {
    enumerable: !0,
    get: function () {
      return IY.Command
    },
  })
  var xY = M(),
    eR = class e extends IY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, _Ae.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, fAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ExecuteTransactionCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, xY.se_ExecuteTransactionCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, xY.de_ExecuteTransactionCommand)(t, n)
      }
    }
  Qa.ExecuteTransactionCommand = eR
})
var rR = l((Za) => {
  'use strict'
  Object.defineProperty(Za, '__esModule', { value: !0 })
  Za.ExportTableToPointInTimeCommand = Za.$Command = void 0
  var hAe = D(),
    yAe = O(),
    RY = v()
  Object.defineProperty(Za, '$Command', {
    enumerable: !0,
    get: function () {
      return RY.Command
    },
  })
  var PY = M(),
    nR = class e extends RY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, yAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, hAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ExportTableToPointInTimeCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, PY.se_ExportTableToPointInTimeCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, PY.de_ExportTableToPointInTimeCommand)(t, n)
      }
    }
  Za.ExportTableToPointInTimeCommand = nR
})
var oR = l((ec) => {
  'use strict'
  Object.defineProperty(ec, '__esModule', { value: !0 })
  ec.GetItemCommand = ec.$Command = void 0
  var gAe = D(),
    EAe = O(),
    AY = v()
  Object.defineProperty(ec, '$Command', {
    enumerable: !0,
    get: function () {
      return AY.Command
    },
  })
  var DY = M(),
    sR = class e extends AY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, EAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, gAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'GetItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, DY.se_GetItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, DY.de_GetItemCommand)(t, n)
      }
    }
  ec.GetItemCommand = sR
})
var aR = l((tc) => {
  'use strict'
  Object.defineProperty(tc, '__esModule', { value: !0 })
  tc.ImportTableCommand = tc.$Command = void 0
  var SAe = D(),
    bAe = O(),
    NY = v()
  Object.defineProperty(tc, '$Command', {
    enumerable: !0,
    get: function () {
      return NY.Command
    },
  })
  var OY = M(),
    iR = class e extends NY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, bAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, SAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ImportTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, OY.se_ImportTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, OY.de_ImportTableCommand)(t, n)
      }
    }
  tc.ImportTableCommand = iR
})
var dR = l((nc) => {
  'use strict'
  Object.defineProperty(nc, '__esModule', { value: !0 })
  nc.ListBackupsCommand = nc.$Command = void 0
  var vAe = D(),
    CAe = O(),
    kY = v()
  Object.defineProperty(nc, '$Command', {
    enumerable: !0,
    get: function () {
      return kY.Command
    },
  })
  var qY = M(),
    cR = class e extends kY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, CAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, vAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListBackupsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, qY.se_ListBackupsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, qY.de_ListBackupsCommand)(t, n)
      }
    }
  nc.ListBackupsCommand = cR
})
var Yg = l((rc) => {
  'use strict'
  Object.defineProperty(rc, '__esModule', { value: !0 })
  rc.ListContributorInsightsCommand = rc.$Command = void 0
  var wAe = D(),
    TAe = O(),
    FY = v()
  Object.defineProperty(rc, '$Command', {
    enumerable: !0,
    get: function () {
      return FY.Command
    },
  })
  var MY = M(),
    uR = class e extends FY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, TAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, wAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListContributorInsightsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, MY.se_ListContributorInsightsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, MY.de_ListContributorInsightsCommand)(t, n)
      }
    }
  rc.ListContributorInsightsCommand = uR
})
var Kg = l((sc) => {
  'use strict'
  Object.defineProperty(sc, '__esModule', { value: !0 })
  sc.ListExportsCommand = sc.$Command = void 0
  var xAe = D(),
    IAe = O(),
    LY = v()
  Object.defineProperty(sc, '$Command', {
    enumerable: !0,
    get: function () {
      return LY.Command
    },
  })
  var UY = M(),
    lR = class e extends LY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, IAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, xAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListExportsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, UY.se_ListExportsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, UY.de_ListExportsCommand)(t, n)
      }
    }
  sc.ListExportsCommand = lR
})
var pR = l((oc) => {
  'use strict'
  Object.defineProperty(oc, '__esModule', { value: !0 })
  oc.ListGlobalTablesCommand = oc.$Command = void 0
  var PAe = D(),
    RAe = O(),
    jY = v()
  Object.defineProperty(oc, '$Command', {
    enumerable: !0,
    get: function () {
      return jY.Command
    },
  })
  var BY = M(),
    mR = class e extends jY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, RAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, PAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListGlobalTablesCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, BY.se_ListGlobalTablesCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, BY.de_ListGlobalTablesCommand)(t, n)
      }
    }
  oc.ListGlobalTablesCommand = mR
})
var Jg = l((ic) => {
  'use strict'
  Object.defineProperty(ic, '__esModule', { value: !0 })
  ic.ListImportsCommand = ic.$Command = void 0
  var DAe = D(),
    AAe = O(),
    $Y = v()
  Object.defineProperty(ic, '$Command', {
    enumerable: !0,
    get: function () {
      return $Y.Command
    },
  })
  var GY = M(),
    fR = class e extends $Y.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, AAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, DAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListImportsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, GY.se_ListImportsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, GY.de_ListImportsCommand)(t, n)
      }
    }
  ic.ListImportsCommand = fR
})
var Xg = l((ac) => {
  'use strict'
  Object.defineProperty(ac, '__esModule', { value: !0 })
  ac.ListTablesCommand = ac.$Command = void 0
  var OAe = D(),
    NAe = O(),
    HY = v()
  Object.defineProperty(ac, '$Command', {
    enumerable: !0,
    get: function () {
      return HY.Command
    },
  })
  var zY = M(),
    _R = class e extends HY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, NAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, OAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListTablesCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, zY.se_ListTablesCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, zY.de_ListTablesCommand)(t, n)
      }
    }
  ac.ListTablesCommand = _R
})
var yR = l((cc) => {
  'use strict'
  Object.defineProperty(cc, '__esModule', { value: !0 })
  cc.ListTagsOfResourceCommand = cc.$Command = void 0
  var qAe = D(),
    kAe = O(),
    VY = v()
  Object.defineProperty(cc, '$Command', {
    enumerable: !0,
    get: function () {
      return VY.Command
    },
  })
  var WY = M(),
    hR = class e extends VY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, kAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, qAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ListTagsOfResourceCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, WY.se_ListTagsOfResourceCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, WY.de_ListTagsOfResourceCommand)(t, n)
      }
    }
  cc.ListTagsOfResourceCommand = hR
})
var ER = l((dc) => {
  'use strict'
  Object.defineProperty(dc, '__esModule', { value: !0 })
  dc.PutItemCommand = dc.$Command = void 0
  var MAe = D(),
    FAe = O(),
    KY = v()
  Object.defineProperty(dc, '$Command', {
    enumerable: !0,
    get: function () {
      return KY.Command
    },
  })
  var YY = M(),
    gR = class e extends KY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, FAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, MAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'PutItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, YY.se_PutItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, YY.de_PutItemCommand)(t, n)
      }
    }
  dc.PutItemCommand = gR
})
var Qg = l((uc) => {
  'use strict'
  Object.defineProperty(uc, '__esModule', { value: !0 })
  uc.QueryCommand = uc.$Command = void 0
  var UAe = D(),
    LAe = O(),
    XY = v()
  Object.defineProperty(uc, '$Command', {
    enumerable: !0,
    get: function () {
      return XY.Command
    },
  })
  var JY = M(),
    SR = class e extends XY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, LAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, UAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'QueryCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, JY.se_QueryCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, JY.de_QueryCommand)(t, n)
      }
    }
  uc.QueryCommand = SR
})
var vR = l((lc) => {
  'use strict'
  Object.defineProperty(lc, '__esModule', { value: !0 })
  lc.RestoreTableFromBackupCommand = lc.$Command = void 0
  var BAe = D(),
    jAe = O(),
    ZY = v()
  Object.defineProperty(lc, '$Command', {
    enumerable: !0,
    get: function () {
      return ZY.Command
    },
  })
  var QY = M(),
    bR = class e extends ZY.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, jAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, BAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'RestoreTableFromBackupCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, QY.se_RestoreTableFromBackupCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, QY.de_RestoreTableFromBackupCommand)(t, n)
      }
    }
  lc.RestoreTableFromBackupCommand = bR
})
var wR = l((mc) => {
  'use strict'
  Object.defineProperty(mc, '__esModule', { value: !0 })
  mc.RestoreTableToPointInTimeCommand = mc.$Command = void 0
  var GAe = D(),
    $Ae = O(),
    t8 = v()
  Object.defineProperty(mc, '$Command', {
    enumerable: !0,
    get: function () {
      return t8.Command
    },
  })
  var e8 = M(),
    CR = class e extends t8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, $Ae.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, GAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'RestoreTableToPointInTimeCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, e8.se_RestoreTableToPointInTimeCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, e8.de_RestoreTableToPointInTimeCommand)(t, n)
      }
    }
  mc.RestoreTableToPointInTimeCommand = CR
})
var Zg = l((pc) => {
  'use strict'
  Object.defineProperty(pc, '__esModule', { value: !0 })
  pc.ScanCommand = pc.$Command = void 0
  var zAe = D(),
    HAe = O(),
    r8 = v()
  Object.defineProperty(pc, '$Command', {
    enumerable: !0,
    get: function () {
      return r8.Command
    },
  })
  var n8 = M(),
    TR = class e extends r8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, HAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, zAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'ScanCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, n8.se_ScanCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, n8.de_ScanCommand)(t, n)
      }
    }
  pc.ScanCommand = TR
})
var IR = l((fc) => {
  'use strict'
  Object.defineProperty(fc, '__esModule', { value: !0 })
  fc.TagResourceCommand = fc.$Command = void 0
  var WAe = D(),
    VAe = O(),
    o8 = v()
  Object.defineProperty(fc, '$Command', {
    enumerable: !0,
    get: function () {
      return o8.Command
    },
  })
  var s8 = M(),
    xR = class e extends o8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, VAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, WAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'TagResourceCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, s8.se_TagResourceCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, s8.de_TagResourceCommand)(t, n)
      }
    }
  fc.TagResourceCommand = xR
})
var RR = l((_c) => {
  'use strict'
  Object.defineProperty(_c, '__esModule', { value: !0 })
  _c.TransactGetItemsCommand = _c.$Command = void 0
  var YAe = D(),
    KAe = O(),
    a8 = v()
  Object.defineProperty(_c, '$Command', {
    enumerable: !0,
    get: function () {
      return a8.Command
    },
  })
  var i8 = M(),
    PR = class e extends a8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, KAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, YAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'TransactGetItemsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, i8.se_TransactGetItemsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, i8.de_TransactGetItemsCommand)(t, n)
      }
    }
  _c.TransactGetItemsCommand = PR
})
var AR = l((hc) => {
  'use strict'
  Object.defineProperty(hc, '__esModule', { value: !0 })
  hc.TransactWriteItemsCommand = hc.$Command = void 0
  var JAe = D(),
    XAe = O(),
    d8 = v()
  Object.defineProperty(hc, '$Command', {
    enumerable: !0,
    get: function () {
      return d8.Command
    },
  })
  var c8 = M(),
    DR = class e extends d8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, XAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, JAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'TransactWriteItemsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, c8.se_TransactWriteItemsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, c8.de_TransactWriteItemsCommand)(t, n)
      }
    }
  hc.TransactWriteItemsCommand = DR
})
var NR = l((yc) => {
  'use strict'
  Object.defineProperty(yc, '__esModule', { value: !0 })
  yc.UntagResourceCommand = yc.$Command = void 0
  var QAe = D(),
    ZAe = O(),
    l8 = v()
  Object.defineProperty(yc, '$Command', {
    enumerable: !0,
    get: function () {
      return l8.Command
    },
  })
  var u8 = M(),
    OR = class e extends l8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, ZAe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, QAe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UntagResourceCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, u8.se_UntagResourceCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, u8.de_UntagResourceCommand)(t, n)
      }
    }
  yc.UntagResourceCommand = OR
})
var kR = l((gc) => {
  'use strict'
  Object.defineProperty(gc, '__esModule', { value: !0 })
  gc.UpdateContinuousBackupsCommand = gc.$Command = void 0
  var eOe = D(),
    tOe = O(),
    p8 = v()
  Object.defineProperty(gc, '$Command', {
    enumerable: !0,
    get: function () {
      return p8.Command
    },
  })
  var m8 = M(),
    qR = class e extends p8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, tOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, eOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateContinuousBackupsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, m8.se_UpdateContinuousBackupsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, m8.de_UpdateContinuousBackupsCommand)(t, n)
      }
    }
  gc.UpdateContinuousBackupsCommand = qR
})
var FR = l((Ec) => {
  'use strict'
  Object.defineProperty(Ec, '__esModule', { value: !0 })
  Ec.UpdateContributorInsightsCommand = Ec.$Command = void 0
  var nOe = D(),
    rOe = O(),
    _8 = v()
  Object.defineProperty(Ec, '$Command', {
    enumerable: !0,
    get: function () {
      return _8.Command
    },
  })
  var f8 = M(),
    MR = class e extends _8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, rOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, nOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateContributorInsightsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, f8.se_UpdateContributorInsightsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, f8.de_UpdateContributorInsightsCommand)(t, n)
      }
    }
  Ec.UpdateContributorInsightsCommand = MR
})
var LR = l((Sc) => {
  'use strict'
  Object.defineProperty(Sc, '__esModule', { value: !0 })
  Sc.UpdateGlobalTableCommand = Sc.$Command = void 0
  var sOe = D(),
    oOe = O(),
    y8 = v()
  Object.defineProperty(Sc, '$Command', {
    enumerable: !0,
    get: function () {
      return y8.Command
    },
  })
  var h8 = M(),
    UR = class e extends y8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, oOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, sOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateGlobalTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, h8.se_UpdateGlobalTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, h8.de_UpdateGlobalTableCommand)(t, n)
      }
    }
  Sc.UpdateGlobalTableCommand = UR
})
var jR = l((bc) => {
  'use strict'
  Object.defineProperty(bc, '__esModule', { value: !0 })
  bc.UpdateGlobalTableSettingsCommand = bc.$Command = void 0
  var iOe = D(),
    aOe = O(),
    E8 = v()
  Object.defineProperty(bc, '$Command', {
    enumerable: !0,
    get: function () {
      return E8.Command
    },
  })
  var g8 = M(),
    BR = class e extends E8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, aOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, iOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateGlobalTableSettingsCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, g8.se_UpdateGlobalTableSettingsCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, g8.de_UpdateGlobalTableSettingsCommand)(t, n)
      }
    }
  bc.UpdateGlobalTableSettingsCommand = BR
})
var $R = l((vc) => {
  'use strict'
  Object.defineProperty(vc, '__esModule', { value: !0 })
  vc.UpdateItemCommand = vc.$Command = void 0
  var cOe = D(),
    dOe = O(),
    b8 = v()
  Object.defineProperty(vc, '$Command', {
    enumerable: !0,
    get: function () {
      return b8.Command
    },
  })
  var S8 = M(),
    GR = class e extends b8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, dOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, cOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateItemCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, S8.se_UpdateItemCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, S8.de_UpdateItemCommand)(t, n)
      }
    }
  vc.UpdateItemCommand = GR
})
var HR = l((Cc) => {
  'use strict'
  Object.defineProperty(Cc, '__esModule', { value: !0 })
  Cc.UpdateTableCommand = Cc.$Command = void 0
  var uOe = D(),
    lOe = O(),
    C8 = v()
  Object.defineProperty(Cc, '$Command', {
    enumerable: !0,
    get: function () {
      return C8.Command
    },
  })
  var v8 = M(),
    zR = class e extends C8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, lOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, uOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateTableCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, v8.se_UpdateTableCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, v8.de_UpdateTableCommand)(t, n)
      }
    }
  Cc.UpdateTableCommand = zR
})
var VR = l((wc) => {
  'use strict'
  Object.defineProperty(wc, '__esModule', { value: !0 })
  wc.UpdateTableReplicaAutoScalingCommand = wc.$Command = void 0
  var mOe = D(),
    pOe = O(),
    T8 = v()
  Object.defineProperty(wc, '$Command', {
    enumerable: !0,
    get: function () {
      return T8.Command
    },
  })
  var w8 = M(),
    WR = class e extends T8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, pOe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, mOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateTableReplicaAutoScalingCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, w8.se_UpdateTableReplicaAutoScalingCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, w8.de_UpdateTableReplicaAutoScalingCommand)(t, n)
      }
    }
  wc.UpdateTableReplicaAutoScalingCommand = WR
})
var KR = l((Tc) => {
  'use strict'
  Object.defineProperty(Tc, '__esModule', { value: !0 })
  Tc.UpdateTimeToLiveCommand = Tc.$Command = void 0
  var fOe = D(),
    _Oe = O(),
    I8 = v()
  Object.defineProperty(Tc, '$Command', {
    enumerable: !0,
    get: function () {
      return I8.Command
    },
  })
  var x8 = M(),
    YR = class e extends I8.Command {
      static getEndpointParameterInstructions() {
        return {
          UseFIPS: { type: 'builtInParams', name: 'useFipsEndpoint' },
          Endpoint: { type: 'builtInParams', name: 'endpoint' },
          Region: { type: 'builtInParams', name: 'region' },
          UseDualStack: { type: 'builtInParams', name: 'useDualstackEndpoint' },
        }
      }
      constructor(t) {
        super(), (this.input = t)
      }
      resolveMiddleware(t, n, r) {
        this.middlewareStack.use(
          (0, _Oe.getSerdePlugin)(n, this.serialize, this.deserialize),
        ),
          this.middlewareStack.use(
            (0, fOe.getEndpointPlugin)(n, e.getEndpointParameterInstructions()),
          )
        let s = t.concat(this.middlewareStack),
          { logger: o } = n,
          a = {
            logger: o,
            clientName: 'DynamoDBClient',
            commandName: 'UpdateTimeToLiveCommand',
            inputFilterSensitiveLog: (d) => d,
            outputFilterSensitiveLog: (d) => d,
          },
          { requestHandler: u } = n
        return s.resolve((d) => u.handle(d.request, r || {}), a)
      }
      serialize(t, n) {
        return (0, x8.se_UpdateTimeToLiveCommand)(t, n)
      }
      deserialize(t, n) {
        return (0, x8.de_UpdateTimeToLiveCommand)(t, n)
      }
    }
  Tc.UpdateTimeToLiveCommand = YR
})
var P8 = l((tE) => {
  'use strict'
  Object.defineProperty(tE, '__esModule', { value: !0 })
  tE.DynamoDB = void 0
  var hOe = v(),
    yOe = cP(),
    gOe = uP(),
    EOe = mP(),
    SOe = fP(),
    bOe = hP(),
    vOe = gP(),
    COe = SP(),
    wOe = vP(),
    TOe = wP(),
    xOe = xP(),
    IOe = PP(),
    POe = DP(),
    ROe = Eh(),
    DOe = OP(),
    AOe = qP(),
    OOe = MP(),
    NOe = UP(),
    qOe = BP(),
    kOe = GP(),
    MOe = rl(),
    FOe = HP(),
    UOe = VP(),
    LOe = KP(),
    BOe = XP(),
    jOe = ZP(),
    GOe = tR(),
    $Oe = rR(),
    zOe = oR(),
    HOe = aR(),
    WOe = dR(),
    VOe = Yg(),
    YOe = Kg(),
    KOe = pR(),
    JOe = Jg(),
    XOe = Xg(),
    QOe = yR(),
    ZOe = ER(),
    eNe = Qg(),
    tNe = vR(),
    nNe = wR(),
    rNe = Zg(),
    sNe = IR(),
    oNe = RR(),
    iNe = AR(),
    aNe = NR(),
    cNe = kR(),
    dNe = FR(),
    uNe = LR(),
    lNe = jR(),
    mNe = $R(),
    pNe = HR(),
    fNe = VR(),
    _Ne = KR(),
    hNe = Ar(),
    yNe = {
      BatchExecuteStatementCommand: yOe.BatchExecuteStatementCommand,
      BatchGetItemCommand: gOe.BatchGetItemCommand,
      BatchWriteItemCommand: EOe.BatchWriteItemCommand,
      CreateBackupCommand: SOe.CreateBackupCommand,
      CreateGlobalTableCommand: bOe.CreateGlobalTableCommand,
      CreateTableCommand: vOe.CreateTableCommand,
      DeleteBackupCommand: COe.DeleteBackupCommand,
      DeleteItemCommand: wOe.DeleteItemCommand,
      DeleteTableCommand: TOe.DeleteTableCommand,
      DescribeBackupCommand: xOe.DescribeBackupCommand,
      DescribeContinuousBackupsCommand: IOe.DescribeContinuousBackupsCommand,
      DescribeContributorInsightsCommand:
        POe.DescribeContributorInsightsCommand,
      DescribeEndpointsCommand: ROe.DescribeEndpointsCommand,
      DescribeExportCommand: DOe.DescribeExportCommand,
      DescribeGlobalTableCommand: AOe.DescribeGlobalTableCommand,
      DescribeGlobalTableSettingsCommand:
        OOe.DescribeGlobalTableSettingsCommand,
      DescribeImportCommand: NOe.DescribeImportCommand,
      DescribeKinesisStreamingDestinationCommand:
        qOe.DescribeKinesisStreamingDestinationCommand,
      DescribeLimitsCommand: kOe.DescribeLimitsCommand,
      DescribeTableCommand: MOe.DescribeTableCommand,
      DescribeTableReplicaAutoScalingCommand:
        FOe.DescribeTableReplicaAutoScalingCommand,
      DescribeTimeToLiveCommand: UOe.DescribeTimeToLiveCommand,
      DisableKinesisStreamingDestinationCommand:
        LOe.DisableKinesisStreamingDestinationCommand,
      EnableKinesisStreamingDestinationCommand:
        BOe.EnableKinesisStreamingDestinationCommand,
      ExecuteStatementCommand: jOe.ExecuteStatementCommand,
      ExecuteTransactionCommand: GOe.ExecuteTransactionCommand,
      ExportTableToPointInTimeCommand: $Oe.ExportTableToPointInTimeCommand,
      GetItemCommand: zOe.GetItemCommand,
      ImportTableCommand: HOe.ImportTableCommand,
      ListBackupsCommand: WOe.ListBackupsCommand,
      ListContributorInsightsCommand: VOe.ListContributorInsightsCommand,
      ListExportsCommand: YOe.ListExportsCommand,
      ListGlobalTablesCommand: KOe.ListGlobalTablesCommand,
      ListImportsCommand: JOe.ListImportsCommand,
      ListTablesCommand: XOe.ListTablesCommand,
      ListTagsOfResourceCommand: QOe.ListTagsOfResourceCommand,
      PutItemCommand: ZOe.PutItemCommand,
      QueryCommand: eNe.QueryCommand,
      RestoreTableFromBackupCommand: tNe.RestoreTableFromBackupCommand,
      RestoreTableToPointInTimeCommand: nNe.RestoreTableToPointInTimeCommand,
      ScanCommand: rNe.ScanCommand,
      TagResourceCommand: sNe.TagResourceCommand,
      TransactGetItemsCommand: oNe.TransactGetItemsCommand,
      TransactWriteItemsCommand: iNe.TransactWriteItemsCommand,
      UntagResourceCommand: aNe.UntagResourceCommand,
      UpdateContinuousBackupsCommand: cNe.UpdateContinuousBackupsCommand,
      UpdateContributorInsightsCommand: dNe.UpdateContributorInsightsCommand,
      UpdateGlobalTableCommand: uNe.UpdateGlobalTableCommand,
      UpdateGlobalTableSettingsCommand: lNe.UpdateGlobalTableSettingsCommand,
      UpdateItemCommand: mNe.UpdateItemCommand,
      UpdateTableCommand: pNe.UpdateTableCommand,
      UpdateTableReplicaAutoScalingCommand:
        fNe.UpdateTableReplicaAutoScalingCommand,
      UpdateTimeToLiveCommand: _Ne.UpdateTimeToLiveCommand,
    },
    eE = class extends hNe.DynamoDBClient {}
  tE.DynamoDB = eE
  ;(0, hOe.createAggregatedClient)(yNe, eE)
})
var R8 = l((k) => {
  'use strict'
  Object.defineProperty(k, '__esModule', { value: !0 })
  var G = (x(), w(T))
  G.__exportStar(cP(), k)
  G.__exportStar(uP(), k)
  G.__exportStar(mP(), k)
  G.__exportStar(fP(), k)
  G.__exportStar(hP(), k)
  G.__exportStar(gP(), k)
  G.__exportStar(SP(), k)
  G.__exportStar(vP(), k)
  G.__exportStar(wP(), k)
  G.__exportStar(xP(), k)
  G.__exportStar(PP(), k)
  G.__exportStar(DP(), k)
  G.__exportStar(Eh(), k)
  G.__exportStar(OP(), k)
  G.__exportStar(qP(), k)
  G.__exportStar(MP(), k)
  G.__exportStar(UP(), k)
  G.__exportStar(BP(), k)
  G.__exportStar(GP(), k)
  G.__exportStar(rl(), k)
  G.__exportStar(HP(), k)
  G.__exportStar(VP(), k)
  G.__exportStar(KP(), k)
  G.__exportStar(XP(), k)
  G.__exportStar(ZP(), k)
  G.__exportStar(tR(), k)
  G.__exportStar(rR(), k)
  G.__exportStar(oR(), k)
  G.__exportStar(aR(), k)
  G.__exportStar(dR(), k)
  G.__exportStar(Yg(), k)
  G.__exportStar(Kg(), k)
  G.__exportStar(pR(), k)
  G.__exportStar(Jg(), k)
  G.__exportStar(Xg(), k)
  G.__exportStar(yR(), k)
  G.__exportStar(ER(), k)
  G.__exportStar(Qg(), k)
  G.__exportStar(vR(), k)
  G.__exportStar(wR(), k)
  G.__exportStar(Zg(), k)
  G.__exportStar(IR(), k)
  G.__exportStar(RR(), k)
  G.__exportStar(AR(), k)
  G.__exportStar(NR(), k)
  G.__exportStar(kR(), k)
  G.__exportStar(FR(), k)
  G.__exportStar(LR(), k)
  G.__exportStar(jR(), k)
  G.__exportStar($R(), k)
  G.__exportStar(HR(), k)
  G.__exportStar(VR(), k)
  G.__exportStar(KR(), k)
})
var A8 = l((D8) => {
  'use strict'
  Object.defineProperty(D8, '__esModule', { value: !0 })
})
var O8 = l((nE) => {
  'use strict'
  Object.defineProperty(nE, '__esModule', { value: !0 })
  nE.paginateListContributorInsights = void 0
  var gNe = Yg(),
    ENe = Ar(),
    SNe = async (e, t, ...n) =>
      await e.send(new gNe.ListContributorInsightsCommand(t), ...n)
  async function* bNe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.NextToken = r),
        (t.MaxResults = e.pageSize),
        e.client instanceof ENe.DynamoDBClient)
      )
        o = await SNe(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.NextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  nE.paginateListContributorInsights = bNe
})
var N8 = l((rE) => {
  'use strict'
  Object.defineProperty(rE, '__esModule', { value: !0 })
  rE.paginateListExports = void 0
  var vNe = Kg(),
    CNe = Ar(),
    wNe = async (e, t, ...n) =>
      await e.send(new vNe.ListExportsCommand(t), ...n)
  async function* TNe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.NextToken = r),
        (t.MaxResults = e.pageSize),
        e.client instanceof CNe.DynamoDBClient)
      )
        o = await wNe(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.NextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  rE.paginateListExports = TNe
})
var q8 = l((sE) => {
  'use strict'
  Object.defineProperty(sE, '__esModule', { value: !0 })
  sE.paginateListImports = void 0
  var xNe = Jg(),
    INe = Ar(),
    PNe = async (e, t, ...n) =>
      await e.send(new xNe.ListImportsCommand(t), ...n)
  async function* RNe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.NextToken = r),
        (t.PageSize = e.pageSize),
        e.client instanceof INe.DynamoDBClient)
      )
        o = await PNe(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.NextToken), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  sE.paginateListImports = RNe
})
var k8 = l((oE) => {
  'use strict'
  Object.defineProperty(oE, '__esModule', { value: !0 })
  oE.paginateListTables = void 0
  var DNe = Xg(),
    ANe = Ar(),
    ONe = async (e, t, ...n) => await e.send(new DNe.ListTablesCommand(t), ...n)
  async function* NNe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartTableName = r),
        (t.Limit = e.pageSize),
        e.client instanceof ANe.DynamoDBClient)
      )
        o = await ONe(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.LastEvaluatedTableName),
        (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  oE.paginateListTables = NNe
})
var M8 = l((iE) => {
  'use strict'
  Object.defineProperty(iE, '__esModule', { value: !0 })
  iE.paginateQuery = void 0
  var qNe = Qg(),
    kNe = Ar(),
    MNe = async (e, t, ...n) => await e.send(new qNe.QueryCommand(t), ...n)
  async function* FNe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof kNe.DynamoDBClient)
      )
        o = await MNe(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.LastEvaluatedKey), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  iE.paginateQuery = FNe
})
var F8 = l((aE) => {
  'use strict'
  Object.defineProperty(aE, '__esModule', { value: !0 })
  aE.paginateScan = void 0
  var UNe = Zg(),
    LNe = Ar(),
    BNe = async (e, t, ...n) => await e.send(new UNe.ScanCommand(t), ...n)
  async function* jNe(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof LNe.DynamoDBClient)
      )
        o = await BNe(e.client, t, ...n)
      else throw new Error('Invalid client, expected DynamoDB | DynamoDBClient')
      yield o
      let i = r
      ;(r = o.LastEvaluatedKey), (s = !!(r && (!e.stopOnSameToken || r !== i)))
    }
    return void 0
  }
  aE.paginateScan = jNe
})
var U8 = l((Or) => {
  'use strict'
  Object.defineProperty(Or, '__esModule', { value: !0 })
  var Uo = (x(), w(T))
  Uo.__exportStar(A8(), Or)
  Uo.__exportStar(O8(), Or)
  Uo.__exportStar(N8(), Or)
  Uo.__exportStar(q8(), Or)
  Uo.__exportStar(k8(), Or)
  Uo.__exportStar(M8(), Or)
  Uo.__exportStar(F8(), Or)
})
var JR = l((cE) => {
  'use strict'
  Object.defineProperty(cE, '__esModule', { value: !0 })
  cE.sleep = void 0
  var GNe = (e) => new Promise((t) => setTimeout(t, e * 1e3))
  cE.sleep = GNe
})
var uE = l((Nr) => {
  'use strict'
  Object.defineProperty(Nr, '__esModule', { value: !0 })
  Nr.checkExceptions = Nr.WaiterState = Nr.waiterServiceDefaults = void 0
  Nr.waiterServiceDefaults = { minDelay: 2, maxDelay: 120 }
  var dE
  ;(function (e) {
    ;(e.ABORTED = 'ABORTED'),
      (e.FAILURE = 'FAILURE'),
      (e.SUCCESS = 'SUCCESS'),
      (e.RETRY = 'RETRY'),
      (e.TIMEOUT = 'TIMEOUT')
  })((dE = Nr.WaiterState || (Nr.WaiterState = {})))
  var $Ne = (e) => {
    if (e.state === dE.ABORTED) {
      let t = new Error(
        `${JSON.stringify({ ...e, reason: 'Request was aborted' })}`,
      )
      throw ((t.name = 'AbortError'), t)
    } else if (e.state === dE.TIMEOUT) {
      let t = new Error(
        `${JSON.stringify({ ...e, reason: 'Waiter has timed out' })}`,
      )
      throw ((t.name = 'TimeoutError'), t)
    } else if (e.state !== dE.SUCCESS)
      throw new Error(`${JSON.stringify({ result: e })}`)
    return e
  }
  Nr.checkExceptions = $Ne
})
var L8 = l((mE) => {
  'use strict'
  Object.defineProperty(mE, '__esModule', { value: !0 })
  mE.runPolling = void 0
  var zNe = JR(),
    lE = uE(),
    HNe = (e, t, n, r) => {
      if (r > n) return t
      let s = e * 2 ** (r - 1)
      return WNe(e, s)
    },
    WNe = (e, t) => e + Math.random() * (t - e),
    VNe = async (
      {
        minDelay: e,
        maxDelay: t,
        maxWaitTime: n,
        abortController: r,
        client: s,
        abortSignal: o,
      },
      i,
      c,
    ) => {
      var a
      let { state: u, reason: d } = await c(s, i)
      if (u !== lE.WaiterState.RETRY) return { state: u, reason: d }
      let p = 1,
        f = Date.now() + n * 1e3,
        _ = Math.log(t / e) / Math.log(2) + 1
      for (;;) {
        if (
          (!((a = r?.signal) === null || a === void 0) && a.aborted) ||
          o?.aborted
        )
          return { state: lE.WaiterState.ABORTED }
        let h = HNe(e, t, _, p)
        if (Date.now() + h * 1e3 > f) return { state: lE.WaiterState.TIMEOUT }
        await (0, zNe.sleep)(h)
        let { state: g, reason: E } = await c(s, i)
        if (g !== lE.WaiterState.RETRY) return { state: g, reason: E }
        p += 1
      }
    }
  mE.runPolling = VNe
})
var B8 = l((pE) => {
  'use strict'
  Object.defineProperty(pE, '__esModule', { value: !0 })
  pE.validateWaiterOptions = void 0
  var YNe = (e) => {
    if (e.maxWaitTime < 1)
      throw new Error('WaiterConfiguration.maxWaitTime must be greater than 0')
    if (e.minDelay < 1)
      throw new Error('WaiterConfiguration.minDelay must be greater than 0')
    if (e.maxDelay < 1)
      throw new Error('WaiterConfiguration.maxDelay must be greater than 0')
    if (e.maxWaitTime <= e.minDelay)
      throw new Error(
        `WaiterConfiguration.maxWaitTime [${e.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
      )
    if (e.maxDelay < e.minDelay)
      throw new Error(
        `WaiterConfiguration.maxDelay [${e.maxDelay}] must be greater than WaiterConfiguration.minDelay [${e.minDelay}] for this waiter`,
      )
  }
  pE.validateWaiterOptions = YNe
})
var G8 = l((fE) => {
  'use strict'
  Object.defineProperty(fE, '__esModule', { value: !0 })
  var j8 = (x(), w(T))
  j8.__exportStar(JR(), fE)
  j8.__exportStar(B8(), fE)
})
var H8 = l((_E) => {
  'use strict'
  Object.defineProperty(_E, '__esModule', { value: !0 })
  _E.createWaiter = void 0
  var KNe = L8(),
    JNe = G8(),
    z8 = uE(),
    $8 = async (e) =>
      new Promise((t) => {
        e.onabort = () => t({ state: z8.WaiterState.ABORTED })
      }),
    XNe = async (e, t, n) => {
      let r = { ...z8.waiterServiceDefaults, ...e }
      ;(0, JNe.validateWaiterOptions)(r)
      let s = [(0, KNe.runPolling)(r, t, n)]
      return (
        e.abortController && s.push($8(e.abortController.signal)),
        e.abortSignal && s.push($8(e.abortSignal)),
        Promise.race(s)
      )
    }
  _E.createWaiter = XNe
})
var XR = l((hE) => {
  'use strict'
  Object.defineProperty(hE, '__esModule', { value: !0 })
  var W8 = (x(), w(T))
  W8.__exportStar(H8(), hE)
  W8.__exportStar(uE(), hE)
})
var Y8 = l((Ic) => {
  'use strict'
  Object.defineProperty(Ic, '__esModule', { value: !0 })
  Ic.waitUntilTableExists = Ic.waitForTableExists = void 0
  var xc = XR(),
    QNe = rl(),
    V8 = async (e, t) => {
      let n
      try {
        let r = await e.send(new QNe.DescribeTableCommand(t))
        n = r
        try {
          if ((() => r.Table.TableStatus)() === 'ACTIVE')
            return { state: xc.WaiterState.SUCCESS, reason: n }
        } catch {}
      } catch (r) {
        if (((n = r), r.name && r.name == 'ResourceNotFoundException'))
          return { state: xc.WaiterState.RETRY, reason: n }
      }
      return { state: xc.WaiterState.RETRY, reason: n }
    },
    ZNe = async (e, t) => {
      let n = { minDelay: 20, maxDelay: 120 }
      return (0, xc.createWaiter)({ ...n, ...e }, t, V8)
    }
  Ic.waitForTableExists = ZNe
  var eqe = async (e, t) => {
    let n = { minDelay: 20, maxDelay: 120 },
      r = await (0, xc.createWaiter)({ ...n, ...e }, t, V8)
    return (0, xc.checkExceptions)(r)
  }
  Ic.waitUntilTableExists = eqe
})
var J8 = l((Pc) => {
  'use strict'
  Object.defineProperty(Pc, '__esModule', { value: !0 })
  Pc.waitUntilTableNotExists = Pc.waitForTableNotExists = void 0
  var sl = XR(),
    tqe = rl(),
    K8 = async (e, t) => {
      let n
      try {
        n = await e.send(new tqe.DescribeTableCommand(t))
      } catch (r) {
        if (((n = r), r.name && r.name == 'ResourceNotFoundException'))
          return { state: sl.WaiterState.SUCCESS, reason: n }
      }
      return { state: sl.WaiterState.RETRY, reason: n }
    },
    nqe = async (e, t) => {
      let n = { minDelay: 20, maxDelay: 120 }
      return (0, sl.createWaiter)({ ...n, ...e }, t, K8)
    }
  Pc.waitForTableNotExists = nqe
  var rqe = async (e, t) => {
    let n = { minDelay: 20, maxDelay: 120 },
      r = await (0, sl.createWaiter)({ ...n, ...e }, t, K8)
    return (0, sl.checkExceptions)(r)
  }
  Pc.waitUntilTableNotExists = rqe
})
var Q8 = l((yE) => {
  'use strict'
  Object.defineProperty(yE, '__esModule', { value: !0 })
  var X8 = (x(), w(T))
  X8.__exportStar(Y8(), yE)
  X8.__exportStar(J8(), yE)
})
var Z8 = l((QR) => {
  'use strict'
  Object.defineProperty(QR, '__esModule', { value: !0 })
  var sqe = (x(), w(T))
  sqe.__exportStar(HT(), QR)
})
var lt = l((Xn) => {
  'use strict'
  Object.defineProperty(Xn, '__esModule', { value: !0 })
  Xn.DynamoDBServiceException = void 0
  var Rc = (x(), w(T))
  Rc.__exportStar(Ar(), Xn)
  Rc.__exportStar(P8(), Xn)
  Rc.__exportStar(R8(), Xn)
  Rc.__exportStar(U8(), Xn)
  Rc.__exportStar(Q8(), Xn)
  Rc.__exportStar(Z8(), Xn)
  var oqe = mh()
  Object.defineProperty(Xn, 'DynamoDBServiceException', {
    enumerable: !0,
    get: function () {
      return oqe.DynamoDBServiceException
    },
  })
})
var ZR = l((Lo) => {
  'use strict'
  Object.defineProperty(Lo, '__esModule', { value: !0 })
  Lo.convertToAttr = void 0
  var iqe = (e, t) => {
    var n, r, s, o, i, c
    if (e === void 0)
      throw new Error(
        'Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.',
      )
    if (e === null && typeof e == 'object') return gE()
    if (Array.isArray(e)) return aqe(e, t)
    if (
      ((n = e?.constructor) === null || n === void 0 ? void 0 : n.name) ===
      'Set'
    )
      return cqe(e, t)
    if (
      ((r = e?.constructor) === null || r === void 0 ? void 0 : r.name) ===
      'Map'
    )
      return dqe(e, t)
    if (
      ((s = e?.constructor) === null || s === void 0 ? void 0 : s.name) ===
        'Object' ||
      (!e.constructor && typeof e == 'object')
    )
      return e4(e, t)
    if (i4(e)) return e.length === 0 && t?.convertEmptyValues ? gE() : n4(e)
    if (
      typeof e == 'boolean' ||
      ((o = e?.constructor) === null || o === void 0 ? void 0 : o.name) ===
        'Boolean'
    )
      return { BOOL: e.valueOf() }
    if (
      typeof e == 'number' ||
      ((i = e?.constructor) === null || i === void 0 ? void 0 : i.name) ===
        'Number'
    )
      return o4(e)
    if (typeof e == 'bigint') return s4(e)
    if (
      typeof e == 'string' ||
      ((c = e?.constructor) === null || c === void 0 ? void 0 : c.name) ===
        'String'
    )
      return e.length === 0 && t?.convertEmptyValues ? gE() : r4(e)
    if (t?.convertClassInstanceToMap && typeof e == 'object') return e4(e, t)
    throw new Error(
      `Unsupported type passed: ${e}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`,
    )
  }
  Lo.convertToAttr = iqe
  var aqe = (e, t) => ({
      L: e
        .filter(
          (n) =>
            !t?.removeUndefinedValues ||
            (t?.removeUndefinedValues && n !== void 0),
        )
        .map((n) => (0, Lo.convertToAttr)(n, t)),
    }),
    cqe = (e, t) => {
      let n = t?.removeUndefinedValues
        ? new Set([...e].filter((s) => s !== void 0))
        : e
      if (!t?.removeUndefinedValues && n.has(void 0))
        throw new Error(
          'Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.',
        )
      if (n.size === 0) {
        if (t?.convertEmptyValues) return gE()
        throw new Error(
          'Pass a non-empty set, or options.convertEmptyValues=true.',
        )
      }
      let r = n.values().next().value
      if (typeof r == 'number')
        return {
          NS: Array.from(n)
            .map(o4)
            .map((s) => s.N),
        }
      if (typeof r == 'bigint')
        return {
          NS: Array.from(n)
            .map(s4)
            .map((s) => s.N),
        }
      if (typeof r == 'string')
        return {
          SS: Array.from(n)
            .map(r4)
            .map((s) => s.S),
        }
      if (i4(r))
        return {
          BS: Array.from(n)
            .map(n4)
            .map((s) => s.B),
        }
      throw new Error(
        'Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.',
      )
    },
    dqe = (e, t) => ({
      M: ((n) => {
        let r = {}
        for (let [s, o] of n)
          typeof o != 'function' &&
            (o !== void 0 || !t?.removeUndefinedValues) &&
            (r[s] = (0, Lo.convertToAttr)(o, t))
        return r
      })(e),
    }),
    e4 = (e, t) => ({
      M: ((n) => {
        let r = {}
        for (let s in n) {
          let o = n[s]
          typeof o != 'function' &&
            (o !== void 0 || !t?.removeUndefinedValues) &&
            (r[s] = (0, Lo.convertToAttr)(o, t))
        }
        return r
      })(e),
    }),
    gE = () => ({ NULL: !0 }),
    n4 = (e) => ({ B: e }),
    r4 = (e) => ({ S: e.toString() }),
    s4 = (e) => ({ N: e.toString() }),
    t4 = (e) => {
      throw new Error(
        `${e} ${
          typeof BigInt == 'function'
            ? 'Use BigInt.'
            : 'Pass string value instead.'
        } `,
      )
    },
    o4 = (e) => {
      if (
        [Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
          .map((t) => t.toString())
          .includes(e.toString())
      )
        throw new Error(`Special numeric value ${e.toString()} is not allowed`)
      return (
        e > Number.MAX_SAFE_INTEGER
          ? t4(
              `Number ${e.toString()} is greater than Number.MAX_SAFE_INTEGER.`,
            )
          : e < Number.MIN_SAFE_INTEGER &&
            t4(
              `Number ${e.toString()} is lesser than Number.MIN_SAFE_INTEGER.`,
            ),
        { N: e.toString() }
      )
    },
    i4 = (e) => {
      let t = [
        'ArrayBuffer',
        'Blob',
        'Buffer',
        'DataView',
        'File',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Uint16Array',
        'Int32Array',
        'Uint32Array',
        'Float32Array',
        'Float64Array',
        'BigInt64Array',
        'BigUint64Array',
      ]
      return e?.constructor ? t.includes(e.constructor.name) : !1
    }
})
var eD = l((Dc) => {
  'use strict'
  Object.defineProperty(Dc, '__esModule', { value: !0 })
  Dc.convertToNative = void 0
  var uqe = (e, t) => {
    for (let [n, r] of Object.entries(e))
      if (r !== void 0)
        switch (n) {
          case 'NULL':
            return null
          case 'BOOL':
            return !!r
          case 'N':
            return a4(r, t)
          case 'B':
            return d4(r)
          case 'S':
            return c4(r)
          case 'L':
            return lqe(r, t)
          case 'M':
            return mqe(r, t)
          case 'NS':
            return new Set(r.map((s) => a4(s, t)))
          case 'BS':
            return new Set(r.map(d4))
          case 'SS':
            return new Set(r.map(c4))
          default:
            throw new Error(`Unsupported type passed: ${n}`)
        }
    throw new Error(`No value defined: ${JSON.stringify(e)}`)
  }
  Dc.convertToNative = uqe
  var a4 = (e, t) => {
      if (t?.wrapNumbers) return { value: e }
      let n = Number(e),
        r = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]
      if (
        (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) &&
        !r.includes(n)
      )
        if (typeof BigInt == 'function')
          try {
            return BigInt(e)
          } catch {
            throw new Error(
              `${e} can't be converted to BigInt. Set options.wrapNumbers to get string value.`,
            )
          }
        else
          throw new Error(
            `${e} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`,
          )
      return n
    },
    c4 = (e) => e,
    d4 = (e) => e,
    lqe = (e, t) => e.map((n) => (0, Dc.convertToNative)(n, t)),
    mqe = (e, t) =>
      Object.entries(e).reduce(
        (n, [r, s]) => ((n[r] = (0, Dc.convertToNative)(s, t)), n),
        {},
      )
})
var u4 = l((EE) => {
  'use strict'
  Object.defineProperty(EE, '__esModule', { value: !0 })
  EE.marshall = void 0
  var pqe = ZR()
  function fqe(e, t) {
    let n = (0, pqe.convertToAttr)(e, t),
      [r, s] = Object.entries(n)[0]
    switch (r) {
      case 'M':
      case 'L':
        return s
      case 'SS':
      case 'NS':
      case 'BS':
      case 'S':
      case 'N':
      case 'B':
      case 'NULL':
      case 'BOOL':
      case '$unknown':
      default:
        return n
    }
  }
  EE.marshall = fqe
})
var m4 = l((l4) => {
  'use strict'
  Object.defineProperty(l4, '__esModule', { value: !0 })
})
var p4 = l((SE) => {
  'use strict'
  Object.defineProperty(SE, '__esModule', { value: !0 })
  SE.unmarshall = void 0
  var _qe = eD(),
    hqe = (e, t) => (0, _qe.convertToNative)({ M: e }, t)
  SE.unmarshall = hqe
})
var f4 = l((Bo) => {
  'use strict'
  Object.defineProperty(Bo, '__esModule', { value: !0 })
  var ol = (x(), w(T))
  ol.__exportStar(ZR(), Bo)
  ol.__exportStar(eD(), Bo)
  ol.__exportStar(u4(), Bo)
  ol.__exportStar(m4(), Bo)
  ol.__exportStar(p4(), Bo)
})
var g4 = l((Ac) => {
  'use strict'
  Object.defineProperty(Ac, '__esModule', { value: !0 })
  Ac.unmarshallOutput = Ac.marshallInput = void 0
  var h4 = f4(),
    _4 = (e, t, n) => {
      if (e !== void 0)
        return !n || (Array.isArray(n) && n.length === 0)
          ? t(e)
          : Array.isArray(n)
          ? tD(e, t, n)
          : yqe(e, t, n.children)
    },
    y4 = (e, t, n) =>
      Array.isArray(e) ? e.map((r) => _4(r, t, n)) : _4(e, t, n),
    tD = (e, t, n) => {
      let r = { ...e }
      return n.reduce(
        (s, { key: o, children: i }) => ((s[o] = y4(s[o], t, i)), s),
        r,
      )
    },
    yqe = (e, t, n) =>
      Object.entries(e).reduce((r, [s, o]) => ((r[s] = y4(o, t, n)), r), {}),
    gqe = (e, t, n) => tD(e, (s) => (0, h4.marshall)(s, n), t)
  Ac.marshallInput = gqe
  var Eqe = (e, t, n) => tD(e, (s) => (0, h4.unmarshall)(s, n), t)
  Ac.unmarshallOutput = Eqe
})
var St = l((vE) => {
  'use strict'
  Object.defineProperty(vE, '__esModule', { value: !0 })
  vE.DynamoDBDocumentClientCommand = void 0
  var Sqe = v(),
    E4 = g4(),
    bE = class e extends Sqe.Command {
      addMarshallingMiddleware(t) {
        let { marshallOptions: n, unmarshallOptions: r } =
          t.translateConfig || {}
        this.clientCommand.middlewareStack.addRelativeTo(
          (s, o) => async (i) => {
            ;(i.input = (0, E4.marshallInput)(
              this.input,
              this.inputKeyNodes,
              n,
            )),
              (o.dynamoDbDocumentClientOptions =
                o.dynamoDbDocumentClientOptions || e.defaultLogFilterOverrides)
            let c = i.input
            return (
              (o.dynamoDbDocumentClientOptions.overrideInputFilterSensitiveLog =
                () => {
                  var a
                  return (a = o.inputFilterSensitiveLog) === null ||
                    a === void 0
                    ? void 0
                    : a.call(o, c)
                }),
              s(i)
            )
          },
          {
            name: 'DocumentMarshall',
            relation: 'before',
            toMiddleware: 'serializerMiddleware',
            override: !0,
          },
        ),
          this.clientCommand.middlewareStack.addRelativeTo(
            (s, o) => async (i) => {
              let c = await s(i),
                a = c.output
              return (
                (o.dynamoDbDocumentClientOptions =
                  o.dynamoDbDocumentClientOptions ||
                  e.defaultLogFilterOverrides),
                (o.dynamoDbDocumentClientOptions.overrideOutputFilterSensitiveLog =
                  () => {
                    var u
                    return (u = o.outputFilterSensitiveLog) === null ||
                      u === void 0
                      ? void 0
                      : u.call(o, a)
                  }),
                (c.output = (0, E4.unmarshallOutput)(
                  c.output,
                  this.outputKeyNodes,
                  r,
                )),
                c
              )
            },
            {
              name: 'DocumentUnmarshall',
              relation: 'before',
              toMiddleware: 'deserializerMiddleware',
              override: !0,
            },
          )
      }
    }
  vE.DynamoDBDocumentClientCommand = bE
  bE.defaultLogFilterOverrides = {
    overrideInputFilterSensitiveLog(...e) {},
    overrideOutputFilterSensitiveLog(...e) {},
  }
})
var rD = l((xs) => {
  'use strict'
  Object.defineProperty(xs, '__esModule', { value: !0 })
  xs.BatchExecuteStatementCommand =
    xs.$Command =
    xs.DynamoDBDocumentClientCommand =
      void 0
  var bqe = lt(),
    vqe = v()
  Object.defineProperty(xs, '$Command', {
    enumerable: !0,
    get: function () {
      return vqe.Command
    },
  })
  var S4 = St()
  Object.defineProperty(xs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return S4.DynamoDBDocumentClientCommand
    },
  })
  var nD = class extends S4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          { key: 'Statements', children: [{ key: 'Parameters' }] },
        ]),
        (this.outputKeyNodes = [
          {
            key: 'Responses',
            children: [
              { key: 'Error', children: [{ key: 'Item' }] },
              { key: 'Item' },
            ],
          },
        ]),
        (this.clientCommand = new bqe.BatchExecuteStatementCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  xs.BatchExecuteStatementCommand = nD
})
var oD = l((Is) => {
  'use strict'
  Object.defineProperty(Is, '__esModule', { value: !0 })
  Is.BatchGetCommand = Is.$Command = Is.DynamoDBDocumentClientCommand = void 0
  var Cqe = lt(),
    wqe = v()
  Object.defineProperty(Is, '$Command', {
    enumerable: !0,
    get: function () {
      return wqe.Command
    },
  })
  var b4 = St()
  Object.defineProperty(Is, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return b4.DynamoDBDocumentClientCommand
    },
  })
  var sD = class extends b4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          { key: 'RequestItems', children: { children: [{ key: 'Keys' }] } },
        ]),
        (this.outputKeyNodes = [
          { key: 'Responses', children: {} },
          { key: 'UnprocessedKeys', children: { children: [{ key: 'Keys' }] } },
        ]),
        (this.clientCommand = new Cqe.BatchGetItemCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Is.BatchGetCommand = sD
})
var aD = l((Ps) => {
  'use strict'
  Object.defineProperty(Ps, '__esModule', { value: !0 })
  Ps.BatchWriteCommand = Ps.$Command = Ps.DynamoDBDocumentClientCommand = void 0
  var Tqe = lt(),
    xqe = v()
  Object.defineProperty(Ps, '$Command', {
    enumerable: !0,
    get: function () {
      return xqe.Command
    },
  })
  var v4 = St()
  Object.defineProperty(Ps, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return v4.DynamoDBDocumentClientCommand
    },
  })
  var iD = class extends v4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          {
            key: 'RequestItems',
            children: {
              children: [
                { key: 'PutRequest', children: [{ key: 'Item' }] },
                { key: 'DeleteRequest', children: [{ key: 'Key' }] },
              ],
            },
          },
        ]),
        (this.outputKeyNodes = [
          {
            key: 'UnprocessedItems',
            children: {
              children: [
                { key: 'PutRequest', children: [{ key: 'Item' }] },
                { key: 'DeleteRequest', children: [{ key: 'Key' }] },
              ],
            },
          },
          {
            key: 'ItemCollectionMetrics',
            children: { children: [{ key: 'ItemCollectionKey' }] },
          },
        ]),
        (this.clientCommand = new Tqe.BatchWriteItemCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Ps.BatchWriteCommand = iD
})
var dD = l((Rs) => {
  'use strict'
  Object.defineProperty(Rs, '__esModule', { value: !0 })
  Rs.DeleteCommand = Rs.$Command = Rs.DynamoDBDocumentClientCommand = void 0
  var Iqe = lt(),
    Pqe = v()
  Object.defineProperty(Rs, '$Command', {
    enumerable: !0,
    get: function () {
      return Pqe.Command
    },
  })
  var C4 = St()
  Object.defineProperty(Rs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return C4.DynamoDBDocumentClientCommand
    },
  })
  var cD = class extends C4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          { key: 'Key' },
          {
            key: 'Expected',
            children: {
              children: [{ key: 'Value' }, { key: 'AttributeValueList' }],
            },
          },
          { key: 'ExpressionAttributeValues' },
        ]),
        (this.outputKeyNodes = [
          { key: 'Attributes' },
          {
            key: 'ItemCollectionMetrics',
            children: [{ key: 'ItemCollectionKey' }],
          },
        ]),
        (this.clientCommand = new Iqe.DeleteItemCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Rs.DeleteCommand = cD
})
var lD = l((Ds) => {
  'use strict'
  Object.defineProperty(Ds, '__esModule', { value: !0 })
  Ds.ExecuteStatementCommand =
    Ds.$Command =
    Ds.DynamoDBDocumentClientCommand =
      void 0
  var Rqe = lt(),
    Dqe = v()
  Object.defineProperty(Ds, '$Command', {
    enumerable: !0,
    get: function () {
      return Dqe.Command
    },
  })
  var w4 = St()
  Object.defineProperty(Ds, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return w4.DynamoDBDocumentClientCommand
    },
  })
  var uD = class extends w4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [{ key: 'Parameters' }]),
        (this.outputKeyNodes = [{ key: 'Items' }, { key: 'LastEvaluatedKey' }]),
        (this.clientCommand = new Rqe.ExecuteStatementCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Ds.ExecuteStatementCommand = uD
})
var pD = l((As) => {
  'use strict'
  Object.defineProperty(As, '__esModule', { value: !0 })
  As.ExecuteTransactionCommand =
    As.$Command =
    As.DynamoDBDocumentClientCommand =
      void 0
  var Aqe = lt(),
    Oqe = v()
  Object.defineProperty(As, '$Command', {
    enumerable: !0,
    get: function () {
      return Oqe.Command
    },
  })
  var T4 = St()
  Object.defineProperty(As, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return T4.DynamoDBDocumentClientCommand
    },
  })
  var mD = class extends T4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          { key: 'TransactStatements', children: [{ key: 'Parameters' }] },
        ]),
        (this.outputKeyNodes = [
          { key: 'Responses', children: [{ key: 'Item' }] },
        ]),
        (this.clientCommand = new Aqe.ExecuteTransactionCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  As.ExecuteTransactionCommand = mD
})
var _D = l((Os) => {
  'use strict'
  Object.defineProperty(Os, '__esModule', { value: !0 })
  Os.GetCommand = Os.$Command = Os.DynamoDBDocumentClientCommand = void 0
  var Nqe = lt(),
    qqe = v()
  Object.defineProperty(Os, '$Command', {
    enumerable: !0,
    get: function () {
      return qqe.Command
    },
  })
  var x4 = St()
  Object.defineProperty(Os, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return x4.DynamoDBDocumentClientCommand
    },
  })
  var fD = class extends x4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [{ key: 'Key' }]),
        (this.outputKeyNodes = [{ key: 'Item' }]),
        (this.clientCommand = new Nqe.GetItemCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Os.GetCommand = fD
})
var yD = l((Ns) => {
  'use strict'
  Object.defineProperty(Ns, '__esModule', { value: !0 })
  Ns.PutCommand = Ns.$Command = Ns.DynamoDBDocumentClientCommand = void 0
  var kqe = lt(),
    Mqe = v()
  Object.defineProperty(Ns, '$Command', {
    enumerable: !0,
    get: function () {
      return Mqe.Command
    },
  })
  var I4 = St()
  Object.defineProperty(Ns, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return I4.DynamoDBDocumentClientCommand
    },
  })
  var hD = class extends I4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          { key: 'Item' },
          {
            key: 'Expected',
            children: {
              children: [{ key: 'Value' }, { key: 'AttributeValueList' }],
            },
          },
          { key: 'ExpressionAttributeValues' },
        ]),
        (this.outputKeyNodes = [
          { key: 'Attributes' },
          {
            key: 'ItemCollectionMetrics',
            children: [{ key: 'ItemCollectionKey' }],
          },
        ]),
        (this.clientCommand = new kqe.PutItemCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Ns.PutCommand = hD
})
var CE = l((qs) => {
  'use strict'
  Object.defineProperty(qs, '__esModule', { value: !0 })
  qs.QueryCommand = qs.$Command = qs.DynamoDBDocumentClientCommand = void 0
  var Fqe = lt(),
    Uqe = v()
  Object.defineProperty(qs, '$Command', {
    enumerable: !0,
    get: function () {
      return Uqe.Command
    },
  })
  var P4 = St()
  Object.defineProperty(qs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return P4.DynamoDBDocumentClientCommand
    },
  })
  var gD = class extends P4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          {
            key: 'KeyConditions',
            children: { children: [{ key: 'AttributeValueList' }] },
          },
          {
            key: 'QueryFilter',
            children: { children: [{ key: 'AttributeValueList' }] },
          },
          { key: 'ExclusiveStartKey' },
          { key: 'ExpressionAttributeValues' },
        ]),
        (this.outputKeyNodes = [{ key: 'Items' }, { key: 'LastEvaluatedKey' }]),
        (this.clientCommand = new Fqe.QueryCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  qs.QueryCommand = gD
})
var wE = l((ks) => {
  'use strict'
  Object.defineProperty(ks, '__esModule', { value: !0 })
  ks.ScanCommand = ks.$Command = ks.DynamoDBDocumentClientCommand = void 0
  var Lqe = lt(),
    Bqe = v()
  Object.defineProperty(ks, '$Command', {
    enumerable: !0,
    get: function () {
      return Bqe.Command
    },
  })
  var R4 = St()
  Object.defineProperty(ks, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return R4.DynamoDBDocumentClientCommand
    },
  })
  var ED = class extends R4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          {
            key: 'ScanFilter',
            children: { children: [{ key: 'AttributeValueList' }] },
          },
          { key: 'ExclusiveStartKey' },
          { key: 'ExpressionAttributeValues' },
        ]),
        (this.outputKeyNodes = [{ key: 'Items' }, { key: 'LastEvaluatedKey' }]),
        (this.clientCommand = new Lqe.ScanCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  ks.ScanCommand = ED
})
var bD = l((Ms) => {
  'use strict'
  Object.defineProperty(Ms, '__esModule', { value: !0 })
  Ms.TransactGetCommand =
    Ms.$Command =
    Ms.DynamoDBDocumentClientCommand =
      void 0
  var jqe = lt(),
    Gqe = v()
  Object.defineProperty(Ms, '$Command', {
    enumerable: !0,
    get: function () {
      return Gqe.Command
    },
  })
  var D4 = St()
  Object.defineProperty(Ms, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return D4.DynamoDBDocumentClientCommand
    },
  })
  var SD = class extends D4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          {
            key: 'TransactItems',
            children: [{ key: 'Get', children: [{ key: 'Key' }] }],
          },
        ]),
        (this.outputKeyNodes = [
          { key: 'Responses', children: [{ key: 'Item' }] },
        ]),
        (this.clientCommand = new jqe.TransactGetItemsCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Ms.TransactGetCommand = SD
})
var CD = l((Fs) => {
  'use strict'
  Object.defineProperty(Fs, '__esModule', { value: !0 })
  Fs.TransactWriteCommand =
    Fs.$Command =
    Fs.DynamoDBDocumentClientCommand =
      void 0
  var $qe = lt(),
    zqe = v()
  Object.defineProperty(Fs, '$Command', {
    enumerable: !0,
    get: function () {
      return zqe.Command
    },
  })
  var A4 = St()
  Object.defineProperty(Fs, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return A4.DynamoDBDocumentClientCommand
    },
  })
  var vD = class extends A4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          {
            key: 'TransactItems',
            children: [
              {
                key: 'ConditionCheck',
                children: [
                  { key: 'Key' },
                  { key: 'ExpressionAttributeValues' },
                ],
              },
              {
                key: 'Put',
                children: [
                  { key: 'Item' },
                  { key: 'ExpressionAttributeValues' },
                ],
              },
              {
                key: 'Delete',
                children: [
                  { key: 'Key' },
                  { key: 'ExpressionAttributeValues' },
                ],
              },
              {
                key: 'Update',
                children: [
                  { key: 'Key' },
                  { key: 'ExpressionAttributeValues' },
                ],
              },
            ],
          },
        ]),
        (this.outputKeyNodes = [
          {
            key: 'ItemCollectionMetrics',
            children: { children: [{ key: 'ItemCollectionKey' }] },
          },
        ]),
        (this.clientCommand = new $qe.TransactWriteItemsCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Fs.TransactWriteCommand = vD
})
var TD = l((Us) => {
  'use strict'
  Object.defineProperty(Us, '__esModule', { value: !0 })
  Us.UpdateCommand = Us.$Command = Us.DynamoDBDocumentClientCommand = void 0
  var Hqe = lt(),
    Wqe = v()
  Object.defineProperty(Us, '$Command', {
    enumerable: !0,
    get: function () {
      return Wqe.Command
    },
  })
  var O4 = St()
  Object.defineProperty(Us, 'DynamoDBDocumentClientCommand', {
    enumerable: !0,
    get: function () {
      return O4.DynamoDBDocumentClientCommand
    },
  })
  var wD = class extends O4.DynamoDBDocumentClientCommand {
    constructor(t) {
      super(),
        (this.input = t),
        (this.inputKeyNodes = [
          { key: 'Key' },
          {
            key: 'AttributeUpdates',
            children: { children: [{ key: 'Value' }] },
          },
          {
            key: 'Expected',
            children: {
              children: [{ key: 'Value' }, { key: 'AttributeValueList' }],
            },
          },
          { key: 'ExpressionAttributeValues' },
        ]),
        (this.outputKeyNodes = [
          { key: 'Attributes' },
          {
            key: 'ItemCollectionMetrics',
            children: [{ key: 'ItemCollectionKey' }],
          },
        ]),
        (this.clientCommand = new Hqe.UpdateItemCommand(this.input)),
        (this.middlewareStack = this.clientCommand.middlewareStack)
    }
    resolveMiddleware(t, n, r) {
      this.addMarshallingMiddleware(n)
      let s = t.concat(this.middlewareStack),
        o = this.clientCommand.resolveMiddleware(s, n, r)
      return async () => o(this.clientCommand)
    }
  }
  Us.UpdateCommand = wD
})
var il = l((Oc) => {
  'use strict'
  Object.defineProperty(Oc, '__esModule', { value: !0 })
  Oc.DynamoDBDocumentClient = Oc.__Client = void 0
  var N4 = v()
  Object.defineProperty(Oc, '__Client', {
    enumerable: !0,
    get: function () {
      return N4.Client
    },
  })
  var xD = class e extends N4.Client {
    constructor(t, n) {
      super(t.config),
        (this.config = t.config),
        (this.config.translateConfig = n),
        (this.middlewareStack = t.middlewareStack)
    }
    static from(t, n) {
      return new e(t, n)
    }
    destroy() {}
  }
  Oc.DynamoDBDocumentClient = xD
})
var xE = l((TE) => {
  'use strict'
  Object.defineProperty(TE, '__esModule', { value: !0 })
  TE.DynamoDBDocument = void 0
  var Vqe = rD(),
    Yqe = oD(),
    Kqe = aD(),
    Jqe = dD(),
    Xqe = lD(),
    Qqe = pD(),
    Zqe = _D(),
    eke = yD(),
    tke = CE(),
    nke = wE(),
    rke = bD(),
    ske = CD(),
    oke = TD(),
    ike = il(),
    ID = class e extends ike.DynamoDBDocumentClient {
      static from(t, n) {
        return new e(t, n)
      }
      batchExecuteStatement(t, n, r) {
        let s = new Vqe.BatchExecuteStatementCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      batchGet(t, n, r) {
        let s = new Yqe.BatchGetCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      batchWrite(t, n, r) {
        let s = new Kqe.BatchWriteCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      delete(t, n, r) {
        let s = new Jqe.DeleteCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      executeStatement(t, n, r) {
        let s = new Xqe.ExecuteStatementCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      executeTransaction(t, n, r) {
        let s = new Qqe.ExecuteTransactionCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      get(t, n, r) {
        let s = new Zqe.GetCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      put(t, n, r) {
        let s = new eke.PutCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      query(t, n, r) {
        let s = new tke.QueryCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      scan(t, n, r) {
        let s = new nke.ScanCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      transactGet(t, n, r) {
        let s = new rke.TransactGetCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      transactWrite(t, n, r) {
        let s = new ske.TransactWriteCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
      update(t, n, r) {
        let s = new oke.UpdateCommand(t)
        if (typeof n == 'function') this.send(s, n)
        else if (typeof r == 'function') {
          if (typeof n != 'object')
            throw new Error(`Expect http options but get ${typeof n}`)
          this.send(s, n || {}, r)
        } else return this.send(s, n)
      }
    }
  TE.DynamoDBDocument = ID
})
var q4 = l((mt) => {
  'use strict'
  Object.defineProperty(mt, '__esModule', { value: !0 })
  var Mt = (x(), w(T))
  Mt.__exportStar(rD(), mt)
  Mt.__exportStar(oD(), mt)
  Mt.__exportStar(aD(), mt)
  Mt.__exportStar(dD(), mt)
  Mt.__exportStar(lD(), mt)
  Mt.__exportStar(pD(), mt)
  Mt.__exportStar(_D(), mt)
  Mt.__exportStar(yD(), mt)
  Mt.__exportStar(CE(), mt)
  Mt.__exportStar(wE(), mt)
  Mt.__exportStar(bD(), mt)
  Mt.__exportStar(CD(), mt)
  Mt.__exportStar(TD(), mt)
})
var M4 = l((k4) => {
  'use strict'
  Object.defineProperty(k4, '__esModule', { value: !0 })
})
var F4 = l((IE) => {
  'use strict'
  Object.defineProperty(IE, '__esModule', { value: !0 })
  IE.paginateQuery = void 0
  var ake = CE(),
    cke = xE(),
    dke = il(),
    uke = async (e, t, ...n) => await e.send(new ake.QueryCommand(t), ...n),
    lke = async (e, t, ...n) => await e.query(t, ...n)
  async function* mke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof cke.DynamoDBDocument)
      )
        o = await lke(e.client, t, ...n)
      else if (e.client instanceof dke.DynamoDBDocumentClient)
        o = await uke(e.client, t, ...n)
      else
        throw new Error(
          'Invalid client, expected DynamoDBDocument | DynamoDBDocumentClient',
        )
      yield o, (r = o.LastEvaluatedKey), (s = !!r)
    }
    return void 0
  }
  IE.paginateQuery = mke
})
var U4 = l((PE) => {
  'use strict'
  Object.defineProperty(PE, '__esModule', { value: !0 })
  PE.paginateScan = void 0
  var pke = wE(),
    fke = xE(),
    _ke = il(),
    hke = async (e, t, ...n) => await e.send(new pke.ScanCommand(t), ...n),
    yke = async (e, t, ...n) => await e.scan(t, ...n)
  async function* gke(e, t, ...n) {
    let r = e.startingToken || void 0,
      s = !0,
      o
    for (; s; ) {
      if (
        ((t.ExclusiveStartKey = r),
        (t.Limit = e.pageSize),
        e.client instanceof fke.DynamoDBDocument)
      )
        o = await yke(e.client, t, ...n)
      else if (e.client instanceof _ke.DynamoDBDocumentClient)
        o = await hke(e.client, t, ...n)
      else
        throw new Error(
          'Invalid client, expected DynamoDBDocument | DynamoDBDocumentClient',
        )
      yield o, (r = o.LastEvaluatedKey), (s = !!r)
    }
    return void 0
  }
  PE.paginateScan = gke
})
var L4 = l((al) => {
  'use strict'
  Object.defineProperty(al, '__esModule', { value: !0 })
  var PD = (x(), w(T))
  PD.__exportStar(M4(), al)
  PD.__exportStar(F4(), al)
  PD.__exportStar(U4(), al)
})
var RD = l((Nc) => {
  'use strict'
  Object.defineProperty(Nc, '__esModule', { value: !0 })
  var RE = (x(), w(T))
  RE.__exportStar(xE(), Nc)
  RE.__exportStar(il(), Nc)
  RE.__exportStar(q4(), Nc)
  RE.__exportStar(L4(), Nc)
})
var wke = {}
Mc(wke, { handler: () => Cke })
module.exports = w(wke)
var DD = ln(Ak())
var Ok = (e) => {
  let t = process.env[e]
  if (!t) throw new Error(`Missing ${e} environment variable`)
  return t
}
var Nk = (e) =>
  e
    .split('&')
    .map((t) => t.split('=').map(decodeURIComponent))
    .reduce((t, [n, r]) => ({ ...t, [n]: r }), {})
var qk = (e, t) => {
  if (t.includes(e)) return e
}
var B4 = ln(lt()),
  j4 = ln(RD()),
  Eke = new B4.DynamoDBClient({ region: process.env.AWS_REGION }),
  G4 = j4.DynamoDBDocumentClient.from(Eke, {
    marshallOptions: { removeUndefinedValues: !0 },
  })
var $4 = process.env.NODE_ENV === 'test' ? 'test_' : 'pomodoro_',
  z4 = { users: `${$4}users`, appSumoCodes: `${$4}app_sumo_codes` }
var H4 = (e) => ({
  UpdateExpression: `set ${Object.entries(e)
    .map(([t]) => `#${t} = :${t}, `)
    .reduce((t, n) => t + n)
    .slice(0, -2)}`,
  ExpressionAttributeNames: Object.keys(e).reduce(
    (t, n) => ({ ...t, [`#${n}`]: n }),
    {},
  ),
  ExpressionAttributeValues: Object.entries(e).reduce(
    (t, [n, r]) => ({ ...t, [`:${n}`]: r }),
    {},
  ),
})
var qc = ln(RD())
var Ske = (e) => ({ TableName: z4.users, Key: { id: e } })
var W4 = async (e, t) => {
  let n = new qc.UpdateCommand({
    ...Ske(e),
    ...H4({ ...t, updatedAt: Date.now() }),
  })
  return G4.send(n)
}
var V4 = (e) => {
  if (e === 'past_due') return 'pastDue'
  if (e === 'deleted') return 'canceled'
  if (e === 'active') return 'active'
  throw new Error(`Unknown subscription status: ${e}`)
}
var bke = [
    'subscription_created',
    'subscription_updated',
    'subscription_cancelled',
    'subscription_payment_succeeded',
    'subscription_payment_failed',
    'subscription_payment_refunded',
  ],
  Y4 = async (e) => {
    if (!qk(e.alert_name, bke)) {
      console.log(
        `Received unsupported alert from Paddle Classic: ${e.alert_name}`,
      )
      return
    }
    console.log(`Processing ${e.alert_name} event from Paddle Classic`)
    let { userId: n } = JSON.parse(e.passthrough),
      r = {
        provider: 'paddleClassic',
        id: e.subscription_id,
        planId: e.subscription_plan_id,
        status: V4(e.status),
        nextBilledAt: e.next_bill_date
          ? new Date(e.next_bill_date).getTime()
          : void 0,
        endsAt: e.cancellation_effective_date
          ? new Date(e.cancellation_effective_date).getTime()
          : void 0,
      }
    await W4(n, { subscription: r })
  }
DD.AWSLambda.init({ dsn: Ok('SENTRY_KEY') })
var vke = async ({ body: e }) => {
    if (!e)
      return (
        console.log('Received empty body from Paddle Classic'),
        { statusCode: 400 }
      )
    console.log(`Received encoded event from Paddle Classic: ${e}`)
    let t = Nk(e)
    return (
      console.log(`Parsed event from Paddle Classic: ${JSON.stringify(t)}`),
      await Y4(t),
      { statusCode: 200 }
    )
  },
  Cke = DD.AWSLambda.wrapHandler(vke)
0 && (module.exports = { handler })
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=lambda.js.map
